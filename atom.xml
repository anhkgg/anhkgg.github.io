<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Anhkgg's website | 内核研究 | 逆向分析 | 漏洞分析挖掘 | Windows Kernel | Rootkit | Reverse Engineer | Expolit]]></title>
  <subtitle><![CDATA[Windows Kernel/Rootkit/Reverse Engineer/Expolit/内核研究/逆向分析/漏洞分析挖掘]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://anhkgg.github.io/"/>
  <updated>2016-07-06T23:46:33.472Z</updated>
  <id>http://anhkgg.github.io/</id>
  
  <author>
    <name><![CDATA[Anhkgg]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Windbg系列-RPC调试]]></title>
    <link href="http://anhkgg.github.io/Windbg%E7%B3%BB%E5%88%97-RPC%E8%B0%83%E8%AF%95/"/>
    <id>http://anhkgg.github.io/Windbg系列-RPC调试/</id>
    <published>2016-01-04T12:16:10.000Z</published>
    <updated>2016-07-06T23:46:33.472Z</updated>
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在调试rpc，没法子，翻译了一下windbg这篇调试RPC的文档，后面可能还有其他内容，也就弄个系列吧<br>算是自己的笔记，有看客的话，可以多多指出问题，</p>
<p>微软的远程过程调用（RPC）可以轻松越过进程和机器的界限并且进行数据通信。这种网络通信标准是微软Window网络通信如此强大的原因（….太绕了，翻不来，也不重要）。<br>然而，因为RPC对进程隐藏了网络调用，所以隐藏了计算机之间的交互细节。这使得用户很难确认线程为什么这么做，正在做什么，为什么在支持的功能上失败。所以，调试和解决RPC错误非常困难。另外，大部分RPC错误的问题实际上出现在配置问题，网络连接问题，其他组件问题上。<br><a id="more"></a><br>Windows有个调试工具是DbgRpc，是RPC相关的调试器扩展。这些扩展能够用来分析Windows Xp以及更新版本系统的各种RPC问题。<br>这些Windows版本可以配置来保存RPC实时状态信息。可以保存不同数量的状态信息；这可以让你获得需要的信息，而不用防止一个重的负担在你的电脑上了（significant burden，什么东西）。细节请看Enabling RPC State Information</p>
<p>之后这些信息就可以被调试器或者DbgRpc访问了。在每种情况下，一个集合的查询都是可以用的。细节请看Displaying RPC State Information</p>
<p>在大部分情况下，你可以通过使用Common RPC Debugging Techniques.中的技术找到问题。<br>如果你想探索一下机器是怎么保存这些细腻的，或者你想设计自己的状态信息分析的技术，可以看看RPC State Information Internals.<br>这些工具和技术在Windows2000中不能使用</p>
<h1 id="激活RPC状态信息"><a href="#激活RPC状态信息" class="headerlink" title="激活RPC状态信息"></a>激活RPC状态信息</h1><p>可以收集两种不同的RPC运行时状态信息：服务端信息和完整信息。必须要在调试器或者DbgRpc使用之前激活状态信息的收集。<br>只有Windows XP以及以后的系统可以收集RPC状态信息。<br>收集服务端状态信息是比较轻量级。每次RPC调用大概需要100条机器指令，甚至在性能测试中都几乎不可察觉已经被加载了（…）。但是收集这些信息会耗费内存（每个RPC服务端大概4KB），所以不推荐内存有压力的机器使用。服务端信息包括数据，endpoints，线程，连接对象和服务调用对象（SCALL）。这些足够调试大部分RPC问题了。<br>收集全部状态信息更加heavyweight。它收集了所有的信息，包括服务端信息，另外还有客户端调用对象（CCALL）。全部状态信息通常是不需要的。<br>在电脑中运行Group Policy Editor(Gpedit.msc)可以激活收集RPC状态信息的功能。在本地电脑策略中，找到Computer Configuration/Administrative Templates/System/Remote Procedure Call。在这节下面可以看到RPC Troubleshooting State Information，当你编辑它的属性时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本地计算机策略-计算机配置-管理模板-系统-远程过程调用-维护RPC疑难解答状态信息（默认未启用，启用之后配置下面5中状态）</div></pre></td></tr></table></figure>
<p>可以看到5中可能的状态：<br>None：不维持任何状态信息。除非你电脑内存压力很大，不推荐这种配置。<br>Server：收集服务端状态信息。推荐在个人电脑中设置这个。<br>Full：收集全部状态信息。<br>Auto1：在内存小于64MB的电脑中，相当于None配置。在大于64MB的电脑中相当于Server配置。<br>Auto2：在内存小于128MB的运行Windows Server2003的电脑，或者运行Windows XP的电脑，相当于None配置。在大于128MB的Windows Server 2003中，相当于Server。这个也是默认配置。</p>
<p>如果你想同时配置一个局域网中的电脑的这些状态，使用Group Policy Editor卷起（roll out）机器策略到首选的机器中。策略引擎会监视你配置的策略传到首选的机器中。在这种情况下，Auto1和Auto2是特别有用的，因为不同机器的操作系统和内存大小是不一样的。<br>如果网络中包括运行了比Windows XP更老的系统，这些电脑会忽略这些配置。</p>
<h1 id="显示RPC状态信息"><a href="#显示RPC状态信息" class="headerlink" title="显示RPC状态信息"></a>显示RPC状态信息</h1><p>各种各样的RPC调试扩展在Rpcexts.dll中导出。<br>这些用来显示RPC状态信息RPC扩展只能在用户模式中运行。他们可以在CDB(或者NTSD)或者用户模式的Windbg中使用。<br>用户模式的调试器必须有一个目标程序，但是这个目标跟RPC扩展又是没有关系的（？？）。如果调试器还没有运行，你可以简单打开它调试一个毫不相干的目标（比如windbg notepad或者cdb winmine）。接着在CDB中CTRL+C，或者Windbg中Debug|Break来停止目标进程，这样可以使用调试器的命令窗口。<br>如果你需要分析一个远程电脑的RPC状态信息，你需要在目标电脑中运行一个用户模式的调试器，然后使用Remote Debugging。<br>通过调试器访问RPC状态信息在一个stress环境中是特别有用的，或者当一个调试器已经运行了。</p>
<h2 id="使用RPC调试扩展"><a href="#使用RPC调试扩展" class="headerlink" title="使用RPC调试扩展"></a>使用RPC调试扩展</h2><p>各种各样的RPC调试扩展在Rpcexts.dll中导出。<br>这些用来显示RPC状态信息RPC扩展只能在用户模式中运行。他们可以在CDB(或者NTSD)或者用户模式的Windbg中使用。<br>用户模式的调试器必须有一个目标程序，但是这个目标跟RPC扩展又是没有关系的（？？）。如果调试器还没有运行，你可以简单打开它调试一个毫不相干的目标（比如windbg notepad或者cdb winmine）。接着在CDB中CTRL+C，或者Windbg中Debug|Break来停止目标进程，这样可以使用调试器的命令窗口。<br>如果你需要分析一个远程电脑的RPC状态信息，你需要在目标电脑中运行一个用户模式的调试器，然后使用Remote Debugging。<br>通过调试器访问RPC状态信息在一个stress环境中是特别有用的，或者当一个调试器已经运行了。</p>
<h2 id="使用DbgRpc工具"><a href="#使用DbgRpc工具" class="headerlink" title="使用DbgRpc工具"></a>使用DbgRpc工具</h2><p>DbgRpc工具（DbgRpc.exe）放在windbg安装目录中，必须使用命令提示窗口打开它。<br>双击是不能启动这个工具的。<br>命令提示窗口必须运行在本地电脑的administrator权限的账户下，或者域管理员权限。<br>DbgRpc不会对系统服务产生任何调用（比如LSASS）。 这个对调试时非常有用的，只要内核还在运行，即便在系统服务已经崩溃了。</p>
<p>在远程电脑中使用DbgRpc<br>DbgRpc也可以用来检查远程电脑的信息。为了让这个可以正常工作，远程电脑需要可以接受远程连接和远程认证用户。如果远程电脑的RPCSS服务已经崩溃，DbgRpc将不能工作。远程电脑中也需要Administrative或者域管理员权限。</p>
<p>-s参数用来指定服务端名字，-p指定传输协议。TCP和命名管道都可以使用。推荐使用TCP协议，它几乎可以在每种情况下使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">G:\&gt;dbgrpc -s MyServer -p ncacn_ip_tcp -l -P 1e8 -L 0.1</div><div class="line">Getting remote cell info ...</div><div class="line">Endpoint</div><div class="line">Status: Active</div><div class="line">Protocol Sequence: LRPC</div><div class="line">Endpoint name: OLE18</div></pre></td></tr></table></figure>
<p>DbgRpc命令行<br>可以查看详细的DbgRpc命令描述</p>
<h2 id="获取RPC-Cell信息"><a href="#获取RPC-Cell信息" class="headerlink" title="获取RPC Cell信息"></a>获取RPC Cell信息</h2><p>详细的cell信息通过!rpcexts.getdbgcell显示，或者使用DbgRpc的-l开关。<br>需要指定进程id已经cell number。<br>下面的例子，进程id是0x278，cell number是0000.0002</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -l -P 278 -L 0.2</div><div class="line">Getting cell info ...</div><div class="line">Thread</div><div class="line">Status: Dispatched</div><div class="line">Thread ID: 0x1A4 (420)</div><div class="line">Last update time (in seconds since boot):470.25 (0x1D6.19)</div><div class="line">For details on the optional parameters, see DbgRpc Command-Line Options.</div><div class="line">For a similar example using the RPC debugger extensions, see !rpcexts.getdbgcell.</div></pre></td></tr></table></figure>
<h2 id="获取RPC-Endpoint信息"><a href="#获取RPC-Endpoint信息" class="headerlink" title="获取RPC Endpoint信息"></a>获取RPC Endpoint信息</h2><p>Endpoint信息通过!rpcexts.getendpointinfo显示，或者DbgRpc的-e开关。<br>如果指定了endpoint number，就会显示它的信息。如果忽略endpoint number，系统中所有进程的endpoint都会显示。<br>下面是显示所有endpoints的例子，通常包含进程id和cell number作为额外的参数是很有用的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -e</div><div class="line">Searching for endpoint info ...</div><div class="line">PID  CELL ID   ST PROTSEQ        ENDPOINT</div><div class="line">-------------------------------------------------------</div><div class="line">00a8 0000.0001 01            NMP \PIPE\InitShutdown</div><div class="line">00a8 0000.0003 01            NMP \PIPE\SfcApi</div><div class="line">00a8 0000.0004 01            NMP \PIPE\ProfMapApi</div><div class="line">00a8 0000.0007 01            NMP \pipe\winlogonrpc</div><div class="line">00a8 0000.0008 01           LRPC OLE5</div><div class="line">00c4 0000.0001 01           LRPC ntsvcs</div><div class="line">00c4 0000.0003 01            NMP \PIPE\ntsvcs</div><div class="line">00c4 0000.0008 01            NMP \PIPE\scerpc</div><div class="line">00d0 0000.0001 01            NMP \PIPE\lsass</div><div class="line">00d0 0000.0004 01            NMP \pipe\WMIEP_d0</div><div class="line">00d0 0000.000b 01            NMP \PIPE\POLICYAGENT</div><div class="line">00d0 0000.000c 01           LRPC policyagent</div><div class="line">0170 0000.0001 01           LRPC epmapper</div><div class="line">0170 0000.0003 01            TCP 135</div><div class="line">0170 0000.0005 01            SPX 34280</div><div class="line">0170 0000.0006 01             NB 135</div><div class="line">0170 0000.0007 01             NB 135</div><div class="line">0170 0000.000b 01            NMP \pipe\epmapper</div><div class="line">01b8 0000.0001 01            NMP \pipe\spoolss</div><div class="line">01b8 0000.0003 01           LRPC spoolss</div><div class="line">01b8 0000.0007 01           LRPC OLE7</div><div class="line">00ec 0000.0001 01           LRPC OLE2</div><div class="line">00ec 0000.0003 01           LRPC senssvc</div><div class="line">00ec 0000.0007 01            NMP \pipe\tapsrv</div><div class="line">00ec 0000.0008 01           LRPC tapsrvlpc</div><div class="line">00ec 0000.000c 01            NMP \PIPE\ROUTER</div><div class="line">00ec 0000.0010 01            NMP \pipe\WMIEP_ec</div><div class="line">0214 0000.0001 01            NMP \PIPE\winreg</div><div class="line">022c 0000.0001 01           LRPC LRPC0000022c.00000001</div><div class="line">022c 0000.0003 01            TCP 1058</div><div class="line">022c 0000.0005 01            SPX 24576</div><div class="line">022c 0000.0006 01            NMP \PIPE\atsvc</div><div class="line">02a8 0000.0001 01           LRPC OLE3</div><div class="line">0370 0000.0001 01           LRPC OLE9</div><div class="line">0278 0000.0001 01            TCP 1120</div><div class="line">030c 0000.0001 01           LRPC OLE12</div></pre></td></tr></table></figure>
<p>For details on the optional parameters, see DbgRpc Command-Line Options.<br>For a similar example using the RPC debugger extensions, see !rpcexts.getendpointinfo.</p>
<h2 id="获取RPC线程信息"><a href="#获取RPC线程信息" class="headerlink" title="获取RPC线程信息"></a>获取RPC线程信息</h2><p>使用显示!rpcexts.getthreadinfo线程信息，或者DbgRpc的-t开关。<br>必须指定进程pid。也可以指定线程ID，如果忽略，显示进程的所有线程。<br>例子，进程ID 0x278，忽略了线程ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -t -P 278</div><div class="line">Searching for thread info ...</div><div class="line">PID  CELL ID   ST TID      LASTTIME</div><div class="line">-----------------------------------</div><div class="line">0278 0000.0002 01 000001a4 00072c09</div><div class="line">0278 0000.0005 03 0000031c 00072bf5</div><div class="line">For details on the optional parameters, see DbgRpc Command-Line Options.</div><div class="line">For a similar example using the RPC debugger extensions, see !rpcexts.getthreadinfo.</div></pre></td></tr></table></figure>
<h2 id="获取RPC调用信息"><a href="#获取RPC调用信息" class="headerlink" title="获取RPC调用信息"></a>获取RPC调用信息</h2><p>服务端调用信息通过!rpcexts.getcallinfo显示，DbgRpc的-c开关<br>有4个可选的参数。其中三个CallID，IfStart，ProcNum是用来跟中RPC调用来标记信息的。第四个参数是ProcessID是服务端的Pid。你可以使用你知道的参数值来缩小搜索。<br>如果没有参数指定，系统中所有可知的SCALLs都会显示。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -c</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   ST PNO IFSTART  TIDNUMBER CALLFLAG CALLID   LASTTIME CONN/CLN</div><div class="line">----------------------------------------------------------------------------</div><div class="line">00c4 0000.0002 00 00f 82273fdc 0000.0007 00000001 00000002 0003595d 0000.0010</div><div class="line">00c4 0000.0006 00 009 367abb81 0000.0015 00000001 0000004d 000185bd 0000.0005</div><div class="line">00c4 0000.000a 00 007 367abb81 0000.002d 00000001 0000009f 00014672 0000.0009</div><div class="line">00c4 0000.000c 00 007 367abb81 0000.002d 00000001 00000083 000122e3 0000.000b</div><div class="line">00c4 0000.000d 00 03b 8d9f4e40 0000.002d 00000001 000000f7 0001aba5 0000.0020</div><div class="line">00c4 0000.000e 00 03b 8d9f4e40 0000.0026 00000001 00000002 00023056 0000.0021</div><div class="line">00c4 0000.000f 00 008 82273fdc 0000.001e 00000009 baadf00d 000366b4 00ec.03bc</div><div class="line">00c4 0000.0012 00 00d 8d9f4e40 0000.0004 00000001 00000051 0000a334 0000.0011</div><div class="line">00c4 0000.0014 00 000 367abb81 0000.0015 00000001 0000004c 0002db53 0000.0013</div><div class="line">00c4 0000.0017 00 007 367abb81 0000.0015 00000001 00000006 0000d102 0000.0016</div><div class="line">00c4 0000.0019 00 007 367abb81 0000.0004 00000001 00000006 0000f09e 0000.0018</div><div class="line">00c4 0000.001b 00 009 65a93890 0000.0007 00000001 0000012e 00630f65 0000.001a</div><div class="line">00c4 0000.001e 00 026 8d9f4e40 0000.0015 00000001 0000037d 0005e579 0000.002c</div><div class="line">00c4 0000.001f 00 008 82273fdc 0000.0033 00000009 baadf00d 000145b3 00c4.02f8</div><div class="line">00c4 0000.0023 00 000 367abb81 0000.0004 00000001 0000007e 000372f3 0000.0022</div><div class="line">00c4 0000.0025 00 03b 8d9f4e40 0000.0026 00000001 0000000b 000122e3 0000.0024</div><div class="line">00c4 0000.0027 00 000 367abb81 0000.002d 00000001 0000000b 00012e27 0000.0028</div><div class="line">00c4 0000.002a 00 008 82273fdc 0000.0033 00000009 baadf00d 0001245f 022c.0290</div><div class="line">00c4 0000.002f 00 007 367abb81 0000.0026 00000001 0000000a 0002983c 0000.002e</div><div class="line">00c4 0000.0031 00 004 3ba0ffc0 0000.0026 00000001 00000007 0005c439 0000.001c</div><div class="line">00c4 0000.0032 00 00b 82273fdc 0000.0039 00000009 baadf00d 00687db6 00d0.01d4</div><div class="line">00c4 0000.0036 00 007 367abb81 0000.0030 00000001 00000065 0003a5e1 0000.0035</div><div class="line">00c4 0000.0037 00 00d 8d9f4e40 0000.0015 00000001 0000033f 000376fa 0000.002b</div><div class="line">00c4 0000.0038 00 008 8d9f4e40 0000.0015 00000001 00000803 0018485c 0000.003b</div><div class="line">00c4 0000.003c 00 00b 82273fdc 0000.0034 00000009 baadf00d 0001f956 00a8.0244</div><div class="line">00c4 0000.003d 00 008 82273fdc 0000.0034 00000009 baadf00d 0001ff02 01b8.037c</div><div class="line">0170 0000.0009 00 002 e60c73e6 0000.0013 00000009 baadf00d 0005a371 00ec.031c</div><div class="line">0170 0000.000a 00 002 0b0a6584 0000.0002 00000009 baadf00d 000126ae 00c4.0130</div><div class="line">0170 0000.000c 00 002 0b0a6584 0000.0010 00000009 baadf00d 00012bc4 022c.0290</div><div class="line">0170 0000.000d 00 003 00000136 0000.001b 00000009 baadf00d 0005ba71 00ec.0310</div><div class="line">0170 0000.000e 00 000 412f241e 0000.0002 00000009 baadf00d 00012f21 02a8.029c</div><div class="line">0170 0000.0010 00 003 00000136 0000.0013 00000009 00000003 000341da 0370.0060</div><div class="line">0170 0000.0011 00 006 e60c73e6 0000.001b 00000009 baadf00d 000f1d00 0370.0328</div><div class="line">0170 0000.0017 00 002 0b0a6584 0000.001b 00000009 baadf00d 0006c803 0278.0184</div><div class="line">0170 0000.001a 00 004 00000136 0000.0012 00000001 baadf00d 00038e9b 00ec.0348</div><div class="line">00ec 0000.0006 00 009 00000134 0000.0011 00000009 baadf00d 000b233f 0170.0244</div><div class="line">00ec 0000.000b 00 001 2f5f6520 0000.001c 00000009 baadf00d 00035510 00ec.0334</div><div class="line">00ec 0000.000e 00 001 629b9f66 0000.0014 00000009 baadf00d 00035813 00ec.01c4</div><div class="line">00ec 0000.0012 00 000 629b9f66 0000.0014 00000009 baadf00d 00026cc6 00a8.0164</div><div class="line">00ec 0000.001b 00 001 2f5f6520 0000.0004 00000001 baadf00d 000352c1 00ec.03a8</div><div class="line">02a8 0000.0004 00 009 00000134 0000.0002 00000009 baadf00d 0009a540 0170.0244</div><div class="line">0370 0000.0006 00 003 00000134 0000.0005 0000000b baadf00d 0002e7cd 00ec.0350</div><div class="line">0370 0000.0008 00 009 00000134 0000.0007 0000000b 01cee9e4 000838fa 0170.0244</div><div class="line">0278 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00072c09 0000.0003</div></pre></td></tr></table></figure>
<p>For details on the optional parameters, see DbgRpc Command-Line Options.<br>For a similar example using the RPC debugger extensions, see !rpcexts.getcallinfo.</p>
<h2 id="获取RPC客户端调用信息"><a href="#获取RPC客户端调用信息" class="headerlink" title="获取RPC客户端调用信息"></a>获取RPC客户端调用信息</h2><p>使用!rpcexts.getclientcallinfo获取客户端调用信息，或者DbgRpc的-a开关。<br>也有四个参数可选。其中三个CallID，IfStart，ProcNum是用来跟中RPC调用来标记信息的。第四个参数ProcessID是属于这个调用的进程的Pid。你可以使用你知道的参数值来缩小搜索。<br>如果没有参数指定，系统中所有可知的CCALLs都会显示。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -a</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   PNO  IFSTART  TIDNUMBER CALLID   LASTTIME PS CLTNUMBER ENDPOINT</div><div class="line">------------------------------------------------------------------------------</div><div class="line">0390 0000.0001 0000 19bb5061 0000.0000 00000001 00072bff 07 0000.0002 1120</div></pre></td></tr></table></figure>
<p>For details on the optional parameters, see DbgRpc Command-Line Options.<br>For a similar example using the RPC debugger extensions, see !rpcexts.getclientcallinfo.</p>
<p>注意：<br>只有在全部状态信息都收集的时候，才有CCALLS的信息。</p>
<h1 id="常用的RPC调试技术"><a href="#常用的RPC调试技术" class="headerlink" title="常用的RPC调试技术"></a>常用的RPC调试技术</h1><p>下面将介绍4中常见的RPC问题。RPC状态信息可以用来检查这些问题。<br>DbgRpc和RPC调试扩展命令都可以使用。</p>
<h2 id="分析一个Stuck（卡）调用问题"><a href="#分析一个Stuck（卡）调用问题" class="headerlink" title="分析一个Stuck（卡）调用问题"></a>分析一个Stuck（卡）调用问题</h2><p>当一个进程直接或间接的进行一次RPC调用时，等待（holding）一个critical section或者资源时通过会出现这个问题。在这种情况下，RPC调用会到另一个进程或者机器，然后派遣到管理接口（服务接口）中，这个会等待很久。这导致调用方会出现等待超时。</p>
<p>当通过调试器检查时，RPC是这个等待线程的最高层，但是不清楚究竟在等待什么。<br>下面是一个这种堆栈的例子，有很多可能性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0:002&gt; ~1k</div><div class="line">ChildEBP RetAddr</div><div class="line">0068fba0 77e9e8eb ntdll!ZwWaitForSingleObject+0xb</div><div class="line">0068fbc8 4efeff73 KERNEL32!WaitForSingleObjectEx+0x5a</div><div class="line">0068fbe8 4eff0012 RPCRT4!UTIL_WaitForSyncIO+0x21</div><div class="line">0068fc0c 4efe6e2b RPCRT4!UTIL_GetOverlappedResultEx+0x44</div><div class="line">0068fc44 4ef973bf RPCRT4!WS_SyncRecv+0x12a</div><div class="line">0068fc68 4ef98d5a RPCRT4!OSF_CCONNECTION__TransSendReceive+0xcb</div><div class="line">0068fce4 4ef9b682 RPCRT4!OSF_CCONNECTION__SendFragment+0x297</div><div class="line">0068fd38 4ef9a5a8 RPCRT4!OSF_CCALL__SendNextFragment+0x272</div><div class="line">0068fd88 4ef9a9cb RPCRT4!OSF_CCALL__FastSendReceive+0x165</div><div class="line">0068fda8 4ef9a7f8 RPCRT4!OSF_CCALL__SendReceiveHelper+0xed</div><div class="line">0068fdd4 4ef946a7 RPCRT4!OSF_CCALL__SendReceive+0x37</div><div class="line">0068fdf0 4efd56b3 RPCRT4!I_RpcSendReceive+0xc4</div><div class="line">0068fe08 01002850 RPCRT4!NdrSendReceive+0x4f</div><div class="line">0068ff40 01001f32 rtclnt+0x2850</div><div class="line">0068ffb4 77e92ca8 rtclnt+0x1f32</div><div class="line">0068ffec 00000000 KERNEL32!CreateFileA+0x11b</div></pre></td></tr></table></figure>
<p>下面是怎么检查这个问题。<br><strong>Troubleshooting a stuck call problem</strong></p>
<p>1- 保证调试器正在调试有这个stuck cell的进程。（是那个可能在等待RPC的线程所属的进程）<br>2- 或者线程的堆栈指针。堆栈就像上面例子中显示的那样，这个例子的堆栈指针是0x0068FBA0<br>3- 获取这个线程的调用信息。通过!rpcexts.rpcreadstack加上堆栈指针作为参数来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.rpcreadstack 68fba0</div><div class="line">CallID: 1</div><div class="line">IfStart: 19bb5061</div><div class="line">ProcNum: 0</div><div class="line">Protocol Sequence:      &quot;ncacn_ip_tcp&quot;  (Address: 00692ED8)</div><div class="line">NetworkAddress: &quot;&quot;      (Address: 00692F38)</div><div class="line">Endpoint:       &quot;1120&quot;  (Address: 00693988)</div></pre></td></tr></table></figure>
<p>显示的这些信息可以让你跟踪这个调用。</p>
<p>4- 网络地址是空的，标明是本地机器。Endpoint是1120。需要确认哪个进程拥有这个endpoint。通过!rpcexts.getendpointinfo加上endpoint作为参数来获取 //应该是客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getendpointinfo 1120</div><div class="line">Searching for endpoint info ...</div><div class="line">PID  CELL ID   ST PROTSEQ        ENDPOINT</div><div class="line">--------------------------------------------</div><div class="line">0278 0000.0001 01            TCP 1120</div></pre></td></tr></table></figure>
<p>5- 根据前面的信息，可以看到进程0x278拥有这个endpoint，可以通过!rpcexts.getcallinfo<br>获取到这个call的所有信息，需要加上四个参数CallID, IfStart, and ProcNum（3步骤已经知道）和进程pid 0x278</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getcallinfo 1 19bb5061 0 278</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   ST PNO IFSTART  TIDNUMBER CALLFLAG CALLID   LASTTIME CONN/CLN</div><div class="line">----------------------------------------------------------------------------</div><div class="line">0278 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00072c09 0000.0003</div></pre></td></tr></table></figure>
<p>6- 第5步的信息非常有用，但是有些信息太少了。第二列给出的cell id是0000.0004。如果<br>!rpcexts.getdbgcell加上这个cell id，可以显示更易读的cell信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getdbgcell 278 0.4</div><div class="line">Getting cell info ...</div><div class="line">Call</div><div class="line">Status: Dispatched</div><div class="line">Procedure Number: 0</div><div class="line">Interface UUID start (first DWORD only): 19BB5061</div><div class="line">Call ID: 0x1 (1)</div><div class="line">Servicing thread identifier: 0x0.2</div><div class="line">Call Flags: cached</div><div class="line">Last update time (in seconds since boot):470.25 (0x1D6.19)</div><div class="line">Owning connection identifier: 0x0.3</div></pre></td></tr></table></figure>
<p>信息显示这个调用已经”dispatched”，表示已经离开了RPC运行时。最后更新时间是470.25，通过!rpcexts.rpctime可以看到现在的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.rpctime</div><div class="line">Current time is: 6003, 422</div></pre></td></tr></table></figure>
<p>表示这次call的最后联系在5533秒之前了，接近92分钟，因此这个肯定是一个stuck call。</p>
<p>7- 在挂载到服务端进程之前，你可以使用Servicing thread identifier找到当前处理这个call的线程信息。也就是另一个cell number，第6步中的0x0.2，可以像下面一样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getdbgcell 278 0.2</div><div class="line">Getting cell info ...</div><div class="line">Thread</div><div class="line">Status: Dispatched</div><div class="line">Thread ID: 0x1A4 (420)</div><div class="line">Last update time (in seconds since boot):470.25 (0x1D6.19)</div></pre></td></tr></table></figure>
<p>现在你知道你要找的是0x278进程的0x1A4线程。</p>
<p>可能这个线程已经在做其他的RPC调用了，你又必要重复这个过程跟踪这个call。</p>
<p>##跟踪服务端进程的Contention（争用）</p>
<p>为了能够处理发来的请求，RPC报了一个工作线程集合。理论上这个线程数量很小。然后理想的情况只存在实验室环境下，这些服务管理函数非常小心和谐（。。。）。在真实情况下，线程的数量决定于服务端的工作量，不过不管怎么样都在1-50的范围内。<br>如果工作线程数量超过了50，可能服务端进程有过多的竞争。通过引起这个的是heap的胡乱使用，内存的压力，或者服务端大部分的活动都通过一个单独的临界区。<br>使用!rpcexts.getthreadinfo获取服务进程的线程数量，或者DbgRpc的-t选项。需要指定进程ID，如下面的0xC4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -t -P c4</div><div class="line">Searching for thread info ...</div><div class="line">PID  CELL ID   ST TID      LASTTIME</div><div class="line">-----------------------------------</div><div class="line">00c4 0000.0004 03 0000011c 000f164f</div><div class="line">00c4 0000.0007 03 00000120 008a6290</div><div class="line">00c4 0000.0015 03 0000018c 008a6236</div><div class="line">00c4 0000.0026 03 00000264 0005c443</div><div class="line">00c4 0000.002d 03 00000268 000265bb</div><div class="line">00c4 0000.0030 03 0000026c 000f1d32</div><div class="line">00c4 0000.0034 03 00000388 007251e9</div></pre></td></tr></table></figure>
<p>在这个例子中，只有7个工作线程，是合理的。<br>如果有超过100个线程，就需要加载调试器看看问题了。<br>Note  Running queries such as dbgrpc -t remotely is expensive to the server and the network. If you use this query in a script, you should make sure this command is not run too often.</p>
<h2 id="检查Struct的线程"><a href="#检查Struct的线程" class="headerlink" title="检查Struct的线程"></a>检查Struct的线程</h2><p>RPC需要它的工作线程来完成正常的工作，通常有个问题，在同一个进程中的组件会因为等待一个公共的临界区死锁（比如，loader lock或者heap lock）。这将导致很多线程暂停，很有可能也有RPC工作线程。<br>如果出现了这种情况，RPC服务器不会再给外界响应。RPC调用将返回RPC_S_SERVER_UNAVAILABLE或者RPC_S_SERVER_TOO_BUSY</p>
<p>一个很小的问题可能会硬气有问题的驱动阻止IRPs完成，到达RPC服务器。<br>如果你怀疑可能出现了这个问题，使用DbgRpc –t或者!rpcexts.getthreadinfo需要进程PID作为参数。下面的列子是0xC4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -t -P c4</div><div class="line">Searching for thread info ...</div><div class="line">PID  CELL ID   ST TID      LASTTIME</div><div class="line">-----------------------------------</div><div class="line">00c4 0000.0004 03 0000011c 000f164f</div><div class="line">00c4 0000.0007 03 00000120 008a6290</div><div class="line">00c4 0000.0015 03 0000018c 008a6236</div><div class="line">00c4 0000.0026 03 00000264 0005c443</div><div class="line">00c4 0000.002d 03 00000268 000265bb</div><div class="line">00c4 0000.0030 03 0000026c 000f1d32</div><div class="line">00c4 0000.0034 03 00000388 007251e9</div></pre></td></tr></table></figure>
<p>TID那一列给出了每个线程的ID。LATSTIME列包含每个线程最近状态改变的时间戳。<br>只要服务器收到一个请求，至少有一个线程会改变状态，时间戳就会更新。因此，一个RPC请求失败了，但是没有任何一个线程的时间戳改变，表示这个请求没有到达RPC运行时中。你需要在研究是什么引起的。</p>
<h2 id="在服务端标明调用者"><a href="#在服务端标明调用者" class="headerlink" title="在服务端标明调用者"></a>在服务端标明调用者</h2><p>有些时候需要确认谁发送的RPC请求，虽然你只有这次调用的服务线程信息。<br>这个非常有用-比如，找到谁传递了不合法的参数给RPC调用。<br>根据某些特别依赖于协议序列的调用，你可以或者不同程度的细节，而有些协议根本没有这些信息（比如NetBiso）</p>
<p>Identifying the caller from the server thread<br>1- 打开用户模式调试器，挂载到目标服务线程中<br>2- 通过|命令获取到进程id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:001&gt; |</div><div class="line">0     id: 3d4 name: rtsvr.exe</div></pre></td></tr></table></figure>
<p>3- !rpcexts.getcallinfo获取到进程中存在的calls。需要指定进程ID 0x3D4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getcallinfo 0 0 FFFF 3d4</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   ST PNO IFSTART  THRDCELL  CALLFLAG CALLID   LASTTIME CONN/CLN</div><div class="line">----------------------------------------------------------------------------</div><div class="line">03d4 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00a1aced 0000.0003</div></pre></td></tr></table></figure>
<p>查找状态时2或1（dispatched或active）的调用。在这个例子中，只有一个call，如果有更多的，你可以使用!rpcexts.getdbgcell加上cell number（THRDCELL列）来获取线程IDs，从而你可以决定哪个是你感兴趣的调用了</p>
<p>4- 在知道你感兴趣的call之后，看看CONN/CLN所在的cell number，这个是连接对象的cell ID。这里是0000.0003。使用!rpcexts.getdbgcell加上这个id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getdbgcell 3d4 0.3</div><div class="line">Getting cell info ...</div><div class="line">Connection</div><div class="line">Connection flags: Exclusive</div><div class="line">Authentication Level: Default</div><div class="line">Authentication Service: None</div><div class="line">Last Transmit Fragment Size: 24 (0x6F56D)</div><div class="line">Endpoint for the connection: 0x0.1</div><div class="line">Last send time (in seconds since boot):10595.565 (0x2963.235)</div><div class="line">Last receive time (in seconds since boot):10595.565 (0x2963.235)</div><div class="line">Getting endpoint info ...</div><div class="line">Process object for caller is 0xFF9DF5F0</div></pre></td></tr></table></figure>
<p>这个命令显示了这个连接的客户端的所有信息。实际的信息会有很多不同，跟使用的transport有关系。<br>在这个例子中，使用的本地命令管道通信，调用者的进程对象地址也显示了。如果你挂载了内核调试器（或者启动一个本地调试器），你可以使用!process看到看看这个地址的信息。<br>如果使用LRPC通信，会显示进程ID和线程ID。<br>如果使用TCP通信，会显示调用者的IP地址。<br>如果使用了远程命名管道，不会显示任何信息。</p>
<hr>
<p>转载请注明出处，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在调试rpc，没法子，翻译了一下windbg这篇调试RPC的文档，后面可能还有其他内容，也就弄个系列吧<br>算是自己的笔记，有看客的话，可以多多指出问题，提提建议，不吝赐教！</p>
<p>微软的远程过程调用（RPC）可以轻松越过进程和机器的界限并且进行数据通信。这种网络通信标准是微软Window网络通信如此强大的原因（….太绕了，翻不来，也不重要）。<br>然而，因为RPC对进程隐藏了网络调用，所以隐藏了计算机之间的交互细节。这使得用户很难确认线程为什么这么做，正在做什么，为什么在支持的功能上失败。所以，调试和解决RPC错误非常困难。另外，大部分RPC错误的问题实际上出现在配置问题，网络连接问题，其他组件问题上。<br>]]>
    
    </summary>
    
      <category term="Windbg调试" scheme="http://anhkgg.github.io/tags/Windbg%E8%B0%83%E8%AF%95/"/>
    
      <category term="RPC" scheme="http://anhkgg.github.io/tags/RPC/"/>
    
      <category term="远程过程调用" scheme="http://anhkgg.github.io/tags/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="debug" scheme="http://anhkgg.github.io/categories/debug/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux pyspider learning]]></title>
    <link href="http://anhkgg.github.io/linux-pyspider-learning/"/>
    <id>http://anhkgg.github.io/linux-pyspider-learning/</id>
    <published>2015-01-24T10:54:17.000Z</published>
    <updated>2016-07-07T04:27:03.432Z</updated>
    <content type="html"><![CDATA[<h1 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1. 创建工程"></a><strong>1. 创建工程</strong></h1><p>运行pyspider，然后浏览器中输入localhost:5000，即可进入project管理，Create创建新的project</p>
<a id="more"></a>
<h1 id="2-编码"><a href="#2-编码" class="headerlink" title="2. 编码"></a><strong>2. 编码</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">from pyspider.libs.base_handler import * </div><div class="line">import re </div><div class="line"></div><div class="line">class Handler(BaseHandler): </div><div class="line">crawl_config = &#123; </div><div class="line">&#125; </div><div class="line">@every(minutes=24 * 60) </div><div class="line">def on_start(self): </div><div class="line">for i in range(1, 287): </div><div class="line">self.crawl(&apos;http://xxx?ajax=1&amp;major=73&amp;showMore=0&amp;refer=cindex&amp;page=&apos;+str(i)+&apos;&amp;_CSRFToken=&apos;, callback=self.index_page) </div><div class="line"></div><div class="line">@config(age=10 * 24 * 60 * 60) </div><div class="line">def index_page(self, response): </div><div class="line">#print response.json[&apos;data&apos;] </div><div class="line">total = response.json[&apos;data&apos;][&apos;total&apos;] </div><div class="line">lists = response.json[&apos;data&apos;][&apos;lists&apos;] </div><div class="line">#print total, len(lists) </div><div class="line">for i in range(0, len(lists)): </div><div class="line">url = lists[i][&apos;url&apos;]; </div><div class="line">#if re.match(&quot;http://xxx?/corp/\d+/project/\d+&quot;, url): </div><div class="line">self.crawl(url, callback=self.detail_page) </div><div class="line"></div><div class="line">def detail_page(self, response): </div><div class="line">#信息过滤提取</div><div class="line">content = response.doc(&apos;div.position-content&apos;).text() </div><div class="line">if content == &quot;&quot; or content == None: </div><div class="line">content = response.doc(&apos;div.project-info &gt; div.pro-detail&apos;).text() </div><div class="line">return &#123; </div><div class="line">&quot;url&quot;: response.url, </div><div class="line">&quot;title&quot;: response.doc(&apos;title&apos;).text(), </div><div class="line">&quot;content&quot;: content </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>self.crawl(url, callback)抓取网页，callback为响应函数<br>def callback(self, response),response表示内容，可以通过response.doc(‘各类选择器’).text()获取到需要的内容<br>更多response的操作可以查看<a href="http://docs.pyspider.org/en/latest/apis/Response/" target="_blank" rel="external">pyspider response</a></p>
<p><em>注意：</em><br>由于 response.doc是一个<a href="https://pythonhosted.org/pyquery/#quickstart" target="_blank" rel="external">pyquery</a>对象，信息过滤中可以使用css选择器<br>pyspider自带css选择器生成，但是貌似不能使用<br>在浏览器中f12，也可以自动生成选择器<br><img src="/img/css_select.png" alt="img"><br>在生成的选择其中，如&lt;#pagecontent &gt; table:nth-child(3) &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(2) &gt; table &gt; tbody &gt; tr &gt; td &gt; div:nth-child(2)&gt;<br>需要去掉其中的tbody标签，否则无法使用，是否还有其他标签，没有过多测试<br>其实css选择器不用从上到下完整的生成，只要能够唯一获取指定的元素即可</p>
<h1 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a><strong>3. 调试</strong></h1><p>第一次run，调用on_start，crawl指定的url，然后调用callback函数，界面显示如图<br><img src="/img/pyspider_d1.png" alt="img"></p>
<p>切换到follow窗口，可以看到符合callback函数的url列表<br><img src="/img/pyspider_d2.png" alt="img"></p>
<p>点击列表中右侧播放按钮，crawl该页面，获取符合规则的url，调用下一个callback<br><img src="/img/pyspider_d3.png" alt="img"></p>
<p>然后继续播放按钮，可能就是需要页面内容过滤了，根据自己的需求进行过滤<br>return返回的内容会写入数据库</p>
<h1 id="4-调试好之后，run"><a href="#4-调试好之后，run" class="headerlink" title="4.  调试好之后，run"></a><strong>4.  调试好之后，run</strong></h1><p><img src="/img/pyspider_d4.png" alt="img"><br>然后就可以在results页面看到爬取结果了。<br><img src="/img/pyspider_d5.png" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1. 创建工程"></a><strong>1. 创建工程</strong></h1><p>运行pyspider，然后浏览器中输入localhost:5000，即可进入project管理，Create创建新的project</p>]]>
    
    </summary>
    
      <category term="pyspider" scheme="http://anhkgg.github.io/tags/pyspider/"/>
    
      <category term="python" scheme="http://anhkgg.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[upx3.05手脱笔记]]></title>
    <link href="http://anhkgg.github.io/upx3-05%E6%89%8B%E8%84%B1%E7%AC%94%E8%AE%B0/"/>
    <id>http://anhkgg.github.io/upx3-05手脱笔记/</id>
    <published>2015-01-07T06:57:42.000Z</published>
    <updated>2015-01-07T07:14:13.000Z</updated>
    <content type="html"><![CDATA[<p>本来一直对upx3.0以后加密壳挺畏惧的，其逻辑看起来挺简单的，有想逆一把的想法，但是都没实施，今天又遇到了，没法，太急，去google了一下，找到几篇资料<br>但是年代都挺久远的，看到[1]中直接esp定律就脱了，有点不信，就试了试，靠，居然可以，只能表示，实践是检验真理的唯一标准。</p>
<a id="more"></a>
<p>#<strong>1. 查壳</strong><br><strong>[!] UPX 3.05 compressed !</strong><br>查出来是3.05，也不知道是不是误报，比[1]中版本高了点，所以也就是尝试尝试esp定律拖一下</p>
<p>#<strong>2. 脱壳</strong><br>OD加载（是个dll，通过load.exe加载），在DllMain断下，看到熟悉的pushad，感觉方法可能靠谱了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">103432E0 &gt;  807C24 08 01    cmp byte ptr ss:[esp+0x8],0x1</div><div class="line">103432E5    0F85 9D0B0000   jnz xxx.10343E88</div><div class="line">103432EB    60              pushad</div><div class="line">103432EC    BE 00C02C10     mov esi,xxx.102CC000</div></pre></td></tr></table></figure></p>
<p>f8到103432EC ，在数据窗口显示esp值，然后右键下了个硬件访问断点（其实以前尝试过，但是下的是内存访问断点，失败了，也不知道是不是这个原因，待会儿试试）。接着F9，断在了下面的代码中，看不出啥，就有个 jmp xxx.100C3C71，地址离当前地址还算较远，可能是另一个节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10343E7B    8D4424 80       lea eax,dword ptr ss:[esp-0x80] //这个就是先前pushad压入的吗？？</div><div class="line">10343E7F    6A 00           push 0x0</div><div class="line">10343E81    39C4            cmp esp,eax</div><div class="line">10343E83  ^ 75 FA           jnz short xxx.10343E7F //循环了多次，F4直接到10343E85  ，应该是在清理堆栈吧？？  </div><div class="line">10343E85    83EC 80         sub esp,-0x80</div><div class="line">10343E88  - E9 E4FDD7FF     jmp xxx.100C3C71</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">100C3C71   /E9 CA371100     jmp xxx.101D7440</div><div class="line">100C3C76   |E9 15311700     jmp xxx.10236D90                           ; jmp 到 kernel32.UnlockFile</div></pre></td></tr></table></figure>
<p>单步到jmp，F8跟到其代码中，看到了熟悉的一段入口代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">101D7440    8BFF            mov edi,edi</div><div class="line">101D7442    55              push ebp</div><div class="line">101D7443    8BEC            mov ebp,esp</div><div class="line">101D7445    837D 0C 01      cmp dword ptr ss:[ebp+0xC],0x1</div><div class="line">101D7449    75 05           jnz short xxx.101D7450</div><div class="line">101D744B    E8 32DFEEFF     call xxx.100C5382</div><div class="line">101D7450    8B45 10         mov eax,dword ptr ss:[ebp+0x10]</div><div class="line">101D7453    50              push eax</div><div class="line">101D7454    8B4D 0C         mov ecx,dword ptr ss:[ebp+0xC]</div><div class="line">101D7457    51              push ecx</div><div class="line">101D7458    8B55 08         mov edx,dword ptr ss:[ebp+0x8]</div><div class="line">101D745B    52              push edx</div><div class="line">101D745C    E8 1F000000     call xxx.101D7480</div><div class="line">101D7461    83C4 0C         add esp,0xC</div><div class="line">101D7464    5D              pop ebp</div><div class="line">101D7465    C2 0C00         retn 0xC</div></pre></td></tr></table></figure></p>
<p>通过堆栈参数，进一步确认了下，这是DllMain函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0006F880   7C92118A  返回到 ntdll.7C92118A</div><div class="line">0006F884   10000000  xxx.10000000</div><div class="line">0006F888   00000001</div><div class="line">0006F88C   00000000</div></pre></td></tr></table></figure></p>
<p>然后在101D7440地址，尝试dump，成功之后在检测壳信息<br><strong>[CompilerDetect] -&gt; Visual C++ 9.0 (Visual Studio 2008)</strong><br>应该是脱壳成功了，但是iat没有修复，先ida看看是否需要修复</p>
<p>#<strong>3. 修复</strong><br>如果需要修复，使用importRec工具<br><img src="/img/fix.png" alt="img"><br>找到进程，选择目标dll，然后填入OEP，修复即可</p>
<p>#<strong>4. 参考</strong></p>
<p>[1]: <a href="http://bbs.pediy.com/showthread.php?t=44125" target="_blank" rel="external">http://bbs.pediy.com/showthread.php?t=44125</a> 【原创】手脱 UPX3.0<br>[2]: <a href="http://bbs.pediy.com/showthread.php?t=140312" target="_blank" rel="external">http://bbs.pediy.com/showthread.php?t=140312</a> 【原创】UPX3.03脱壳机-学习版[代码更新]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来一直对upx3.0以后加密壳挺畏惧的，其逻辑看起来挺简单的，有想逆一把的想法，但是都没实施，今天又遇到了，没法，太急，去google了一下，找到几篇资料<br>但是年代都挺久远的，看到[1]中直接esp定律就脱了，有点不信，就试了试，靠，居然可以，只能表示，实践是检验真理的唯一标准。</p>]]>
    
    </summary>
    
      <category term="upx" scheme="http://anhkgg.github.io/tags/upx/"/>
    
      <category term="unpack" scheme="http://anhkgg.github.io/tags/unpack/"/>
    
      <category term="reverse" scheme="http://anhkgg.github.io/categories/reverse/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xctf sctf summary, little writeup]]></title>
    <link href="http://anhkgg.github.io/sctf-summary/"/>
    <id>http://anhkgg.github.io/sctf-summary/</id>
    <published>2014-12-07T13:02:23.000Z</published>
    <updated>2016-07-07T04:28:44.869Z</updated>
    <content type="html"><![CDATA[<h1 id="1-Misc10"><a href="#1-Misc10" class="headerlink" title="1. Misc10"></a><strong>1. Misc10</strong></h1><p>xctf优良传统，百度之<br>手持两把锟斤拷，口中疾呼烫烫烫<br>脚踏千朵屯屯屯，笑看万物锘锘锘<br>其实我没提交，队友提交的，应该是这个</p>
<a id="more"></a>
<h1 id="2-Re50"><a href="#2-Re50" class="headerlink" title="2. Re50"></a><strong>2. Re50</strong></h1><p>听说逆向都挺难的，这里有个简单的，快来秒~~~ :D</p>
<p>逆向题把我们逼疯了，才弄个这个出来，秀优越吗？<br>队友做的，看了一下，很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">k = &quot;Jr3gFud6n&quot;</div><div class="line">flag = &quot;&quot;</div><div class="line">for i in range(0, len(k)):</div><div class="line">    a = ord(k[i])-3</div><div class="line">    flag += chr(a)</div><div class="line"></div><div class="line">print flag</div><div class="line">#应该是这个SCTF&#123;Go0dCra3k&#125;</div></pre></td></tr></table></figure></p>
<h1 id="3-Misc100"><a href="#3-Misc100" class="headerlink" title="3. Misc100"></a><strong>3. Misc100</strong></h1><p>简单的贪吃蛇，吃到30分它就告诉你flag！但是要怎么控制它呢? </p>
<p>妹的，确定是100的，搞了老半天，还是linux的，upx加壳，首先就乱了<br>好吧，过了不知道多久，回过神来，upx脱壳，ida加载分析，大致弄清楚流程，代码用到了几个关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">move移动光标</div><div class="line">printw显示字符</div></pre></td></tr></table></figure></p>
<p>然后就是位置比较，成功了30次之后，就会显示出flag，可是代码中没有啊，习惯了可以f5就f5，所以，乱了很久<br>回到汇编窗口，通过printw找到几处打印，提取字符，通过python打印了一下，妹的乱码，有什么编码问题，不懂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">flag = [0x7F, 0x1A, 0x64, 0x7F, 0x78, 0x44, 0x5E, 0x50, 0x67, 0x7d, 0x4E, 0x5F, 0x2A, </div><div class="line">        0x64, 0x6D, 0x52, 0x4C, 0x67, 0x72, 0x64, 0x4C, 0x70, 0x44, 0x7C, 0x5F, 0x2A,</div><div class="line">        0x48, 0x44, 0x41, 0x1C, 0x61, 0x72, 0x1A, 0x17]</div><div class="line">def printArr(arr):</div><div class="line">    for i in range(0, len(arr)):</div><div class="line">        s += chr(arr[i])</div><div class="line">    print s</div><div class="line">printArr(flag)</div></pre></td></tr></table></figure></p>
<p>没法子，我也不可能玩30分钟，只好暴力解决了，修改了几个比较，成功进入异常处理（请原谅我，看着真是异常处理），注释中是几次暴力修改位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//.text:08049D75 jz      loc_8049EA0</div><div class="line">  if ( v11 &amp;&amp; v6 == target_y )//!=text:08049EA6 jnz     loc_8049D7B</div><div class="line">        &#123;</div><div class="line">          ++dword_804C3C0;</div><div class="line">          if ( dword_804C3C0 == 5 * dword_804C3C0 / 5 )</div><div class="line">            ++dword_804C3D8;</div><div class="line">          if ( dword_804C3C0 == 3 * dword_804C3C0 / 3 )</div><div class="line">            ++dword_804C3D4;</div><div class="line">          if ( dword_804C3C0 == 30 )//!=.text:08049EFD   jz      loc_8049F94</div><div class="line">          &#123;</div><div class="line">            if ( dword_804C3D8 == 6 )//!=text:08049F9B  jnz     loc_8049F03</div><div class="line">            &#123;</div><div class="line">              if ( dword_804C3D4 == 10 )//!=.text:08049FA8 jnz     loc_8049F03</div><div class="line">              &#123;</div><div class="line">                v16 = __cxa_allocate_exception();</div><div class="line">		//执行异常中会调用chk(3)，显示Mission Complete，然后居然没有调用打印flag，</div><div class="line">		//看到有个.text:0804A039 cmp     ds:dword_804C3DC, 3Bh</div><div class="line">		//.text:0804A040 jg      short loc_804A051强制跳转到打印flag</div><div class="line">		//会进入f5没解析成功的代码，最后我都没弄清，是出题人故意的，还是ida能力问题，亦或是我的问题</div><div class="line">                *(_DWORD *)v16 = 0;</div><div class="line">                __cxa_throw(v16, &amp;_typeinfo_for_int, 0, v17);</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>ok,终于打印出来了U0NURntzMWduNGxfMXNfZnVubnk6KX0=，base64解码之后SCTF{s1gn4l_1s_funny:)}，做出来还是比较兴奋的</p>
<h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a><strong>4. 其他</strong></h1><p>其他题目也尝试了很多。<br>re300，算法太绕，晕了，没去弄了，后面提示是三阶魔方，你妹啊，被吓住了，最后也没人做出来<br>re500，又来了个lua虚拟机，额，我再次败退，这次比赛逆向题基本完败，丢人。<br>图片题貌似是两题，用自己知道的各种方式尝试了，无果。<br>web题目，额，我scan了一题，看到了个head attck，然后不会了。<br>pwn题目，好简单，可是，路在何方？求writeup啊。<br>哦，还有两道code的题目，code200在我们努力下，队友提交成功，code400目前还在暴力运算中，明天看看有答案不（求思路，野路子只有暴力破了，也不知道对不）。<br>我想说code500，请问3 3 1是几个意思啊。按我们分析的思路弄出来了，跟我说wrong input！逗我呢啊，要writeup！</p>
<p>最后总结：<br>太急躁，没思路，最后还是能力问题！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-Misc10"><a href="#1-Misc10" class="headerlink" title="1. Misc10"></a><strong>1. Misc10</strong></h1><p>xctf优良传统，百度之<br>手持两把锟斤拷，口中疾呼烫烫烫<br>脚踏千朵屯屯屯，笑看万物锘锘锘<br>其实我没提交，队友提交的，应该是这个</p>]]>
    
    </summary>
    
      <category term="ctf" scheme="http://anhkgg.github.io/tags/ctf/"/>
    
      <category term="sctf" scheme="http://anhkgg.github.io/tags/sctf/"/>
    
      <category term="writeup" scheme="http://anhkgg.github.io/tags/writeup/"/>
    
      <category term="ctf" scheme="http://anhkgg.github.io/categories/ctf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[some thing in c++ reverse]]></title>
    <link href="http://anhkgg.github.io/some-thing-in-c-reverse/"/>
    <id>http://anhkgg.github.io/some-thing-in-c-reverse/</id>
    <published>2014-12-05T09:10:20.000Z</published>
    <updated>2016-07-07T04:29:20.554Z</updated>
    <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a><strong>1. 工具</strong></h1><p>逆向中，在c++类识别中，IDA能够比较好完成一些工作。<br>由于此类经验较少，写上一点自己的总结，不对之处，请指正，或者有更好的经验，请大牛们指导，最好能放点com逆向的经验就更好了。<br><a id="more"></a></p>
<h1 id="2-寻找构造函数"><a href="#2-寻找构造函数" class="headerlink" title="2. 寻找构造函数"></a><strong>2. 寻找构造函数</strong></h1><p>在分析mfc程序中，很多时候，对应响应函数的查找比较麻烦。比如，注册验证中，无法定位按钮点击之后的响应函数，无法对获取输出函数下断，无法弹框下断。但是可以对控件类下断，比如<br>窗口初始化中，控件初始化，可以对某些控件类进行下断，如CButton::CButton，那么就可以回溯到窗口的构造函数中了。至于如何获取CButton::CButton地址，那就要结合ida（符号文件）之类的的</p>
<h1 id="3-虚表"><a href="#3-虚表" class="headerlink" title="3. 虚表"></a><strong>3. 虚表</strong></h1><p>在窗口的构造函数中，一般会对对象进行初始化，很重要的一个就是虚表指针的初始化，嘿嘿，那么我们就可以到虚表指针一观了，看到了什么，恩，类脱光了衣服（别想歪了），我们可以很方便找到<br>窗口类的各种相应函数了，详细就多说了，各自体会吧</p>
<h1 id="4-详细分析"><a href="#4-详细分析" class="headerlink" title="4. 详细分析"></a><strong>4. 详细分析</strong></h1><p>既然找到了响应函数，那么后续的就是详细的分析了。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h1><p>这只是自己的一点点小小总结，内容较少，希望对大家有点帮助，还是那句话，请大家多交流，多指导。<br>某对于com逆向真是，，，一个字，，，很晕。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a><strong>1. 工具</strong></h1><p>逆向中，在c++类识别中，IDA能够比较好完成一些工作。<br>由于此类经验较少，写上一点自己的总结，不对之处，请指正，或者有更好的经验，请大牛们指导，最好能放点com逆向的经验就更好了。<br>]]>
    
    </summary>
    
      <category term="reverse" scheme="http://anhkgg.github.io/tags/reverse/"/>
    
      <category term="c++" scheme="http://anhkgg.github.io/tags/c/"/>
    
      <category term="reverse" scheme="http://anhkgg.github.io/categories/reverse/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[inject process analyze 2]]></title>
    <link href="http://anhkgg.github.io/inject-process-analyze%202/"/>
    <id>http://anhkgg.github.io/inject-process-analyze 2/</id>
    <published>2014-11-25T09:45:00.000Z</published>
    <updated>2016-07-07T04:31:16.973Z</updated>
    <content type="html"><![CDATA[<h1 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a><strong>1. 来源</strong></h1><p>某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。<br>前面分析了一种进程注入方法，现在开始分析另外一种貌似更猥琐的方式，貌似说这种技术用在ramnit病毒中，下面这图是大致原理图（<a href="http://www.pctrojan.com/content/723-virus-blocks-itself" target="_blank" rel="external">引用的</a>）<br><a id="more"></a><br><img src="/img/it_infection.png" alt="img"><br>简单测试了下，CreateProcess时，会多次调用ZwWriteVirtualMemroy，本以为是写入PE文件的，结果没有看到，所有有点不明白，钩住ZwWriteVirtualMemroy怎么用，文章中提到的是这样：<br>The hooked Windows native system service redirects the code execution flow to the module defined in the caller process to perform the code injection routine. The injected code in the new process includes the capability for file infection (Windows executable and HTML files), as well as backdoor and downloader functionalities.<br>大意可能是各位写入进程中一些代码，比如backdoor，downloader，但是就是不明白如何执行起来，所以需要找个样本来学习一下，如何利用</p>
<h1 id="2-样本获取"><a href="#2-样本获取" class="headerlink" title="2. 样本获取"></a><strong>2. 样本获取</strong></h1><p>在卡饭中搜索到了几个可能是ramnit的样本，有两个没有解压密码，气死了，其他的都是upx3.0加壳，妹啊，脱不了啊，最后下了个交desktoplayer.exe，以为没壳了，结果弄了半天还是upx3.0.8，最后，直接OD吧，<br>断了几次CreateProcessA，可以看到创建了iexplorer.exe，但是参数貌似不是CREATE_SUSPENDED（后面才想起，这种方式不用），然后就想直接在ZwWriteVirtualMemory下断，od没法了，转到windbg吧，有了下面的分析</p>
<h1 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a><strong>3. 分析</strong></h1><p>首先想到就是直接对zwwritevirtualmemory下断，然后回溯到inject代码中，结果居然会崩。。这。。不过还是找到了inject代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">0:000&gt; bp ntdll!zwwritevirtualmemory</div><div class="line">0:000&gt; g</div><div class="line">(7e8.af4): Break instruction exception - code 80000003 (first chance)</div><div class="line">eax=00960000 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56c</div><div class="line">eip=00930005 esp=0012f094 ebp=0012f0b4 iopl=0         nv up ei pl nz na pe cy</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207</div><div class="line">00930005 cc              int     3</div><div class="line">0:000&gt; g</div><div class="line">(7e8.af4): Access violation - code c0000005 (first chance)</div><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected and handled.</div><div class="line">eax=ba960002 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56c</div><div class="line">eip=7c92df96 esp=0012f094 ebp=0012f0b4 iopl=0         nv up ei ng nz na po nc</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010282</div><div class="line">ntdll!ZwWriteVirtualMemory+0x6:</div><div class="line">7c92df96 0003            add     byte ptr [ebx],al          ds:0023:000009c6=??</div><div class="line">0:000&gt; kn</div><div class="line"> # ChildEBP RetAddr  </div><div class="line">00 0012f090 00402a74 ntdll!ZwWriteVirtualMemory+0x6</div><div class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</div><div class="line">01 0012f0b4 7c81a636 image00400000+0x2a74//这里既是调用ZwWriteVirtualMemory的代码</div><div class="line">02 0012f3ac 7c819da8 kernel32!BasePushProcessParameters+0x281</div><div class="line">03 0012fe0c 7c81d627 kernel32!CreateProcessInternalW+0x184e</div><div class="line">04 0012fef8 7c802397 kernel32!CreateProcessInternalA+0x29c</div><div class="line">05 0012ff30 004013c0 kernel32!CreateProcessA+0x2c</div><div class="line">06 0012ffb4 00402cda image00400000+0x13c0</div><div class="line">07 0012fff0 00000000 image00400000+0x2cda</div><div class="line">0:000&gt; ub 7c81a636</div><div class="line">kernel32!BasePushProcessParameters+0x266:</div><div class="line">7c81a61b 6a00            push    0</div><div class="line">7c81a61d 53              push    ebx</div><div class="line">7c81a61e 56              push    esi</div><div class="line">7c81a61f 8b85ccfdffff    mov     eax,dword ptr [ebp-234h]</div><div class="line">7c81a625 ff7048          push    dword ptr [eax+48h]</div><div class="line">7c81a628 ffb580fdffff    push    dword ptr [ebp-280h]</div><div class="line">7c81a62e 8b350014807c    mov     esi,dword ptr [kernel32!_imp__NtWriteVirtualMemory (7c801400)]</div><div class="line">7c81a634 ffd6            call    esi//这里既是调用ZwWriteVirtualMemory的代码</div></pre></td></tr></table></figure></p>
<p>对7c81a634 下断，重新加载程序，g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">0:000&gt; bp 7c81a634</div><div class="line">0:000&gt; g</div><div class="line">ModLoad: 76300000 7631d000   C:\WINDOWS\system32\IMM32.DLL</div><div class="line">ModLoad: 62c20000 62c29000   C:\WINDOWS\system32\LPK.DLL</div><div class="line">ModLoad: 73fa0000 7400b000   C:\WINDOWS\system32\USP10.dll</div><div class="line">ModLoad: 77180000 77283000   C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\comctl32.dll</div><div class="line">ModLoad: 5d170000 5d20a000   C:\WINDOWS\system32\comctl32.dll</div><div class="line">(1ec.1f4): Access violation - code c0000005 (first chance)</div><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected and handled.</div><div class="line">eax=00000001 ebx=84493bb9 ecx=7ffdf000 edx=00150608 esi=00150000 edi=84493bb1</div><div class="line">eip=7c98d811 esp=0012fc38 ebp=0012fc98 iopl=0         nv up ei pl zr na pe nc</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246</div><div class="line">ntdll!RtlDebugFreeHeap+0x82:</div><div class="line">7c98d811 0fb707          movzx   eax,word ptr [edi]       ds:0023:84493bb1=????</div><div class="line">0:000&gt; g</div><div class="line">Breakpoint 0 hit</div><div class="line">eax=00960000 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56c</div><div class="line">eip=7c81a634 esp=0012f0bc ebp=0012f3ac iopl=0         nv up ei pl zr na pe nc</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</div><div class="line">kernel32!BasePushProcessParameters+0x27f:</div><div class="line">7c81a634 ffd6            call    esi &#123;ntdll!ZwWriteVirtualMemory (7c92df90)&#125;</div></pre></td></tr></table></figure></p>
<p>确认一下ZwWriteVirtualMemory被hook<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0:000&gt; u 7c92df90</div><div class="line">ntdll!ZwWriteVirtualMemory:</div><div class="line">*** WARNING: Unable to verify checksum for image00400000</div><div class="line">*** ERROR: Module load completed but symbols could not be loaded for image00400000</div><div class="line">7c92df90 e9c44aad83      jmp     image00400000+0x2a59 (00402a59)</div><div class="line">7c92df95 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)</div><div class="line">7c92df9a ff12            call    dword ptr [edx]</div><div class="line">7c92df9c c21400          ret     14h</div><div class="line">7c92df9f 90              nop</div></pre></td></tr></table></figure></p>
<p>想着就在这把文件dump出来，在ida中看方便点，然后再od中下断，为了怕跑飞，也对CreateProcessA下断了，然后运行，现在CreateProcessA中断下来，回溯了一下，看着堆栈栈帧很少，就尝试看能够脱壳不<br>很笨的下断回溯了两次，到了00402C5B ，一点都不想c入口，但是上次没有，调用地址是0012FFC4   7C817067  返回到 kernel32.7C817067<br>也不像是壳进行了入口的patch，将就吧，dump出来，importrect修复了一下，嘿，在ida中一看，还不错，入口代码这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00402C5B    68 00040000     push 0x400</div><div class="line">00402C60    68 D0DF4000     push DesktopL.0040DFD0</div><div class="line">00402C65    E8 AEEAFFFF     call DesktopL.00401718</div><div class="line">00402C6A    83F8 01         cmp eax,0x1</div><div class="line">00402C6D    75 70           jnz short DesktopL.00402CDF</div><div class="line">00402C6F    68 00404000     push DesktopL.00404000                                            ; ASCII &quot;KyUffThOkYwRRtgPP&quot;</div><div class="line">00402C74    E8 66EAFFFF     call DesktopL.004016DF</div></pre></td></tr></table></figure></p>
<p>马上定位到image00400000+0x2a59，修复的还不错，这下子方便多了，可以直接f5，但是不能正常执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">__int64 __stdcall myHookZwWriteVirtualMemory(HANDLE hProcess, int a2, int a3, int a4, int a5) </div><div class="line">&#123; </div><div class="line">LODWORD(v5) = mySysZwWriteVirtualMemory(hProcess, a2, a3, a4, a5, NumberOfBytesWritten, flOldProtect, v12);// 调用原函数 </div><div class="line">NumberOfBytesWritten = (SIZE_T)&amp;v12;</div><div class="line">v9 = v5;</div><div class="line">if ( hProcess != (HANDLE)-1 )</div><div class="line">&#123;</div><div class="line">if ( !myInjectFlag )</div><div class="line">&#123;</div><div class="line">if ( !lpAddress ) // 初始化为0</div><div class="line">&#123;</div><div class="line">EOP = (void *)myGetEOP(hProcess); // 获取到宿主进程EOP</div><div class="line">if ( EOP )</div><div class="line">&#123;</div><div class="line">myInjectFlag = 1;</div><div class="line">lpAddress = EOP;</div><div class="line">dword_40DFA8 = myInjectMyExe(hProcess, (int)&quot;MZ, 0x9800u);</div><div class="line">dword_40DFAD = v7;</div><div class="line">if ( dword_40DFA8 )</div><div class="line">&#123;</div><div class="line">VirtualProtectEx(hProcess, lpAddress, 0xCu, 0x40u, &amp;flOldProtect);</div><div class="line">WriteProcessMemory(hProcess, lpAddress, &amp;byte_40DFA7, 0xCu, &amp;NumberOfBytesWritten); //入口感染</div><div class="line">VirtualProtectEx(hProcess, lpAddress, 0xCu, flOldProtect, &amp;flOldProtect);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return v9;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在钩子函数中，工作很少，获取到宿主进程EOP，在宿主进程中加载自己的程序，然后对EOP进行感染，也就是跳转到自己的程序代码空间<br>代码基本就这么多了，最后怎么玩就靠自己的代码了。</p>
<h1 id="3-技术总结"><a href="#3-技术总结" class="headerlink" title="3. 技术总结"></a><strong>3. 技术总结</strong></h1><p>其实和另一个中注入方式大同小异，目标都是为了将自己的程序映射到宿主进程空间中。<br>一个直接暴力suspend，读写，另一个在创建进程过程中进行读写。<br>由于两种方式都有远程进程读写操作，都应该会被主防拦住，貌似现在效果也不是很好了<br>是否可以再读写内存时，对主防进行欺骗呢，还需要研究….</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a><strong>1. 来源</strong></h1><p>某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。<br>前面分析了一种进程注入方法，现在开始分析另外一种貌似更猥琐的方式，貌似说这种技术用在ramnit病毒中，下面这图是大致原理图（<a href="http://www.pctrojan.com/content/723-virus-blocks-itself">引用的</a>）<br>]]>
    
    </summary>
    
      <category term="inject process" scheme="http://anhkgg.github.io/tags/inject-process/"/>
    
      <category term="reverse" scheme="http://anhkgg.github.io/tags/reverse/"/>
    
      <category term="security" scheme="http://anhkgg.github.io/categories/security/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[inject process analyze and code]]></title>
    <link href="http://anhkgg.github.io/inject-process-analyze-and-code/"/>
    <id>http://anhkgg.github.io/inject-process-analyze-and-code/</id>
    <published>2014-11-25T09:45:00.000Z</published>
    <updated>2016-07-07T15:17:29.010Z</updated>
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a><strong>1. 起因</strong></h1><p>某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。由于没有样本，也没有搜索到资料，只能作罢。<br>某天，突然来了兴致，要分析个样本，随便在卡饭样本区下了个感觉挺啥啥的样本，一分析，你妹，咋这么熟悉呢，居然就是同类的进程注入，然后某人就有了下面的文章。</p>
<a id="more"></a>
<h1 id="2-分析与实现"><a href="#2-分析与实现" class="headerlink" title="2. 分析与实现"></a><strong>2. 分析与实现</strong></h1><h2 id="2-1-PEID"><a href="#2-1-PEID" class="headerlink" title="2.1 PEID"></a><strong>2.1 PEID</strong></h2><p>壳信息：Microsoft Visual C++ v6.0，无壳<br>文件名：bbs.exe<br>既然无壳，直接ida先分析一下，遇到无法分析的OD继续调试。</p>
<h2 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a><strong>2.2 分析</strong></h2><p>打开IDA，拖入文件，找到主函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.text:0040A720 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</div><div class="line">.text:0040A720</div><div class="line">.text:0040A720                 push    ebp</div><div class="line">.text:0040A721                 mov     ebp, esp</div><div class="line">.text:0040A723                 push    ecx</div><div class="line">.text:0040A724                 call    sub_408BE0</div><div class="line">.text:0040A729                 mov     esp_4FEE68, esp</div><div class="line">.text:0040A72F                 mov     esp_4FEE6C, ebp</div><div class="line">.text:0040A735                 call    sub_408929//主功能函数</div><div class="line">.text:0040A73A                 mov     [ebp+var_4], eax</div><div class="line">.text:0040A73D                 mov     eax, [ebp+var_4]</div><div class="line">.text:0040A740                 mov     esp, ebp</div><div class="line">.text:0040A742                 pop     ebp</div><div class="line">.text:0040A743                 retn    10h</div><div class="line">.text:0040A743 _WinMain@16     endp</div></pre></td></tr></table></figure></p>
<p>没什么东西，继续sub_408929：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.text:00408929 sub_408929      proc near               ; CODE XREF: WinMain(x,x,x,x)+15p</div><div class="line">.text:00408929                 cld</div><div class="line">.text:0040892A                 fninit</div><div class="line">.text:0040892C                 call    myNewObj</div><div class="line">.text:00408931                 push    offset sub_406C2A</div><div class="line">.text:00408936                 mov     eax, 3</div><div class="line">.text:0040893B                 call    myInitFunc</div><div class="line">.text:00408940                 add     esp, 4</div><div class="line">.text:00408943                 call    sub_40101D//这几个都是些无用函数，多半是花指令</div><div class="line">.text:00408948                 call    sub_406B84</div><div class="line">.text:0040894D                 call    sub_406BDB</div><div class="line">.text:00408952                 call    sub_401000</div><div class="line">.text:00408957                 call    sub_406BBE</div><div class="line">.text:0040895C                 call    sub_406BA1</div><div class="line">.text:00408961                 call    sub_406BF8</div><div class="line">.text:00408966                 call    myReleaseFile//文件释放，可能是功能文件</div><div class="line">.text:0040896B                 push    eax             ; uExitCode</div><div class="line">.text:0040896C                 call    nullsub_1</div><div class="line">.text:00408971                 call    j_myExit</div><div class="line">.text:00408976                 add     esp, 4</div><div class="line">.text:00408979                 retn</div><div class="line">.text:00408979 sub_408929      endp</div></pre></td></tr></table></figure></p>
<p>其他函数都没有什么重要的代码，接着看看myReleaseFile，代码太多，直接f5看看整体流程，结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">int __cdecl myReleaseFile()</div><div class="line">&#123;</div><div class="line">  lpMem = &quot;QzpcUHJvZ3JhbSBGaWxlc1xDb21tb24gRmlsZXNcTWljcm9zb2Z0IFNoYXJlZFxNU0luZm9ca2trLnR4dA==&quot;;// C:\Program Files\Common Files\Microsoft Shared\MSInfo\kkk.txt</div><div class="line">  v12 = (void *)myBase64Dec(&amp;lpMem);</div><div class="line">  if ( lpMem )</div><div class="line">    j_myIsInMyImg(lpMem);</div><div class="line">  v1 = (int)v12;</div><div class="line">  if ( !v12 )</div><div class="line">    v1 = (int)dword_416285;</div><div class="line">  pszPath = (LPCSTR)myFormat(ebp0, 1, (unsigned int)v1, 0x80000005u);//  C:\Program Files\Common Files\Microsoft Shared\MSInfo\kkk.txt</div><div class="line">  v2 = (int)v12;</div><div class="line">  if ( v12 )</div><div class="line">    j_myIsInMyImg(v12);</div><div class="line">  v10 = (int *)&amp;v6;</div><div class="line">  v3 = PathFileExistsA(pszPath);</div><div class="line">  if ( (void **)v10 != &amp;v6 )</div><div class="line">    v3 = myRunError(v2, 6);</div><div class="line">  v9 = v3;</div><div class="line">  if ( pszPath )</div><div class="line">    j_myIsInMyImg((void *)pszPath);</div><div class="line">  if ( v9 == 1 )</div><div class="line">  &#123;</div><div class="line">    lpMem = &quot;我是一个中国人&quot;;//恩，很爱国</div><div class="line">    v12 = &quot;34,85,10,1D,04,D1,CF,42,DF,A4,B0,&quot;;</div><div class="line">    pszPath = (LPCSTR)myDecStr(&amp;v12, &amp;lpMem);   // 字符串解密，&quot;svchost.exe&quot;</div><div class="line">    if ( v12 )</div><div class="line">      j_myIsInMyImg(v12);</div><div class="line">    if ( lpMem )</div><div class="line">      j_myIsInMyImg(lpMem);</div><div class="line">    v4 = j_myNewBuf(ebp0, 0x10u);</div><div class="line">    v10 = (int *)v4;</div><div class="line">    *(_DWORD *)v4 = 0;</div><div class="line">    *((_DWORD *)v4 + 1) = 0;</div><div class="line">    *((_DWORD *)v4 + 2) = 0;</div><div class="line">    *((_DWORD *)v4 + 3) = 0;</div><div class="line">    v9 = 0;</div><div class="line">    v8 = 0;</div><div class="line">    v7 = 0;</div><div class="line">    v6 = &amp;unk_4162BE;</div><div class="line">    myWork(&amp;v6, &amp;v7, 0, &amp;pszPath, 1, 0, 0, 0, 0, &amp;v10, 0);//注入进程的功能，代码中很多混淆</div><div class="line">    if ( v6 )</div><div class="line">      j_myIsInMyImg(v6);</div><div class="line">    if ( v7 )</div><div class="line">      j_myIsInMyImg(v7);</div><div class="line">    if ( pszPath )</div><div class="line">      j_myIsInMyImg((void *)pszPath);</div><div class="line">    j_myIsInMyImg(v10);</div><div class="line">    sub_40574F();</div><div class="line">  &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于在myWork中太多混淆，IDA无力，转战OD，看到高大上的进程注入。由于代码混淆，太多PE操作，而且IDA没有有效识别内存拷贝函数，给分析带来了较大困难。<br>下面是主要的进程注入用到的函数表，myWork中调用这些关键函数，都是通过该函数表调用，里面通过loaddll+getprocaddress获取到函数地址，返回，然后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">.data:004FB87F myLocalSize1    dd offset myLocalSize   ; DATA XREF: .text:00402CACr</div><div class="line">.data:004FB883 myRtlMoveMemory1 dd offset myRtlMoveMemory ; DATA XREF: .text:00402F32r</div><div class="line">.data:004FB887 myLocalSize2    dd offset sub_4089DC    ; DATA XREF: .text:00403303r</div><div class="line">.data:004FB88B myRtlMoveMemory2 dd offset sub_4089F2   ; DATA XREF: .text:00403701r</div><div class="line">.data:004FB88F myLocalSize3    dd offset sub_408A08    ; DATA XREF: .text:00403A06r</div><div class="line">.data:004FB893 myCreateProcessA dd offset sub_408A1E   ; DATA XREF: .text:00403DEEr</div><div class="line">.data:004FB897 myGetThreadContext dd offset sub_408A34 ; DATA XREF: sub_403FC0+C8r</div><div class="line">.data:004FB89B myReadProcessMemory dd offset sub_408A4A ; DATA XREF: sub_403FC0+2E9r</div><div class="line">.data:004FB89F myZwUnmapViewOfSection dd offset sub_408A60 ; DATA XREF: sub_403FC0+335r</div><div class="line">.data:004FB8A3 myVirtualAllocEx dd offset sub_408A76   ; DATA XREF: sub_403FC0+3ACr</div><div class="line">.data:004FB8A7 myWriteProcessMemory dd offset sub_408A8C ; DATA XREF: sub_403FC0+43Fr</div><div class="line">.data:004FB8AB myLocalSize5    dd offset sub_408AA2    ; DATA XREF: sub_403FC0+9A7r</div><div class="line">.data:004FB8AF myRtlMoveMemory_0 dd offset sub_408AB8  ; DATA XREF: sub_403FC0+B0Er</div><div class="line">.data:004FB8B3 myVirtualProtectEx dd offset sub_408ACE ; DATA XREF: sub_403FC0+D60r</div><div class="line">.data:004FB8B7 myWriteProcessMemory_0 dd offset sub_408AE4 ; DATA XREF: sub_403FC0+DD2r</div><div class="line">.data:004FB8BB mySetThreadContext dd offset sub_408AFA ; DATA XREF: sub_403FC0+FA8r</div><div class="line">.data:004FB8BF myResumeThread  dd offset sub_408B10    ; DATA XREF: sub_403FC0+1172r</div><div class="line">.data:004FB8C3 myWaitForSingleObject dd offset sub_408B26 ; DATA XREF: sub_403FC0+11ADr</div><div class="line">.data:004FB8C7 myCloseHandle_  dd offset sub_408B3C    ; DATA XREF: sub_403FC0+11E6r</div><div class="line">.data:004FB8CB myGetEnvironmentVariableA dd offset sub_408B52</div><div class="line">.data:004FB8CF myTerminateProcess dd offset sub_408B68 ; DATA XREF: sub_4053DE+1Er</div><div class="line">.data:004FB8D3 myReadFileEx    dd offset sub_408B7E    ; DATA XREF: sub_405FAA+1E2r</div><div class="line">.data:004FB8D7 myGetFileSize   dd offset sub_408B94    ; DATA XREF: sub_4063B0+DFr</div><div class="line">.data:004FB8DB myCloseHandle   dd offset sub_408BAA    ; DATA XREF: sub_4064C4+1Dr</div><div class="line">.data:004FB8DF myLocalFree     dd offset sub_408BC0    ; DATA XREF: sub_4065D9+541r</div></pre></td></tr></table></figure></p>
<p>获取函数的代码结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.text:004089B0 myLocalSize     proc near               ; CODE XREF: .text:00402CACp</div><div class="line">.text:004089B0                                         ; DATA XREF: .data:myLocalSize1o</div><div class="line">.text:004089B0                 push    offset myLocalSize1 ; int</div><div class="line">.text:004089B5                 push    offset aLocalsize ; &quot;LocalSize&quot;</div><div class="line">.text:004089BA                 push    offset aKernel32 ; &quot;kernel32&quot;</div><div class="line">.text:004089BF                 call    myGetProc</div><div class="line">.text:004089C4                 jmp     eax</div><div class="line">.text:004089C4 myLocalSize     endp</div></pre></td></tr></table></figure></p>
<p>最后基本总结了myWork的代码逻辑，也一窥了进程注入的猥琐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CreateProcessA(0, &quot;svchost.exe&quot;, 0, 0, 0, 4/*CREATE_SUSPENDED*/, 0, 0, &amp;sa, &amp;pi );//按suspend创建进程，这样主线程就会挂起，等待后面的宰割</div><div class="line">GetThreadContext(pi.hThread, &amp;context);</div><div class="line">ReadProcessMemory(pi.hProcess, 0x7ffde008/*peb-&gt;ImageBaseAddress*/, buf, 4, &amp;size); /*获取到的是img基地址 peb-&gt;ImageBaseAddress*/</div><div class="line">ZwUnmapViewOfSection(pi.hProcess, buf);//这里有个bug，buf传递方式错误，导致无法unmap，应该是&amp;buf</div><div class="line">VirtualAllocEx(pi.hProcess, 0x400000, size, MEM_COMMIT|MEM_RESERVE/*0x3000*/, PAGE_READWRITE/**4/ );</div><div class="line">//解析PE文件，写入进程对应位置</div><div class="line">WriteProcessMemory(pi.hProcess, 0x400000, buf, 0x1000, &amp;size);//写入头部</div><div class="line">for(i =0 ;i&lt;num_of_sec; i++)</div><div class="line">&#123;</div><div class="line">    WriteProcessMemory(pi.hProcess, 0x400000+sec[i].va, buf, sec[i].size, &amp;size);//.text, .rdata, .data</div><div class="line">    VirtualProtectEx(pi.hProcess, 0x400000+sec[i].va, sec[i].size, NewProtect, &amp;oldProtect);//PAGE_EXECUTE_READ, PAGE_READONLY, PAGE_READWRITE</div><div class="line">&#125;</div><div class="line">//重写eop</div><div class="line">//重写基地址</div><div class="line">WriteProcessMemory(pi.hProcess, 0x7ffde008/*peb-&gt;ImageBaseAddress*/, MyBaseAddr, 4, &amp;size);//写入我的img 基地址 0x400000</div><div class="line">SetThreadContext(pi.hProcess, context);//恢复</div><div class="line">ResumeThread(pi.hThread);//恢复线程执行</div></pre></td></tr></table></figure></p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h1><p>本来打算完整分析一下的，在分析到进程注入时，由于自己代码实现中，遇到了一些问题，调试无语，eop和基地址都改写了，那么就是映射section遇到问题，终于修改成<br>直接pe完整写入宿主进程，成功执行了注入进程的功能。<br>所以，后面也没时间具体分析样本的功能了。<br>测试了该方式，无法过掉主防，在WriteProcessMemory就会被拦截，所以该方式基本只是作为技术研究，直接使用，还需努力。</p>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a><strong>4. 参考</strong></h1><p>[1] <a href="http://www.cnblogs.com/lbq1221119/archive/2008/07/22/1248706.html" target="_blank" rel="external">http://www.cnblogs.com/lbq1221119/archive/2008/07/22/1248706.html</a><br>[2] <a href="http://blog.csdn.net/darthas/article/details/12569443" target="_blank" rel="external">http://blog.csdn.net/darthas/article/details/12569443</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a><strong>1. 起因</strong></h1><p>某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。由于没有样本，也没有搜索到资料，只能作罢。<br>某天，突然来了兴致，要分析个样本，随便在卡饭样本区下了个感觉挺啥啥的样本，一分析，你妹，咋这么熟悉呢，居然就是同类的进程注入，然后某人就有了下面的文章。</p>]]>
    
    </summary>
    
      <category term="inject process" scheme="http://anhkgg.github.io/tags/inject-process/"/>
    
      <category term="reverse" scheme="http://anhkgg.github.io/tags/reverse/"/>
    
      <category term="security" scheme="http://anhkgg.github.io/categories/security/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[010注册算法分析]]></title>
    <link href="http://anhkgg.github.io/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://anhkgg.github.io/010注册算法分析/</id>
    <published>2014-11-17T02:13:19.000Z</published>
    <updated>2016-07-07T04:32:12.042Z</updated>
    <content type="html"><![CDATA[<h2 id="1-关键函数定位"><a href="#1-关键函数定位" class="headerlink" title="1. 关键函数定位"></a><strong>1. 关键函数定位</strong></h2><p>进入register窗口，随便填入name，然后check license，弹框信息”Invalid name or password. Please enter your name and password exactly as given when you purchased 010 Editor (make sure no quotes are included).”，通过该信息在IDA中找到对应函数地址，基本可以确认是关键函数位置，函数居然有名字，这是作者故意留下的吗。下面是整个验证函数流程：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void __usercall chekc(char a1&lt;zf&gt;, int a2&lt;ecx&gt;)</div><div class="line">&#123;</div><div class="line">	//获取用户名</div><div class="line">	//是否为空</div><div class="line">	//获取注册码</div><div class="line">	//是否为空</div><div class="line">	//注册码格式检查xxxx-xxxx-xxxx-xxxx-xxxx</div><div class="line">	v42 = (void *)myCheck(mygbName, 3u, &apos;9A&apos;); //注册码验证，返回值v42对于是否注册成功，有很大关系，返回值为231，为失败</div><div class="line">	v26 = mySecondCheck(mygbName, 3u, &apos;9A&apos;);  // 第二次检查，如果返回中为219，就会进入后面的注册成功提示</div><div class="line">	//myCheck中返回不等于231，mygbName + 44提示进入网络验证，没有弄清楚，哪里会等于1</div><div class="line">	if ( v42 != (void *)231 &amp;&amp; *(_DWORD *)(mygbName + 44) )</div><div class="line">	&#123;</div><div class="line">		v27 = myWebCheck((void *)mygbName, 0);</div><div class="line">		if(v27 &lt; 0 )</div><div class="line">		&#123;</div><div class="line">			v43 = myMsg(&quot;Could not contact the webserver. Please check your internet connection. If your internet connection is currently working, the server may be down. If this problem persists, please visit &apos;http://www.sweetscape.com/support/&apos; (&quot;, 0xFFFFFFFFu);</div><div class="line">		&#125;</div><div class="line">		if ( !v27 )</div><div class="line">		&#123;</div><div class="line">			v43 = myMsg( &quot;010 Editor has detected that you have entered an invalid license. Please check to see if your license is entered correctly and try again. If this problem persists, please visit &apos;http://www.sweetscape.com/support/&apos;.&quot;, 0xFFFFFFFFu);</div><div class="line">		&#125;</div><div class="line">		v33 = mySecondCheck(mygbName, 3u, &apos;9A&apos;);//网络验证是否成功，成功，返回219</div><div class="line">	&#125;</div><div class="line">	if ( v43 == (void *)219 )                     // v43 == 219，注册成功</div><div class="line">	&#123;</div><div class="line">		v43 = myMsg(&quot;Password accepted. Thank you for purchasing 010 Editor!&quot;, 0xFFFFFFFFu);</div><div class="line">		//写入注册表</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2. 算法分析"></a><strong>2. 算法分析</strong></h2><p>下面看看主要的验证函数myCheck和mySecondCheck，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">signed int __thiscall mySecondCheck(int this, unsigned int a2, unsigned int a3)</div><div class="line">&#123;</div><div class="line">  int v3; // esi@1</div><div class="line">  signed int result; // eax@2</div><div class="line">  int v5; // eax@3</div><div class="line">  int v6; // eax@6</div><div class="line">  int v7; // eax@9</div><div class="line"></div><div class="line">  v3 = this;</div><div class="line">  if ( *(_DWORD *)(this + 44) )                 // 要让这个值等于0，否则进入网络验证，初始化就是0</div><div class="line">	return 275;</div><div class="line">  v5 = myCheck(this, a2, a3);	//可以看到，只有返回值是45时，才能返回219，注册成功</div><div class="line">  if ( v5 == 45 )</div><div class="line">  &#123;</div><div class="line">	result = 219;                               // 返回219， 注册成功</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，只有返回值是45时，才能返回219，注册成功。<br>那么返回myCheck看看，怎么才能得到45的返回值，整个返回值查看一下，只有两处位置，可能返回45，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if ( v26 == 0x9Cu )</div><div class="line">&#123;</div><div class="line">	v20 = *(_DWORD *)(regdlg + 28) &lt; a2;</div><div class="line">	return (-v20 &amp; 0x21) + 45;                  // 成功？</div><div class="line">&#125;</div><div class="line">if ( v26 != 0xFCu )</div><div class="line">&#123;</div><div class="line">	if ( v26 == 0xACu &amp;&amp; v33 )</div><div class="line">	&#123;</div><div class="line">	  v20 = v33 &lt; a3;</div><div class="line">	  return (-v20 &amp; 0x21) + 45;                // 成功？</div><div class="line">	&#125;</div><div class="line">return 231;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么就需要回溯回去，看看v26，是如何得到的，只有在v26等于0x9c或者0xAc时，才有可能注册成功。下面看看完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">int __thiscall myCheck(int this, unsigned int a2, unsigned int a3)</div><div class="line">&#123;</div><div class="line">	//name和key长度是否为0</div><div class="line">	//myPassCheck(this, (int)&amp;v23);//将key字符串转换成数值，每两个字符转化成2为十六进制数，</div><div class="line">	//xxxx-xxxx-xxxx-xxxx-xxxx分别对应k1k2-k3k4-k5k6-k7k8-k9k10</div><div class="line">	//v23其实就是一个数组，存的就是k1-k10</div><div class="line">	//检测name是否等于&apos;999&apos;,是，则失败</div><div class="line">	if ( v26 == 0x9Cu )</div><div class="line">	&#123;</div><div class="line">		LOBYTE(v32) = v23 ^ v28;                    // k1^k7</div><div class="line">		LOWORD(v6) = (unsigned __int8)(v24 ^ v29);  // k2^k8</div><div class="line">		LOWORD(v7) = (unsigned __int8)(v25 ^ HIBYTE(v27));// k3^k6</div><div class="line">		v11 = v7 + ((_DWORD)v6 &lt;&lt; 8);               // v11 = k3^k6 + ((k2^k8)&lt;&lt;8)</div><div class="line">		*(_DWORD *)(regdlg + 28) = (unsigned __int8)myCal1(v23 ^ v28);// k1^k7 =&gt; 不能等于0</div><div class="line">		v9 = myCal2(v11);                           // 不能等于0</div><div class="line">		v10 = *(_DWORD *)(regdlg + 28);</div><div class="line">		*(_DWORD *)(regdlg + 32) = (unsigned __int16)v9;</div><div class="line">		// v10==0,v9==0或者v9&gt;0x3e8，返回231</div><div class="line">		if ( !v10 || !v9 || (unsigned __int16)v9 &gt; 0x3E8u )</div><div class="line">		  return 231;                               </div><div class="line">		v12 = v10 &lt; 2 ? v10 : 0;                    // v12 = 0或者1</div><div class="line">	&#125;else</div><div class="line">	&#123;</div><div class="line">		if(v26 == 0xFC)</div><div class="line">		&#123;//不可能成功</div><div class="line">		&#125;esle </div><div class="line">		&#123;</div><div class="line">			//v26不等于0xAC，退出，返回231，失败</div><div class="line">			//myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &gt;  0x3E8, 失败</div><div class="line">			if ( v26 != 0xACu</div><div class="line">			|| (v15 = v24 ^ v29,//k2^k8</div><div class="line">				v16 = v25 ^ HIBYTE(v27),//k3^k6</div><div class="line">				*(_DWORD *)(regdlg + 28) = 2,</div><div class="line">				v14 = (unsigned __int16)myCal2(v16 + (v15 &lt;&lt; 8)),v11 = k3^k6 + ((k2^k8)&lt;&lt;8)</div><div class="line">				*(_DWORD *)(regdlg + 32) = (unsigned __int16)v14,</div><div class="line">				!(_WORD)v14)</div><div class="line">				|| v14 &gt; 0x3E8 )</div><div class="line">			return 231;</div><div class="line">			//sub_4FD0B9( (k1^k7 + (k9^k5 + (k6^k10)&lt;&lt;8)&lt;&lt;8), xxx);</div><div class="line">			//其实就是凑成十六进制数(k6^k10)(k9^k5)(k1^k7)</div><div class="line">			v17 = sub_4FD0B9(</div><div class="line">				  (v23 ^ v28) + (((v30 ^ (unsigned __int8)v27) + ((HIBYTE(v27) ^ v31) &lt;&lt; 8)) &lt;&lt; 8),</div><div class="line">				  (char *)loc_5B8C25 + 2);</div><div class="line">			v33 = v17;</div><div class="line">			*(_DWORD *)(regdlg + 52) = v17;</div><div class="line">			v12 = v17;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//编码name，返回给v18，</div><div class="line">	v18 = myEncStr(*(const char **)(*(_DWORD *)qstrname + 12), v26 != -4, v12, *(_DWORD *)(regdlg + 32));</div><div class="line">	//如果v18，如0xABCDEF10分解成0xAB，0xCD， 0xEF10,不等于v29, v28,v27就失败，其实就是</div><div class="line">	//(k6k5) = 0xEF10, k7 = 0xCD, k8 = 0xAB</div><div class="line">	if ( v27 != (_WORD)v18</div><div class="line">		|| v28 != (unsigned __int8)((unsigned int)v18 &gt;&gt; 0x10u)</div><div class="line">		|| v29 != (unsigned __int8)((unsigned int)v18 &gt;&gt; 0x18u) )</div><div class="line">		return 231;                                 // 这三个条件很重要啊</div><div class="line">	//下面就接近成功了，就是上面提到的返回45的结果，成功</div><div class="line">	if ( v26 == 0x9Cu )</div><div class="line">	&#123;</div><div class="line">		//这里就需要regdlg + 28 = myCal1(k1^k7) &gt;= a2,也就是3，传入的a2是3</div><div class="line">		//然后v20就是0，那么(-v20 &amp; 0x21)=0，最后返回45</div><div class="line">		v20 = *(_DWORD *)(regdlg + 28) &lt; a2;</div><div class="line">		return (-v20 &amp; 0x21) + 45;                  // 成功？</div><div class="line">	&#125;</div><div class="line">	if ( v26 != 0xFCu )</div><div class="line">	&#123;</div><div class="line">		if ( v26 == 0xACu &amp;&amp; v33 )</div><div class="line">		&#123;</div><div class="line">		  v20 = v33 &lt; a3;</div><div class="line">		  return (-v20 &amp; 0x21) + 45;                // 成功？</div><div class="line">		&#125;</div><div class="line">	return 231;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后总结一下算法，基本可以列出一个方程类似的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">k4 = 0x9C或者0xAC</div><div class="line">myCal1(k1^k7) &gt;= 3;//可以任取大于等于3的值，算出k1^k7=？</div><div class="line">myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &gt; 0;//可以任去大于0</div><div class="line">myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &lt; 0x3E8;//小于0x3E8的某一个值，算出k3^k6 + ((k2^k8)&lt;&lt;8) = ？</div><div class="line">k8k7k6k5 = v18;//0xABCDEF10，可以得到k5=?,k6=?,k7=?,k8=?，由此可以算出上面的k1,k2</div><div class="line">sub_4FD0B9((k6^k10)(k9^k5)(k1^k7), xx) = ?//可以算出k9，k10</div></pre></td></tr></table></figure></p>
<p>下面就0x9C的情况写了个注册机</p>
<h2 id="3-注册机"><a href="#3-注册机" class="headerlink" title="3. 注册机"></a><strong>3. 注册机</strong></h2><p>根据上面的注册算法，写了个针对0x9c的注册机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">DWORD ckname(char* name, int isnotFC,  int islowk1k7, DWORD k3k6k2k8 )</div><div class="line">&#123;</div><div class="line">	int slen = strlen(name);</div><div class="line">	if(slen &gt; 0 )</div><div class="line">	&#123;</div><div class="line">		DWORD v15 = 0, v17 = 0, v16 = 0, chk = 0, v9 = 0, v8=0, v14 = 0, v5 = 0, v6 = 0;</div><div class="line">		while(v14 &lt; slen)</div><div class="line">		&#123;</div><div class="line">			DWORD v7 = toupper(name[v14]);</div><div class="line">			if(isnotFC)</div><div class="line">			&#123;</div><div class="line">				v9 = dword_B21DC4[(v17 + 15 * k3k6k2k8) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v6 + 17 * islowk1k7) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v7 + 47) &amp; 0xFF] * ((v5 + dword_B21DC4[v7]) ^ dword_B21DC4[(v7 + 13) &amp; 0xFF]);</div><div class="line">				v8 = v16;</div><div class="line">			&#125;</div><div class="line">			else&#123;</div><div class="line">				v9 = dword_B21DC4[(v17 + 15 * k3k6k2k8) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v6 + 17 * islowk1k7) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v7 + 23) &amp; 0xFF] * ((v5 + dword_B21DC4[v7]) ^ dword_B21DC4[(v7 + 63) &amp; 0xFF]);</div><div class="line">				v8 = v15;</div><div class="line">			&#125;</div><div class="line">			v16 += 19;</div><div class="line">			v17 += 13;</div><div class="line">			v15 += 7;</div><div class="line">			v6 += 9;</div><div class="line">			v5 = dword_B21DC4[v8] + v9;</div><div class="line">			v14 = v14 + 1;</div><div class="line">		&#125;</div><div class="line">		return v5;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	char name[] = &quot;&quot;;</div><div class="line">	char key[0x20] = &#123;0&#125;;</div><div class="line">	int k4 = 0x9c;//0xac	</div><div class="line">	int islowk1k7 = 3;//&gt;=3</div><div class="line">	int k1_xor_k7 = ((islowk1k7^0xA7)-61)^0x18;</div><div class="line"></div><div class="line">	int k3k6k2k8 = 1;//k3k6k2k8&gt;=1 &amp;&amp; k3k6k2k8&lt;0x3E8，其中任意一个值</div><div class="line">	int k3_xor_k6_k2_xor_k8 = 0xFFFF &amp; (((k3k6k2k8*11)^0x3421)-19760);</div><div class="line">	k3_xor_k6_k2_xor_k8 = k3_xor_k6_k2_xor_k8^0x7892;</div><div class="line">	int k3_xor_k6 = k3_xor_k6_k2_xor_k8 &amp; 0xff;//低位</div><div class="line">	int k2_xor_k8 = k3_xor_k6_k2_xor_k8 &gt;&gt; 8;//高位</div><div class="line"></div><div class="line">	int k1=0, k2=0, k3=0, k5=0, k6=0, k7=0, k8=0, k9=0, k10=0;//</div><div class="line"></div><div class="line">	printf(&quot;****************************************************\n&quot;);</div><div class="line">	printf(&quot;************* 010 Editor v3.1.2 keygen *************\n&quot;);</div><div class="line">	printf(&quot;*************   by anhkgg 2014-11-18   *************\n&quot;);</div><div class="line">	printf(&quot;****************************************************\n\n&quot;);</div><div class="line">	printf(&quot;name&gt;&quot;);</div><div class="line">	</div><div class="line">	scanf(&quot;%s&quot;, name);</div><div class="line">	</div><div class="line">	if(!stricmp(name, &quot;999&quot;))</div><div class="line">	&#123;</div><div class="line">		printf(&quot;name is not valid!\n&quot;);</div><div class="line">		system(&quot;pause&quot;);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	DWORD name_chk = ckname(name, k4==0x9C?1:0, islowk1k7&lt;2?islowk1k7:0, k3k6k2k8) ;</div><div class="line">	k5 = name_chk &amp; 0xFF;</div><div class="line">	k6 = (name_chk &amp; 0xFFFF)&gt;&gt;8;//</div><div class="line">	k7 = (name_chk &gt;&gt; 16) &amp; 0xFF;//</div><div class="line">	k8 = (name_chk &gt;&gt; 24) &amp; 0xFF;//</div><div class="line">	k1 = k1_xor_k7 ^ k7;//</div><div class="line">	k2 = k2_xor_k8 ^ k8;</div><div class="line">	k3 = k3_xor_k6 ^ k6;//</div><div class="line"></div><div class="line">	printf(&quot;key&gt;%02x%02x-%02x%02x-%02x%02x-%02x%02x\n\n&quot;, k1, k2, k3, k4, k5, k6, k7, k8);</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a><strong>4. 其他</strong></h2><ul>
<li>本次分析针对的是010 v3.1.2</li>
<li>希望各位大牛不要见笑，欢迎交流</li>
<li>网站：<a href="http://anhkgg.gitcafe.com" target="_blank" rel="external">anhkgg.gitcafe.com</a>， <a href="http://www.devilstep.com" target="_blank" rel="external">www.devilstep.com</a></li>
<li>转载请注明出处：<a href="http://anhkgg.gitcafe.com/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">anhkgg.gitcafe.com/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</a></li>
<li>更新：最新版v5.0.2，分析之后，算法流程基本没有变化，只需要myCal1(k1^k7)条件更新一下就行！</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-关键函数定位"><a href="#1-关键函数定位" class="headerlink" title="1. 关键函数定位"></a><strong>1. 关键函数定位</strong></h2><p>进入register窗口，随便填入name，然后check license，弹框信息”Invalid name or password. Please enter your name and password exactly as given when you purchased 010 Editor (make sure no quotes are included).”，通过该信息在IDA中找到对应函数地址，基本可以确认是关键函数位置，函数居然有名字，这是作者故意留下的吗。下面是整个验证函数流程：</p>]]>
    
    </summary>
    
      <category term="010editor" scheme="http://anhkgg.github.io/tags/010editor/"/>
    
      <category term="reverse" scheme="http://anhkgg.github.io/categories/reverse/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hctf writeup]]></title>
    <link href="http://anhkgg.github.io/hctf-writeup/"/>
    <id>http://anhkgg.github.io/hctf-writeup/</id>
    <published>2014-11-10T01:08:58.000Z</published>
    <updated>2014-11-10T02:15:50.000Z</updated>
    <content type="html"><![CDATA[<p><strong>1. 丘比龙的最爱</strong><br>传说，丘比龙是丘比特的弟弟，丘比龙是一只小爱神，虽然有两只翅膀，但因为吃多了，导致身体太胖，所以飞不起来~那么问题来了?!丘比龙吃什么食物吃多了变胖了<br>百度之：甜甜圈</p>
<a id="more"></a>
<p><strong>1. nvshen</strong><br>猫流大大发现一个女神，你能告诉我女神的名字么（名字即是flag） <a href="http://107.189.158.112/0aab9b20410fdd880c53922048023266/nvshen.zip" target="_blank" rel="external">http://107.189.158.112/0aab9b20410fdd880c53922048023266/nvshen.zip</a><br>打开大量数据，感觉是base64，解密了前一部分数据看到PNG, IHDR字符，应该就是png图片了，然后python写了段脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import base64</div><div class="line">f1 = open(&quot;nvshen.txt&quot;, &quot;r&quot;)</div><div class="line">f2 = open(&quot;nvshen.png&quot;, &quot;wb&quot;)</div><div class="line"></div><div class="line">while 1:</div><div class="line">	buf = f1.read(12)</div><div class="line">	if not buf:</div><div class="line">		break;</div><div class="line">	#print buf, base64.decodestring(buf)</div><div class="line">	f2.write(base64.decodestring(buf))	</div><div class="line"></div><div class="line">f1.close()</div><div class="line">f2.close()</div></pre></td></tr></table></figure></p>
<p>得到一张女神照片，纠结了会，google图片之，找到女神名字“爱新觉罗·启星”，被中间的点坑了几次，然后flag是“爱新觉罗启星”， 出题人原来喜欢她啊<br><img src="http://www.taihainet.com/news/UploadFiles_6334/201306/20130618160811617.jpg" alt="img"></p>
<p><strong>3. babyCrack</strong><br>107.189.158.112/d55757a7ccf958399789e18e1d8199de/babyCrack.zip<br>PEID查了下，是.net，马上祭出神奇.net reflector， 结果工具过期，重新下了个注册机，搞定，几个函数，翻了下，看到flag：hctf{bABy<em>CtsvlmE</em>!}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void button1_Click(object sender, EventArgs e)</div><div class="line">&#123;</div><div class="line">	bool flag = false;</div><div class="line">	Config.user = this.textBox1.Text;</div><div class="line">	string user = Config.user;</div><div class="line">	string str2 = &quot;hctf&#123;bABy_CtsvlmE_!&#125;&quot;;</div><div class="line">	if (str2.CompareTo(user) == 0)</div><div class="line">	&#123;</div><div class="line">		flag = true;</div><div class="line">	&#125;</div><div class="line">	if (flag)</div><div class="line">	&#123;</div><div class="line">		MessageBox.Show(&quot;good !!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4. stego_final</strong><br>图片隐写题，Stegsolve各种通道翻了一下，看到张二维码，用手机一扫，识别不了，背影有些黑点，又不会图片处理，ps一番，终于找到flag：flag{hctf_3xF$235#^3}</p>
<p><strong>5. wzwzDingDing</strong><br>被坑的最惨的一道题，是个64位驱动，代码真不多，只有30多个函数，翻了一个遍，流程分析清楚，最后有个字符串提示 “OK!YOU ARE REALLY GOOD!Also, there is a } left!”<br>就是说代码执行到这，应该会得到flag，然后这个是在IRP_MJ_DEVICE_CONTROL函数中，函数对应多个ctl code，分别是：<br>0x88102004，0x88102008, 0x8810200C, 0x88102014, 0x88102010，以及都不是前面的一个ctl code，每个ctl code对应分支都会对偏移0x48E0的一个标志进行操作，最后得到0xFFFFFF，执行提示字符串的分支。<br>下面是触发的ring3代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">HANDLE hDev = CreateFileA(DRV_SYM, GENERIC_ALL, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</div><div class="line">if(hDev == INVALID_HANDLE_VALUE)</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] open dev error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">printf(&quot;[+] open dev success!\n&quot;);</div><div class="line">char buf[20] = &quot;^lejAJ]O&quot;;</div><div class="line">DWORD dwReturn = 0;</div><div class="line">if(! DeviceIoControl(hDev, 0x88102004, buf, strlen(buf), buf, strlen(buf),  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">char buf1[20] = &quot;MNIII&quot;;</div><div class="line">if(! DeviceIoControl(hDev, 0x88102004, buf1, strlen(buf1), buf1, strlen(buf1),  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(! DeviceIoControl(hDev, 0x88102008, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//8810200C</div><div class="line">if(! DeviceIoControl(hDev, 0x8810200C, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;	</div><div class="line"></div><div class="line">if(! DeviceIoControl(hDev, 0x88102014, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;	</div><div class="line">//88102010</div><div class="line">if(! DeviceIoControl(hDev,  0x88102010, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后就进入了提示字符分支，结果在这里 <code>text:0000000000012361 call    [rsp+0C8h+ShellCode]</code>，就崩了，被坑了好久，这里需要结合题目提示flag: HCTF{‘intput’.encode(‘hex’)}<br>就是需要修复那段shellcode，让其正确执行，然后顺利执行到提示字符串位置，分支中还有代码提示需要修复的代码字节位置，然后就是根据一个堆栈平衡就能修复（开始明显看不懂题意啊，坑）<br>修复前代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">fffff880`02f85d90 l5b</div><div class="line">wzwzDingDing+0x2d90:</div><div class="line">fffff880`02f85d90 （10） 5152          adc     byte ptr [rcx+52h],dl =&gt;(50 //push rax push rcx</div><div class="line">fffff880`02f85d93 53              push    rbx</div><div class="line">fffff880`02f85d94 55              push    rbp</div><div class="line">fffff880`02f85d95 56              push    rsi</div><div class="line">fffff880`02f85d96 57              push    rdi</div><div class="line">fffff880`02f85d97 （90）              nop</div><div class="line">fffff880`02f85d98 （90）              nop//push r8  (41 50</div><div class="line">fffff880`02f85d99 4151            push    r9</div><div class="line">fffff880`02f85d9b 4152            push    r10</div><div class="line">fffff880`02f85d9d 4153            push    r11</div><div class="line">fffff880`02f85d9f 4154            push    r12</div><div class="line">fffff880`02f85da1 4155            push    r13</div><div class="line">fffff880`02f85da3 4156            push    r14</div><div class="line">fffff880`02f85da5 4157            push    r15</div><div class="line">fffff880`02f85da7 90              nop</div><div class="line">fffff880`02f85da8 （90）              nop//(48 83 EC 28 sub rsp,28h</div><div class="line">fffff880`02f85da9 (90              nop</div><div class="line">fffff880`02f85daa (90              nop</div><div class="line">fffff880`02f85dab (90              nop</div><div class="line">fffff880`02f85dac 90              nop</div><div class="line">fffff880`02f85dad 48c7c600000000  mov     rsi,0</div><div class="line">fffff880`02f85db4 488b040e        mov     rax,qword ptr [rsi+rcx]</div><div class="line">fffff880`02f85db8 4883f007        xor     rax,7</div><div class="line">fffff880`02f85dbc 4889040e        mov     qword ptr [rsi+rcx],rax</div><div class="line">fffff880`02f85dc0 90              nop</div><div class="line">fffff880`02f85dc1 90              nop</div><div class="line">fffff880`02f85dc2 90              nop</div><div class="line">fffff880`02f85dc3 90              nop</div><div class="line">fffff880`02f85dc4 48ffc6          inc     rsi</div><div class="line">fffff880`02f85dc7 4883fe0b        cmp     rsi,0Bh</div><div class="line">fffff880`02f85dcb 74e0            je      wzwzDingDing+0x2dad (fffff880`02f85dad)</div><div class="line">fffff880`02f85dcd 90              nop</div><div class="line">fffff880`02f85dce 4883c428        add     rsp,28h</div><div class="line">fffff880`02f85dd2 415f            pop     r15</div><div class="line">fffff880`02f85dd4 415e            pop     r14</div><div class="line">fffff880`02f85dd6 415d            pop     r13</div><div class="line">fffff880`02f85dd8 415c            pop     r12</div><div class="line">fffff880`02f85dda 415b            pop     r11</div><div class="line">fffff880`02f85ddc 415a            pop     r10</div><div class="line">fffff880`02f85dde 4159            pop     r9</div><div class="line">fffff880`02f85de0 4158            pop     r8</div><div class="line">fffff880`02f85de2 5f              pop     rdi</div><div class="line">fffff880`02f85de3 5e              pop     rsi</div><div class="line">fffff880`02f85de4 5d              pop     rbp</div><div class="line">fffff880`02f85de5 5b              pop     rbx</div><div class="line">fffff880`02f85de6 5a              pop     rdx</div><div class="line">fffff880`02f85de7 (90)              nop //59 pop rcx </div><div class="line">fffff880`02f85de8 58              pop     rax</div><div class="line">fffff880`02f85de9 (90)              nop//ret C3</div><div class="line">fffff880`02f85dea 00cc            add     ah,cl</div></pre></td></tr></table></figure>
<p>修复后代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">kd&gt; u fffff880`02f85d90 l5b</div><div class="line">wzwzDingDing+0x2d90:</div><div class="line">fffff880`02f85d90 50              push    rax</div><div class="line">fffff880`02f85d91 51              push    rcx</div><div class="line">fffff880`02f85d92 52              push    rdx</div><div class="line">fffff880`02f85d93 53              push    rbx</div><div class="line">fffff880`02f85d94 55              push    rbp</div><div class="line">fffff880`02f85d95 56              push    rsi</div><div class="line">fffff880`02f85d96 57              push    rdi</div><div class="line">fffff880`02f85d97 4150            push    r8</div><div class="line">fffff880`02f85d99 4151            push    r9</div><div class="line">fffff880`02f85d9b 4152            push    r10</div><div class="line">fffff880`02f85d9d 4153            push    r11</div><div class="line">fffff880`02f85d9f 4154            push    r12</div><div class="line">fffff880`02f85da1 4155            push    r13</div><div class="line">fffff880`02f85da3 4156            push    r14</div><div class="line">fffff880`02f85da5 4157            push    r15</div><div class="line">fffff880`02f85da7 90              nop</div><div class="line">fffff880`02f85da8 4883ec28        sub     rsp,28h</div><div class="line">fffff880`02f85dac 90              nop</div><div class="line">fffff880`02f85dad 48c7c600000000  mov     rsi,0</div><div class="line">fffff880`02f85db4 488b040e        mov     rax,qword ptr [rsi+rcx]</div><div class="line">fffff880`02f85db8 4883f007        xor     rax,7</div><div class="line">fffff880`02f85dbc 4889040e        mov     qword ptr [rsi+rcx],rax</div><div class="line">fffff880`02f85dc0 90              nop</div><div class="line">fffff880`02f85dc1 90              nop</div><div class="line">fffff880`02f85dc2 90              nop</div><div class="line">fffff880`02f85dc3 90              nop</div><div class="line">fffff880`02f85dc4 48ffc6          inc     rsi</div><div class="line">fffff880`02f85dc7 4883fe0b        cmp     rsi,0Bh</div><div class="line">fffff880`02f85dcb 74e0            je      wzwzDingDing+0x2dad (fffff880`02f85dad)</div><div class="line">fffff880`02f85dcd 90              nop</div><div class="line">fffff880`02f85dce 4883c428        add     rsp,28h</div><div class="line">fffff880`02f85dd2 415f            pop     r15</div><div class="line">fffff880`02f85dd4 415e            pop     r14</div><div class="line">fffff880`02f85dd6 415d            pop     r13</div><div class="line">fffff880`02f85dd8 415c            pop     r12</div><div class="line">fffff880`02f85dda 415b            pop     r11</div><div class="line">fffff880`02f85ddc 415a            pop     r10</div><div class="line">fffff880`02f85dde 4159            pop     r9</div><div class="line">fffff880`02f85de0 4158            pop     r8</div><div class="line">fffff880`02f85de2 5f              pop     rdi</div><div class="line">fffff880`02f85de3 5e              pop     rsi</div><div class="line">fffff880`02f85de4 5d              pop     rbp</div><div class="line">fffff880`02f85de5 5b              pop     rbx</div><div class="line">fffff880`02f85de6 5a              pop     rdx</div><div class="line">fffff880`02f85de7 59              pop     rcx</div><div class="line">fffff880`02f85de8 58              pop     rax</div><div class="line">fffff880`02f85de9 c3              ret</div><div class="line">fffff880`02f85dea 00cc            add     ah,cl</div></pre></td></tr></table></figure></p>
<p>然后flag：HCTF{5041504883ec2859c3}，注意大小写啊</p>
<p><strong>6. 其他</strong></p>
<p>就这么多了，经验太少，就各路大牛路过指导</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1. 丘比龙的最爱</strong><br>传说，丘比龙是丘比特的弟弟，丘比龙是一只小爱神，虽然有两只翅膀，但因为吃多了，导致身体太胖，所以飞不起来~那么问题来了?!丘比龙吃什么食物吃多了变胖了<br>百度之：甜甜圈</p>]]>
    
    </summary>
    
      <category term="hctf" scheme="http://anhkgg.github.io/tags/hctf/"/>
    
      <category term="ctf" scheme="http://anhkgg.github.io/categories/ctf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[how to get GS cookie]]></title>
    <link href="http://anhkgg.github.io/how-to-get-GS-cookie/"/>
    <id>http://anhkgg.github.io/how-to-get-GS-cookie/</id>
    <published>2014-11-05T03:32:29.000Z</published>
    <updated>2016-07-07T04:33:15.101Z</updated>
    <content type="html"><![CDATA[<h1 id="Stack-cookie"><a href="#Stack-cookie" class="headerlink" title="Stack cookie"></a><strong>Stack cookie</strong></h1><p>Stack cookies (/GS Switch cookie)，windows防止栈溢出的一种机制，<a href="http://www.pediy.com/kssd/pediy12/102719/724039/39112.pdf" target="_blank" rel="external">详见</a>。</p>
<a id="more"></a>
<blockquote>
<p><strong>栈中的 cookie/GS保护</strong></p>
<p>/GS 编译选项会在函数的开头和结尾添加代码来阻止对典型的栈溢出漏洞（字符串缓冲区）的利用。<br>当应用程序启动时，程序的 cookie（4 字节（dword），无符号整型）被计算出来（伪随机数）并保存在<br>加载模块的.data 节中,在函数的开头这个 cookie 被拷贝到栈中，位于 EBP 和返回地址的正前方（位于返<br>回地址和局部变量的中间）。<br>[buffer][cookie][saved EBP][saved EIP]<br>在函数的结尾处，程序会把这个 cookie 和保存在.data 节中的 cookie 进行比较。<br>如果不相等，就说明进程栈被破坏，进程必须被终止。</p>
<p><strong>栈中的 cookie/GS绕过方法</strong><br>挫败这种栈溢出保护机制的最直接的方法是检索/猜测/计算出 cookie 值（这样就可以用相同的 cookie<br>覆盖栈中的 cookie），这个 cookie 有时候（很少）是一个静态值…但即使如此，它也可能包含一些不利<br>的字符而导致不能使用它。</p>
</blockquote>
<h1 id="如何通过PE来获取GS-cookie的值"><a href="#如何通过PE来获取GS-cookie的值" class="headerlink" title="如何通过PE来获取GS cookie的值"></a><strong>如何通过PE来获取GS cookie的值</strong></h1><p>在PE的DataDirectory中，第10序号的是一个叫做LoadConfig的东西，保存了映像的配置数据，里面就有GS cookie，来看看这个数据结构<br><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680328(v=vs.85).aspx" title="loadconfig" target="_blank" rel="external">IMAGE_LOAD_CONFIG_DIRECTORY32</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    DWORD   Size;</div><div class="line">    DWORD   TimeDateStamp;</div><div class="line">    WORD    MajorVersion;</div><div class="line">    WORD    MinorVersion;</div><div class="line">    DWORD   GlobalFlagsClear;</div><div class="line">    DWORD   GlobalFlagsSet;</div><div class="line">    DWORD   CriticalSectionDefaultTimeout;</div><div class="line">    DWORD   DeCommitFreeBlockThreshold;</div><div class="line">    DWORD   DeCommitTotalFreeThreshold;</div><div class="line">    DWORD   LockPrefixTable;            // VA</div><div class="line">    DWORD   MaximumAllocationSize;</div><div class="line">    DWORD   VirtualMemoryThreshold;</div><div class="line">    DWORD   ProcessHeapFlags;</div><div class="line">    DWORD   ProcessAffinityMask;</div><div class="line">    WORD    CSDVersion;</div><div class="line">    WORD    Reserved1;</div><div class="line">    DWORD   EditList;                   // VA</div><div class="line">    DWORD   SecurityCookie;             // VA</div><div class="line">    DWORD   SEHandlerTable;             // VA</div><div class="line">    DWORD   SEHandlerCount;</div><div class="line">&#125; IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>SecurityCookie</strong><br>A pointer to a cookie that is used by Visual C++ or GS implementation.</p>
</blockquote>
<p>所以，可以通过解析pe的方式，获取到SecurityCookie，进而绕过cookie/GS保护，这只是我的想法，也没测试过，是在分析某个sys的时间想到的，下面贴出获取Cookie的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">unsigned int __stdcall myGetGSSecureCookie(PVOID ImageBase, ULONG Size)</div><div class="line">&#123;</div><div class="line">  ULONG v2; // edi@1</div><div class="line">  PVOID v3; // esi@1</div><div class="line">  PVOID v4; // eax@2</div><div class="line">  unsigned int result; // eax@7</div><div class="line"></div><div class="line">  v3 = ImageBase;</div><div class="line">  v2 = Size;</div><div class="line">  if ( (signed int)myGetValidNtHeader(1, (unsigned int)ImageBase, Size, (int)&amp;ImageBase) &lt; 0//myGetValidNtHeader获取nt头地址</div><div class="line">    || (v4 = RtlImageDirectoryEntryToData(v3, 1u, 0xAu, &amp;Size), !v4)// 通过加载配置目录信息找到SecureCookie</div><div class="line">    || !Size</div><div class="line">    || Size != 0x40 &amp;&amp; Size != *(_DWORD *)v4</div><div class="line">    || *(_DWORD *)v4 &lt; 0x48u</div><div class="line">    || (result = *((_DWORD *)v4 + 15), result &lt;= (unsigned int)v3)// loadcofig-&gt;SecurityCookie</div><div class="line">						// A pointer to a cookie that is used by Visual C++ or GS implementation.</div><div class="line">    || result &gt;= (unsigned int)(v3 + v2 - 4) )</div><div class="line">    result = 0;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><p>没来得及查资料，是否有完整的绕过方法，这只是自己突然分析到这，想到的，不对之处，敬请见谅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Stack-cookie"><a href="#Stack-cookie" class="headerlink" title="Stack cookie"></a><strong>Stack cookie</strong></h1><p>Stack cookies (/GS Switch cookie)，windows防止栈溢出的一种机制，<a href="http://www.pediy.com/kssd/pediy12/102719/724039/39112.pdf">详见</a>。</p>]]>
    
    </summary>
    
      <category term="PE" scheme="http://anhkgg.github.io/tags/PE/"/>
    
      <category term="GS" scheme="http://anhkgg.github.io/tags/GS/"/>
    
      <category term="cookie" scheme="http://anhkgg.github.io/tags/cookie/"/>
    
      <category term="security" scheme="http://anhkgg.github.io/categories/security/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ctf认识]]></title>
    <link href="http://anhkgg.github.io/known-ctf/"/>
    <id>http://anhkgg.github.io/known-ctf/</id>
    <published>2014-11-04T07:08:11.000Z</published>
    <updated>2016-07-07T04:35:08.046Z</updated>
    <content type="html"><![CDATA[<h1 id="CTF-meaning"><a href="#CTF-meaning" class="headerlink" title="CTF meaning"></a><strong>CTF meaning</strong></h1><p><a href="http://www.csdn.net/article/2013-01-04/2813390-hackers-confs-comparison" title="ctf meaning" target="_blank" rel="external">CTF</a>: 全称Capture The Flag， 就是夺旗比赛，衍生自古代军事战争模式，两队人马前往对方基地夺旗，每队人马须在保护好己方旗帜的情况下将对方旗帜带回基地。在计算机安全领域，CTF是一种<a href="http://en.wikipedia.org/wiki/Capture_the_flag" title="computer security" target="_blank" rel="external">计算机安全竞赛</a>。<br>CTF通常有两种形式，<a href="http://bctf.cn/faq" title="ctf mode" target="_blank" rel="external">解题模式</a>（Jeopardy）和<a href="http://bctf.cn/faq" title="ctf mode" target="_blank" rel="external">攻防模式</a>（Attack-Defense）, 在解题模式的比赛中，主办方会提供一系列不同类型的赛题，比如上线一个有漏洞的服务、提供一段网络流量、给出一个加密后的数据或经过隐写后的文件等，他们将 flag 隐藏在这些赛题中，选手们通过比拼解题来一决高下；在攻防模式比赛中，主办方会事先编写一系列有漏洞的服务，并将它们安装在每个参赛队伍都相同的环境中，参赛队伍一方面需要修补自己服务的漏洞，同时也需要去攻击对手们的服务、拿到对手环境中的 flag 来得分，攻防模式的竞赛往往比解题模式的竞赛更接近真实环境，比赛过程也更加激烈。 一般资格赛采用解题模式，决赛采用攻防模式。</p>
<a id="more"></a>
<h1 id="CTF-content"><a href="#CTF-content" class="headerlink" title="CTF content"></a><strong>CTF content</strong></h1><p>CTF包含题目较广，有</p>
<ul>
<li>逆向工程</li>
<li>密码学 </li>
<li>ACM编程 </li>
<li>web漏洞 </li>
<li>二进制练习 </li>
<li>网络和取证</li>
<li>隐写术 </li>
<li>无线安全<br>等等。需要深入研究某几个方向，涉及其他方向的知识。</li>
</ul>
<h1 id="CTF-matchs"><a href="#CTF-matchs" class="headerlink" title="CTF matchs"></a><strong>CTF matchs</strong></h1><p>国际赛比较有名的比赛：<br><a href="http://hitcon.org/2014/CTF/" target="_blank" rel="external">DEFCON CTF</a><br><a href="https://legitbs.net/2014" target="_blank" rel="external">HITCON CTF</a></p>
<p>国内较有名气的信息安全比赛有：<br><a href="http://iscc.org.cn/" target="_blank" rel="external">ISCC ctf</a><br>2011年上海市信息安全技能竞赛<br>全国大学生信息安全竞赛<br>四川省大学生信息安全技术大赛<br>全国大学生网络安全实战竞赛<br>江西高校信息安全知识及软件设计大赛<br>绿盟科技杯-信息安全对抗技术竞赛<br>XCon安全焦点信息安全技术峰会</p>
<p>以及目前各网络公司组办的ctf比赛，如<a href="http://alictf.com/" target="_blank" rel="external">alictf</a>, <a href="http://bctf.cn/faq" target="_blank" rel="external">bctf</a>, <a href="http://is.campus.360.cn/" target="_blank" rel="external">360信息安全技术大赛</a></p>
<h1 id="CTF-starting"><a href="#CTF-starting" class="headerlink" title="CTF starting"></a><strong><a href="http://www.freebuf.com/articles/others-articles/36927.html" target="_blank" rel="external">CTF starting</a></strong></h1><p>各个方向学习参考(ctrl+c+v)：</p>
<ol>
<li>逆向工程。我强烈建议你得到一个IDA Pro的副本，这有免费版和学生认证书。尝试下crack me的问题。写出你的C语言代码，然后进行反编译。重复这个过程，同时更改编译器的选项和程序逻辑。在编译的二进制文件中“if”声明和“select”语句有什么不同？我建议你专注于一个单一的原始架构：x86、x86_64或是ARM。在处理器手册中查找你要找的，参考有：<br>《Practical Reverse Engineering》<br>《Reversing: Secrets of Reverse Engineering》<br>《The IDA Pro Book》</li>
<li>加密。虽然这不是我自己的强项，但这里有一些参考还是要看看的：<br>《Applied Cryptography》<br>《Practical Cryptography》<br>Cryptography I</li>
<li>ACM编程。选择一个高层次的语言，我推荐使用Python或Ruby。对于Python而言，阅读下《Dive into Python》和找一些你要加入的项目。值得一提的是Metasploit是用Ruby编写的。关于算法和数据结构的计算机科学课也要在此类中要走很长的路。看看来自CTF和其他编程的挑战，战胜他们。专注于创建一个解决方法而不是最快或是最好的方法，特别是在你刚刚开始的时候。</li>
<li>web漏洞。有很多的网络编程技术，在CTF中最流行的就是PHP和SQL。php.net网站（译者注：需翻墙）是一个梦幻的语言参考，只要搜索你好奇的功能。PHP之后，看到网页上存在的挑战的最常见的方法就是使用Python或Ruby脚本。主要到技术有重叠，这有一本关于网络安全漏洞的好书，是《黑客攻防技术宝典：Web实战篇》。除此之外，在学习了一些基本技术之后，你可能也想通过比较流行的免费软件工具来取得一些经验。这些在CTF竞争中也可能会偶尔用到，这些加密会和你凭经验得到的加密重叠。</li>
<li>二进制练习。这是我个人的爱好，我建议你在进入二进制练习前要完成逆向工程的学习。这有几个你可以独立学习的常见类型漏洞：栈溢出，堆溢出，对于初学者的格式字符串漏洞。很多是通过练习思维来辨别漏洞的类型。学习以往的漏洞是进入二进制门槛的最好途径。推荐你可以阅读：<br>《黑客：漏洞发掘的艺术》<br>《黑客攻防技术宝典：系统实战篇》<br>《The Art of Software Security Assessment》</li>
<li>取证/网络。大多数的CTF团队往往有“一个”负责取证的人。我不是那种人，但是我建议你学习如何使用010 hex editor，不要怕做出荒谬、疯狂、随机的猜测这些问题运行的结果是怎样。<br>最后，Dan Guido和公司最近推出了CTF领域指南，会对以上几个主题的介绍有很好的帮助。</li>
<li>其他<br><a href="http://smashthestack.org/" target="_blank" rel="external">Smash the Stack</a>（漏洞利用）<br><a href="http://crackmes.de/" target="_blank" rel="external">Crackmes.de</a>（逆向工程）<br><a href="http://netforce.nl/" target="_blank" rel="external">Netforce.nl</a>（web渗透与密码学）<br>另外，BCTF赛题会与国际CTF比赛接轨，因此可以报名参加国际CTF比赛（详情参考<a href="http://ctftime.org/" target="_blank" rel="external">ctftime</a>）进行练手，也可以随时练习往届CTF赛题（<a href="http://repo.shell-storm.org/CTF/" target="_blank" rel="external">赛题集合</a>）。</li>
</ol>
<h1 id="CTF-stars"><a href="#CTF-stars" class="headerlink" title="CTF stars"></a><strong>CTF stars</strong></h1><p>国内ctf赛棍：</p>
<ol>
<li>HITCON<br>被称为”新台湾之光”， 2014年DEFCON 22 CTF中，取得世界第二的成绩。</li>
<li>Blue-Lotus<br>蓝莲花（blue-lotus）战队成立于清华大学网络与信息安全实验室，主要从事计算机安全攻防方面的研究。 多数主要成员为清华大学在读研究生，后吸纳包括来自浙江大学、上海交大、青岛理工、中国海洋大学、杭州电子科大等高校的多名学生， 以及若干绿盟、阿里巴巴等公司的年轻安全技术人员。在业余时间，团队组队参加多项国际知名CTF赛事， 曾作为中国的团队首次闯入全球顶级的DEFCON CTF总决赛。这里可以看到blue-lotus在各项国际CTF赛事中取得的所有成绩。</li>
<li>其他</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CTF-meaning"><a href="#CTF-meaning" class="headerlink" title="CTF meaning"></a><strong>CTF meaning</strong></h1><p><a href="http://www.csdn.net/article/2013-01-04/2813390-hackers-confs-comparison" title="ctf meaning">CTF</a>: 全称Capture The Flag， 就是夺旗比赛，衍生自古代军事战争模式，两队人马前往对方基地夺旗，每队人马须在保护好己方旗帜的情况下将对方旗帜带回基地。在计算机安全领域，CTF是一种<a href="http://en.wikipedia.org/wiki/Capture_the_flag" title="computer security">计算机安全竞赛</a>。<br>CTF通常有两种形式，<a href="http://bctf.cn/faq" title="ctf mode">解题模式</a>（Jeopardy）和<a href="http://bctf.cn/faq" title="ctf mode">攻防模式</a>（Attack-Defense）, 在解题模式的比赛中，主办方会提供一系列不同类型的赛题，比如上线一个有漏洞的服务、提供一段网络流量、给出一个加密后的数据或经过隐写后的文件等，他们将 flag 隐藏在这些赛题中，选手们通过比拼解题来一决高下；在攻防模式比赛中，主办方会事先编写一系列有漏洞的服务，并将它们安装在每个参赛队伍都相同的环境中，参赛队伍一方面需要修补自己服务的漏洞，同时也需要去攻击对手们的服务、拿到对手环境中的 flag 来得分，攻防模式的竞赛往往比解题模式的竞赛更接近真实环境，比赛过程也更加激烈。 一般资格赛采用解题模式，决赛采用攻防模式。</p>]]>
    
    </summary>
    
      <category term="ctf" scheme="http://anhkgg.github.io/tags/ctf/"/>
    
      <category term="ctf" scheme="http://anhkgg.github.io/categories/ctf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ssctf crack5详述]]></title>
    <link href="http://anhkgg.github.io/ssctf-crack5-study/"/>
    <id>http://anhkgg.github.io/ssctf-crack5-study/</id>
    <published>2014-11-04T02:13:37.000Z</published>
    <updated>2016-07-07T04:35:06.621Z</updated>
    <content type="html"><![CDATA[<h2 id="crack5中的坑"><a href="#crack5中的坑" class="headerlink" title="crack5中的坑"></a><strong>crack5中的坑</strong></h2><p>注册验证函数中，各种int 3，致使进入通过SetUnhandledExceptionFilter设置的异常处理函数TopLevelExceptionFilter，在TopLevelExceptionFilter控制验证函数中的执行流程，由于先前我用的win7 x64调试，注册毫无反应，以为验证函数无法正常完整执行，so手工乱恢复，看了writeup之后，在xp中调试，你妹，居然可以正常执行…这是坑吗</p>
<a id="more"></a>
<h2 id="某两大神writeup中的解题思路"><a href="#某两大神writeup中的解题思路" class="headerlink" title="某两大神writeup中的解题思路"></a><strong>某两大神writeup中的解题思路</strong></h2><ol>
<li>geek710 FROM SSEg33k</li>
</ol>
<p>在TopLevelExceptionFilter亦有花，geek710大神的想法是，走一遍TopLevelExceptionFilter，去除功能代码，然后再要跳去执行验证函数的位置，nop验证函数中所有花，这样，一次执行完整之后，就可以得到无花的验证函数，beautiful，跟着这个思想走了一下，不晓得那弄错了，每次都异常退出，下面是提取的TopLevelExceptionFilter的大致代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">00401336    87ED            xchg ebp,ebp</div><div class="line">0040134A    8BDB            mov ebx,ebx                              ; CrackMe.004012F0</div><div class="line"></div><div class="line">00401354    8B4424 04       mov eax,dword ptr ss:[esp+0x4]//STRUCT _EXCEPTION_POINTERS *ExceptionInfo </div><div class="line">00401442    8B08            mov ecx,dword ptr ds:[eax]//exp-&gt;ExceptionRecord</div><div class="line">0040139A    8139 03000080   cmp dword ptr ds:[ecx],0x80000003 //exp-&gt;ExceptionRecord == int 3</div><div class="line">0040144A  ^\0F85 14FFFFFF   jnz CrackMe.00401364</div><div class="line"></div><div class="line">//不是 int 3</div><div class="line">00401391    33C0            xor eax,eax</div><div class="line">0040140D    C2 0400         retn 0x4</div><div class="line"></div><div class="line">//是int 3</div><div class="line">0040138A    56              push esi                                 ; kernel32.7C885780</div><div class="line">00401471    8B70 04         mov esi,dword ptr ds:[eax+0x4]//exp-&gt;ContextRecord; </div><div class="line">0040149F    8B96 B8000000   mov edx,dword ptr ds:[esi+0xB8]          ; CrackMe.0040164B</div><div class="line"></div><div class="line">004014B8    803A CC         cmp byte ptr ds:[edx],0xCC</div><div class="line"></div><div class="line">004012F2   /0F85 D6000000   jnz CrackMe.004013CE </div><div class="line"></div><div class="line">//是int 3</div><div class="line">00401329    42              inc edx                                  ; CrackMe.0040164B</div><div class="line">004013B0    87ED            xchg ebp,ebp</div><div class="line">004013C4    8BDB            mov ebx,ebx                              ; CrackMe.004012F0</div><div class="line">jmp 004014A8</div><div class="line"></div><div class="line">//不是int 3了，0xCC</div><div class="line">004014A8    8A0A            mov cl,byte ptr ds:[edx]</div><div class="line">004013F1    8AC1            mov al,cl</div><div class="line">004014D0    C0E0 06         shl al,0x6</div><div class="line">00401477    C0E9 02         shr cl,0x2</div><div class="line">00401495    02C1            add al,cl</div><div class="line">0040149A    34 0D           xor al,0xD</div><div class="line">004014B0    8AC8            mov cl,al</div><div class="line">00401430    C0E9 05         shr cl,0x5</div><div class="line">004014CA    C0E0 03         shl al,0x3</div><div class="line">004014D6    87ED            xchg ebp,ebp</div><div class="line">004014EA    8BDB            mov ebx,ebx                              ; CrackMe.004012F0</div><div class="line">004014F4    02C8            add cl,al</div><div class="line">004014C1    80C1 11         add cl,0x11</div><div class="line">004012FF    8AC1            mov al,cl</div><div class="line">004013AA    C0E0 05         shl al,0x5</div><div class="line">004013DA    C0E9 03         shr cl,0x3</div><div class="line">0040146C    02C1            add al,cl</div><div class="line">0040141F    34 51           xor al,0x51</div><div class="line">0040147D    8AC8            mov cl,al</div><div class="line">004013D4    C0E1 07         shl cl,0x7</div><div class="line">004013FF    D0E8            shr al,1</div><div class="line">00401367    87ED            xchg ebp,ebp</div><div class="line">0040137B    8BDB            mov ebx,ebx                              ; CrackMe.004012F0</div><div class="line">00401385    02C8            add cl,al</div><div class="line">00401407    80E9 6F         sub cl,0x6F</div><div class="line">0040145A    81E1 FF000000   and ecx,0xFF</div><div class="line">00401463    81E1 07000080   and ecx,0x80000007</div><div class="line"></div><div class="line">00401424    03D1            add edx,ecx</div><div class="line">00401307    87ED            xchg ebp,ebp</div><div class="line">0040131B    8BDB            mov ebx,ebx                              ; CrackMe.004012F0</div><div class="line">00401325    42              inc edx                                  ; CrackMe.00401653</div><div class="line">004013E7    83C8 FF         or eax,0xFFFFFFFF</div><div class="line">00401416    8996 B8000000   mov dword ptr ds:[esi+0xB8],edx          ; CrackMe.00401654</div><div class="line"></div><div class="line">//清楚混淆的代码，填充0x90</div><div class="line">0040136E    8BCA            mov ecx,edx</div><div class="line">00401370    2BCF            sub ecx,edi</div><div class="line">00401372    B0 90           mov al,0x90</div><div class="line">00401374    F3:AA           rep stos byte ptr es:[edi]</div><div class="line"></div><div class="line">004013E7    83C8 FF         or eax,0xFFFFFFFF</div><div class="line"></div><div class="line">0040142C    5E              pop esi                                  ; kernel32.7C885780</div><div class="line">00401439    C2 0400         retn 0x4</div></pre></td></tr></table></figure>
<p>本来这个是很妙的方法，但是无奈没成功，换一个思路</p>
<ol>
<li>Anonymous</li>
</ol>
<p>这个方法较麻烦，在 <code>00401416   mov dword ptr ds:[esi+0xB8],edx</code> 处下条件断点，<code>byte ptr[edx] != 0xCC</code>，每次断下之后，记录edx指向的代码（新的int 3之前），完整记录之后，就是注册验证的代码，手工记录如下（不会脚本啊）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line">0040168D    6A 01           push 0x1</div><div class="line">0040168F    E8 30100000     call &lt;jmp.&amp;MFC42.#6334&gt;</div><div class="line">004016CE    BB E2D90100     mov ebx,0x1D9E2</div><div class="line">00401715    8D77 64         lea esi,dword ptr ds:[edi+0x64]</div><div class="line">00401718    6A 00           push 0x0</div><div class="line">0040171A    8BCE            mov ecx,esi</div><div class="line">0040171C    E8 9D0F0000     call &lt;jmp.&amp;MFC42.#2915&gt;</div><div class="line">00401721    8945 F8         mov dword ptr ss:[ebp-0x8],eax</div><div class="line">0040175A    8B06            mov eax,dword ptr ds:[esi]</div><div class="line">0040175C    8B48 F8         mov ecx,dword ptr ds:[eax-0x8]</div><div class="line">0040175F    894D FC         mov dword ptr ss:[ebp-0x4],ecx</div><div class="line">004017A1    8B36            mov esi,dword ptr ds:[esi]</div><div class="line">004017A3    68 0C414000     push CrackMe.0040410C</div><div class="line">004017A8    56              push esi</div><div class="line">004017A9    8B35 B4314000   mov esi,dword ptr ds:[&lt;&amp;MSVCRT._mbscmp&gt;] ; msvcrt._mbscmp</div><div class="line">004017AF    FFD6            call esi</div><div class="line">004017B1    83C4 08         add esp,0x8</div><div class="line">004017B4    85C0            test eax,eax</div><div class="line">004017B6    74 4C           je short CrackMe.00401804</div><div class="line">004017F2    8B47 60         mov eax,dword ptr ds:[edi+0x60]</div><div class="line">004017F5    68 0C414000     push CrackMe.0040410C</div><div class="line">004017FA    50              push eax</div><div class="line">004017FB    FFD6            call esi</div><div class="line">004017FD    83C4 08         add esp,0x8</div><div class="line">00401800    85C0            test eax,eax</div><div class="line">00401802    75 17           jnz short CrackMe.0040181B</div><div class="line">00401804    6A 00           push 0x0</div><div class="line">00401806    6A 00           push 0x0</div><div class="line">00401808    68 2C404000     push CrackMe.0040402C                    ; ASCII &quot;注册失败！&quot;</div><div class="line">0040180D    8BCF            mov ecx,edi</div><div class="line">0040180F    E8 A40E0000     call &lt;jmp.&amp;MFC42.#4224&gt;</div><div class="line">00401814    5F              pop edi</div><div class="line">00401815    5E              pop esi</div><div class="line">00401816    5B              pop ebx</div><div class="line">00401817    8BE5            mov esp,ebp</div><div class="line">00401819    5D              pop ebp</div><div class="line">0040181A    C3              retn</div><div class="line"></div><div class="line">004018ED    8B45 FC         mov eax,dword ptr ss:[ebp-0x4]</div><div class="line">004018F0    8B55 F8         mov edx,dword ptr ss:[ebp-0x8]</div><div class="line">004018F3    83C9 FF         or ecx,0xFFFFFFFF</div><div class="line">004018F6    8D7410 01       lea esi,dword ptr ds:[eax+edx+0x1]</div><div class="line">004018FA    2BCA            sub ecx,edx</div><div class="line"></div><div class="line">004018FC    8BC6            mov eax,esi</div><div class="line"></div><div class="line">00401947    0FBE50 FE       movsx edx,byte ptr ds:[eax-0x2]</div><div class="line">0040194B    48              dec eax</div><div class="line">0040194C    03DA            add ebx,edx</div><div class="line">00401994    8D149B          lea edx,dword ptr ds:[ebx+ebx*4]</div><div class="line">00401997    8D14D3          lea edx,dword ptr ds:[ebx+edx*8]</div><div class="line">0040199A    8D1C52          lea ebx,dword ptr ds:[edx+edx*2]</div><div class="line">004019E4    8818            mov byte ptr ds:[eax],bl</div><div class="line">00401A22    81F3 3A45AC14   xor ebx,0x14AC453A</div><div class="line">00401A66    0018            add byte ptr ds:[eax],bl</div><div class="line">00401AA1    8D1401          lea edx,dword ptr ds:[ecx+eax]</div><div class="line">00401AA4    85D2            test edx,edx</div><div class="line">00401AA6  ^ 0F8F 52FEFFFF   jg CrackMe.004018FE</div><div class="line"></div><div class="line">00401B42    8BC6            mov eax,esi</div><div class="line"></div><div class="line">00401B96    0FBE50 FE       movsx edx,byte ptr ds:[eax-0x2]</div><div class="line">00401B9A    48              dec eax</div><div class="line">00401B9B    03DA            add ebx,edx</div><div class="line">00401BD6    8D149B          lea edx,dword ptr ds:[ebx+ebx*4]</div><div class="line">00401BD9    8D14D3          lea edx,dword ptr ds:[ebx+edx*8]</div><div class="line">00401BDC    8D1C52          lea ebx,dword ptr ds:[edx+edx*2]</div><div class="line">00401C2F    8818            mov byte ptr ds:[eax],bl</div><div class="line">00401C6C    81E3 46A554A4   and ebx,0xA454A546</div><div class="line">00401CAE    0018            add byte ptr ds:[eax],bl</div><div class="line">00401CF8    8D1408          lea edx,dword ptr ds:[eax+ecx]</div><div class="line">00401CFB    85D2            test edx,edx</div><div class="line">00401CFD  ^ 0F8F 41FEFFFF   jg CrackMe.00401B44</div><div class="line"></div><div class="line">00401D92    8BC6            mov eax,esi</div><div class="line"></div><div class="line">00401DDC    0FBE50 FE       movsx edx,byte ptr ds:[eax-0x2]</div><div class="line">00401DE0    48              dec eax</div><div class="line">00401DE1    03DA            add ebx,edx</div><div class="line">00401E27    8D149B          lea edx,dword ptr ds:[ebx+ebx*4]</div><div class="line">00401E2A    8D14D3          lea edx,dword ptr ds:[ebx+edx*8]</div><div class="line">00401E2D    8D1C52          lea ebx,dword ptr ds:[edx+edx*2]</div><div class="line">00401E75    8818            mov byte ptr ds:[eax],bl</div><div class="line">00401ECD    81CB 37214715   or ebx,0x15472137</div><div class="line">00401F0A    0018            add byte ptr ds:[eax],bl</div><div class="line">00401F4E    8D1408          lea edx,dword ptr ds:[eax+ecx]</div><div class="line">00401F51    85D2            test edx,edx</div><div class="line">00401F53  ^ 0F8F 3BFEFFFF   jg CrackMe.00401D94</div><div class="line"></div><div class="line">00401F9E    8BC3            mov eax,ebx</div><div class="line">00401FA0    33D2            xor edx,edx</div><div class="line">00401FA2    B9 1F011500     mov ecx,0x15011F</div><div class="line">00401FA7    F7F1            div ecx</div><div class="line">00401FA9    8BDA            mov ebx,edx</div><div class="line"></div><div class="line">00401FF0    8D77 60         lea esi,dword ptr ds:[edi+0x60]</div><div class="line">00401FF3    6A 00           push 0x0</div><div class="line">00401FF5    8BCE            mov ecx,esi</div><div class="line">00401FF7    E8 C2060000     call &lt;jmp.&amp;MFC42.#2915&gt;</div><div class="line"></div><div class="line">00402043    8B16            mov edx,dword ptr ds:[esi]</div><div class="line">00402045    8B52 F8         mov edx,dword ptr ds:[edx-0x8]</div><div class="line">004020D5    33C9            xor ecx,ecx</div><div class="line">00402111    83CE FF         or esi,0xFFFFFFFF</div><div class="line">00402114    8D5402 01       lea edx,dword ptr ds:[edx+eax+0x1]</div><div class="line">00402118    2BF0            sub esi,eax</div><div class="line"></div><div class="line">004021A6    0FBE42 FE       movsx eax,byte ptr ds:[edx-0x2]</div><div class="line">004021AA    4A              dec edx</div><div class="line">004021AB    8D0C89          lea ecx,dword ptr ds:[ecx+ecx*4]</div><div class="line">004021AE    8D4C48 D0       lea ecx,dword ptr ds:[eax+ecx*2-0x30]</div><div class="line">004021F9    880A            mov byte ptr ds:[edx],cl</div><div class="line">00402245    8D0432          lea eax,dword ptr ds:[edx+esi]</div><div class="line">00402248    85C0            test eax,eax</div><div class="line">0040224A  ^ 0F8F CAFEFFFF   jg CrackMe.0040211A</div><div class="line"></div><div class="line">00402290    3BD9            cmp ebx,ecx</div><div class="line">00402292    75 17           jnz short CrackMe.004022AB</div><div class="line">00402294    6A 00           push 0x0</div><div class="line">00402296    6A 00           push 0x0</div><div class="line">00402298    68 20404000     push CrackMe.00404020                    ; ASCII &quot;注册成功！&quot;</div><div class="line">0040229D    8BCF            mov ecx,edi</div><div class="line">0040229F    E8 14040000     call &lt;jmp.&amp;MFC42.#4224&gt;</div><div class="line">004022A4    5F              pop edi</div><div class="line">004022A5    5E              pop esi</div><div class="line">004022A6    5B              pop ebx</div><div class="line">004022A7    8BE5            mov esp,ebp</div><div class="line">004022A9    5D              pop ebp</div><div class="line">004022AA    C3              retn</div><div class="line"></div><div class="line">00402384    6A 00           push 0x0</div><div class="line">00402386    6A 00           push 0x0</div><div class="line">00402388    68 2C404000     push CrackMe.0040402C                    ; ASCII &quot;注册失败！&quot;</div><div class="line">0040238D    8BCF            mov ecx,edi</div><div class="line">0040238F    E8 24030000     call &lt;jmp.&amp;MFC42.#4224&gt;</div></pre></td></tr></table></figure>
<p>根据这个写出注册机就行</p>
<h2 id="注册算法"><a href="#注册算法" class="headerlink" title="注册算法"></a><strong>注册算法</strong></h2><p>待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="crack5中的坑"><a href="#crack5中的坑" class="headerlink" title="crack5中的坑"></a><strong>crack5中的坑</strong></h2><p>注册验证函数中，各种int 3，致使进入通过SetUnhandledExceptionFilter设置的异常处理函数TopLevelExceptionFilter，在TopLevelExceptionFilter控制验证函数中的执行流程，由于先前我用的win7 x64调试，注册毫无反应，以为验证函数无法正常完整执行，so手工乱恢复，看了writeup之后，在xp中调试，你妹，居然可以正常执行…这是坑吗</p>]]>
    
    </summary>
    
      <category term="ssctf" scheme="http://anhkgg.github.io/tags/ssctf/"/>
    
      <category term="ctf" scheme="http://anhkgg.github.io/categories/ctf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ssctf writeup by anhkgg]]></title>
    <link href="http://anhkgg.github.io/ssctf-2014-11-1/"/>
    <id>http://anhkgg.github.io/ssctf-2014-11-1/</id>
    <published>2014-11-03T08:01:09.000Z</published>
    <updated>2016-07-07T04:34:56.388Z</updated>
    <content type="html"><![CDATA[<h1 id="ssctf-wirteup"><a href="#ssctf-wirteup" class="headerlink" title="ssctf wirteup"></a><strong>ssctf wirteup</strong></h1><h3 id="1-web8-U盘病毒"><a href="#1-web8-U盘病毒" class="headerlink" title="1. web8 U盘病毒"></a><strong>1. web8 U盘病毒</strong></h3><p>UP_BOOT.img解压之后是两个文件autorun.txt和<code>是男人你就下100层.exe</code>，autorun.txt中的内容是”你真厉害都到这了，看看这个游戏你肯定会喜欢的，但是据说这个游戏是被加了后门的，找到后门操作的文件的内容，取文件内容的16位md5值作为key！祝你好运…….”。<br>根据题目知道<code>是男人你就下100层.exe</code>添加了后门，那么在执行的时候肯定要释放后门，所以找了一款 文件操作监控工具 进行监测，添加了文件创建，进程创建监测，然后发现在tmp目录中创建了RarSFX0目录，然后在RarSFX0中创建了1.exe, 1.vbs, 2.exe，以及test.txt，简单查看1.vbs启动1.exe和2.exe，1.exe是后门，2.exe是原始的<code>是男人你就下100层.exe</code>，test.txt时候后门生成的，题目中要后门操作文件的·内容·16位md5作为key，那么1.exe，2.exe不大可能，只有1.vbs和test.txt了，提交了两次，test.txt的内容md5成功。</p>
<a id="more"></a>
<h3 id="2-crack1"><a href="#2-crack1" class="headerlink" title="2.crack1"></a><strong>2.crack1</strong></h3><p>代码很简单，输入用户名密码之后，讲密码每个字符和408030所在内存的数据xor得到的值和用户名比较，相同则成功。用了个py脚本将用户名和408030内存的值xor得到密码，然后密码的md5即是key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">k = [1, 2, 3, 4, 1, 5]#408030的值，还有其他的</div><div class="line">n = &quot;xxxxx&quot;#用户名</div><div class="line">a = &quot;&quot;</div><div class="line"></div><div class="line">for i in range(0, len(n)):</div><div class="line">    k1 = ord(n[i])</div><div class="line">    k1 = k[i] ^ k1</div><div class="line">    a = a + chr(k1)</div><div class="line">    </div><div class="line">print a</div></pre></td></tr></table></figure></p>
<h3 id="3-crack2"><a href="#3-crack2" class="headerlink" title="3.crack2"></a><strong>3.crack2</strong></h3><p>反调试太多，没搞定</p>
<h3 id="4-crack3"><a href="#4-crack3" class="headerlink" title="4.crack3"></a><strong>4.crack3</strong></h3><p>程序流程是，多次右键或者左键点击，会给403070写入R或者L字符，48次之后，点击确认，如果右键活左键点击姿势正确，就可以弹出正确的key。<br>验证过程是，通过48个L或者R可到key，如果通过48个L或者R的一个算法得到”查水表“三个字，那么点击姿势正确，key也正确，所以需要通过”查水表“的值逆推得到L和R的个数，具体算法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">do</div><div class="line">  &#123;</div><div class="line">    v11[v2] = 0;</div><div class="line">    v3 = v1;</div><div class="line">    if ( __SETO__(v1, v1 + 8) ^ 1 )</div><div class="line">    &#123;</div><div class="line">      do</div><div class="line">      &#123;</div><div class="line">	v4 = 2 * v11[v2];</div><div class="line">	v5 = a1[v3] == 0x52;</div><div class="line">	v11[v2] = v4;</div><div class="line">	if ( v5 )</div><div class="line">	  v11[v2] = v4 + 1;</div><div class="line">	++v3;</div><div class="line">      &#125;</div><div class="line">      while ( v3 &lt; v1 + 8 );</div><div class="line">    &#125;</div><div class="line">    v1 += 8;</div><div class="line">    ++v2;                                      </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>”查水表“的值是B2 E9 CB AE  B1 ED，通过上面算法和B2 E9 CB AE  B1 ED推得点击姿势是:<br>RLRRLLRLRRRLRLLRRRLLRLRRRLRLRRRLRLRRLLLRRRRLRRLR<br>然后，操作一次，或者调试器内存修改，都可以得到key</p>
<h3 id="5-crack4"><a href="#5-crack4" class="headerlink" title="5.crack4"></a><strong>5.crack4</strong></h3><p>题目是<br>”输入正确的密码，会释放出文件。key就在文件中。<br>tips:第一层密码为6为纯数字，第二层密码也是6位。“<br>粗略分析，输入第一次密码，释放并解密得到encrypt.exe，是一个exe，运行这个exe，输入第二次密码，释放并解密得到一个gif，密码验证算法是md5(md5(“HOWMPxxxxxx”)) == 09B2F924C20C5CA427EED2C5B98BEFBF，xxxxxx就是密码，先前一直想md5算出来，，没可能，后面发现释放文件之后的解密算法是xor，那么，嘿嘿，exe和gif格式的开头几个字节都是固定的，那么通过加密文件和正常文件的前6个字节xor即可得到密码，分别是564987和w!q&amp;cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MZ...... =&gt;4D 5A 00 00 00 00 xor 78 6C 34 39 38 37 =&gt;35 36 34 49 48 47 =》564987</div><div class="line">GIF89aX =》47 49 46 38 39 61 58 xor 30 68 37 1E 5A 12 =&gt; w!q&amp;cs</div></pre></td></tr></table></figure></p>
<p>最后得到解密之后的图片，图片就有key</p>
<h3 id="6-crack5"><a href="#6-crack5" class="headerlink" title="6.crack5"></a><strong>6.crack5</strong></h3><p>这到题太坑，点击注册啥反应没有，以为是没有调用注册功能函数，后来通过网上的特征码定位到了注册按钮的函数，地址是：00401640，结果一看代码全是混淆，各种int 3，jmp，，完全无法正常执行，所以点击之后无反应，尝试恢复，大概流程得到，先UpdateData获取到输入，然后一段算法比较，MessageBox注册成功或者失败。。但是加密算法那部分，实在是无力恢复了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ssctf-wirteup"><a href="#ssctf-wirteup" class="headerlink" title="ssctf wirteup"></a><strong>ssctf wirteup</strong></h1><h3 id="1-web8-U盘病毒"><a href="#1-web8-U盘病毒" class="headerlink" title="1. web8 U盘病毒"></a><strong>1. web8 U盘病毒</strong></h3><p>UP_BOOT.img解压之后是两个文件autorun.txt和<code>是男人你就下100层.exe</code>，autorun.txt中的内容是”你真厉害都到这了，看看这个游戏你肯定会喜欢的，但是据说这个游戏是被加了后门的，找到后门操作的文件的内容，取文件内容的16位md5值作为key！祝你好运…….”。<br>根据题目知道<code>是男人你就下100层.exe</code>添加了后门，那么在执行的时候肯定要释放后门，所以找了一款 文件操作监控工具 进行监测，添加了文件创建，进程创建监测，然后发现在tmp目录中创建了RarSFX0目录，然后在RarSFX0中创建了1.exe, 1.vbs, 2.exe，以及test.txt，简单查看1.vbs启动1.exe和2.exe，1.exe是后门，2.exe是原始的<code>是男人你就下100层.exe</code>，test.txt时候后门生成的，题目中要后门操作文件的·内容·16位md5作为key，那么1.exe，2.exe不大可能，只有1.vbs和test.txt了，提交了两次，test.txt的内容md5成功。</p>]]>
    
    </summary>
    
      <category term="ssctf" scheme="http://anhkgg.github.io/tags/ssctf/"/>
    
      <category term="ctf" scheme="http://anhkgg.github.io/categories/ctf/"/>
    
  </entry>
  
</feed>
