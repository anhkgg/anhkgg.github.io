<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anhkgg&#39;Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘</title>
  <subtitle>Windows Kernel/Rootkit/Reverse Engineer/Expolit/内核研究/逆向分析/漏洞分析挖掘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://anhkgg.github.io/"/>
  <updated>2017-05-26T01:32:41.281Z</updated>
  <id>https://anhkgg.github.io/</id>
  
  <author>
    <name>Anhkgg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WannaCry深度详细分析报告</title>
    <link href="https://anhkgg.github.io/wannacry-analyze-report/"/>
    <id>https://anhkgg.github.io/wannacry-analyze-report/</id>
    <published>2017-05-26T01:29:07.000Z</published>
    <updated>2017-05-26T01:32:41.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00. 前言"></a>0x00. 前言</h1><p>最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。</p>
<p>趁着这个热度，我也来跟风一把。</p>
<p>前前后后把WannaCry详细分析了一遍。</p>
<p>从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。</p>
<a id="more"></a>
<p>由于没有拿到初始样本，没有包含漏洞利用部分的分析。</p>
<p>样本信息：</p>
<blockquote>
<p>MD5: 84C82835A5D21BBCF75A61706D8AB549</p>
<p>SHA1: 5FF465AFAABCBF0150D1A3AB2C2E74F3A4426467</p>
<p>CRC32: 4022FCAA</p>
<p>无壳 / Visual C++ 6.0</p>
</blockquote>
<p>下面具体看分析内容。</p>
<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01. 概述"></a>0x01. 概述</h1><ol>
<li>样本首先通过资源释放各种文件，包括加密器、解密器、几个辅助程序、桌面背景图、说明文件、语言文件等等。</li>
<li>内存加载加密器模块，执行加密部分功能。</li>
<li>枚举目标文件（目标文件后缀列表后面给出），加密为.WNCRY文件（加密策略后面详述），删除原始文件。</li>
<li>复制自身为tasksche.exe，安装启动项</li>
<li>启动解密器</li>
</ol>
<p>大致流程图如图：</p>
<p><img src="d:/note/wannacry/00.png" alt="img"></p>
<p>下面开始详细分析各个部分细节。</p>
<h1 id="0x02-释放文件"><a href="#0x02-释放文件" class="headerlink" title="0x02. 释放文件"></a>0x02. 释放文件</h1><p>设置当前目录为工作目录，然后查找PE中资源(XIA)。</p>
<p><img src="d:/note/wannacry/1_0.png" alt="img"></p>
<p>直接用资源工具看一下，发现是PK开头的，多半是个压缩文件了，导出来试试。</p>
<p><img src="d:/note/wannacry/1_1.png" alt="img"></p>
<p>解压还要密码，看代码密码是WNcry@2ol7，解压成功。</p>
<p><img src="d:/note/wannacry/1_3.png" alt="img"></p>
<p>读取资源数据后，解压释放文件到当前目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//部分释放文件说明：</div><div class="line">b.wnry      //桌面背景图片</div><div class="line">c.wnry      //加密相关</div><div class="line">msg/*.wnry  //语言相关文件</div><div class="line">r.wnry      //@Please_Read_Me@.txt</div><div class="line">s.wnry      //是压缩文件，打包的是Tor相关组件</div><div class="line"></div><div class="line">taskdl.exe  //删除回收站文件</div><div class="line">taskse.exe  //用于启动其他session的@WanaDecryptor@.exe</div><div class="line"></div><div class="line">u.wnry      //@WanaDecryptor@.exe 解密器 </div><div class="line">t.wnry      //解密后是加密器</div></pre></td></tr></table></figure>
<p>在三个比特币交易地址中随机选择一个，写入c.wnry</p>
<p><img src="/img\wannacry\1_6.png" alt="img"></p>
<p>然后设置当前目录为隐藏属性，且设置为everyone可访问</p>
<p><img src="d:/note/wannacry/1_2.png" alt="img"></p>
<p>然后初始化Crypt相关函数，用于后面的解密操作。</p>
<p>开始操作文件t.wnry，看看内容，应该是个加密文件。</p>
<p><img src="d:/note/wannacry/1_4.png" alt="img"></p>
<p>然后通过crypt API将t.wnry解密之后（解密后是个DLL模块，dump数据后可以用于分析），映射到内存（自己loaddll），然后找到导出接口函数TaskStart调用，开始加密工作。</p>
<p><img src="d:/note/wannacry/1_5.png" alt="img"></p>
<h1 id="0x03-加密部分"><a href="#0x03-加密部分" class="headerlink" title="0x03. 加密部分"></a>0x03. 加密部分</h1><p>TaskStart一进来，通过MsWinZonesCacheCounterMutexA的Mutex进行单示例检查，有则退出，没有继续工作。</p>
<p>然后是设置工作目录，读取c.wnry信息。</p>
<p>检查是否是SYSTEM账户。</p>
<p><img src="/img\wannacry\3_0.png" alt="img"></p>
<p>初始化Crypt相关函数，以及文件操作函数（增加一点分析成本）。</p>
<p><img src="/img\wannacry\3_1.png" alt="img"><br><img src="/img\wannacry\3_2.png" alt="img"></p>
<p>检查Global\MsWinZonesCacheCounterMutexW，Global\MsWinZonesCacheCounterMutexA\0是否存在，</p>
<p>存在则表示加密相关准备工作已经完成，不在进行，没有则创建Global\MsWinZonesCacheCounterMutexA\0</p>
<p>检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则加密相关准备工作已经完成，不在进行，没有则进行后续工作。</p>
<p><img src="/img\wannacry\3_6.png" alt="img"></p>
<p>如果加密相关准备工作已经完成，创建一个线程，完成如下工作（记为工作A）：</p>
<ol>
<li>如果不是管理员权限，并且不是SYSTEM账户，通过taskse.exe提权启动@WanaDecryptor@.exe，是则普通方式启动@WanaDecryptor@.exe</li>
</ol>
<p><img src="/img\wannacry\3_3.png" alt="img"></p>
<ol>
<li>安装tasksche.exe启动项（注册表Run），键名随机</li>
</ol>
<p><img src="/img\wannacry\3_4.png" alt="img"></p>
<p>如果加密准备未完成，初始化密钥，保存到00000000.pky, 00000000.eky。</p>
<blockquote>
<p>由于时间关系，具体加密密钥产生过程不再详述，很多分析文章说的很清楚了，本文重点不在此。</p>
</blockquote>
<p>然后是如果00000000.res不存在，通过CryptGenRandom产生8字节随机值，后续会写入00000000.res</p>
<p>接着创建5个工作线程，完成不同的工作。</p>
<ol>
<li>线程1每隔25秒循环写入数据到00000000.res，包括前面CryptGenRandom生成的随机值，已经更新的当前时间，直到线程退出标记为真退出</li>
</ol>
<p><img src="/img\wannacry\3_5.png" alt="img"></p>
<ol>
<li>线程2每5秒检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则设置全局标志，然后退出线程</li>
</ol>
<p><img src="/img\wannacry\3_7.png" alt="img"></p>
<ol>
<li>线程3监测新增磁盘，加密新磁盘的文件（和其他磁盘加密相同）</li>
</ol>
<p><img src="/img\wannacry\3_8.png" alt="img"></p>
<ol>
<li><p>线程4每30秒启动taskdl.exe清除所有磁盘的回收站文件</p>
</li>
<li><p>线程5完成的也是前面提到的工作A的内容，不再详述</p>
</li>
</ol>
<p>然后就是重点了，加密文件部分了。</p>
<h2 id="加密文件部分"><a href="#加密文件部分" class="headerlink" title="加密文件部分"></a>加密文件部分</h2><p>拷贝u.wnry为@WanaDecryptor@.exe，通过写一个bat创建@WanaDecryptor@.exe.lnk快捷方式。</p>
<p><img src="/img\wannacry\3_9.png" alt="img"></p>
<p><img src="/img\wannacry\2_11.png" alt="img"></p>
<p>读取r.wnry内容，生成@Please_Read_Me@.txt文件。</p>
<p>枚举当前用户桌面和文档目录文件，进行加密（没有设置不复写标记，删除前会复写）。</p>
<p>枚举All Users\Desktop和All Users\Documents，找到非当前用户目录进行加密（没有设置不复写标记，删除前会复写）。</p>
<p>下面记为工作B:</p>
<p>通过taskkill强删Microsoft.Exchange、sql和mysql进程（加密其数据）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">anhkgg_CreateProc_10001080(aTaskkill_exeFI, 0, 0);// taskkill.exe /f /im Microsoft.Exchange.*</div><div class="line">anhkgg_CreateProc_10001080(aTaskkill_exe_0, 0, 0);// taskkill.exe /f /im MSExchange*</div><div class="line">anhkgg_CreateProc_10001080(aTaskkill_exe_1, 0, 0);// &apos;taskkill.exe /f /im sqlserver.exe</div><div class="line">anhkgg_CreateProc_10001080(aTaskkill_exe_2, 0, 0);// taskkill.exe /f /im sqlwriter.exe</div><div class="line">anhkgg_CreateProc_10001080(aTaskkill_exe_3, 0, 0);// taskkill.exe /f /im mysqld.exe</div><div class="line">```      </div><div class="line"></div><div class="line">加密磁盘中文件，每个分区重复两次（会设置不复写标记，删除前不会复写）。</div><div class="line"></div><div class="line">枚举All Users\Desktop目录，复制b.wnry到目录中为@WanaDecryptor@.bmp，设置桌面背景为@WanaDecryptor@.bmp，</div><div class="line"></div><div class="line">执行@WanaDecryptor@.exe co</div><div class="line"></div><div class="line">更新00000000.res</div><div class="line"></div><div class="line">cmd.exe /c start /b @WanaDecryptor@.exe vs</div><div class="line"></div><div class="line">每个磁盘(fixed)创建x:/$Recycle/hibsys.WNCRYT（系统盘写在temp目录，x:/$Recycle被设置为系统隐藏属性），读取分区可用空间大小，大于0x40000000（1GB）的话，每10微秒循环写入0xa00000个字节的&apos;U&apos;，写20次，然后删除该文件，并且设置了重启后删除。</div><div class="line"></div><div class="line">每隔60s重复工作B，知道退出标志为真。</div><div class="line"></div><div class="line">## 文件枚举</div><div class="line"></div><div class="line">枚举文件采用方式为：</div><div class="line"></div><div class="line">1. 枚举当前目录中所有文件(排除文件看下文)，加入文件链表，记录所有子目录（排除目录看下文）到目录链表。</div><div class="line"></div><div class="line">2. 本目录文件有加密操作（具体看下文件）</div><div class="line"></div><div class="line">3. 分析目录层级，少于等于6层的，拷贝lease_Read_Me@.txt到目录，5-6层的拷贝@WanaDecryptor@.exe.lnk，1-4层拷贝@WanaDecryptor@.exe到目录。</div><div class="line"></div><div class="line">4. 然后遍历目录链表，枚举子目录，重复1操作。</div><div class="line"></div><div class="line">5. 子目录枚举完成，所有文件记录到链表，进行后续操作。</div><div class="line"></div><div class="line">目录和文件采用相同的链表结果，总结如下：</div></pre></td></tr></table></figure>
<p>struct FILE_LIST_CONTEXT<br>{<br>    DWORD vtable;<br>    FILE_LIST *list;//<br>    DWORD file_count;//8<br>}</p>
<p>struct FILE_LIST<br>{<br>    FILE_LIST<em> prev;<br>    FILE_LIST</em> next;<br>    FILE_INFO file;//8<br>}</p>
<p>struct FILE_INFO<br>{<br>    WCHAR path[0x168];//<br>    WCHAR name[0x104];//2d0<br>    DWORD nFileSizeLow;//4d8<br>    DWORD nFileSizeHigh;//4dc<br>    DWORD type;//4e0  FILE_TYPE<br>}//0x4e4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 排除目录</div><div class="line"></div><div class="line">枚举子目录时，会跳过如下目录（保证系统正常工作）：</div></pre></td></tr></table></figure></p>
<p>\Intel<br>\ProgramData<br>\WINDOWS<br>\Program Files<br>\Program Files (x86)<br>\AppData\Local\Temp<br>\Local Settings\Temp<br>This folder protects against ransomware. Modifying it will reduce protection<br>Temporary Internet Files<br>Content.IE5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 文件分类</div><div class="line"></div><div class="line">枚举文件时，首先跳过 @Please_Read_Me@.txt，@WanaDecryptor@.exe.lnk， @WanaDecryptor@.bmp</div><div class="line"></div><div class="line">然后检查文件类型，跳过0,1,6类型文件，其他文件加入链表。</div><div class="line"></div><div class="line">具体类型如下：</div></pre></td></tr></table></figure></p>
<p>0 没有后缀以及其他类型后缀<br>1 .exe, .dll<br>4 .WNCRYT<br>5 .WNCYR<br>6 .WNCRY</p>
<p>2.<br>“.doc””.docx””.xls””.xlsx””.ppt””.pptx””.pst””.ost””.msg””.eml””.vsd””.vsdx”<br>“.txt””.csv””.rtf””.123””.wks””.wk1””.pdf””.dwg””.onetoc2””.snt””.jpeg””.jpg”</p>
<ol>
<li>“.docb””.docm””.dot””.dotm””.dotx””.xlsm””.xlsb””.xlw””.xlt””.xlm””.xlc””.xltx””.xltm””.pptm””.pot””.pps””.ppsm””.ppsx””.ppam””.potx””.potm”<br>“.edb””.hwp””.602””.sxi””.sti””.sldx””.sldm””.sldm””.vdi””.vmdk””.vmx””.gpg””.aes””.ARC””.PAQ””.bz2””.tbk””.bak””.tar””.tgz””.gz””.7z””.rar”<br>“.zip””.backup””.iso””.vcd””.bmp””.png””.gif””.raw””.cgm””.tif””.tiff””.nef””.psd””.ai””.svg””.djvu””.m4u””.m3u””.mid””.wma””.flv””.3g2””.mkv”<br>“.3gp””.mp4””.mov””.avi””.asf””.mpeg””.vob””.mpg””.wmv””.fla””.swf””.wav””.mp3””.sh””.class””.jar””.java””.rb””.asp””.php””.jsp””.brd””.sch”<br>“.dch””.dip””.pl””.vb””.vbs””.ps1””.bat””.cmd””.js””.asm””.h””.pas””.cpp””.c””.cs””.suo””.sln””.ldf””.mdf””.ibd””.myi””.myd””.frm””.odb””.dbf”<br>“.db””.mdb””.accdb””.sql””.sqlitedb””.sqlite3””.asc””.lay6””.lay””.mml””.sxm””.otg””.odg””.uop””.std””.sxd””.otp””.odp””.wb2””.slk””.dif””.stc”<br>“.sxc””.ots””.ods””.3dm””.max””.3ds””.uot””.stw””.sxw””.ott””.odt””.pem””.p12””.csr””.crt””.key””.pfx””.der”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">总结为下面的enum</div></pre></td></tr></table></figure>
</li>
</ol>
<p>enum FILE_TYPE<br>{<br>    FILE_TYPE_NULL = 0,<br>    FILE_TYPE_EXEDLL,<br>    FILE_TYPE_DOC,<br>    FILE_TYPE_DOCEX,<br>    FILE_TYPE_WNCRYT, //.wncryt<br>    FILE_TYPE_WNCYR, //.wncyr<br>    FILE_TYPE_WNCRY //.wncry<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 文件加密策略</div><div class="line"></div><div class="line">加密文件函数中有个参数，我取做cmd（取值是1-4）。因为不同的值会有不同的操作方式。</div><div class="line"></div><div class="line">根据cmd和文件类型和大小等等，函数`sub_10002E70`返回不同的操作方式。</div></pre></td></tr></table></figure></p>
<ol>
<li>cmd&gt;=4, FOT_ENCRYPT_NORMAL_4</li>
<li>cmd&lt;=3，FILE_TYPE_NULL，FOT_NULL_1 </li>
<li>cmd==3, 非FILE_TYPE_NULL，FOT_ENCRYPT_NORMAL_4</li>
<li>cmd&lt;=2, .wncyr, FOT_NULL_1</li>
<li>cmd&lt;=2, .wncryt, FOT_DELETE_FILE_2</li>
</ol>
<p>//用于枚举中的操作，直接操作普通文件（不加入链表）和大文件.doc（加入链表），小文件.doc,.docex加入链表，其他文件不加入链表<br>//枚举中完成加密操作的文件不加入链表了</p>
<ol>
<li>cmd==1, .doc, 大文件, FOT_ENCRYPT_WRITESRC_3 //也要加入链表</li>
<li>cmd==1, .doc, 普通文件, FOT_ENCRYPT_NORMAL_4</li>
<li>cmd==1, .doc, 小文件，FOT_NULL_1</li>
<li><p>cmd==1, .docex, FOT_NULL_1</p>
</li>
<li><p>cmd==2, .doc, FOT_NULL_1</p>
</li>
<li>cmd==2, .docex, 大文件， FOT_ENCRYPT_WRITESRC_3</li>
<li>cmd==2, .docex, 小文件，FOT_NULL_1</li>
<li>cmd==2, .docex, 普通文件，FOT_ENCRYPT_NORMAL_4</li>
</ol>
<p>其他返回FOT_NULL_0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面提到的大文件，普通文件，小文件定义如下：</div></pre></td></tr></table></figure></p>
<p>小于0x400的是小文件，大于0xC800000的是大文件，中间的是普通文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![img](/img\wannacry\4_0.png)</div><div class="line"></div><div class="line">上面提到的作方式具体定义如下：</div></pre></td></tr></table></figure></p>
<p>//返回0表示未作处理，或者处理未完成，需要插入链表或者不从链表中删除<br>enum FILE_OP_TYPE{<br>    FOT_NULL_0 = 0,     //0 未操作，返回1<br>    FOT_NULL_1,         //1,default 未操作，返回0<br>    FOT_DELETE_FILE_2,    //2 //删除文件，返回1<br>    FOT_ENCRYPT_WRITESRC_3, //3 改源文件，返回0<br>    FOT_ENCRYPT_NORMAL_4, //4 只加密，返回1<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">代码如下：</div><div class="line"></div><div class="line">![img](/img\wannacry\4_1.png)</div><div class="line"></div><div class="line">对加密策略做一下总结：</div><div class="line">1. 在枚举文件中，cmd=1，会对普通文件直接加密为.WNCRY，不再加入链表，大文件处理为.WNCYR，以及其他未作处理文件继续加入链表等待处理。</div><div class="line"></div><div class="line">![img](/img\wannacry\4_2.png)</div><div class="line"></div><div class="line">2. 枚举完成后，cmd从2-4，每个cmd遍历都遍历加密文件。</div><div class="line"></div><div class="line">* cmd=2，加密FILE_TYPE_DOCEX普通文件为.WNCRY（移出链表），以及FILE_TYPE_DOCEX大文件为.WNCYR。</div><div class="line">* cmd=2, 删除.WNCRYT</div><div class="line">* cmd=3, 加密链表中所有文件（移出链表）</div><div class="line">* cmd=4, 加密可能剩余链表中的文件</div><div class="line"></div><div class="line">![img](/img\wannacry\4_3.png)</div><div class="line"></div><div class="line">## 文件内容加密过程</div><div class="line"></div><div class="line">验证文件是否未加密，或者未加密完成。已完成加密，直接退出。</div><div class="line"></div><div class="line">![img](/img\wannacry\4_5.png)</div><div class="line"></div><div class="line">对于FOT_ENCRYPT_WRITESRC_3，按写打开源文件，将文件头0x10000字节内容移动到尾部，头部内容清零，写入加密文件头部数据，然后源文件移动为.WNCYR，完成退出。</div><div class="line"></div><div class="line">![img](/img\wannacry\4_4.png)</div><div class="line"></div><div class="line">对于FOT_ENCRYPT_NORMAL_4，按读打开源文件，对于普通文件进行随机值检查，满足100倍数，且文件数据小于10，那么换本次加密算法为免费解密的算法，标记，加密完成后调用回调函数写入f.wnry中。</div><div class="line"></div><div class="line">![img](/img\wannacry\4_6.png)</div><div class="line">![img](/img\wannacry\4_7.png)</div><div class="line"></div><div class="line">加密前，将文件后缀加上T变成.WNCRYT，然后创建文件。</div><div class="line"></div><div class="line">写入加密文件头部数据</div><div class="line"></div><div class="line">![img](/img\wannacry\4_8.png)</div></pre></td></tr></table></figure></p>
<p>//加密文件头部数据结构<br>struct<br>{<br>    char magic[8];//WANACRY!’<br>    int size;//0x100<br>    char key[size];//<br>    int type;//加密文件类型3,4<br>    __int64 datasize;// &lt;=0x6400000 源文件大小<br>    char data[1];//<br>}<br>```</p>
<p>对于.WNCYR文件（FOT_ENCRYPT_WRITESRC_3处理过一次），读取尾部0x10000的数据加密写入文件。</p>
<p><img src="/img\wannacry\4_9.png" alt="img"></p>
<p>然后每0x1000读取加密，写入.WNCRYT文件，循环知道所有数据加密。移动.WNCRYT为.WNCRT。</p>
<p><img src="/img\wannacry\4_10.png" alt="img"></p>
<p>对于FOT_ENCRYPT_NORMAL_4，加密完成后会将源文件加入删除链表，在删除线程中文件会被复写删除。</p>
<p>复写通过生成随机值或者一片’U’，循环写入文件，细节不再阐述（桌面我的文档目录文件目录会被复写，其他目录文件不会）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，wannacry大部分内容都分析完成，由于时间精力的关系，后续解密器就不再分析了。<br>最后说一句，现在这个时代不再适合裸奔！！！</p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/wannacry-analyze-report">https://anhkgg.github.io/wannacry-analyze-report</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00. 前言&quot;&gt;&lt;/a&gt;0x00. 前言&lt;/h1&gt;&lt;p&gt;最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。&lt;/p&gt;
&lt;p&gt;趁着这个热度，我也来跟风一把。&lt;/p&gt;
&lt;p&gt;前前后后把WannaCry详细分析了一遍。&lt;/p&gt;
&lt;p&gt;从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Security" scheme="https://anhkgg.github.io/categories/Security/"/>
    
    
      <category term="wannacry" scheme="https://anhkgg.github.io/tags/wannacry/"/>
    
      <category term="比特币病毒" scheme="https://anhkgg.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81%E7%97%85%E6%AF%92/"/>
    
      <category term="逆向分析" scheme="https://anhkgg.github.io/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="样本分析" scheme="https://anhkgg.github.io/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
      <category term="locky" scheme="https://anhkgg.github.io/tags/locky/"/>
    
  </entry>
  
  <entry>
    <title>免杀技术有一套（免杀方法大集结）(Anti-AntiVirus)</title>
    <link href="https://anhkgg.github.io/aanti-virus/"/>
    <id>https://anhkgg.github.io/aanti-virus/</id>
    <published>2017-05-22T00:07:45.000Z</published>
    <updated>2017-05-22T00:14:21.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="00-概述"><a href="#00-概述" class="headerlink" title="00. 概述"></a>00. 概述</h1><p>什么是免杀？来自百科的注解：</p>
<blockquote>
<p>免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。</p>
</blockquote>
<p>有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》</p>
<blockquote>
<p>其实我大概好像只看过目录…( ╯□╰ )</p>
</blockquote>
<p>下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。</p>
<a id="more"></a>
<h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01. 简介"></a>01. 简介</h1><p>免杀大概可以分为两种情况：</p>
<ol>
<li>二进制的免杀（无源码），只能通过通过修改asm代码／二进制数据／其他数据来完成免杀。</li>
<li>有源码的免杀，可以通过修改源代码来完成免杀，也可以结合二进制免杀的技术。</li>
</ol>
<p>免杀也可以分为这两种情况：</p>
<ol>
<li>静态文件免杀，被杀毒软件病毒库/云查杀了，也就是文件特征码在病毒库了。免杀方式可能是上面的两种方式，看情况。</li>
<li>动态行为免杀，运行中执行的某些行为被杀毒软件拦截报读。行为免杀如果没有源码就不是很好搞了。</li>
</ol>
<p>下面就静态和动态免杀来详细说说免杀的技术。</p>
<h1 id="02-静态免杀"><a href="#02-静态免杀" class="headerlink" title="02. 静态免杀"></a>02. 静态免杀</h1><p>对于静态免杀，针对的是杀毒软件的静态文件扫描，云查（病毒库）杀。</p>
<p>杀毒是提取文件一段特征码来识别病毒文件。</p>
<blockquote>
<p>能识别一个程序是一个病毒的一段不大于64字节的特征串</p>
</blockquote>
<p>那杀毒软件是怎么提取文件特征码的？</p>
<p>如果我们知道了一个文件是病毒，那么通过md5肯定可以判断一个就是这个病毒文件，那如果该病毒文件做了小小变动呢，直接md5肯定是不行了，那杀毒软件是怎么做的呢？这里有个叫做模糊哈希（<code>Fuzzy Hashing</code>）算法的东西。</p>
<blockquote>
<p>模糊哈希算法又叫基于内容分割的分片分片哈希算法（context triggered piecewise hashing, CTPH），主要用于文件的相似性比较。</p>
</blockquote>
<p>大致就可以理解为，不要把一个文件的所有内容都拿来计算hash，而通过分片，取出部分重要（不易改变）的内容进行hash计算，这样就能达到通过一个特征码找到类似的病毒变种。</p>
<p>关于模糊哈希更加详细的内容可以查看文章后面的参考文章，这里不再详述。</p>
<p>具体杀毒软件是不是通过这个算法来计算特征码的，我也不能完全肯定（纯猜测加网上一点点信息），但是根据免杀的经验可以总结出几点：</p>
<ol>
<li>特征码会有多个串组合（减少误报）</li>
<li>代码数据（肯定有）</li>
<li>会解析PE，检查附加文件数据、PE文件的资源等等</li>
</ol>
<h2 id="1-怎么找特征码"><a href="#1-怎么找特征码" class="headerlink" title="1. 怎么找特征码"></a>1. 怎么找特征码</h2><h3 id="工具查找"><a href="#工具查找" class="headerlink" title="工具查找"></a>工具查找</h3><p>常见的特征码定位工具有CCL、MYCCL。工具大致原理就是分割文件，某些分割部分填入数据(0)，如果扫描该部分不报警，则特征码在这个部分。如此反复，直到找到很短的某一段内容。不同工具之前局别是使用的分割算法不同，查找特征码的效果不同。</p>
<blockquote>
<p>目前比较常有名气的特征码定位器主要有CCL与MYCCL，他们都采用文件分块定位的办法，定位效果带有运气成份，且可能每次定位出的位置都不尽相同，这个免杀带来了困难。</p>
</blockquote>
<p>后来出来了一款新的特征码定位软件<code>VirTest</code>。下面是作者自己的介绍：</p>
<blockquote>
<p>我们可以这样假设报毒过程，如果检测文件是PE,如果在CODE位置存在 标志A,在DATA位置存在标志B,在资源位置存在标志C,同时满足这个3个条件，那么杀软就会报毒,VIRTEST工作原理就是要找到引起报毒最后一个标志，也就是假设中的标志C。</p>
<p>因此VIRTEST采用2分排除法，测试标志C所在文件中的位置，由于被杀的文件可能存在多个 类似于ABC这样的连锁条件，所以我们必须要通过一种排除机制，先要找最靠近文件前部的连锁条件，排除掉文件尾部数据，当找到第一个连锁条件后，抹掉引标志C，再恢复尾部数据，</p>
<p>然后继续测试另外的连锁条件，直到找到最后一个连锁条件，抹掉后，整个文件免杀了，则说明特征代码被定为完毕了，所以VIRTEST绝对可以精确的定位出所有的复合特征。这比文件分块定位法先进得多，更为科学。</p>
</blockquote>
<p>工具查找肯定是针对二进制文件（有源码的也编译后在检查）。</p>
<p>具体用过MYCCL（使用方法自行查找），确实比手工分割文件定位方便，也可以找到某些文件的特征码，但是有些时候可能会出现非常多非常多…的被杀文件分割，然后…崩溃了。</p>
<p>后来也用了virtest，感觉作者说的挺有道理，应该挺好用吧。然后试了试，确实感觉比MYCCL高大上多了，也可以定位到特征码，但是tmd改了之后怎么还是报呢，反正你可能会折腾很久…</p>
<h3 id="手工查找"><a href="#手工查找" class="headerlink" title="手工查找"></a>手工查找</h3><p>这里说的是针对有源码的（二进制就别想手工了…），方法非常简单。</p>
<ol>
<li>mian中屏蔽所有代码，编译，扫描。不报的话继续2，如果依然报毒，去5。</li>
<li>放开一层（可以多层、二分也可以）函数，编译，扫描。不报的话，重复2。直到定位到某个函数或者多个函数，进入3。</li>
<li>在函数内部屏蔽部分代码（二分），编译，扫描。不报，重复2。</li>
<li>直到定位某段代码（无自定义内部调用），特征码在此。</li>
<li>是不是有附加数据，或者资源存储的文件。有，单独检查该文件或者数据，方法从1开始。如果没有，那去找找PE头吧。</li>
</ol>
<p>大致流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. sub1 //未报</div><div class="line">2. sub1 sub2 //未报</div><div class="line">3. sub1 sub2 sub3 //报</div><div class="line">4. sub1 sub2 sub3(sub31) //未报</div><div class="line">5. sub1 sub2 sub3(sub31 sub32) //报</div><div class="line">6. sub1 sub2 sub3(sub31 sub32(sub321)) //报</div><div class="line">...</div><div class="line">直到找到某API调用，或者逻辑代码（没有自定义函数调用）</div></pre></td></tr></table></figure>
<p>此方法，虽然笨，但是定位特征码不会很慢，挺准确。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>别找了，直接盲免杀吧（后面具体看，有效）</p>
<h2 id="2-怎么免杀？"><a href="#2-怎么免杀？" class="headerlink" title="2. 怎么免杀？"></a>2. 怎么免杀？</h2><p>前面已经找到特征码了，怎么免杀呢？</p>
<p>其实前面已经说到了，找到特征码之后，只要改变这个特征码值得话就免杀成功。如果不需要软件正常运行，直接填零得了…开玩笑，这怎么可能。所以修改特征码还得保证软件正常功能。所以也是有讲究的。</p>
<p>常用的修改工具有，OD，C32ASM，UE，010Editor等等。</p>
<h3 id="手工修改"><a href="#手工修改" class="headerlink" title="手工修改"></a>手工修改</h3><h4 id="非源码"><a href="#非源码" class="headerlink" title="非源码"></a>非源码</h4><p><strong>1. 数据</strong></p>
<p>如果特征码定位到数据（通过IDA/OD等确认），其实不好修改，稍微不慎就会导致程序不能运行，或者影响程序运行流程或结果。</p>
<ul>
<li>字符串，如果不影响程序逻辑，可以替换大小写；如果无关紧要的数据，随意替换；等等，看情况而定。</li>
<li>整数，如果不影响结果，替换值，清零等等操作。</li>
<li>地址，基本应该不能修改，具体看情况。</li>
<li>PE头数据，根据PE结构具体来看，无用数据清零或修改，有用数据看情况修改。</li>
<li>最后，终极修改方法，找到访问数据的代码，直接修改代码访问数据的地址，数据也可以放到其他地址了，其实就如同修改源码一样修改，肯定没有修改源码那么容易（见后）。</li>
</ul>
<p>反正特征码定位到数据位置不容易修改（可以再试试后面的盲免杀）。</p>
<p><strong>2. 代码</strong></p>
<p>如果特征码定位到代码（也通过IDA/OD等确认），在不改变程序功能基础上，应用各种方法修改。</p>
<ul>
<li>等价替换汇编代码，如mov eax，0可以换成xor eax，eax，直接结果相同，二进制代码不同。</li>
<li>交换代码顺序，在不影响逻辑的情况下。</li>
<li>代码块移位，将代码块移动不用的内存位置，通过加入jmp addr跳过去执行，addr是新的代码块地址。</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>在有源码的情况下，修改的方式就更灵活了，更简单了。</p>
<ul>
<li><p>如果特征码是数据，那么修改数据位置，访问数据的代码位置等（思想类比非源码方式）。</p>
</li>
<li><p>加花指令，这是最有效也是最常用的方式，要点在于如何加话指令。</p>
</li>
</ul>
<ol>
<li>加数据计算代码，加减乘除各类组合。</li>
<li>加字符串操作代码，增加、删除、查找、替换等。</li>
<li>加多层跳转，跳转间加无效指令（不会执行的）。</li>
<li>加貌似有效的API调用，如LoadLibrary+GetProcAddr+API等。</li>
<li>等等。</li>
</ol>
<h3 id="工具免杀（盲免杀）"><a href="#工具免杀（盲免杀）" class="headerlink" title="工具免杀（盲免杀）"></a>工具免杀（盲免杀）</h3><p>在没找到有效的特征码，或者不好修改的时候，可以试试这种方式。</p>
<h4 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h4><p><strong>1. 加资源</strong></p>
<p>使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等。</p>
<p><strong>2. 替换资源</strong></p>
<p>使用ResHacker替换无用的资源（Version等）。</p>
<p><strong>3. 加签名</strong></p>
<p>使用签名伪造工具，将正常软件的签名信息加入到自己软件中。</p>
<p>几种方式可以交替重复多次进行组合使用。</p>
<h4 id="PE操作"><a href="#PE操作" class="headerlink" title="PE操作"></a>PE操作</h4><p><strong>1. PE优化</strong></p>
<p>使用PE优化工具对文件进行优化，删除0，PE头优化，附加数据等。</p>
<p><strong>2. 增加节</strong></p>
<p>增加节数据，随意加入无效数据。</p>
<h4 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h4><p>可以将加壳简单理解为：解密器/解压器+加密器/压缩器（原始代码）。</p>
<p>通过加密器/压缩器将原始代码进行加密压缩，让其特征码变化隐藏，然后组装上解密器/解压器到文件中，运行是先运行解密/解压器，将加密压缩内容解密解压，然后继续运行原始代码。</p>
<p><strong>1. 加冷门壳</strong></p>
<p>壳也有特征，知名壳都已经被分析的非常多了，杀软基本都能查这类壳，或者自动脱壳，然后进行查杀。</p>
<p>所以加冷门壳，壳特征未被分析，不能自动脱壳，可以更好隐藏原始代码，得到免杀效果。</p>
<p><strong>2. 加壳改壳</strong></p>
<p>将常用壳进行修改，让壳特征变化，也可以是杀软失效。</p>
<p>比如修改入口，区段信息修改，入口代码移位。</p>
<p>可以类比为免杀壳，上面介绍的方法都可以使用。</p>
<h1 id="03-行为动态免杀"><a href="#03-行为动态免杀" class="headerlink" title="03. 行为动态免杀"></a>03. 行为动态免杀</h1><p>杀毒软件现在都会有主防的功能，对恶意行为进行拦截提示。</p>
<p>比如这些行为：</p>
<ol>
<li>注册表操作，添加启动项，添加服务</li>
<li>文件写入、读系统文件、删除文件，移动文件</li>
<li>杀进程，创建进程</li>
<li>注入、劫持等</li>
</ol>
<h2 id="行为拦截原理"><a href="#行为拦截原理" class="headerlink" title="行为拦截原理"></a>行为拦截原理</h2><p>说白了，恶意行为都是通过API调用来完成的，可能是一个API，可能是多个APi组合。</p>
<p>杀软通过技术手段拦截这些API调用，通过策略来判断是否属于恶意行为。</p>
<p>关键点：</p>
<ol>
<li>API</li>
<li>策略（顺序，调用源，参数等等）</li>
</ol>
<p>所以后面的方法就是针对这两点做的工作。</p>
<h2 id="如何进行行为免杀呢？"><a href="#如何进行行为免杀呢？" class="headerlink" title="如何进行行为免杀呢？"></a>如何进行行为免杀呢？</h2><p>下面介绍的方式对非源码、源码都有效，但是非源码修改起来非常非常麻烦…</p>
<p><strong>1. 替换api</strong></p>
<p>使用相同功能的API进行替换，杀软不可能拦截了所有API，所以这种方式还是有效的。比如MoveFileEx替换MoveFile。</p>
<p><strong>2. 未导出api</strong></p>
<p>寻找相同功能的未导出API进行替换，杀软拦截一般是导出API，或者底层调用，寻找未导出API有一定效果。</p>
<p>寻找方法，通过分析目标API内部调用，找到内部一个或多个未导出API，来完成相同功能。</p>
<p><strong>3. 重写api</strong></p>
<p>完全重写系统API功能（通过逆向），实现自己的对应功能API，对于ring3的行为拦截非常有效。比如实现MoveFile等。</p>
<p><strong>4. api+5</strong></p>
<p>ring3的API拦截通过是挂钩API头几个字节内容，然后进入杀软自己函数进行参数检查之类的。</p>
<p>那么如果调用API时，跳过头部几字节，就可以避开这种拦截方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__API:</div><div class="line">1 push ebp;</div><div class="line">2 mov ebp, esp;</div><div class="line">3 mov edi, edi;</div><div class="line">4 ...</div></pre></td></tr></table></figure>
<p>调用时，不适用1地址，而使用4地址，然后自己函数内部还原跳过几字节的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__API_MY:</div><div class="line">push ebp;</div><div class="line">mov ebp, esp;</div><div class="line">mov edi, edi;</div><div class="line">call 4</div></pre></td></tr></table></figure>
<p><strong>5. 底层api</strong></p>
<p>该方法类似于2和3，杀软拦截API可能更加高层（语义更清楚），那就可以找更底层API进行调用，绕过拦截，比如使用NT函数。</p>
<p>或者通过DeviceIoControl调用驱动功能来完成API功能。</p>
<p>模拟系统调用。</p>
<p><strong>6. 合理替换调用顺序</strong></p>
<p>有时拦截行为是通过多个API组合来完成的，所以合理替换顺序，绕过杀软拦截策略，也可以绕过改行为拦截。</p>
<p>比如，先创建服务，再将服务对应文件拷贝过去。</p>
<p><strong>7. 绕过调用源</strong></p>
<p>通过调用其它进行功能来完成API的功能。比较经典的如，通过rundll32.exe来完成dll加载，通过COM来操作文件等等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方法大概就总结到这，要更好的完成免杀，需要各种方式进行合理灵活组合变化，或者挖掘更多的方法。</p>
<h2 id="注意-技巧"><a href="#注意-技巧" class="headerlink" title="注意/技巧"></a>注意/技巧</h2><ol>
<li>非源码修改时，通过OD能够更好的完成，配合IDA进行观察，具体参考OD/IDA使用教程。</li>
<li>源码免杀加花，要灵活多变，不拘于形式。</li>
<li>行为免杀多尝试，猜出杀软拦截策略，能够更有效的找到绕过方式。</li>
</ol>
<blockquote>
<p>道高一尺，魔高一丈</p>
</blockquote>
<p>各路大神有更多的技巧和方式，请不吝赐教，相互交流。</p>
<p>我们不做坏事，但是可以了解做坏事的手段，更好的破坏防御这些手段。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/cwqbuptcwqbupt/article/details/7591818" target="_blank" rel="external">模糊哈希算法的原理与应用</a></li>
<li><a href="http://www.freebuf.com/sectool/40580.html" target="_blank" rel="external">VirTest5.0特征码定位器（开源）</a></li>
<li><a href="http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO" target="_blank" rel="external">http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO</a></li>
</ol>
<p>转载请注明出处：<a href="https://anhkgg.github.io/aanti-virus">https://anhkgg.github.io/aanti-virus</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;00-概述&quot;&gt;&lt;a href=&quot;#00-概述&quot; class=&quot;headerlink&quot; title=&quot;00. 概述&quot;&gt;&lt;/a&gt;00. 概述&lt;/h1&gt;&lt;p&gt;什么是免杀？来自百科的注解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实我大概好像只看过目录…( ╯□╰ )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="Anti-AntiVirus" scheme="https://anhkgg.github.io/tags/Anti-AntiVirus/"/>
    
      <category term="免杀" scheme="https://anhkgg.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
      <category term="AntiVirus" scheme="https://anhkgg.github.io/tags/AntiVirus/"/>
    
      <category term="杀毒软件" scheme="https://anhkgg.github.io/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>微信(WeChat)电脑端多开研究+源码</title>
    <link href="https://anhkgg.github.io/wechat-multi-pc/"/>
    <id>https://anhkgg.github.io/wechat-multi-pc/</id>
    <published>2017-05-14T07:07:51.000Z</published>
    <updated>2017-05-16T15:01:04.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>不知道大家有没有多个微信号，我反正有一两三个。</p>
<p>现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。</p>
<p>哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个…</p>
<p>不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！</p>
<a id="more"></a>
<h1 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h1><p>了解过单实例的同学，应该都知道大概是怎么实现的单开。</p>
<p>简单说下，大都通过判断Mutex、Event、File等等是否已经存在，存在则退出当前开启进程（说明已经有一个进程了），这样也就是单实例了。</p>
<p>那只要找到微信是通过什么标志来实现单实例的，然后干掉这个标志即可。</p>
<p>然后…基于这个思路，我们上工具。</p>
<p>使用procexp找到微信进程，然后翻了一遍句柄。</p>
<p>找到疑是的一段句柄。</p>
<p><img src="/img/webchat.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\Sessions\1\BaseNamedObjects\_WeChat_App_Instance_Identity_Mutex_Name</div><div class="line">\Sessions\1\BaseNamedObjects\WeChat_GlobalConfig_Multi_Process_Mutex</div></pre></td></tr></table></figure>
<p>感觉这两个都像，不管了，上pchunter，kill掉句柄试一下。</p>
<p>经过尝试，发现<code>_WeChat_App_Instance_Identity_Mutex_Name</code>是单实例标志（kill句柄后可以开第二个客户端），<code>WeChat_GlobalConfig_Multi_Process_Mutex</code>没用。</p>
<p>既然如此，那开始码代码吧。</p>
<h1 id="0x02-代码"><a href="#0x02-代码" class="headerlink" title="0x02 代码"></a>0x02 代码</h1><p>可能的方案：</p>
<ol>
<li>找微信判断标识的代码位置，然后直接patch掉，或者整个dll进去patch。然后大致去翻了一下，貌似代码在wechatwin.dll，然后加了vmp壳，所以就不折腾这个了。</li>
<li>直接通过代码kill掉这个Mutex的句柄（类似Pchunter操作），然后就可以开启第二个实例了，貌似明显更有优势啊。</li>
<li>额，如果觉得无所谓，每次开之前用pchunter关一次句柄也行，下面就不用看了…</li>
</ol>
<p>这里选择第二个方案，开始代码。</p>
<p>流程：</p>
<ol>
<li>枚举句柄，找到_WeChat_App_Instance_Identity_Mutex_Name的mutant</li>
<li>duplicate句柄到本进程，然后close</li>
<li>启动微信</li>
</ol>
<p>下面是主要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//步骤1和2的代码</div><div class="line">//获取到微信所有进程句柄</div><div class="line">DWORD Num = GetProcIds(L&quot;WeChat.exe&quot;, Pids);</div><div class="line">...</div><div class="line"></div><div class="line">Status = ZwQuerySystemInformation(SystemHandleInformation, pbuffer, 0x1000, &amp;dwSize);</div><div class="line"></div><div class="line">PSYSTEM_HANDLE_INFORMATION1 pHandleInfo = (PSYSTEM_HANDLE_INFORMATION1)pbuffer;</div><div class="line"></div><div class="line">	for(nIndex = 0; nIndex &lt; pHandleInfo-&gt;NumberOfHandles; nIndex++)</div><div class="line">	&#123;</div><div class="line">	    //句柄在Pids中，就是微信进程的句柄信息</div><div class="line">		if(IsTargetPid(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, Pids, Num))</div><div class="line">		&#123;</div><div class="line">		    HANDLE hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, </div><div class="line">						(HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue,</div><div class="line">						DUPLICATE_SAME_ACCESS</div><div class="line">						);</div><div class="line">						</div><div class="line">			//对象名</div><div class="line">			Status = NtQueryObject(hHandle, ObjectNameInformation, szName, 512, &amp;dwFlags);</div><div class="line">			//对象类型名</div><div class="line">			Status = NtQueryObject(hHandle,  ObjectTypeInformation, szType, 128, &amp;dwFlags);</div><div class="line">			</div><div class="line">			//找到微信的标志</div><div class="line">			if (0 == wcscmp(TypName, L&quot;Mutant&quot;))</div><div class="line">			&#123;</div><div class="line">				if (wcsstr(Name, L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;))</div><div class="line">				&#123;</div><div class="line">				    </div><div class="line">				    //DUPLICATE_CLOSE_SOURCE标志很重要，不明白的查一查</div><div class="line">    				hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, </div><div class="line">						(HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue,</div><div class="line">						DUPLICATE_CLOSE_SOURCE</div><div class="line">						);</div><div class="line">					if(hHandle)</div><div class="line">					&#123;</div><div class="line">						printf(&quot;+ Patch wechat success!\n&quot;);</div><div class="line">						CloseHandle(hHandle);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">步骤3的代码</div><div class="line"></div><div class="line">//通过注册表找到微信安装目录</div><div class="line">if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, L&quot;Software\\Tencent\\WeChat&quot;, &amp;hKey))</div><div class="line">&#123;</div><div class="line">	return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD Type = REG_SZ;</div><div class="line">WCHAR Path[MAX_PATH] = &#123;0&#125;;</div><div class="line">DWORD cbData = MAX_PATH*sizeof(WCHAR);</div><div class="line">if(ERROR_SUCCESS != RegQueryValueEx(hKey, L&quot;InstallPath&quot;, 0, &amp;Type, (LPBYTE)Path, &amp;cbData))</div><div class="line">&#123;</div><div class="line">	goto __exit;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PathAppend(Path, L&quot;WeChat.exe&quot;);</div><div class="line"></div><div class="line">//启动微信客户端</div><div class="line">ShellExecute(NULL, L&quot;Open&quot;, Path, NULL, NULL, SW_SHOW);</div></pre></td></tr></table></figure>
<p>代码就这样，有注释，就不再啰嗦。</p>
<p>完整代码，请看后面的地址。</p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>一个小玩意，供大家一笑。</p>
<p>编译好的可执行文件：</p>
<p><a href="https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe" target="_blank" rel="external">https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe</a></p>
<p>源码地址：</p>
<p><a href="https://github.com/anhkgg/multi_wechat_pc" target="_blank" rel="external">https://github.com/anhkgg/multi_wechat_pc</a></p>
<p>博客原文：</p>
<p><a href="https://anhkgg.github.io/wechat-multi-pc">https://anhkgg.github.io/wechat-multi-pc</a></p>
<p>转载请注明出处：<a href="https://anhkgg.github.io/wechat-multi-pc">https://anhkgg.github.io/wechat-multi-pc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;不知道大家有没有多个微信号，我反正有一两三个。&lt;/p&gt;
&lt;p&gt;现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。&lt;/p&gt;
&lt;p&gt;哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个…&lt;/p&gt;
&lt;p&gt;不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="wechat" scheme="https://anhkgg.github.io/tags/wechat/"/>
    
      <category term="handle" scheme="https://anhkgg.github.io/tags/handle/"/>
    
      <category term="patch" scheme="https://anhkgg.github.io/tags/patch/"/>
    
  </entry>
  
  <entry>
    <title>让代码飞出一段钢琴曲(freepiano小助手)</title>
    <link href="https://anhkgg.github.io/coding-piano-hook/"/>
    <id>https://anhkgg.github.io/coding-piano-hook/</id>
    <published>2017-05-01T07:11:42.000Z</published>
    <updated>2017-05-01T07:27:41.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>突然想玩一下键盘弹曲子，就找到了<a href="http://freepiano.tiwb.com/cn/" target="_blank" rel="external">freepiano</a>，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~</p>
<p>玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~</p>
<p>说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎</p>
<p>突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~</p>
<p>有了想法，就开整！！！</p>
<a id="more"></a>
<p>有下面几点问题：</p>
<ol>
<li>freepiano必须是激活窗口下，才能接受键盘输入</li>
<li>我要在写代码时，让freepiano响应按键，就需要全局劫持键盘输入了</li>
<li>怎么给freepiano通知，我按下了什么呢？</li>
</ol>
<p>忘了说，freepiano长这样：<br><img src="/img/freepiano_1.png" alt="img"></p>
<h1 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h1><p>先简单整理下思路：</p>
<ol>
<li>首先肯定是弄个键盘钩子难道全局的所有键盘输入，暂定WH_KEYBOARD</li>
<li>怎么让钩子执行？弄个exe，把freepiano再启动起来，感觉麻烦，然后就想让freepiano加载我的模块吧，简单确认了一下，可行（后面具体描述）</li>
<li>劫持到键盘输入之后，通过PostMessage给freepiano发送键盘消息，模拟WM_KEYDOWN/WM_KEYUP</li>
</ol>
<h2 id="1-加载我的模块"><a href="#1-加载我的模块" class="headerlink" title="1. 加载我的模块"></a>1. 加载我的模块</h2><p>首先想到的就是DLL劫持和修改freepiano的导入表，后者不够优雅，果断要选择dll劫持。</p>
<p>然后就用depends看了下freepiano的导入信息，发现几个可以劫持的（dsound.dll，d3d9.dll等），简单代码确认了一下，freepiano可以劫持这两个模块，选择了d3d9.dll（函数少）。</p>
<p><img src="/img/freepiano_2.png" alt="img"></p>
<p>然后偷懒用了aheadlib导出了d3d9.dll的导出函数信息，简单方便，飞快得就搞定了劫持。</p>
<p>代码很简单，就贴一点（都不需要手写）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 导出函数</div><div class="line">#pragma comment(linker, &quot;/EXPORT:Direct3DShaderValidatorCreate9=_AheadLib_Direct3DShaderValidatorCreate9,@1&quot;)</div><div class="line">#pragma comment(linker, &quot;/EXPORT:PSGPError=_AheadLib_PSGPError,@2&quot;)</div><div class="line">#pragma comment(linker, &quot;/EXPORT:PSGPSampleTexture=_AheadLib_PSGPSampleTexture,@3&quot;)</div><div class="line">...</div><div class="line">// 导出函数</div><div class="line">ALCDECL AheadLib_Direct3DShaderValidatorCreate9(void)</div><div class="line">&#123;</div><div class="line">	// 保存返回地址</div><div class="line">	__asm POP m_dwReturn[0 * TYPE long];</div><div class="line"></div><div class="line">	// 调用原始函数</div><div class="line">	GetAddress(&quot;Direct3DShaderValidatorCreate9&quot;)();</div><div class="line"></div><div class="line">	// 转跳到返回地址</div><div class="line">	__asm JMP m_dwReturn[0 * TYPE long];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一试，OK，模块起来了，freepiano正常工作。</p>
<p><img src="/img/freepiano_3.png" alt="img">)</p>
<h2 id="2-安装钩子"><a href="#2-安装钩子" class="headerlink" title="2. 安装钩子"></a>2. 安装钩子</h2><p>选择了安装全局WH_KEYBOARD钩子，这个代码网上也太多了，就不细说了，看看就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//安装钩子</div><div class="line">BOOL Hook(HMODULE hMod)</div><div class="line">&#123;</div><div class="line">	g_Hook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, hMod, 0);</div><div class="line">	return g_Hook?TRUE:FALSE;</div><div class="line">&#125;</div><div class="line">//卸载钩子</div><div class="line">VOID Unhook()</div><div class="line">&#123;</div><div class="line">	if(g_Hook)</div><div class="line">	&#123;</div><div class="line">		UnhookWindowsHookEx(g_Hook);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//钩子函数，劫持键盘消息</div><div class="line">LRESULT CALLBACK KeyboardProc(  int code,       // hook code</div><div class="line">							  WPARAM wParam,  // virtual-key code</div><div class="line">							  LPARAM lParam   // keystroke-message information</div><div class="line">							  )</div><div class="line">&#123;	</div><div class="line">	if(code == HC_ACTION)</div><div class="line">	&#123;</div><div class="line">		SendKeyMsg(wParam, lParam);</div><div class="line">	&#125;</div><div class="line">	return CallNextHookEx(g_Hook, code, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-发送按键信息给freepiano"><a href="#3-发送按键信息给freepiano" class="headerlink" title="3. 发送按键信息给freepiano"></a>3. 发送按键信息给freepiano</h2><p>首先想到的就是在钩子函数里给freepiano发送WM_KEYDOWN/WM_KEYUP消息就行了。</p>
<p>先找到freepiano的窗口，spy++上，找到窗口标题和类型信息，然后代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HWND hwnd = FindWindow(&quot;FreePianoMainWindow&quot;, &quot;Wispow Freepiano 2&quot;);</div><div class="line">if(hwnd == NULL)</div><div class="line">&#123;</div><div class="line">	hwnd =  FindWindow(&quot;FreePianoMainWindow&quot;, NULL);</div><div class="line">	if(hwnd == NULL)</div><div class="line">	&#123;</div><div class="line">		hwnd =  FindWindow(NULL, &quot;Wispow Freepiano 2&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后就是发消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if(hwnd)</div><div class="line">&#123;</div><div class="line">	SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);</div><div class="line">	if(keydown)</div><div class="line">	&#123;</div><div class="line">		keydown = false;</div><div class="line">		PostMessage(hwnd, WM_KEYDOWN, wParam, lParam);</div><div class="line">	&#125;else</div><div class="line">	&#123;</div><div class="line">		keydown = true;</div><div class="line">		PostMessage(hwnd, WM_KEYUP, wParam, lParam);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试，失败了，没有预想的效果。</p>
<p>分析原因：</p>
<ol>
<li>Post发送消息失败。但是通过spy++抓消息看到freepiano是收到了消息的。那就不是这个原因。</li>
<li>freepiano校验了窗口是否激活？然后就用上面每次置顶试了一下，依然不行。</li>
<li>freepiano使用了GetKeyState之类的函数检查按键状态，通过ida简单看了一下导入表，没有相关函数（没有深究是否显示导入了）。</li>
<li>用ida看了下freepiano的窗口消息处理，看是否有什么过滤</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">v7.lpfnWndProc = (WNDPROC)xxx_main_wndproc_41D070; //窗口响应函数</div><div class="line">v7.cbClsExtra = 0;</div><div class="line">v7.cbWndExtra = 0;</div><div class="line">v7.hInstance = GetModuleHandleA(0);</div><div class="line">v7.hIcon = LoadIconA(v1, (LPCSTR)0xA);</div><div class="line">v7.hCursor = 0;</div><div class="line">v7.hbrBackground = 0;</div><div class="line">v7.lpszMenuName = 0;</div><div class="line">v7.lpszClassName = &quot;FreePianoMainWindow&quot;;</div></pre></td></tr></table></figure>
<p>然后发现居然没有对WM_KEYDOWN/WM_KEYUP/WM_CHAR之类的消息进行处理，那是怎么接受的按键信息</p>
<p>继续用ida看是否有钩子之类的处理，果然，导入表中明晃晃的SetWindowsHookEx，进入一看，一个WM_KEYBOARD_LL局部钩子</p>
<p><img src="/img/freepiano_4.png" alt="img"></p>
<p>进钩子函数一下，各种按键状态记录的处理，不深究了。基本确认他使用这种方式来接受按键信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">v6 = (unsigned __int8)byte_4F6DC8[scanCode];</div><div class="line"> if ( (unsigned int)(v6 - 1) &gt; 0x6A )</div><div class="line">   goto LABEL_23;</div><div class="line"> if ( (unsigned __int8)byte_4F6ED0[v6] != pressed_0 )</div><div class="line"> &#123;</div><div class="line">   byte_4F6ED0[v6] = pressed_0;</div><div class="line">   sub_449B20(v6, pressed_0 != 0);</div><div class="line"> &#125;</div><div class="line"> if ( (_BYTE)dword_4F6DC0</div><div class="line">   || BYTE1(dword_4F6DC0) &amp;&amp; (v6 == &apos;D&apos; || v6 == &apos;H&apos;)</div><div class="line">   || BYTE2(dword_4F6DC0) &amp;&amp; (byte_4F6F15 || byte_4F6F17) &amp;&amp; v6 == 28 )</div><div class="line">   result = 1;</div><div class="line"> else</div></pre></td></tr></table></figure>
<h2 id="4-改变策略"><a href="#4-改变策略" class="headerlink" title="4. 改变策略"></a>4. 改变策略</h2><p>那就不能直接PostMessage发送消息了。</p>
<p>修改我的钩子为WM_KEYBOARD_LL全局键盘钩子，消息和freepiano完全一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_Hook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, hMod, 0);</div></pre></td></tr></table></figure>
<p>钩子函数通过WM_COPYDATA打包数据，发送给freepiano</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK LowLevelKeyboardProc(  int nCode,     // hook code</div><div class="line">									  WPARAM wParam, // message identifier  </div><div class="line">									  LPARAM lParam  // message data</div><div class="line">									  )</div><div class="line">&#123;</div><div class="line">	COPYDATASTRUCT CopyData = &#123;0&#125;;</div><div class="line">	KeyboardLL_Msg Msg = &#123;0&#125;;</div><div class="line"></div><div class="line">	Msg.nCode = nCode;</div><div class="line">	Msg.wParam = wParam;</div><div class="line">	memcpy(&amp;Msg.lParam, (char*)lParam, sizeof(KBDLLHOOKSTRUCT));</div><div class="line"></div><div class="line">	CopyData.cbData = sizeof(KeyboardLL_Msg);</div><div class="line">	CopyData.dwData = 0;</div><div class="line">	CopyData.lpData = &amp;Msg;</div><div class="line"></div><div class="line">	HWND hwnd = FindFreepiano();</div><div class="line">	if(hwnd)</div><div class="line">	&#123;</div><div class="line">		BOOL ret = SendMessage(hwnd, WM_COPYDATA, (WPARAM)hwnd, (LPARAM)&amp;CopyData);</div><div class="line">	&#125;</div><div class="line">	return CallNextHookEx(g_Hook, nCode, wParam, lParam);</div><div class="line">&#125;</div><div class="line">typedef struct _KeyboardLL_Msg</div><div class="line">&#123;</div><div class="line">	int nCode;</div><div class="line">	WPARAM wParam;</div><div class="line">	KBDLLHOOKSTRUCT lParam;</div><div class="line">&#125;KeyboardLL_Msg, *PKeyboardLL_Msg;</div></pre></td></tr></table></figure>
<p>通过SetWindowLong挂钩freepiano的窗口响应函数，增加处理WM_COPYDATA，来接受全局键盘信息，找到freepiano的钩子函数地址A，然后接受到WM_COPYDATA之后，直接调用A，把键盘信息给freepiano</p>
<p>通过一个线程，循环查找freepianp窗口（可能还没起来），然后hook窗口响应函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void HookWinProc()</div><div class="line">&#123;</div><div class="line">	while(1)</div><div class="line">	&#123;</div><div class="line">		HWND hwnd = FindFreepiano();</div><div class="line">		if(hwnd)</div><div class="line">		&#123;</div><div class="line">			g_WndProc = (pfn_WindProc)GetWindowLong(hwnd, GWL_WNDPROC);</div><div class="line">			if(g_WndProc)</div><div class="line">			&#123;</div><div class="line">				SetWindowLong(hwnd, GWL_WNDPROC, (LONG)fakeWindowProc);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		Sleep(10);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自己的函数中加入对WM_COPYDATA的消息处理，调用freepiano的钩子函数g_LowLevelKeyboardProc发键盘消息过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LRESULT WINAPI fakeWindowProc(</div><div class="line">					   HWND hWnd,              // handle to window</div><div class="line">					   UINT Msg,               // message</div><div class="line">					   WPARAM wParam,          // first message parameter</div><div class="line">					   LPARAM lParam           // second message parameter</div><div class="line">					   )</div><div class="line">&#123;</div><div class="line">	if(Msg == WM_COPYDATA)</div><div class="line">	&#123;</div><div class="line">		COPYDATASTRUCT* CopyData = (COPYDATASTRUCT*)lParam;	</div><div class="line">		//if(CopyData-&gt;cbData == sizeof(KeyboardLL_Msg))</div><div class="line">		&#123;</div><div class="line">			KeyboardLL_Msg* Msg = (KeyboardLL_Msg*)CopyData-&gt;lpData;</div><div class="line">			g_LowLevelKeyboardProc(Msg-&gt;nCode, Msg-&gt;wParam, (LPARAM)&amp;Msg-&gt;lParam);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return g_WndProc(hWnd, Msg, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>g_LowLevelKeyboardProc地址这里使用硬编码，图方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HMODULE hExe = GetModuleHandle(NULL);</div><div class="line">g_LowLevelKeyboardProc = (pfn_LowLevelKeyboardProc)((DWORD)hExe + (DWORD)g_LowLevelKeyboardProc);</div></pre></td></tr></table></figure></p>
<p>功能到这里基本搞定。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>测试通过。</p>
<p>手指立马不受控制的在编辑器里、浏览器、文件浏览器里各种按键，然后耳边响起了悠扬（忽略乱打的节奏的话）的钢琴声~~</p>
<p>可能的优化：</p>
<ol>
<li>加入进程名单控制，不想在某些进程中听到琴声</li>
<li>代码优化~~</li>
</ol>
<p>有兴趣的同学可以去折腾，我这里就不继续了~~</p>
<p>转载请注明出处：<a href="http://anhkgg.github.io/coding-piano-hook">http://anhkgg.github.io/coding-piano-hook</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;突然想玩一下键盘弹曲子，就找到了&lt;a href=&quot;http://freepiano.tiwb.com/cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;freepiano&lt;/a&gt;，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~&lt;/p&gt;
&lt;p&gt;玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~&lt;/p&gt;
&lt;p&gt;说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎&lt;/p&gt;
&lt;p&gt;突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~&lt;/p&gt;
&lt;p&gt;有了想法，就开整！！！&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="WM_KEYBOARD_LL" scheme="https://anhkgg.github.io/tags/WM-KEYBOARD-LL/"/>
    
      <category term="HOOK" scheme="https://anhkgg.github.io/tags/HOOK/"/>
    
      <category term="freepiano" scheme="https://anhkgg.github.io/tags/freepiano/"/>
    
      <category term="inject" scheme="https://anhkgg.github.io/tags/inject/"/>
    
  </entry>
  
  <entry>
    <title>小Win，点一份APC（Apc机制详解）（一）</title>
    <link href="https://anhkgg.github.io/win-apc-analyze1/"/>
    <id>https://anhkgg.github.io/win-apc-analyze1/</id>
    <published>2017-04-28T10:20:47.000Z</published>
    <updated>2017-04-28T14:11:51.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻开"><a href="#翻开" class="headerlink" title="翻开"></a>翻开</h1><p>翻开小Win的菜单，APC赫然在目…</p>
<p>做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！</p>
<p>吃了可以做很多事情…</p>
<ul>
<li>APC注入</li>
<li>APC注入</li>
<li>APC注入</li>
<li>…</li>
</ul>
<a id="more"></a>
<blockquote>
<p>细节来自于<code>ReactOS</code>源码分析。</p>
<p>如果对这个发神经的文风有任何不适，请谅解，因为我确实神经了</p>
</blockquote>
<h1 id="来一份APC"><a href="#来一份APC" class="headerlink" title="来一份APC"></a>来一份APC</h1><h2 id="ring3这么做的"><a href="#ring3这么做的" class="headerlink" title="ring3这么做的"></a>ring3这么做的</h2><p>点APC的正确姿势是使用<code>QueueUserApc</code>，不走寻常路的也可以使用<code>NtQueueApcThread</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">DWORD WINAPI QueueUserApc(PARCFUNC pfnApc, HANDLE hThread, ULONG_PTR dwData);</div><div class="line">&#123;</div><div class="line">    NtQueueApcThread(hThread, IntCallUserApc, pfnApc, dwData, NULL);    </div><div class="line">&#125;</div><div class="line"></div><div class="line">NTSTATUS NTAPI NtQueueApcThread(IN HANDLE ThreadHandle, </div><div class="line">                                IN PKNORMAL_ROUTINUE ApcRoutine,</div><div class="line">                                IN PVOID NormalContext, //pfnApc</div><div class="line">                                IN PVOID SystemArgument1, //dwData</div><div class="line">                                IN PVOID SystemArgument2</div><div class="line">                                );</div></pre></td></tr></table></figure>
<p>也就是QueueUserApc内部是NtQueueApcThread做的，两者区别不大，当然，使用后者可以字节加点调料（不使用IntCallUserApc、换成自己的函数，函数参数也可以有三个了，而PARCFUNC只有一个参数）。</p>
<p>小Win默认是通过统一的接口IntCallUserApc来调用的顾客指定的Apc函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void CALLBACK </div><div class="line">IntCallUserApc(PVOID Function, PVOID dwData, PVOID Arg3)</div><div class="line">&#123;</div><div class="line">    ((PAPCFUNC)Function)(dwData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ring0这么做的"><a href="#ring0这么做的" class="headerlink" title="ring0这么做的"></a>ring0这么做的</h2><p>NtQueueApcThread经过系统调用进入到ring0，一般人是看不到了…，我也是一般人来着，下面努力变成二班的…。</p>
<h3 id="1-创建APC对象"><a href="#1-创建APC对象" class="headerlink" title="1. 创建APC对象"></a>1. 创建APC对象</h3><p>进了NtQueueApcThread，先通过KeInitializeApc初始化一个Apc对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* Initialize the APC */</div><div class="line">KeInitializeApc(Apc,</div><div class="line">                &amp;Thread-&gt;Tcb, //KTHREAD</div><div class="line">                OriginalApcEnvironment,</div><div class="line">                PspQueueApcSpecialApc,</div><div class="line">                NULL,</div><div class="line">                ApcRoutine,</div><div class="line">                UserMode,</div><div class="line">                NormalContext);</div></pre></td></tr></table></figure></p>
<p>APC对象结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct _KAPC &#123;</div><div class="line">  UCHAR Type; //类型ApcObject</div><div class="line">  UCHAR SpareByte0;</div><div class="line">  UCHAR Size; //APC结构体大小</div><div class="line">  UCHAR SpareByte1;</div><div class="line">  ULONG SpareLong0;</div><div class="line">  struct _KTHREAD *Thread; //当前线程的KTHREAD</div><div class="line">  LIST_ENTRY ApcListEntry; //当前线程的APC链表</div><div class="line">  PKKERNEL_ROUTINE KernelRoutine; //</div><div class="line">  PKRUNDOWN_ROUTINE RundownRoutine; //</div><div class="line">  PKNORMAL_ROUTINE NormalRoutine; //</div><div class="line">  PVOID NormalContext; //用户定义的Apc函数</div><div class="line">  PVOID SystemArgument1; //用户Apc函数的参数</div><div class="line">  PVOID SystemArgument2;//</div><div class="line">  CCHAR ApcStateIndex; //Apc状态</div><div class="line">  KPROCESSOR_MODE ApcMode; //Apc所处的Mode，UserMode/KernelMode</div><div class="line">  BOOLEAN Inserted;     //是否已经被插入队列</div><div class="line">&#125; KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;</div></pre></td></tr></table></figure></p>
<p>根据KeInitializeApc传入参数，Apc被赋值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Apc-&gt;KernelRoutine = PspQueueApcSpecialApc;</div><div class="line">Apc-&gt;RundownRoutine = NULL;</div><div class="line">Apc-&gt;NormalRoutine = ApcRoutine;//如果使用QueueUserApc，其实就是IntCallUserApc</div><div class="line">Apc-&gt;NormalContext = NormalContext;//pfnApc;//用户指定的Apc函数</div><div class="line">Apc-&gt;Type = ApcObject;</div><div class="line"></div><div class="line">//如果参数指定的是CurrentApcEnvironment，直接赋值Thread-&gt;ApcStateIndex</div><div class="line">Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</div><div class="line">//不是则</div><div class="line">Apc-&gt;ApcStateIndex = OriginalApcEnvironment;//</div><div class="line"></div><div class="line">//如果参数ApcRoutine不是NULL</div><div class="line">Apc-&gt;ApcMode = Mode;</div><div class="line">Apc-&gt;NormalContext = Context;</div><div class="line">//是NULL</div><div class="line">Apc-&gt;ApcMode = KernelMode;</div><div class="line">Apc-&gt;NormalContext = NULL;</div><div class="line"></div><div class="line">Apc-&gt;Inserted = False;</div></pre></td></tr></table></figure>
<p>其中关于ApcStateIndex有4中值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// APC Environment Types</div><div class="line">//</div><div class="line">typedef enum _KAPC_ENVIRONMENT</div><div class="line">&#123;</div><div class="line">    OriginalApcEnvironment,//0</div><div class="line">    AttachedApcEnvironment,//1</div><div class="line">    CurrentApcEnvironment,//2</div><div class="line">    InsertApcEnvironment</div><div class="line">&#125; KAPC_ENVIRONMENT;</div></pre></td></tr></table></figure></p>
<p>Apc-&gt;KernelRoutine总是有值的，被赋值为PspQueueApcSpecialApc，用于Apc结束时候释放Apc对象内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">VOID</div><div class="line">NTAPI</div><div class="line">PspQueueApcSpecialApc(IN PKAPC Apc,</div><div class="line">                      IN OUT PKNORMAL_ROUTINE* NormalRoutine,</div><div class="line">                      IN OUT PVOID* NormalContext,</div><div class="line">                      IN OUT PVOID* SystemArgument1,</div><div class="line">                      IN OUT PVOID* SystemArgument2)</div><div class="line">&#123;</div><div class="line">    /* Free the APC and do nothing else */</div><div class="line">    ExFreePool(Apc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-插入APC队列"><a href="#2-插入APC队列" class="headerlink" title="2. 插入APC队列"></a>2. 插入APC队列</h3><p>通过<code>KeInsertQueueApc</code>插入队列，在队列中等待被上菜…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">KeInsertQueueApc(Apc,</div><div class="line">                          SystemArgument1,</div><div class="line">                          SystemArgument2,</div><div class="line">                          IO_NO_INCREMENT))</div></pre></td></tr></table></figure>
<ol>
<li>确认Apc未被插入，Thread-&gt;ApcQueueable为真</li>
<li>Apc-&gt;Inserted = True</li>
<li>然后通过<code>KiInsertQueueApc</code>插入队列，可能通过软中断或者唤醒线程得到执行Apc的机会</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">VOID</div><div class="line">FASTCALL</div><div class="line">KiInsertQueueApc(IN PKAPC Apc,</div><div class="line">                 IN KPRIORITY PriorityBoost)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (Apc-&gt;ApcStateIndex == InsertApcEnvironment)</div><div class="line">    &#123;</div><div class="line">        Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //PKAPC_STATE ApcStatePointer[2];//说明ApcStateIndex只能是</div><div class="line">    //OriginalApcEnvironment,//0</div><div class="line">    //AttachedApcEnvironment,//1</div><div class="line">    //从Thread的ApcStatePointer取出对应的ApcState</div><div class="line">    ApcState = Thread-&gt;ApcStatePointer[(UCHAR)Apc-&gt;ApcStateIndex];</div><div class="line">    ApcMode = Apc-&gt;ApcMode;</div><div class="line">    </div><div class="line">    ASSERT(Apc-&gt;Inserted == TRUE);</div><div class="line">    </div><div class="line">    /* 插入队列的三种方式:</div><div class="line">     * 1) Kernel APC with Normal Routine or User APC = Put it at the end of the List</div><div class="line">     * 2) User APC which is PsExitSpecialApc = Put it at the front of the List</div><div class="line">     * 3) Kernel APC without Normal Routine = Put it at the end of the No-Normal Routine Kernel APC list</div><div class="line">     */</div><div class="line">    //PsExitSpecialApc</div><div class="line">    </div><div class="line">    if (Thread-&gt;ApcStateIndex == Apc-&gt;ApcStateIndex)</div><div class="line">    &#123;</div><div class="line">        if(当前线程 ) &#123;</div><div class="line">            if(KernelMode) &#123;</div><div class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</div><div class="line">                if (!Thread-&gt;SpecialApcDisable)</div><div class="line">                    &#123;</div><div class="line">                        //中断线程当前执行六？？</div><div class="line">                        /* They&apos;re not, so request the interrupt */</div><div class="line">                        HalRequestSoftwareInterrupt(APC_LEVEL);</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            if(KernelMode) &#123;</div><div class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</div><div class="line">                if (Thread-&gt;State == Running) HalRequestSoftwareInterrupt(APC_LEVEL);</div><div class="line">                else if(一堆条件)&#123;</div><div class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125; else &#123;</div><div class="line">                if ((Thread-&gt;State == Waiting) &amp;&amp;</div><div class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</div><div class="line">                     ((Thread-&gt;Alertable) || //</div><div class="line">                      (Thread-&gt;ApcState.UserApcPending)))</div><div class="line">                &#123;</div><div class="line">                    /* Set user-mode APC pending */</div><div class="line">                    Thread-&gt;ApcState.UserApcPending = TRUE;</div><div class="line">                    Status = STATUS_USER_APC;</div><div class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先不管Apc是怎么得到执行的，来看看KAPC_STATE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct _KAPC_STATE</div><div class="line">&#123;</div><div class="line">    LIST_ENTRY ApcListHead[2];//UserMode/KernelMode的两个链表</div><div class="line">    struct _KPROCESS *Process;</div><div class="line">    BOOLEAN KernelApcInProgress;</div><div class="line">    BOOLEAN KernelApcPending; //等待执行</div><div class="line">    BOOLEAN UserApcPending; //等待执行</div><div class="line">&#125; KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;</div></pre></td></tr></table></figure>
<p>其中ApcListHead保存了线程的两个Apc链表，分别对应UserMode和KernelMode。</p>
<p>Thread-&gt;ApcState表示当前需要执行的ApcState，可能是挂靠进程的</p>
<p>Thread-&gt;SavedApcState表示挂靠后保存的当前线程的ApcState，</p>
<p>KTHREAD的ApcStatePointer[2]字段保存了两个ApcState的指针</p>
<p>具体看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">KeAttachProcess-&gt;</div><div class="line">VOID</div><div class="line">NTAPI</div><div class="line">KiAttachProcess(IN PKTHREAD Thread,</div><div class="line">                IN PKPROCESS Process,</div><div class="line">                IN PKLOCK_QUEUE_HANDLE ApcLock,</div><div class="line">                IN PRKAPC_STATE SavedApcState //&amp;Thread-&gt;SavedApcThread</div><div class="line">                )</div><div class="line">&#123;</div><div class="line">/* Swap the APC Environment */</div><div class="line">    KiMoveApcState(&amp;Thread-&gt;ApcState, SavedApcState); //把当前ApcState保存到SavedApcState</div><div class="line"></div><div class="line">    /* Reinitialize Apc State */</div><div class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]);</div><div class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]);</div><div class="line">    Thread-&gt;ApcState.Process = Process;</div><div class="line">    Thread-&gt;ApcState.KernelApcInProgress = FALSE;</div><div class="line">    Thread-&gt;ApcState.KernelApcPending = FALSE;</div><div class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</div><div class="line"></div><div class="line">    /* Update Environment Pointers if needed*/</div><div class="line">    if (SavedApcState == &amp;Thread-&gt;SavedApcState)</div><div class="line">    &#123;</div><div class="line">        Thread-&gt;ApcStatePointer[OriginalApcEnvironment] = &amp;Thread-&gt;</div><div class="line">                                                          SavedApcState;//</div><div class="line">        Thread-&gt;ApcStatePointer[AttachedApcEnvironment] = &amp;Thread-&gt;ApcState;</div><div class="line">        Thread-&gt;ApcStateIndex = AttachedApcEnvironment; //index变成了AttachedApcEnvironment</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>来一个结构图</p>
<p><img src="/img/apc.png" alt="img"></p>
<h1 id="上菜吃饭"><a href="#上菜吃饭" class="headerlink" title="上菜吃饭"></a>上菜吃饭</h1><p>Apc已经点了，什么时候才能端上来呢？我们接着看…</p>
<h2 id="Apc投递"><a href="#Apc投递" class="headerlink" title="Apc投递"></a>Apc投递</h2><blockquote>
<p>线程wait、线程切换到应用层、线程被挂起等，一旦线程有空隙了，windows就会把apc队列顺便执行一遍</p>
</blockquote>
<p>搜索<code>NormalRoutine</code>和<code>KernelRoutine</code>字段，找到<code>KiDeliverApc</code>，这个函数是具体分发Apc的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VOID</div><div class="line">NTAPI</div><div class="line">KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode,</div><div class="line">             IN PKEXCEPTION_FRAME ExceptionFrame,</div><div class="line">             IN PKTRAP_FRAME TrapFrame)</div><div class="line">             </div><div class="line"> * @remarks First, Special APCs are delivered, followed by Kernel-Mode APCs and</div><div class="line"> *          User-Mode APCs. Note that the TrapFrame is only valid if the</div><div class="line"> *          delivery mode is User-Mode.</div><div class="line"> *          Upon entry, this routine executes at APC_LEVEL.</div></pre></td></tr></table></figure>
<p>那在哪里调用的KiDeliverApc的呢，找到多处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//hal\halx86\generic\irq.S</div><div class="line">.globl _HalpApcInterrupt2ndEntry</div><div class="line">.func HalpApcInterrupt2ndEntry]</div><div class="line"></div><div class="line">//hal\halx86\generic\irql.c</div><div class="line">VOID HalpLowerIrql(KIRQL NewIrql)；</div><div class="line"></div><div class="line">//暂时忽略上面两个了</div><div class="line"></div><div class="line">//ke\i386\trap.s</div><div class="line">.func KiServiceExit</div><div class="line">_KiServiceExit:</div><div class="line">    /* Disable interrupts */</div><div class="line">    cli</div><div class="line"></div><div class="line">    /* Check for, and deliver, User-Mode APCs if needed */</div><div class="line">    CHECK_FOR_APC_DELIVER 1 //</div><div class="line"></div><div class="line">    /* Exit and cleanup */</div><div class="line">    TRAP_EPILOG FromSystemCall, DoRestorePreviousMode, DoNotRestoreSegments, DoNotRestoreVolatiles, DoRestoreEverything</div><div class="line">.endfunc</div></pre></td></tr></table></figure>
<blockquote>
<p>根据《windows内核情景分析》介绍, 执行用户APC的时机在从内核返回用户空间的途中（可能是系统调用、中断、异常处理之后需要返回用户空间）</p>
</blockquote>
<p>也就是肯定会经过<code>_KiServiceExit</code>，那就跟着来看看吧。</p>
<ol>
<li><code>CHECK_FOR_APC_DELIVER</code>宏 检查是不是需要投递Apc，具体检查trapframe是不是指向返回用户模式的，是则继续检查用户模式Apc是否需要投递。<br>参数：<code>ebp = PKTRAP_FRAME</code>，PreserveEax</li>
</ol>
<ul>
<li>trap_frame.Eflags == EFLAGS_V86_MASK，运行在V86模式，不检查是否是用户模式的trap_frame</li>
<li>trap_frame.Segcs != 1（KernelMode），表示是用户模式</li>
<li>kthread = PCR[KPCR_CURRENT_THREAD]，kthread.alerted = 0，置为不可唤醒</li>
<li>kthread-&gt;ApcState.UserApcPending 是FALSE，啥也不做，TRUE才进行投递</li>
<li>如果PreserveEax=1，保存eax，保存一些IRQL提升会清除的信息到trap_frame，fs，ds，es，gs</li>
<li>提示irql到APC_LEVEL</li>
<li>调用KiDeliverApc(UserMode, 0, trap_frame);</li>
<li>恢复irql</li>
<li>如果PreserveEax=1，恢复eax</li>
</ul>
<ol>
<li><code>TRAP_EPILOG</code>是自陷处理，参数：<code>ebp = PKTRAP_FRAME</code><blockquote>
<p>// This macro creates an epilogue for leaving any system trap.<br>// It is used for exiting system calls, exceptions, interrupts and generic<br>// traps.</p>
</blockquote>
</li>
</ol>
<ul>
<li>通过TrapFrame恢复一堆寄存器、堆栈信息，然后sysexit回到用户态空间</li>
</ul>
<p>继续看一下调用<code>KiDeliverApc</code>内部究竟是怎么处理的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode,</div><div class="line">             IN PKEXCEPTION_FRAME ExceptionFrame,</div><div class="line">             IN PKTRAP_FRAME TrapFrame) //系统空间堆栈的“自陷框架”</div><div class="line">&#123;</div><div class="line">//1. 保存原来的trap_frame</div><div class="line">OldTrapFrame = Thread-&gt;TrapFrame;</div><div class="line">Thread-&gt;TrapFrame = TrapFrame;</div><div class="line"></div><div class="line">/* Clear Kernel APC Pending */</div><div class="line">Thread-&gt;ApcState.KernelApcPending = FALSE;</div><div class="line">/* Check if Special APCs are disabled */</div><div class="line">if (Thread-&gt;SpecialApcDisable) goto Quickie;</div><div class="line"></div><div class="line">//2. 先投递内核Apc，循环投递队列中所有的内核apc，不涉及切换到用户空间</div><div class="line">while (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]))</div><div class="line">&#123;</div><div class="line">    //Thread-&gt;ApcQueueLock加锁访问</div><div class="line">    //取出一个Apc</div><div class="line">    ApcListEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink;</div><div class="line">    Apc = CONTAINING_RECORD(ApcListEntry, KAPC, ApcListEntry);</div><div class="line">    NormalRoutine = Apc-&gt;NormalRoutine;</div><div class="line">    KernelRoutine = Apc-&gt;KernelRoutine;</div><div class="line">    NormalContext = Apc-&gt;NormalContext;</div><div class="line">    SystemArgument1 = Apc-&gt;SystemArgument1;</div><div class="line">    SystemArgument2 = Apc-&gt;SystemArgument2;</div><div class="line">    </div><div class="line">    //特殊Apc，特指内核Apc，但是Apc的NormalRoutine是空的</div><div class="line">    if (!NormalRoutine) &#123;</div><div class="line">        //将Apc出队列，然通过KernelRoutine调用内核Apc响应函数</div><div class="line">        KernelRoutine(Apc,</div><div class="line">                          &amp;NormalRoutine,</div><div class="line">                          &amp;NormalContext,</div><div class="line">                          &amp;SystemArgument1,</div><div class="line">                          &amp;SystemArgument2);</div><div class="line">    &#125; else &#123;</div><div class="line">        //普通的内核Apc</div><div class="line">        if ((Thread-&gt;ApcState.KernelApcInProgress) ||</div><div class="line">                (Thread-&gt;KernelApcDisable))</div><div class="line">            &#123; //退出，必须安全才会投递</div><div class="line">            &#125;</div><div class="line">        ////将Apc出队列，然通过KernelRoutine调用内核Apc响应函数</div><div class="line">        KernelRoutine(Apc,</div><div class="line">                          &amp;NormalRoutine, //内部可能修改NormalRoutine</div><div class="line">                          &amp;NormalContext,</div><div class="line">                          &amp;SystemArgument1,</div><div class="line">                          &amp;SystemArgument2);</div><div class="line">        </div><div class="line">        //如果NormalRoutine依然不为空，在调用NormalRoutine</div><div class="line">        if (NormalRoutine)</div><div class="line">        &#123;</div><div class="line">            /* At Passive Level, an APC can be prempted by a Special APC */</div><div class="line">            Thread-&gt;ApcState.KernelApcInProgress = TRUE;</div><div class="line">            KeLowerIrql(PASSIVE_LEVEL); //将到PASSIVE_LEVEL执行</div><div class="line"></div><div class="line">            /* Call and Raise IRQ back to APC_LEVEL */</div><div class="line">            NormalRoutine(NormalContext, SystemArgument1, SystemArgument2);</div><div class="line">            KeRaiseIrql(APC_LEVEL, &amp;ApcLock.OldIrql);</div><div class="line">        &#125;</div><div class="line">        Thread-&gt;ApcState.KernelApcInProgress = FALSE;</div><div class="line">        //继续循环</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3. 投递完内核apc，如果KiDeliverApc目标是用户apc，那么继续投递用户apc</div><div class="line">//每次值投递一个User mode Apc</div><div class="line">if ((DeliveryMode == UserMode) &amp;&amp;</div><div class="line">        !(IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])) &amp;&amp;</div><div class="line">         (Thread-&gt;ApcState.UserApcPending)) //TRUE  </div><div class="line">&#123;</div><div class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</div><div class="line">    //取出第一个Apc</div><div class="line">    //先调用他的KernelRoutine</div><div class="line">    KernelRoutine(Apc,</div><div class="line">                  &amp;NormalRoutine,</div><div class="line">                  &amp;NormalContext,</div><div class="line">                  &amp;SystemArgument1,</div><div class="line">                  &amp;SystemArgument2);</div><div class="line">    /* Check if there&apos;s no normal routine */</div><div class="line">    if (!NormalRoutine)</div><div class="line">    &#123;</div><div class="line">        /* Check if more User APCs are Pending */</div><div class="line">        KeTestAlertThread(UserMode);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        /* Set up the Trap Frame and prepare for Execution in NTDLL.DLL */</div><div class="line">        //不是直接调用NormalRoutine，因为他是用户太的函数，需要切换到用户空间才能执行</div><div class="line">        KiInitializeUserApc(ExceptionFrame,</div><div class="line">                            TrapFrame,</div><div class="line">                            NormalRoutine,</div><div class="line">                            NormalContext,</div><div class="line">                            SystemArgument1,</div><div class="line">                            SystemArgument2);</div><div class="line">    &#125;                  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据注释应该很清楚deliver的逻辑了，还是在看张图<br><img src="/img/KiDeliverApc.png" alt="img"></p>
<p><code>CHECK_FOR_APC_DELIVER</code>用户态Apc的delvier有个重点，Thread-&gt;ApcState.UserApcPending必须是TRUE，那什么时候才会是TRUE，我蛮来看看</p>
<ol>
<li>在KiInsertQueueApc，如果线程等待，且Alertable是TRUE<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">else if ((Thread-&gt;State == Waiting) &amp;&amp;</div><div class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</div><div class="line">                     ((Thread-&gt;Alertable) || //</div><div class="line">                      (Thread-&gt;ApcState.UserApcPending)))</div><div class="line">            &#123;</div><div class="line">                /* Set user-mode APC pending */</div><div class="line">                Thread-&gt;ApcState.UserApcPending = TRUE;</div><div class="line">                Status = STATUS_USER_APC;</div><div class="line">                goto Unwait;</div><div class="line">            &#125;</div><div class="line">```            </div><div class="line">2. KiCheckAlertability中(wrk中是TestForAlertPending)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>FORCEINLINE<br>NTSTATUS<br>KiCheckAlertability(IN PKTHREAD Thread,<br>                    IN BOOLEAN Alertable,<br>                    IN KPROCESSOR_MODE WaitMode)<br>{<br>    /<em> Check if the wait is alertable </em>/<br>    if (Alertable)<br>    {<br>        /<em> It is, first check if the thread is alerted in this mode </em>/<br>        if (Thread-&gt;Alerted[WaitMode])<br>        {<br>            /<em> It is, so bail out of the wait </em>/<br>            Thread-&gt;Alerted[WaitMode] = FALSE;<br>            return STATUS_ALERTED;<br>        }<br>        else if ((WaitMode != KernelMode) &amp;&amp;<br>                (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])))<br>        {<br>            /<em> It’s isn’t, but this is a user wait with queued user APCs </em>/<br>            Thread-&gt;ApcState.UserApcPending = TRUE;<br>            return STATUS_USER_APC;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">两种情况都需要Alertable = TRUE，这个字段表示线程是唤醒的，也就是说只有可唤醒的线程，才能拿投递他的用态APC，否则不会</div><div class="line"></div><div class="line">&gt; SleepEx, WaitForSingleObject，WaitForMultipleObjects都可以设置线程为Alertable</div><div class="line"></div><div class="line">接着继续看看`KiInitializeUserApc`是怎么切换到用户空间执行的用户态函数</div></pre></td></tr></table></figure></p>
<p>VOID<br>NTAPI<br>KiInitializeUserApc(IN PKEXCEPTION_FRAME ExceptionFrame,<br>                    IN PKTRAP_FRAME TrapFrame,<br>                    IN PKNORMAL_ROUTINE NormalRoutine,<br>                    IN PVOID NormalContext,<br>                    IN PVOID SystemArgument1,<br>                    IN PVOID SystemArgument2)<br>{</p>
<pre><code>//V86模式下，不投递

 /* Save the full context */
Context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
KeTrapFrameToContext(TrapFrame, ExceptionFrame, &amp;Context);

//检查不是KernleMode
ASSERT((TrapFrame-&gt;SegCs &amp; MODE_MASK) != KernelMode);

...

/* Get the aligned size */
AlignedEsp = Context.Esp &amp; ~3;//来自于TrapFrame.HardwareEsp或TempEsp
//Context和4个参数的长度
ContextLength = CONTEXT_ALIGNED_SIZE + (4 * sizeof(ULONG_PTR));
//将原始堆栈扩展ContextLength，用来保存Context和参数
Stack = ((AlignedEsp - 8) &amp; ~3) - ContextLength;

/* Probe the stack */
ProbeForWrite((PVOID)Stack, AlignedEsp - Stack, 1);
ASSERT(!(Stack &amp; 3));

/* Copy data into it */
//(4 * sizeof(ULONG_PTR)))是后面4个参数的位置，然后接着拷贝Context，将老的TrapFrame内容拷贝到用户太堆栈中
RtlCopyMemory((PVOID)(Stack + (4 * sizeof(ULONG_PTR))),
              &amp;Context,
              sizeof(CONTEXT));

/* Run at APC dispatcher */
TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //KeUserApcDispatcher保存的其实就是KiUserApcDispatcher，是用户空间函数
TrapFrame-&gt;HardwareEsp = Stack;//栈顶

/* Setup Ring 3 state */
TrapFrame-&gt;SegCs = Ke386SanitizeSeg(KGDT_R3_CODE, UserMode);
TrapFrame-&gt;HardwareSegSs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode);
TrapFrame-&gt;SegDs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode);
TrapFrame-&gt;SegEs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode);
TrapFrame-&gt;SegFs = Ke386SanitizeSeg(KGDT_R3_TEB, UserMode);
TrapFrame-&gt;SegGs = 0;
TrapFrame-&gt;ErrCode = 0;

/* Sanitize EFLAGS */
TrapFrame-&gt;EFlags = Ke386SanitizeFlags(Context.EFlags, UserMode);

/* Check if thread has IOPL and force it enabled if so */
if (KeGetCurrentThread()-&gt;Iopl) TrapFrame-&gt;EFlags |= 0x3000;

/* Setup the stack */
*(PULONG_PTR)(Stack + 0 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalRoutine;
*(PULONG_PTR)(Stack + 1 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalContext;
*(PULONG_PTR)(Stack + 2 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument1;
*(PULONG_PTR)(Stack + 3 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument2;
...
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">执行流程根据注释应该很清楚了，这里要解释一下TrapFrame。</div><div class="line">&gt; CPU进入啮合之后，内核堆栈就会有个TrapFrame，保存的是用户空间的线程（因进入内核原因不同，可能是自陷、中断、异常框架，都是一样的结构）。CPU返回用户空间时会使用这个TrapFrame，才能正确返回原理啊的断点，并回复寄存器的状态</div><div class="line">&gt; 这里为了让Apc返回到用户空间执行，就会修改这个TrapFrame，原来的TrapFrame就需要保存，这里保存在了用户空间堆栈中（CONTEXT)</div><div class="line">&gt; 执行完Apc函数之后，执行一个NtContinue，将这个CONTEXT作为参数，这样保存的TrapFrame就会还原到原来的状态，然后CPU又能正常回之前的用户空间了。</div><div class="line"></div><div class="line">KiDeliverApc完了之后，回到_KiServiceExit，会使用被修改过的TrapFrame回到用户空间，执行指定的`KiUserApcDispatcher`(ntdll提供)</div></pre></td></tr></table></figure></p>
<p>//更具这个执行KiUserApcDispatcher<br>TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //其实就是KiUserApcDispatcher，是用户空间函数<br>TrapFrame-&gt;HardwareEsp = Stack;//栈顶</p>
<p>.func KiUserApcDispatcher@16<br>.globl _KiUserApcDispatcher@16<br>_KiUserApcDispatcher@16:</p>
<pre><code>/* Setup SEH stack */
lea eax, [esp+CONTEXT_ALIGNED_SIZE+16];原始堆栈的位置，SEH
mov ecx, fs:[TEB_EXCEPTION_LIST]
mov edx, offset _KiUserApcExceptionHandler
mov [eax], ecx
mov [eax+4], edx

/* Enable SEH */
mov fs:[TEB_EXCEPTION_LIST], eax

/* Put the Context in EDI */
pop eax;弹出第一个参数
lea edi, [esp+12];context的位置

/* Call the APC Routine */
call eax //调用IntCallUserApc

/* Restore exception list */
mov ecx, [edi+CONTEXT_ALIGNED_SIZE]
mov fs:[TEB_EXCEPTION_LIST], ecx

/* Switch back to the context */
push 1
push edi;Context
call _ZwContinue@8 //正常是不会返回的

/* Save callback return value */
mov esi, eax

/* Raise status */
</code></pre><p>StatusRaiseApc:<br>    push esi<br>    call _RtlRaiseStatus@4 //如果ZwContinue失败了，这里处理<br>    jmp StatusRaiseApc<br>    ret 16<br>.endfunc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`KiUserApcDispatcher`其实挺简单的，通过esp弹出APc函数，然后调用，就进入了IntCallUserApc，</div><div class="line"></div><div class="line">## 恢复TrapFrame</div><div class="line"></div><div class="line">执行完成后，调用_ZwContinue(Context, 1)，回到内核回复之前修改TrapFrame，也会重新检查是否有Apc需要投递，有则继续投递，</div><div class="line">重复上面的步骤，直到没有了则可以回到之前被中断的用户态的断点处。</div></pre></td></tr></table></figure></p>
<p>.func NtContinue@8<br>_NtContinue@8:</p>
<pre><code>/* NOTE: We -must- be called by Zw* to have the right frame! */
/* Push the stack frame */
push ebp ; 指向本次调用的自陷框架，记为T1

/* Get the current thread and restore its trap frame */
mov ebx, PCR[KPCR_CURRENT_THREAD]
mov edx, [ebp+KTRAP_FRAME_EDX]
mov [ebx+KTHREAD_TRAP_FRAME], edx;thread-&gt;TrapFrame = edx

/* Set up stack frame */
mov ebp, esp ; ESP指向新的框架（函数调用框架）

/* Save the parameters */
mov eax, [ebp+0] ; 原来的EBP，就是自陷框架指针，就是T1
mov ecx, [ebp+8] ; Context

/* Call KiContinue */
push eax ;TrapFrame
push 0 ;ExceptionFrame
push ecx ;Context
call _KiContinue@12 ; 将Context恢复到T1中

/* Check if we failed (bad context record) */
or eax, eax
jnz Error

/* Check if test alert was requested */
cmp dword ptr [ebp+12], 0
je DontTest

/* Test alert for the thread */
mov al, [ebx+KTHREAD_PREVIOUS_MODE]
push eax
call _KeTestAlertThread@4 ; 检查用户模式APC队列是否为空，不空将UserApcPending置为TRUE
</code></pre><p>DontTest:<br>    /<em> Return to previous context </em>/<br>    pop ebp<br>    mov esp, ebp<br>    jmp _KiServiceExit2 ; 本质和_KiServiceExit相同，如果还有用户APC，会继续投递，直到投递完，才会回到用户被中断的点</p>
<p>Error:<br>    pop ebp<br>    mov esp, ebp<br>    jmp _KiServiceExit<br>.endfunc</p>
<p>```</p>
<p>下面将_KiServiceExit到IntCallUserApc的流程总结一下：<br><img src="/img/deliver.png" alt="img"></p>
<p>到这里，终于执行到了用户的Apc函数。</p>
<h1 id="结账走人"><a href="#结账走人" class="headerlink" title="结账走人"></a>结账走人</h1><p>到这，APC流程基本弄清楚了。</p>
<p>下一篇将结合APC机制分析一下最近比较新的AtomBombing注入技术的详细实现和各个细节。</p>
<p><strong>参考</strong></p>
<ol>
<li><a href="">Reactos内核情景源码分析</a></li>
<li><a href="http://bbs.pediy.com/thread-209377.htm" target="_blank" rel="external">线程的Alertable与User APC</a></li>
</ol>
<p>转载请注明出处，博客原文：<a href="http://anhkgg.github.io/win-apc-analyze1/">http://anhkgg.github.io/win-apc-analyze1/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻开&quot;&gt;&lt;a href=&quot;#翻开&quot; class=&quot;headerlink&quot; title=&quot;翻开&quot;&gt;&lt;/a&gt;翻开&lt;/h1&gt;&lt;p&gt;翻开小Win的菜单，APC赫然在目…&lt;/p&gt;
&lt;p&gt;做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！&lt;/p&gt;
&lt;p&gt;吃了可以做很多事情…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APC注入&lt;/li&gt;
&lt;li&gt;APC注入&lt;/li&gt;
&lt;li&gt;APC注入&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="windows" scheme="https://anhkgg.github.io/tags/windows/"/>
    
      <category term="APC" scheme="https://anhkgg.github.io/tags/APC/"/>
    
  </entry>
  
  <entry>
    <title>Rust笔记（一）-- 环境配置</title>
    <link href="https://anhkgg.github.io/rust-note-1-config-environment/"/>
    <id>https://anhkgg.github.io/rust-note-1-config-environment/</id>
    <published>2017-04-25T14:03:33.000Z</published>
    <updated>2017-05-01T07:24:48.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装rust"><a href="#安装rust" class="headerlink" title="安装rust"></a>安装rust</h1><p>Rust中文站下载rust<br><a href="https://www.rust-lang.org/zh-CN/install.html" target="_blank" rel="external">https://www.rust-lang.org/zh-CN/install.html</a><br><a href="https://www.rust-lang.org/zh-CN/downloads.html" target="_blank" rel="external">https://www.rust-lang.org/zh-CN/downloads.html</a></p>
<p>安装：</p>
<ol>
<li>Windows平台<br>下载<a href="https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi" target="_blank" rel="external">https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi</a>，然后双击运行即可，需要选上PATH环境变量配置</li>
</ol>
<a id="more"></a>
<p>其实应该下载这个版本<a href="https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi" target="_blank" rel="external">https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi</a>，后面会说为什么</p>
<ol>
<li>Linux平台<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//安装</div><div class="line">   $ curl -sf -L https://static.rust-lang.org/rustup.sh | sh</div><div class="line">//卸载</div><div class="line">  $ sudo /usr/local/lib/rustlib/uninstall.sh</div></pre></td></tr></table></figure>
</li>
</ol>
<p>下面命令成功表示安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c:\&gt; rustc --version</div><div class="line">rustc 1.13.0 (2c6933acc 2016-11-07)</div><div class="line">C:\&gt; cargo --version</div><div class="line">cargo 0.13.0-nightly (eca9e15 2016-11-01)</div></pre></td></tr></table></figure>
<h1 id="配置IDE"><a href="#配置IDE" class="headerlink" title="配置IDE"></a>配置IDE</h1><p>这里介绍的是微软的Visual Studio Code编辑器配置Rust的环境。</p>
<p>Visual Studio Code支持windows、linux、mac等，所以在不同平台配置rust都是一样的步骤。</p>
<p>下载地址： <a href="https://code.visualstudio.com/" target="_blank" rel="external">https://code.visualstudio.com/</a></p>
<p>启动visual studio code，ctrl+shift+x切换到插件安装页面，输入rust。</p>
<p><img src="/img/rust_note_one_1.png" alt="image"></p>
<p>选择安装Rusty Code插件，支持自动完成、跳转到定义、符号等等功能。<br>安装完成后，重新加载即可启用。</p>
<p>新建一个rs文件，visual studio code自动识别为rust语言。右下角有个Rust tool missing，点击后会提示插件缺少的库，选择安装即可（需要保证rust环境安装成功）</p>
<p><img src="/img/rust_note_one_2.png" alt="image"></p>
<p>会出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Executing &quot;cargo install racer&quot;</div><div class="line"> Updating registry `https://github.com/rust-lang/crates.io-index`</div><div class="line"> ···</div><div class="line">    Finished release [optimized + debuginfo] target(s) in 335.15 secs</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\racer.exe</div><div class="line">warning: be sure to add `C:\Users\xxx\.cargo\bin` to your PATH to be able to run the installed binaries</div><div class="line">Executing &quot;cargo install rustfmt&quot;</div><div class="line">    Updating registry `https://github.com/rust-lang/crates.io-index`</div><div class="line"> ···</div><div class="line">    Finished release [optimized] target(s) in 270.41 secs</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\cargo-fmt.exe</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\rustfmt.exe</div><div class="line">warning: be sure to add `C:\Users\xxx\.cargo\bin` to your PATH to be able to run the installed binaries</div><div class="line">Executing &quot;cargo install rustsym&quot;</div><div class="line">    Updating registry `https://github.com/rust-lang/crates.io-index`</div><div class="line"> ···</div><div class="line">    Finished release [optimized] target(s) in 203.64 secs</div><div class="line">  Installing C:\Users\xxx\.cargo\bin\rustsym.exe</div><div class="line">warning: be sure to add `C:\Users\xxx\.cargo\bin` to your PATH to be able to run the installed binaries</div></pre></td></tr></table></figure></p>
<p>安装完成后即可。测试一下，ok。</p>
<p><img src="/img/rust_note_one_3.png" alt="image"></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>直接rustc xxx.rs编译程序，会出现缺少linker.exe（选择gnu版是不会出现这个错误，应该是不依赖msvc编译环境）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: could not exec the linker `link.exe`: 系统找不到指定的文件。 (os error 2)</div><div class="line">  |</div><div class="line">  = note: &quot;link.exe&quot;</div></pre></td></tr></table></figure></p>
<p>因为在Windows平台，rust编译程序需要vs c++编译工具，可以安装vs2013或者更高版本工具，更简单的方式就是下载<br><a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="external">Microsoft Visual C++ Build Tools 2015</a></p>
<blockquote>
<p>Windows considerations</p>
<p>On Windows, Rust additionally requires the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is by installing Microsoft Visual C++ Build Tools 2015 which provides just the Visual C++ build tools. Alternately, you can install Visual Studio 2015 or Visual Studio 2013 and during install select the “C++ tools”.</p>
<p>For further information about configuring Rust on Windows see the Windows-specific rustup documentation.</p>
</blockquote>
<p>安装完之后，重新编译成功。（编译不需要重启，但是后面调试中需要重启，否则调试器异常）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Compiling hello_world v0.1.0 (file:///xxx/rust/hello_world)</div><div class="line">  Finished debug [unoptimized + debuginfo] target(s) in 0.28 secs</div></pre></td></tr></table></figure></p>
<p>生成目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">D:\xxx\hello_world&gt;dir</div><div class="line"> 驱动器 D 中的卷没有标签。</div><div class="line"> 卷的序列号是 309A-078B</div><div class="line"></div><div class="line"> D:\xxx\hello_world 的目录</div><div class="line"></div><div class="line">2016/12/19  11:21    &lt;DIR&gt;          .</div><div class="line">2016/12/19  11:21    &lt;DIR&gt;          ..</div><div class="line">2016/12/19  10:59                 7 .gitignore</div><div class="line">2016/12/19  11:00                47 Cargo.lock</div><div class="line">2016/12/19  10:59                89 Cargo.toml</div><div class="line">2016/12/19  11:21           103,424 main.exe</div><div class="line">2016/12/19  11:21           487,424 main.pdb</div><div class="line">2016/12/19  10:59    &lt;DIR&gt;          src</div><div class="line">2016/12/19  11:00    &lt;DIR&gt;          target</div><div class="line">               5 个文件        590,991 字节</div><div class="line">               4 个目录 58,963,050,496 可用字节</div></pre></td></tr></table></figure></p>
<p>在Visual Studio Code直接输入命令编译</p>
<ol>
<li>ctrl+`，打开集成终端窗口</li>
<li>输入rust的编译命令即可</li>
</ol>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>Rust目前支持使用LLDB和GDB调试，在Visual Studio Code可以安装lldb调试插件。</p>
<p>但是目前lldb不支持windows平台，只能在linux平台配置lldb，配置步骤如下：</p>
<p>依然ctrl+shift+x，然后输入rust，在列表中选择LLDB Debugger安装即可</p>
<p><img src="/img/rust_note_one_1.png" alt="image"></p>
<p>安装之后，重新加载窗口，调试插件生效。<br>打开之前的rs文件（vs code需要打开其目录作为工程目录），切换到调试窗口，点击调试开始按钮，会打开launch.json配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</div><div class="line">    &quot;configurations&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;Debug&quot;,</div><div class="line">            &quot;type&quot;: &quot;lldb&quot;,</div><div class="line">            &quot;request&quot;: &quot;launch&quot;,</div><div class="line">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/xxx&quot;, //main</div><div class="line">            &quot;args&quot;: []</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将program中xxx配置为编译后的文件名就可以进行调试了。</p>
<p>在windows平台，需要使用gdb进行调试<br>使用TDM-GCC的GDB（需要支持Python扩展，MinGW64的GDB貌似不支持） </p>
<ol>
<li><p>下载<a href="https://sourceforge.net/projects/tdm-gcc/files/GDB/" target="_blank" rel="external">TDM-GCC-gdb</a>, 不需要安装，解压后，拷贝bin、gdb64、share目录到rust安装目录，修改gdb64\bin目录中gdbinit内容，文件末尾加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">python</div><div class="line"></div><div class="line">print &quot;---- Loading Rust pretty-printers ----&quot; </div><div class="line"></div><div class="line">sys.path.insert(0, &quot;你的rust安装目录/lib/rustlib/etc&quot;) </div><div class="line">import gdb_rust_pretty_printing </div><div class="line">gdb_rust_pretty_printing.register_printers(gdb) </div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
</li>
<li><p>下载rust源码, <a href="https://github.com/rust-lang/rust" target="_blank" rel="external">https://github.com/rust-lang/rust</a>，拷贝etc目录到x\rust\lib\rustlib目录</p>
</li>
<li><p>测试gdb是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\&gt;gdb</div><div class="line">GNU gdb (GDB) 7.9.1</div><div class="line">Copyright (C) 2015 Free Software Foundation, Inc.</div><div class="line">...</div><div class="line">---- Loading Rust pretty-printers ----</div></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio Code中搜搜安装native debug插件（不止支持gdb），重新加载后，打开rs文件目录，切换到调试页面，点击调试按钮，弹出调试器列表，选择gdb，然后配置好launch.json文件（同lldb），保存即可开始调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</div><div class="line">    &quot;configurations&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;Debug&quot;,</div><div class="line">            &quot;type&quot;: &quot;gdb&quot;,</div><div class="line">            &quot;request&quot;: &quot;launch&quot;,</div><div class="line">            &quot;target&quot;: &quot;./target/debug/hello_world.exe&quot;,</div><div class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>在调试中遇到问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">---- Loading Rust pretty-printers ----</div><div class="line">No symbol table is loaded.  Use the &quot;file&quot; command.</div></pre></td></tr></table></figure>
</li>
</ol>
<p>经过一番周折发现是racer\rustfmt\rustsym没有安装成功，符号相关的是rustsym，<br>安装完成之后，依然无法识别符号，各种翻找资料，无果。</p>
<p>最后在一篇<a href="https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/" target="_blank" rel="external">英文博客</a>中看到别人下载的rust版本是rust-nightly-x86_64-pc-windows-gnu.msi，突然想是不是跟版本有关，因为我下载的是msvc版，编译结果符号应该也是ms的，而调试其是gdb，是不是这样就识别不了了呢，而gnu版rust正好和gdb配套（猜测），所以应该会ok。</p>
<p>果不其然，重新下载了<a href="https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi" target="_blank" rel="external">https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi</a>，配置之后，可以正常识别符号了。</p>
<p>效果图：</p>
<p><img src="/img/rust_note_one_4.png" alt="image"></p>
<p>gnu版的rust在配置gdb时，不用下载rust源码添加etc目录的文件</p>
<ol>
<li>Visual Studio Code左下角出现racer crashed，点击之后看到<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Racer Output: </div><div class="line">RUST_SRC_PATH environment variable must be set to point to the src directory of a rust checkout. E.g. &quot;/home/foouser/src/rust/src&quot;</div><div class="line">Racer Error:</div></pre></td></tr></table></figure>
</li>
</ol>
<p>是因为安装racer步骤不完整，<br>需要将rust源码中src拷贝到rust安装目录中，然后设置环境变量<br>RUST_SRC_PATH = rust安装目录\src<br>验证racer是否成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">c:\&gt;racer complete std::io::B</div><div class="line">MATCH BufReader,50,11,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\buffered.rs,Struct,pub struct BufReader&lt;R&gt;</div><div class="line">MATCH BufWriter,309,11,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\buffered.rs,Struct,pub struct BufWriter&lt;W: Write&gt;</div><div class="line">MATCH BufRead,1208,10,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\mod.rs,Trait,pub trait BufRead: Read</div><div class="line">MATCH Bytes,1605,11,C:\Program Files\Rust stable MSVC 1.13\src\libstd\io\mod.rs,Struct,pub struct Bytes&lt;R&gt;</div><div class="line">MATCH BufReader,50,11,.\libstd\io\buffered.rs,Struct,pub struct BufReader&lt;R&gt;</div><div class="line">MATCH BufWriter,309,11,.\libstd\io\buffered.rs,Struct,pub struct BufWriter&lt;W: Write&gt;</div><div class="line">MATCH BufRead,1208,10,.\libstd\io\mod.rs,Trait,pub trait BufRead: Read</div><div class="line">MATCH Bytes,1605,11,.\libstd\io\mod.rs,Struct,pub struct Bytes&lt;R&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在用户设置中配置如下参数：<br>（如果已经将rust\bin和.cargo\bin加入PATH，并且设置好了RUST_SRC_PATH的话，这一步可以省略）<br>{<br>“rust.racerPath”: null, // Specifies path to Racer binary if it’s not in PATH<br>“rust.rustLangSrcPath”: null, // Specifies path to /src directory of local copy of Rust sources<br>“rust.rustfmtPath”: null, // Specifies path to Rustfmt binary if it’s not in PATH<br>“rust.cargoPath”: null, // Specifies path to Cargo binary if it’s not in PATH<br>“rust.cargoHomePath”: null, // Path to Cargo home directory, mostly needed for racer. Needed only if using custom rust installation.<br>“rust.formatOnSave”: false, // Turn on/off autoformatting file on save (EXPERIMENTAL)<br>“rust.checkOnSave”: false, // Turn on/off <code>cargo check</code> project on save (EXPERIMENTAL)<br>“rust.checkWith”: “build” // Specifies the linter to use. (EXPERIMENTAL)<br>} </p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://m.douban.com/group/topic/89086749/" target="_blank" rel="external">https://m.douban.com/group/topic/89086749/</a></li>
<li><a href="https://www.douban.com/group/topic/63968269/" target="_blank" rel="external">https://www.douban.com/group/topic/63968269/</a></li>
<li><a href="https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/" target="_blank" rel="external">https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/</a></li>
</ol>
<p>转载请注明出处，博客原文：<a href="http://anhkgg.github.io/rust-note-1-config-environment/">http://anhkgg.github.io/rust-note-1-config-environment/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装rust&quot;&gt;&lt;a href=&quot;#安装rust&quot; class=&quot;headerlink&quot; title=&quot;安装rust&quot;&gt;&lt;/a&gt;安装rust&lt;/h1&gt;&lt;p&gt;Rust中文站下载rust&lt;br&gt;&lt;a href=&quot;https://www.rust-lang.org/zh-CN/install.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.rust-lang.org/zh-CN/install.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.rust-lang.org/zh-CN/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.rust-lang.org/zh-CN/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows平台&lt;br&gt;下载&lt;a href=&quot;https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi&lt;/a&gt;，然后双击运行即可，需要选上PATH环境变量配置&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="rust" scheme="https://anhkgg.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://anhkgg.github.io/tags/rust/"/>
    
      <category term="linux" scheme="https://anhkgg.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IDC脚本小试笔记</title>
    <link href="https://anhkgg.github.io/idc-base-usage-test-note/"/>
    <id>https://anhkgg.github.io/idc-base-usage-test-note/</id>
    <published>2016-10-10T07:56:17.000Z</published>
    <updated>2016-10-10T07:58:20.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IDC是IDA扩展的一种脚本语言，用于自动化，或者扩展查询IDA数据库</p>
<p>可以使用IDC或者python编写</p>
<p>语法类似C、也应用了C++类似的对象特性和异常处理</p>
<p>可以是单独的IDC文件，通过File-&gt;Script File加载，<br>也可以是简单的IDC命令，通过File-&gt;Script Command来编写</p>
<a id="more"></a>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>包括字符串、整形、浮点型，后来又增加了对象、引用、函数指针等变量类型。</p>
<p>字符串是IDC的本地数据类型。</p>
<p>变量通过auto声明，在使用前都需要声明，没有知名明确的变量类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto addr, reg, val; /*xxxx*/</div><div class="line">auto count = 0; // xxx</div></pre></td></tr></table></figure>
<p>注释使用//或者/**/，语句使用；作为结束</p>
<p>不支持C风格数组（使用分片）、指针（使用引用）、结构体和联合体之类的复杂数据结构，之后引入了类的概念。</p>
<p>extern引入全局变量声明，不能声明中初始化值，可以在任何函数内外声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">extern outglobal;</div><div class="line">static mian()</div><div class="line">&#123;</div><div class="line">    extern inglobal;</div><div class="line">    outglobal = &quot;xx&quot;;</div><div class="line">    inglobal = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>支持几乎所有的C算术和逻辑运算符，除了几个特例外（？？）。包括三元运算？：，不支持op=(+=，*=， &gt;&gt;=)等复合运算符。后来可以支持逗号运算，</p>
<p>所有整数操作都是有符号的值处理。所以在整数比较和右移运算（&gt;&gt;）收到影响。</p>
<p>如果需要逻辑右移位，必须自己修改结果的最高位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = (x &gt;&gt; 1)&amp;0x7fffffff;</div></pre></td></tr></table></figure></p>
<p>字符串操作、分片（语法类似python字符串操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">auto str = &quot;string to slice&quot;;</div><div class="line">auto s1, s2, s3, s4;</div><div class="line">s1 = str[7:9];</div><div class="line">s2 = str[:6];</div><div class="line">s3 = str[10:];</div><div class="line">s4 = str[5];</div></pre></td></tr></table></figure></p>
<h1 id="IDC语句"><a href="#IDC语句" class="headerlink" title="IDC语句"></a>IDC语句</h1><p>唯一不支持C中的switch语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto i;</div><div class="line">for(i = 0; i&lt;10; i = i+1) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>可以在花括号开始声明变量，但是变量没有具体作用域，可以在外面使用。但是函数中不能使用其他函数内部声明的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(1) &#123;</div><div class="line">    auto x; x = 10;</div><div class="line">&#125;</div><div class="line">Message(&quot;x = %d\n&quot;, x);</div></pre></td></tr></table></figure>
<h1 id="IDC函数"><a href="#IDC函数" class="headerlink" title="IDC函数"></a>IDC函数</h1><p>只有独立IDC文件才支持函数，IDC命令框不支持函数。</p>
<p>使用static引入一个函数定义。函数参数只有参数名列表，逗号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static test(x, y, z) </div><div class="line">&#123;</div><div class="line">    auto a, b, c;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IDA5.6之前，函数参数严格使用传值传递，之后引入了传地址参数传递机制。采用哪种方式传递参数，使用调用者来决定的，而不是函数声明决定的。<br>传地址方式在调用方参数前加入&amp;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto q=1, r=0, s=2;</div><div class="line">test(q,r, s);</div><div class="line">test(q, &amp;r, s);//</div></pre></td></tr></table></figure></p>
<p>函数声明不会指明要返回一个值，以及返回什么类型的值。</p>
<p>如果需要返回值，使用return返回指定的值即可。</p>
<p>可以在不同的路径返回不同类型的值。任何不显示返回值的函数默认返回为0.</p>
<p>IDA5.6之后，函数离成为IDC中第一类对象更近了一布，函数引用可以作为参数传给另一个函数，也可以将函数引用作为函数返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static ret() &#123;</div><div class="line">    return Message;</div><div class="line">&#125;</div><div class="line">staic call(fun, arg) &#123;</div><div class="line">    fun(arg);</div><div class="line">&#125;</div><div class="line">static main() &#123;</div><div class="line">    auto f = ret();</div><div class="line">    call(f, &quot;Message Call&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="IDC对象"><a href="#IDC对象" class="headerlink" title="IDC对象"></a>IDC对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class People</div><div class="line">&#123;</div><div class="line">    People(name, age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    ~People() &#123;</div><div class="line">    &#125;</div><div class="line">    print() &#123;</div><div class="line">        Message(&quot;name: %s, age: %d&quot;, this.name, this.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">static main() &#123;</div><div class="line">    People p;//error</div><div class="line">    auto p = People(&quot;john&quot;, 12);</div><div class="line">    p.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//Array操作</div><div class="line">class MyArray</div><div class="line">&#123;</div><div class="line">	MyArray(name) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.id = CreateArray(name);</div><div class="line">		if(this.id == -1) &#123;</div><div class="line">			this.id = GetArrayId(name);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	~MyArray() &#123;</div><div class="line">		if(this.id != -1) &#123;</div><div class="line">			DeleteArray(this.id);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	SetArrayData(tag, idx, val) &#123;</div><div class="line">		if(tag == AR_LONG) &#123;</div><div class="line">			SetArrayLong(this.id, idx, val);</div><div class="line">		&#125;</div><div class="line">		else if(tag == AR_STR) &#123;</div><div class="line">			SetArrayString(this.id, idx, val);</div><div class="line">		&#125;else &#123;</div><div class="line">			return 0;</div><div class="line">		&#125;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	GetArrayData(tag, idx) &#123;</div><div class="line">		return GetArrayElement(tag, this.id, idx);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	DelArrayData(tag, idx) &#123;</div><div class="line">		return DelArrayElement(tag, this.id, idx);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">auto val;</div><div class="line">val = Byte(0x00EEEC1A);</div><div class="line">Message(&quot;val = %08x \n&quot;, val);</div><div class="line">print(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxx&quot;);</div><div class="line">//Warning(&quot;val = %08x\n&quot;, val);</div><div class="line"></div><div class="line">//交互</div><div class="line">val = AskStr(&quot;124&quot;, &quot;enter a val&quot;); //AskFile, AskYN</div><div class="line">if(val == 0) &#123;</div><div class="line">	print(&quot;no enter val&quot;);</div><div class="line">&#125;else &#123;</div><div class="line">	Message(&quot;val = %08x \n&quot;, val);</div><div class="line">&#125;</div><div class="line">Jump(0x400000);</div><div class="line">Message(&quot;cursor = %08x\n&quot;, ScreenEA());</div><div class="line"></div><div class="line">//字符串操作</div><div class="line">//val= 0000302d</div><div class="line">val = sprintf(&quot;%08x&quot;, 12333);//form</div><div class="line">Message(&quot;val = %s \n&quot;, val);</div><div class="line"></div><div class="line">////val = 0000302d 12333</div><div class="line">Message(&quot;val = %08x %d\n&quot;, xtol(val), xtol(val));//atol xtol </div><div class="line">Message(&quot;A = %d %02x\n&quot;, ord(&quot;A&quot;), ord(&quot;A&quot;)); //A = 65 41</div><div class="line">Message(&quot;val size = %d\n&quot;, strlen(val));//strstr, substr, str[s:e]</div><div class="line"></div><div class="line">//文件操作</div><div class="line">class MyFile</div><div class="line">&#123;</div><div class="line">	MyFile(name, mode) &#123;</div><div class="line">		this.h = fopen(name, mode);</div><div class="line">		if(this.h == 0) &#123;</div><div class="line">			//error</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	~MyFile() &#123;</div><div class="line">		if(this.h != 0) &#123;</div><div class="line">			fclose(this.h);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	length() &#123;</div><div class="line">		return filelength(this.h);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_fgetc() &#123;</div><div class="line">		return fgetc(this.h);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_fputc(val) &#123;</div><div class="line">		return fputs(val, this.h);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//_fprintf(format, ...) &#123;</div><div class="line">		//return fprintf(this.h, format, ...);</div><div class="line">	//&#125;</div><div class="line">	</div><div class="line">	_writestr(str) &#123;</div><div class="line">		return writestr(this.h, str);</div><div class="line">	&#125;</div><div class="line">	_readstr() &#123;</div><div class="line">		return readstr(this.h);//-1=end</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_writelongb(val) &#123;</div><div class="line">		return writelong(this.h, val, 1);//大端</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_writelongs(val) &#123;</div><div class="line">		return writelong(this.h, val, 0);//小端</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_readlongb() &#123;</div><div class="line">		return readlong(this.h, 1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_readlongs() &#123;</div><div class="line">		return readlong(this.h, 0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_writeshortb(val) &#123;</div><div class="line">		return writeshort(this.h, val, 1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_writeshorts(val) &#123;</div><div class="line">		return writeshort(this.h, val, 0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_readshortb() &#123;</div><div class="line">		return readshort(this.h, 1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_readshorts() &#123;</div><div class="line">		return readshort(this.h, 0);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_loadfile(pos, addr, length) &#123;</div><div class="line">		return loadfile(this.h, pos, addr, length);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	_savefile(pos, addr, length) &#123;</div><div class="line">		return savefile(this.h, pos, addr, length);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//file</div><div class="line">auto fn = AskFile(1, &quot;*.txt&quot;, &quot;save file&quot;);//1=save, 0=open</div><div class="line">Message(&quot;save file = %s\n&quot;, fn);</div><div class="line">auto mf = MyFile(fn, &apos;w&apos;);</div><div class="line">//mf._writelongb(122222);</div><div class="line">//mf._writestr(&quot;test file write data&quot;);</div><div class="line">//writestr(mf.h, &quot;test file write data&quot;);</div><div class="line">//mf._savefile(0, 0x400000, 50);</div><div class="line">Message(&quot;file data = %s&quot;, mf._readstr());</div><div class="line">//Message(&quot;file data = %s&quot;, mf._readlongb());</div><div class="line"></div><div class="line"></div><div class="line">//name, address</div><div class="line">Message(&quot;%08x, %s\n&quot;, 0x400016, Name(0x400016));</div><div class="line">//Message(&quot;xxx = %s\n&quot;, NameEx(0x0040BD14, 0x0040BD1C));</div><div class="line">MakeNameEx(0x0040BD1C, &quot;testxxxx&quot;, 1);</div><div class="line">Message(&quot;xxx = %08x\n&quot;, LocByName(&quot;testxxxx&quot;));</div><div class="line">Message(&quot;xxx = %08x\n&quot;, LocByNameEx(0x0040BD14, &quot;testxxxx&quot;));</div><div class="line"></div><div class="line">//function</div><div class="line">Message(&quot;end = %08x, start = %08x\n&quot;, GetFunctionAttr(0x0040BD14, FUNCATTR_END), GetFunctionAttr(0x0040BD14, FUNCATTR_START));</div><div class="line">Message(&quot;f = %s\n&quot;, GetFunctionName(0x0040BD1C));</div><div class="line">Message(&quot;f_next = %08x\n&quot;, NextFunction(0x0040BD1C));</div><div class="line">Message(&quot;f_prev = %08x\n&quot;, PrevFunction(0x0040BD1C));</div><div class="line"></div><div class="line">//代码xref</div><div class="line">auto cur = Rfirst(0x0040BD1C);//跳到哪里去，第一个</div><div class="line">Message(&quot;to = %08x\n&quot;, cur);</div><div class="line">Message(&quot;to = %08x\n&quot;, Rnext(0x0040BD1C, cur));//跳到哪里去，下一个</div><div class="line">Message(&quot;to = %08x\n&quot;, XrefType());//fl_CN, fl_CF, fl_JN, fl_JF, fl_F</div><div class="line">cur = RfirstB(0x40B928);//什么地方跳来的，第一个</div><div class="line">Message(&quot;from = %08x\n&quot;, cur );</div><div class="line">Message(&quot;from = %08x\n&quot;, RnextB(0x40B928, cur));//什么地方跳来的，下一个</div><div class="line"></div><div class="line">//数据xref</div><div class="line">cur = Dfirst(0x01410559);//改地址引用的第一个数据的地址</div><div class="line">Message(&quot;to d = %08x\n&quot;, cur);</div><div class="line">Message(&quot;to d = %08x\n&quot;, Dnext(0x01410559, cur));</div><div class="line">Message(&quot;to = %08x\n&quot;, XrefType());//dr_O偏移量, dr_W数据写入, dr_R数据读取</div><div class="line">cur = DfirstB(0x01411EF0);//引用该数据的第一个地址</div><div class="line">Message(&quot;from d = %08x\n&quot;, cur);</div><div class="line">Message(&quot;from d = %08x\n&quot;, DnextB(0x01411EF0, cur));//引用该数据的下一个地址</div><div class="line"></div><div class="line">//database</div><div class="line">MakeUnkn(0x0043DC57, DOUNK_SIMPLE);//undefine</div><div class="line">MakeCode(0x0043DC57);//转为code</div><div class="line">//MakeUnkn(0x0043DC57, DOUNK_SIMPLE);//undefine</div><div class="line">//MakeUnkn(0x0043DC58, DOUNK_SIMPLE);//</div><div class="line">//MakeWord(0x0043DC57);//转为数据 MakeWord, MakeDword</div><div class="line">MakeComm(0x0043DC57, &quot;just for test comment&quot;);//</div><div class="line">//MakeFunction(s, e);//</div><div class="line">//MakeStr(s, e);//</div><div class="line"></div><div class="line">//search SEARCH_DOWN, SEARCH_NEXT, SEARCH_CASE</div><div class="line">Message(&quot;code = %08x\n&quot;, FindCode(0x400000, 1));//从这开始搜索一条指令</div><div class="line">Message(&quot;data = %08x\n&quot;, FindData(0x400000, 1));//从这开始搜索一个数据</div><div class="line">//Message(&quot;find = %08x\n&quot;, FindBinary(0x400000, 1, &quot;FFAB3740&quot;));//从这开始搜索hex数据</div><div class="line">auto row = 0;</div><div class="line">auto column = 0;</div><div class="line">//Message(&quot;find = %08x\n&quot;, FindText(0x400000, 1, row, column, &quot;http://&quot;));</div><div class="line"></div><div class="line">//asm</div><div class="line">Message(&quot;asm = %s\n&quot;, GetDisasm(0x0043D7D8));//asm = push    ebp             ; xxxxxxxxxxxxxxxx</div><div class="line">Message(&quot;asm = %s\n&quot;, GetMnem(0x0043D7D8));//asm = push</div><div class="line">Message(&quot;asm = %s\n&quot;, GetOpnd(0x0043D7D8, 0));//asm = ebp</div><div class="line">Message(&quot;asm = %d\n&quot;, GetOpType(0x0043D7D8, 0));//asm = 1</div><div class="line">Message(&quot;asm = %08x\n&quot;, GetOperandValue(0x0043D7D8, 0));//asm = 00000005</div><div class="line">Message(&quot;asm = %s\n&quot;, CommentEx(0x0043D7D8, 0));//asm = xxxxxxxxxxxxxxxx</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，idc语法真的挺简单的，跟c基本一样，写起来不需要多大力气，就是需要熟悉idc提供的各类功能函数，应用起来才能得心应手。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;IDC是IDA扩展的一种脚本语言，用于自动化，或者扩展查询IDA数据库&lt;/p&gt;
&lt;p&gt;可以使用IDC或者python编写&lt;/p&gt;
&lt;p&gt;语法类似C、也应用了C++类似的对象特性和异常处理&lt;/p&gt;
&lt;p&gt;可以是单独的IDC文件，通过File-&amp;gt;Script File加载，&lt;br&gt;也可以是简单的IDC命令，通过File-&amp;gt;Script Command来编写&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="IDAPro" scheme="https://anhkgg.github.io/tags/IDAPro/"/>
    
      <category term="IDC" scheme="https://anhkgg.github.io/tags/IDC/"/>
    
      <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>libcurl小记-简单http封装使用-源码分析</title>
    <link href="https://anhkgg.github.io/liburl-use-minihttp/"/>
    <id>https://anhkgg.github.io/liburl-use-minihttp/</id>
    <published>2016-08-25T12:32:06.000Z</published>
    <updated>2016-08-26T00:29:49.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前面"><a href="#0x00-前面" class="headerlink" title="0x00. 前面"></a>0x00. 前面</h1><p>以前用Wininet api包了一个简单易用的http请求的lib，但是居然会遇到系统不支持的情况，难道要我自己用socket写吗？no way！</p>
<p>以前知道liburl，第一次使用，啥都不知道，反正感觉挺强大的</p>
<p>&lt; libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP.</p>
<p>须知，我这里只用到了HTTP</p>
<p><a href="https://curl.haxx.se/" target="_blank" rel="external">home: https://curl.haxx.se/</a></p>
<p><a href="https://curl.haxx.se/libcurl/" target="_blank" rel="external">document: https://curl.haxx.se/libcurl/</a></p>
<p>其实使用比较简单，但对我没有认真看过文档，并且没有找到好资料的情况下，我遇到了很多弯路，并且想吐槽实例代码，搞那么复杂干嘛，还没有我想要的代码。</p>
<a id="more"></a>
<p>下面开始坑。</p>
<h1 id="0x01-就这么简单"><a href="#0x01-就这么简单" class="headerlink" title="0x01. 就这么简单"></a>0x01. 就这么简单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* curl stuff */ </div><div class="line">#include &lt;curl/curl.h&gt;</div><div class="line">//#pragma comment(lib, &quot;liburl.lib&quot;)</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  CURL *curl;</div><div class="line">  CURLcode res;</div><div class="line"> </div><div class="line">  /* In windows, this will init the winsock stuff */ </div><div class="line">  curl_global_init(CURL_GLOBAL_ALL);</div><div class="line"> </div><div class="line">  /* get a curl handle */ </div><div class="line">  curl = curl_easy_init();</div><div class="line">  if(curl) &#123;</div><div class="line">    /* First set the URL that is about to receive our POST. This URL can</div><div class="line">       just as well be a https:// URL if that is what should receive the</div><div class="line">       data. */ </div><div class="line">    curl_easy_setopt(curl, CURLOPT_URL, &quot;http://postit.example.com/moo.cgi&quot;);</div><div class="line">    /* Now specify the POST data */ </div><div class="line">    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;);</div><div class="line"> </div><div class="line">    /* Perform the request, res will get the return code */ </div><div class="line">    res = curl_easy_perform(curl);</div><div class="line">    /* Check for errors */ </div><div class="line">    if(res != CURLE_OK)</div><div class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</div><div class="line">              curl_easy_strerror(res));</div><div class="line"> </div><div class="line">    /* always cleanup */ </div><div class="line">    curl_easy_cleanup(curl);</div><div class="line">  &#125;</div><div class="line">  curl_global_cleanup();</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单应用就是这样子，关键在这两句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(curl, CURLOPT_URL, &quot;http://postit.example.com/moo.cgi&quot;);</div><div class="line">    /* Now specify the POST data */ </div><div class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;);</div></pre></td></tr></table></figure></p>
<p>liburl通过设置各种回调函数来完成各种功能。</p>
<h1 id="0x02-http请求"><a href="#0x02-http请求" class="headerlink" title="0x02. http请求"></a>0x02. http请求</h1><p>CURLOPT_URL ： 访问的目标url路径，如果是GET方式请求，需要将请求数据加到URL后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">www.baidu.com/login.asp?name=111&amp;password=111</div></pre></td></tr></table></figure>
<p>CURLOPT_POSTFIELDS ： POST请求中发送的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;);</div></pre></td></tr></table></figure>
<p>并且POST请求中还需要设置CURLOPT_POST为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* size of the POST data */</div><div class="line">curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, data.length());</div><div class="line">curl_easy_setopt(curl, CURLOPT_POST, 1);</div></pre></td></tr></table></figure>
<p>另外，奇葩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); //url在release可正常使用，debug去不行，只能使用url.c_str();</div></pre></td></tr></table></figure></p>
<h1 id="0x03-接收数据"><a href="#0x03-接收数据" class="headerlink" title="0x03. 接收数据"></a>0x03. 接收数据</h1><p>接收数据需要注册CURLOPT_WRITEFUNCTION回调函数，在回调函数中进行数据处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(*curl, CURLOPT_WRITEFUNCTION, write_callback);</div></pre></td></tr></table></figure>
<p>如果数据不能一次接收完成，需要利用回调中的参数来缓存数据，也就是通过CURLOPT_WRITEDATA设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(*curl, CURLOPT_WRITEDATA, data);</div></pre></td></tr></table></figure>
<p>回调函数处理中，最后一次参数就是设置的用于缓存的变量，需要注意的是数据长度，不是size，而是<code>size*nmemb</code>。 并且如果返回值不等于size*nmemb，libcurl会认为处理失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata)</div><div class="line">&#123;</div><div class="line">	size_t all_size = size*nmemb;</div><div class="line">	PWRITE_CALLBACK_DATA data = (PWRITE_CALLBACK_DATA)userdata;</div><div class="line"></div><div class="line">	data-&gt;data.append(ptr);</div><div class="line">	data-&gt;size += all_size;</div><div class="line"></div><div class="line">	return all_size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="0x04-cookie"><a href="#0x04-cookie" class="headerlink" title="0x04. cookie"></a>0x04. cookie</h1><p>通过cookie文件保存，读取cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl_easy_setopt(*curl, CURLOPT_COOKIEJAR, &quot;cookie.txt&quot;);        //把服务器发过来的cookie保存到cookie.txt</div><div class="line">curl_easy_setopt(*curl, CURLOPT_COOKIEFILE, &quot;cookie.txt&quot;);        //读取本地存储的cookie</div></pre></td></tr></table></figure>
<p>直接设置cookie信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//curl_easy_setopt(curl, CURLOPT_COOKIE, m_cookies.c_str());</div></pre></td></tr></table></figure>
<h1 id="0x05-一点点分析"><a href="#0x05-一点点分析" class="headerlink" title="0x05. 一点点分析"></a>0x05. 一点点分析</h1><p>下面是遇到坑时的一小点点源码翻阅，觉得有用的可以看看</p>
<h2 id="1-curl-easy-setopt调用中"><a href="#1-curl-easy-setopt调用中" class="headerlink" title="1. curl_easy_setopt调用中"></a>1. curl_easy_setopt调用中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//curl_easy_setopt调用中</div><div class="line">CURLcode curl_easy_setopt(struct Curl_easy *data, CURLoption tag, ...)//lib/easy.c</div><div class="line">--&gt;</div><div class="line">CURLcode Curl_setopt(struct Curl_easy *data, CURLoption option,</div><div class="line">                     va_list param)//lib/url.c</div><div class="line">&#123;</div><div class="line">    //根据option类型，设置不同回调</div><div class="line">    //保存在data-&gt;set的不同字段中</div><div class="line">    case CURLOPT_URL:</div><div class="line">    if(data-&gt;change.url_alloc) &#123;</div><div class="line">      /* the already set URL is allocated, free it first! */</div><div class="line">      Curl_safefree(data-&gt;change.url);</div><div class="line">      data-&gt;change.url_alloc = FALSE;</div><div class="line">    &#125;</div><div class="line">    result = setstropt(&amp;data-&gt;set.str[STRING_SET_URL],</div><div class="line">                       va_arg(param, char *));</div><div class="line">    data-&gt;change.url = data-&gt;set.str[STRING_SET_URL];</div><div class="line">    break;</div><div class="line">    case CURLOPT_PORT:</div><div class="line">    data-&gt;set.use_port = va_arg(param, long);</div><div class="line">    break;</div><div class="line">    case CURLOPT_WRITEFUNCTION:</div><div class="line">    data-&gt;set.fwrite_func = va_arg(param, curl_write_callback);</div><div class="line">    if(!data-&gt;set.fwrite_func) &#123;</div><div class="line">      data-&gt;set.is_fwrite_set = 0;</div><div class="line">      /* When set to NULL, reset to our internal default function */</div><div class="line">      data-&gt;set.fwrite_func = (curl_write_callback)fwrite;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">      data-&gt;set.is_fwrite_set = 1;</div><div class="line">    break;</div><div class="line">    case CURLOPT_WRITEDATA:</div><div class="line">    data-&gt;set.out = va_arg(param, void *);</div><div class="line">    break;</div><div class="line">    case CURLOPT_HTTPHEADER:</div><div class="line">    data-&gt;set.headers = va_arg(param, struct curl_slist *);</div><div class="line">    break;</div><div class="line">    case CURLOPT_COOKIEJAR:</div><div class="line">    &#123;</div><div class="line">    struct CookieInfo *newcookies;</div><div class="line">    result = setstropt(&amp;data-&gt;set.str[STRING_COOKIEJAR],</div><div class="line">                       va_arg(param, char *));</div><div class="line">    newcookies = Curl_cookie_init(data, NULL, data-&gt;cookies,</div><div class="line">                                  data-&gt;set.cookiesession);</div><div class="line">    if(!newcookies)</div><div class="line">      result = CURLE_OUT_OF_MEMORY;</div><div class="line">    data-&gt;cookies = newcookies;</div><div class="line">    &#125;</div><div class="line">    break;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-请求中"><a href="#2-请求中" class="headerlink" title="2. 请求中"></a>2. 请求中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div></pre></td><td class="code"><pre><div class="line">CURLcode curl_easy_perform(struct Curl_easy *data)//lib/easy.c</div><div class="line">-&gt;</div><div class="line">static CURLcode easy_perform(struct Curl_easy *data, bool events)//lib/easy.c</div><div class="line">-&gt;</div><div class="line">static CURLcode easy_transfer(struct Curl_multi *multi)//lib/easy.c</div><div class="line">-&gt;</div><div class="line">CURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)//\lib\multi.c</div><div class="line">&#123;</div><div class="line">  data=multi-&gt;easyp;//就是Curl_easy *data</div><div class="line">  while(data) &#123;</div><div class="line">    CURLMcode result;</div><div class="line">    SIGPIPE_VARIABLE(pipe_st);</div><div class="line"></div><div class="line">    sigpipe_ignore(data, &amp;pipe_st);</div><div class="line">    result = multi_runsingle(multi, now, data);//一次请求</div><div class="line">    sigpipe_restore(&amp;pipe_st);</div><div class="line"></div><div class="line">    if(result)</div><div class="line">      returncode = result;</div><div class="line"></div><div class="line">    data = data-&gt;next; /* operate on next handle */</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">static CURLMcode multi_runsingle(struct Curl_multi *multi,</div><div class="line">                                 struct timeval now,</div><div class="line">                                 struct Curl_easy *data)//\lib\multi.c</div><div class="line">&#123;</div><div class="line">    //这里面有个重要的字段data-&gt;mstate，表示当前curl的状态</div><div class="line">    //通过multistate(data, CURLM_STATE_PERFORM);=&gt;static void mstate(struct Curl_easy *data, CURLMstate state)赋值</div><div class="line">    //CURLMcode curl_multi_add_handle(struct Curl_multi *multi, struct Curl_easy *data) =&gt; multistate(data, CURLM_STATE_INIT);</div><div class="line">    //CURLMcode Curl_multi_add_perform(struct Curl_multi *multi, struct Curl_easy *data, struct connectdata *conn)=&gt;multistate(data, CURLM_STATE_PERFORM);</div><div class="line">    //等等</div><div class="line">    </div><div class="line">    //...</div><div class="line">    do&#123;</div><div class="line">        //本函数中，循环各种状态判断，处理不同逻辑</div><div class="line">        switch(data-&gt;mstate) &#123;</div><div class="line">        //初始化</div><div class="line">        case CURLM_STATE_INIT:</div><div class="line">          /* init this transfer. */</div><div class="line">          result=Curl_pretransfer(data);//各种信息初始化，ssl，cookie</div><div class="line">    </div><div class="line">          if(!result) &#123;</div><div class="line">            /* after init, go CONNECT */</div><div class="line">            multistate(data, CURLM_STATE_CONNECT);//状态更改</div><div class="line">            Curl_pgrsTime(data, TIMER_STARTOP);</div><div class="line">            rc = CURLM_CALL_MULTI_PERFORM;</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">         case CURLM_STATE_CONNECT:</div><div class="line">          /* Connect. We want to get a connection identifier filled in. */</div><div class="line">          Curl_pgrsTime(data, TIMER_STARTSINGLE);</div><div class="line">          result = Curl_connect(data, &amp;data-&gt;easy_conn,</div><div class="line">                                &amp;async, &amp;protocol_connect);</div><div class="line">          if(CURLE_NO_CONNECTION_AVAILABLE == result) &#123;</div><div class="line">            /* There was no connection available. We will go to the pending</div><div class="line">               state and wait for an available connection. */</div><div class="line">            multistate(data, CURLM_STATE_CONNECT_PEND);</div><div class="line">    </div><div class="line">            /* add this handle to the list of connect-pending handles */</div><div class="line">            if(!Curl_llist_insert_next(multi-&gt;pending, multi-&gt;pending-&gt;tail, data))</div><div class="line">              result = CURLE_OUT_OF_MEMORY;</div><div class="line">            else</div><div class="line">              result = CURLE_OK;</div><div class="line">            break;</div><div class="line">          &#125;</div><div class="line">    </div><div class="line">          if(!result) &#123;</div><div class="line">            /* Add this handle to the send or pend pipeline */</div><div class="line">            result = Curl_add_handle_to_pipeline(data, data-&gt;easy_conn);</div><div class="line">            if(result)</div><div class="line">              disconnect_conn = TRUE;</div><div class="line">            else &#123;</div><div class="line">              if(async)</div><div class="line">                /* We&apos;re now waiting for an asynchronous name lookup */</div><div class="line">                multistate(data, CURLM_STATE_WAITRESOLVE);</div><div class="line">              else &#123;</div><div class="line">                /* after the connect has been sent off, go WAITCONNECT unless the</div><div class="line">                   protocol connect is already done and we can go directly to</div><div class="line">                   WAITDO or DO! */</div><div class="line">                rc = CURLM_CALL_MULTI_PERFORM;</div><div class="line">    </div><div class="line">                if(protocol_connect)</div><div class="line">                  multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?</div><div class="line">                             CURLM_STATE_WAITDO:CURLM_STATE_DO);</div><div class="line">                else &#123;</div><div class="line">    #ifndef CURL_DISABLE_HTTP</div><div class="line">                  if(data-&gt;easy_conn-&gt;tunnel_state[FIRSTSOCKET] == TUNNEL_CONNECT)</div><div class="line">                    multistate(data, CURLM_STATE_WAITPROXYCONNECT);</div><div class="line">                  else</div><div class="line">    #endif</div><div class="line">                    multistate(data, CURLM_STATE_WAITCONNECT);</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">        case CURLM_STATE_DO://开始发送</div><div class="line">            /* Perform the protocol&apos;s DO action */</div><div class="line">            result = multi_do(&amp;data-&gt;easy_conn, &amp;dophase_done);</div><div class="line">            //-&gt;</div><div class="line">            //详细的http请求封装，可以看看这个Curl_http</div><div class="line">            //CURLcode Curl_http(struct connectdata *conn, bool *done)//\lib\http.c</div><div class="line">            </div><div class="line">        case CURLM_STATE_DONE:</div><div class="line">            /* post-transfer command */</div><div class="line">            res = multi_done(&amp;data-&gt;easy_conn, result, FALSE);</div><div class="line">            </div><div class="line">        case CURLM_STATE_PERFORM:</div><div class="line">            /* read/write data if it is ready to do so */</div><div class="line">            result = Curl_readwrite(data-&gt;easy_conn, data, &amp;done);//接受数据中</div><div class="line"></div><div class="line">        //...</div><div class="line">        </div><div class="line">    &#125;while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));</div><div class="line"></div><div class="line">  data-&gt;result = result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//所有状态</div><div class="line">/* NOTE: if you add a state here, add the name to the statename[] array as</div><div class="line">   well!</div><div class="line">*/</div><div class="line">typedef enum &#123;</div><div class="line">  CURLM_STATE_INIT,         /* 0 - start in this state */</div><div class="line">  CURLM_STATE_CONNECT_PEND, /* 1 - no connections, waiting for one */</div><div class="line">  CURLM_STATE_CONNECT,      /* 2 - resolve/connect has been sent off */</div><div class="line">  CURLM_STATE_WAITRESOLVE,  /* 3 - awaiting the resolve to finalize */</div><div class="line">  CURLM_STATE_WAITCONNECT,  /* 4 - awaiting the TCP connect to finalize */</div><div class="line">  CURLM_STATE_WAITPROXYCONNECT, /* 5 - awaiting proxy CONNECT to finalize */</div><div class="line">  CURLM_STATE_SENDPROTOCONNECT, /* 6 - initiate protocol connect procedure */</div><div class="line">  CURLM_STATE_PROTOCONNECT, /* 7 - completing the protocol-specific connect</div><div class="line">                                   phase */</div><div class="line">  CURLM_STATE_WAITDO,       /* 8 - wait for our turn to send the request */</div><div class="line">  CURLM_STATE_DO,           /* 9 - start send off the request (part 1) */</div><div class="line">  CURLM_STATE_DOING,        /* 10 - sending off the request (part 1) */</div><div class="line">  CURLM_STATE_DO_MORE,      /* 11 - send off the request (part 2) */</div><div class="line">  CURLM_STATE_DO_DONE,      /* 12 - done sending off request */</div><div class="line">  CURLM_STATE_WAITPERFORM,  /* 13 - wait for our turn to read the response */</div><div class="line">  CURLM_STATE_PERFORM,      /* 14 - transfer data */</div><div class="line">  CURLM_STATE_TOOFAST,      /* 15 - wait because limit-rate exceeded */</div><div class="line">  CURLM_STATE_DONE,         /* 16 - post data transfer operation */</div><div class="line">  CURLM_STATE_COMPLETED,    /* 17 - operation complete */</div><div class="line">  CURLM_STATE_MSGSENT,      /* 18 - the operation complete message is sent */</div><div class="line">  CURLM_STATE_LAST          /* 19 - not a true state, never use this */</div><div class="line">&#125; CURLMstate;</div><div class="line"></div><div class="line"></div><div class="line">//单独看connect</div><div class="line">CURLcode Curl_connect(struct Curl_easy *data,</div><div class="line">                      struct connectdata **in_connect,</div><div class="line">                      bool *asyncp,</div><div class="line">                      bool *protocol_done)</div><div class="line">&#123;</div><div class="line">    static CURLcode create_conn(struct Curl_easy *data,</div><div class="line">                            struct connectdata **in_connect,</div><div class="line">                            bool *async)</div><div class="line">    -&gt;</div><div class="line">    static CURLcode resolve_server(struct Curl_easy *data,</div><div class="line">                               struct connectdata *conn,</div><div class="line">                               bool *async)</div><div class="line">                               </div><div class="line">&#125;  </div><div class="line"></div><div class="line">result = Curl_async_resolved(data-&gt;easy_conn, &amp;protocol_connect);-&gt;</div><div class="line">result = Curl_setup_conn(conn, protocol_done);-&gt;</div><div class="line">result = Curl_connecthost(conn, conn-&gt;dns_entry);-&gt;</div><div class="line">result = singleipconnect(conn, conn-&gt;tempaddr[0], &amp;(conn-&gt;tempsock[0]));-&gt;</div><div class="line">static CURLcode singleipconnect(struct connectdata *conn,</div><div class="line">                                const Curl_addrinfo *ai,</div><div class="line">                                curl_socket_t *sockp)</div><div class="line">-&gt;</div><div class="line">CURLcode Curl_socket(struct connectdata *conn,</div><div class="line">                     const Curl_addrinfo *ai,</div><div class="line">                     struct Curl_sockaddr_ex *addr,</div><div class="line">                     curl_socket_t *sockfd)</div><div class="line">                     </div><div class="line">//Crul对socket等的封装</div><div class="line">//\lib\connect.c</div><div class="line">CURLcode Curl_socket(struct connectdata *conn,</div><div class="line">                     const Curl_addrinfo *ai,</div><div class="line">                     struct Curl_sockaddr_ex *addr,</div><div class="line">                     curl_socket_t *sockfd)</div><div class="line">CURLcode Curl_connecthost(struct connectdata *conn,  /* context */</div><div class="line">                          const struct Curl_dns_entry *remotehost)           int Curl_closesocket(struct connectdata *conn,</div><div class="line">                      curl_socket_t sock)</div><div class="line">curl_socket_t Curl_getconnectinfo(struct Curl_easy *data,</div><div class="line">                                  struct connectdata **connp)</div></pre></td></tr></table></figure>
<h2 id="3-接受数据时"><a href="#3-接受数据时" class="headerlink" title="3. 接受数据时"></a>3. 接受数据时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">static CURLMcode multi_runsingle(struct Curl_multi *multi,</div><div class="line">                                 struct timeval now,</div><div class="line">                                 struct Curl_easy *data)//\lib\multi.c</div><div class="line">-&gt;</div><div class="line">CURLcode Curl_readwrite(struct connectdata *conn,</div><div class="line">                        struct Curl_easy *data,</div><div class="line">                        bool *done)//\lib\transfer.c</div><div class="line">&#123;</div><div class="line"> /* We go ahead and do a read if we have a readable socket or if</div><div class="line">     the stream was rewound (in which case we have data in a</div><div class="line">     buffer) */</div><div class="line">  if((k-&gt;keepon &amp; KEEP_RECV) &amp;&amp;</div><div class="line">     ((select_res &amp; CURL_CSELECT_IN) || conn-&gt;bits.stream_was_rewound)) &#123;</div><div class="line"></div><div class="line">    result = readwrite_data(data, conn, k, &amp;didwhat, done);//</div><div class="line">    if(result || *done)</div><div class="line">      return result;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">static CURLcode readwrite_data(struct Curl_easy *data,</div><div class="line">                               struct connectdata *conn,</div><div class="line">                               struct SingleRequest *k,</div><div class="line">                               int *didwhat, bool *done)//\lib\transfer.c</div><div class="line">&#123;</div><div class="line">    //接受头部</div><div class="line">    result = Curl_http_readwrite_headers(data, conn, &amp;nread, &amp;stop_reading);</div><div class="line">    //-&gt;</div><div class="line">    //CURLcode Curl_client_write(struct connectdata *conn,</div><div class="line">    //                       int type,</div><div class="line">    //                       char *ptr,</div><div class="line">    //                       size_t len)//lib\sendf.c</div><div class="line">    </div><div class="line">    //接受数据</div><div class="line">    result = Curl_client_write(conn, CLIENTWRITE_BODY, k-&gt;str,</div><div class="line">                                           nread);</div><div class="line">    //-》</div><div class="line">    //Curl_client_write-&gt;Curl_client_chop_write-&gt; 调用回调函数</div><div class="line">    //</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用回调函数</div><div class="line">CURLcode Curl_client_chop_write(struct connectdata *conn,</div><div class="line">                                int type,</div><div class="line">                                char * ptr,</div><div class="line">                                size_t len)</div><div class="line">&#123;               </div><div class="line"></div><div class="line">    curl_write_callback writeheader = NULL;</div><div class="line">    curl_write_callback writebody = NULL;</div><div class="line">    //...</div><div class="line">    </div><div class="line">    /* Determine the callback(s) to use. */</div><div class="line">  if(type &amp; CLIENTWRITE_BODY)</div><div class="line">    writebody = data-&gt;set.fwrite_func;</div><div class="line">    </div><div class="line">    if(writebody) &#123;</div><div class="line">        //调用回调函数</div><div class="line">      size_t wrote = writebody(ptr, 1, chunklen, data-&gt;set.out);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-cookie相关"><a href="#4-cookie相关" class="headerlink" title="4. cookie相关"></a>4. cookie相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">//解析指定的cookie文件</div><div class="line">//支持# Netscape HTTP Cookie File和Mozilla cookie</div><div class="line">CURLcode Curl_pretransfer(struct Curl_easy *data)//lib\transfer.c</div><div class="line">&#123;</div><div class="line"> /* If there is a list of cookie files to read, do it now! */</div><div class="line">  if(data-&gt;change.cookielist)//cookie文件列表</div><div class="line">    Curl_cookie_loadfiles(data);</div><div class="line">&#125;</div><div class="line">-&gt;</div><div class="line">void Curl_cookie_loadfiles(struct Curl_easy *data)//lib\cookie.c</div><div class="line">-&gt;</div><div class="line">//读取cookie文件，初始化cookie结构</div><div class="line">struct CookieInfo *Curl_cookie_init(struct Curl_easy *data,</div><div class="line">                                    const char *file,</div><div class="line">                                    struct CookieInfo *inc,</div><div class="line">                                    bool newsession)//lib\cookie.c</div><div class="line">-&gt;</div><div class="line">//lineptr是从cookie.txt中读取的每行数据，解析数据，插入CookieInfo链</div><div class="line">struct Cookie *</div><div class="line">Curl_cookie_add(struct Curl_easy *data,</div><div class="line">                /* The &apos;data&apos; pointer here may be NULL at times, and thus</div><div class="line">                   must only be used very carefully for things that can deal</div><div class="line">                   with data being NULL. Such as infof() and similar */</div><div class="line"></div><div class="line">                struct CookieInfo *c,</div><div class="line">                bool httpheader, /* TRUE if HTTP header-style line */</div><div class="line">                char *lineptr,   /* first character of the line */</div><div class="line">                const char *domain, /* default domain */</div><div class="line">                const char *path)   /* full path used when this cookie is set,</div><div class="line">                                       used to get default path for the cookie</div><div class="line">                                       unless set */</div><div class="line">&#123;</div><div class="line">//...</div><div class="line">clist = c-&gt;cookies;</div><div class="line">  replace_old = FALSE;</div><div class="line">  while(clist) &#123;</div><div class="line">    if(Curl_raw_equal(clist-&gt;name, co-&gt;name)) &#123;</div><div class="line">      /* the names are identical */</div><div class="line"></div><div class="line">      if(clist-&gt;domain &amp;&amp; co-&gt;domain) &#123;</div><div class="line">        if(Curl_raw_equal(clist-&gt;domain, co-&gt;domain))</div><div class="line">          /* The domains are identical */</div><div class="line">          replace_old=TRUE;</div><div class="line">      &#125;</div><div class="line">      else if(!clist-&gt;domain &amp;&amp; !co-&gt;domain)</div><div class="line">        replace_old = TRUE;</div><div class="line"></div><div class="line">      if(replace_old) &#123;</div><div class="line">        /* the domains were identical */</div><div class="line"></div><div class="line">        if(clist-&gt;spath &amp;&amp; co-&gt;spath) &#123;</div><div class="line">          if(Curl_raw_equal(clist-&gt;spath, co-&gt;spath)) &#123;</div><div class="line">            replace_old = TRUE;</div><div class="line">          &#125;</div><div class="line">          else</div><div class="line">            replace_old = FALSE;</div><div class="line">        &#125;</div><div class="line">        else if(!clist-&gt;spath &amp;&amp; !co-&gt;spath)</div><div class="line">          replace_old = TRUE;</div><div class="line">        else</div><div class="line">          replace_old = FALSE;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      //。。。</div><div class="line"></div><div class="line">      if(replace_old) &#123;</div><div class="line">        co-&gt;next = clist-&gt;next; /* get the next-pointer first */</div><div class="line"></div><div class="line">        *clist = *co;  /* then store all the new data */</div><div class="line"></div><div class="line">        free(co);   /* free the newly alloced memory */</div><div class="line">        co = clist; /* point to the previous struct instead */</div><div class="line"></div><div class="line">        /* We have replaced a cookie, now skip the rest of the list but</div><div class="line">           make sure the &apos;lastc&apos; pointer is properly set */</div><div class="line">        do &#123;</div><div class="line">          lastc = clist;</div><div class="line">          clist = clist-&gt;next;</div><div class="line">        &#125; while(clist);</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    lastc = clist;</div><div class="line">    clist = clist-&gt;next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if(c-&gt;running)</div><div class="line">    /* Only show this when NOT reading the cookies from a file */</div><div class="line">    infof(data, &quot;%s cookie %s=\&quot;%s\&quot; for domain %s, path %s, &quot;</div><div class="line">          &quot;expire %&quot; CURL_FORMAT_CURL_OFF_T &quot;\n&quot;,</div><div class="line">          replace_old?&quot;Replaced&quot;:&quot;Added&quot;, co-&gt;name, co-&gt;value,</div><div class="line">          co-&gt;domain, co-&gt;path, co-&gt;expires);</div><div class="line"></div><div class="line">  if(!replace_old) &#123;</div><div class="line">    /* then make the last item point on this new one */</div><div class="line">    if(lastc)</div><div class="line">      lastc-&gt;next = co;</div><div class="line">    else</div><div class="line">      c-&gt;cookies = co;</div><div class="line">    c-&gt;numcookies++; /* one more cookie in the jar */</div><div class="line">  &#125;</div><div class="line"> //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="0x06-其他"><a href="#0x06-其他" class="headerlink" title="0x06. 其他"></a>0x06. 其他</h1><p>封装了一份简单的http类，支持GET、POST、ajax，代码比较简单，有需要的可以拿来用，后续可能会更新</p>
<p>源码：<a href="https://github.com/anhkgg/minihttp" target="_blank" rel="external">https://github.com/anhkgg/minihttp</a></p>
<p><a href="https://curl.haxx.se/libcurl/" target="_blank" rel="external">https://curl.haxx.se/libcurl/</a></p>
<p><a href="http://www.liyuduo.com/?p=1103" target="_blank" rel="external">https://curl.haxx.se/libcurl/3</a></p>
<p><a href="http://blog.csdn.net/breaksoftware/article/details/45874197" target="_blank" rel="external">http://blog.csdn.net/breaksoftware/article/details/45874197</a></p>
<p>转载请注明出处：<a href="http://anhkgg.github.io/liburl-use-minihttp/">http://anhkgg.github.io/liburl-use-minihttp/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前面&quot;&gt;&lt;a href=&quot;#0x00-前面&quot; class=&quot;headerlink&quot; title=&quot;0x00. 前面&quot;&gt;&lt;/a&gt;0x00. 前面&lt;/h1&gt;&lt;p&gt;以前用Wininet api包了一个简单易用的http请求的lib，但是居然会遇到系统不支持的情况，难道要我自己用socket写吗？no way！&lt;/p&gt;
&lt;p&gt;以前知道liburl，第一次使用，啥都不知道，反正感觉挺强大的&lt;/p&gt;
&lt;p&gt;&amp;lt; libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP.&lt;/p&gt;
&lt;p&gt;须知，我这里只用到了HTTP&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;home: https://curl.haxx.se/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/libcurl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;document: https://curl.haxx.se/libcurl/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实使用比较简单，但对我没有认真看过文档，并且没有找到好资料的情况下，我遇到了很多弯路，并且想吐槽实例代码，搞那么复杂干嘛，还没有我想要的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://anhkgg.github.io/categories/code/"/>
    
    
      <category term="libcurl" scheme="https://anhkgg.github.io/tags/libcurl/"/>
    
      <category term="http" scheme="https://anhkgg.github.io/tags/http/"/>
    
      <category term="minihttp" scheme="https://anhkgg.github.io/tags/minihttp/"/>
    
      <category term="get_post_ajax" scheme="https://anhkgg.github.io/tags/get-post-ajax/"/>
    
  </entry>
  
  <entry>
    <title>pin使用小记-函数分析</title>
    <link href="https://anhkgg.github.io/pin-use-note-function-analysis/"/>
    <id>https://anhkgg.github.io/pin-use-note-function-analysis/</id>
    <published>2016-07-28T05:27:33.000Z</published>
    <updated>2016-07-28T05:42:35.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相关：<a href="https://software.intel.com/en-us/articles/pintool/" target="_blank" rel="external">pin是什么</a>  <a href="https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/" target="_blank" rel="external">pin可以做什么</a>  <a href="https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/index.html#EXAMPLES" target="_blank" rel="external">pin examples</a></p>
<p>此次使用pin目的，是为了能够应用pin在函数分析方面的功能，以及XXXInsertCall的功能</p>
<p>由于此前对pin了解不够深入，以为可以实现相应功能，哪知撞了南墙才知道pin也有些许局限。</p>
<p>下面将我对了解到的pin可以实现以及不能实现的各种坑写作笔记。</p>
<a id="more"></a>
<h1 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h1><h2 id="RTN"><a href="#RTN" class="headerlink" title="RTN"></a>RTN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PIN_CALLBACK 	LEVEL_PINCLIENT::RTN_AddInstrumentFunction (RTN_INSTRUMENT_CALLBACK fun, VOID *val)</div></pre></td></tr></table></figure>
<p>使用<code>RTN_AddInstrumentFunction</code>即可对分析目标添加函数级插桩，在设置的回调中可以获取函数的各种信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef VOID(*) LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK(RTN rtn, VOID *v)</div></pre></td></tr></table></figure>
<p>回调函数中rtn就表示被插桩的该函数，通过RTN_XXX相关函数可以获取函数的名字、地址、大小、范围等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const string &amp; 	LEVEL_PINCLIENT::RTN_Name (RTN x)</div><div class="line">ADDRINT 	LEVEL_PINCLIENT::RTN_Address (RTN rtn)</div><div class="line">USIZE 	LEVEL_PINCLIENT::RTN_Size (RTN rtn)</div><div class="line">USIZE 	LEVEL_PINCLIENT::RTN_Range (RTN rtn)</div></pre></td></tr></table></figure>
<p>不得不提一个函数，<code>RTN_FindByName</code>类似于GetProcAddress，可以获取img(模块对象)中指定名字的rtn对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTN 	LEVEL_PINCLIENT::RTN_FindByName (IMG img, const CHAR *name)</div></pre></td></tr></table></figure>
<p>也可以通过地址来获取对应的rtn对象，但是如果对应函数没有符号信息，获取到的rtn是不对的，会找到最小范围内满足的rtn对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RTN 	LEVEL_PINCLIENT::RTN_FindByAddress (ADDRINT address)</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>初以为RTN表示所有函数对象，像IDA一样能将基本所有函数分析出来，哪知吃了不看文档的亏(虽然知道使用RTN之前需要调用符号相关初始化)。</p>
<blockquote>
<p>A RTN represents the functions/routines/procedures typically produced by a compiler for a procedural programming language such as C. Pin finds routines by using the symbol table information. You must call PIN_InitSymbols() so that symbol table information will be available. Can be accessed at instrumentation time and analysis time.</p>
</blockquote>
<p>也就是说pin是根据符号信息来分析函数，生成RTN对象。那么没有符号信息的函数，像IDA中的是那么<code>sub_xxxx</code>也就没有可能这么方便的使用了。</p>
<p>当然，如果需求是对有符号信息的函数，比如对系统函数的分析，那么RTN还是能够提供相当nb的功能的。记得调用<code>PIN_InitSymbols()</code>初始化符号信息。</p>
<h3 id="maybe-hook"><a href="#maybe-hook" class="headerlink" title="maybe hook"></a>maybe hook</h3><p>pin可以实现类似于对函数hook的功能，有两类，第一类用在JIT模式下，另一类用在Probe模式下。</p>
<p>先说JIT模式下使用的<code>RTN_InsertCall</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VOID LEVEL_PINCLIENT::RTN_InsertCall	(	RTN 	rtn,</div><div class="line">IPOINT 	action,</div><div class="line">AFUNPTR 	funptr,</div><div class="line"> 	...	 </div><div class="line">)</div></pre></td></tr></table></figure>
<blockquote>
<p>Insert call relative to a rtn.</p>
</blockquote>
<p>使用这个函数注册一个回调函数，该回调函数可以在rtn调用前（IPOINT_BEFORE）或者调用后（IPOINT_AFTER）被调用。可以给回调函数传递各种信息，使用第三个参数之后的内容传递。</p>
<p>pin中各种XXX_InsertCall传递参数有一个统一的类型<code>IARG_TYPE</code>。这里简单说一下传递方法，具体要根据<code>IARG_TYPE</code>说明来使用，大致分为两种：</p>
<ol>
<li>只需要指定IARG_XXX类型，pin自己传递具体值给回调函数</li>
<li>指定IARG_XXX类型，开发者传递类型对应的具体值</li>
</ol>
<p>必须以IARG_END表示参数结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//pin传递值，只需要指定类型即可</div><div class="line">IARG_RETURN_IP 	Type: ADDRINT. Return address for function call, valid only at the function entry point.</div><div class="line">IARG_ORIG_FUNCPTR 	Type: AFUNPTR. Function pointer to the relocated entry of the original uninstrumented function.</div><div class="line">IARG_PROTOTYPE 	Type: PROTO. The function prototype of the application function. See Prototypes.</div><div class="line">IARG_THREAD_ID 	Type: THREADID. Application thread id.</div><div class="line">//开发者需要自己传递具体值</div><div class="line">IARG_ADDRINT 	Type: ADDRINT. Constant value (additional arg required).</div><div class="line">IARG_PTR 	Type: &quot;VOID *&quot;. Constant value (additional pointer arg required).</div><div class="line">IARG_BOOL 	Type: BOOL. Constant (additional BOOL arg required).</div><div class="line">IARG_UINT32 	Type: UINT32. Constant (additional integer arg required).</div><div class="line">IARG_INST_PTR 	Type: ADDRINT. The address of the instrumented instruction. This value does not change at IPOINT_AFTER. This is simply shorthand for IARG_ADDRINT, INS_Address(ins).</div><div class="line">IARG_REG_VALUE 	Type: ADDRINT for integer register. Value of a register (additional register arg required) REG: Register Object Basically, this cannot be used to retrieve the value of registers whose size is different than ADDRINT&apos;s (i.e.: x87/XMM/YMM/ZMM registers) or registeres which are not architectural (REG_PIN_*), but there are some exceptions for this rule.</div></pre></td></tr></table></figure>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">char* p = &quot;this is log info.&quot;;</div><div class="line">BOOL log_falg = TRUE;</div><div class="line">ADDRINT addr = RTN_Address(rtn);</div><div class="line">RTN_InsertCall(rtn, IPOINT_BEFORE, RtnClk, </div><div class="line">                IARG_ORIG_FUNCPTR, </div><div class="line">                IARG_RETURN_IP, </div><div class="line">                IARG_ADDRINT, addr, </div><div class="line">                IARG_PTR, p,</div><div class="line">                IARG_BOOL, log_falg,</div><div class="line">                IARG_END);</div><div class="line">                </div><div class="line">VOID RtnClk(ADDRINT OrigFunc, ADDRINT retIp, ADDRINT addr, void* log, BOOL log_falg)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Probe模式下使用下面两个函数，其实没有弄明白这两个函数和JIT模式下RTN_InserCall的区别，暂时就不做深入了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">VOID 	LEVEL_PINCLIENT::RTN_InsertCallProbed (RTN orgRtn, IPOINT action, AFUNPTR funptr,...)</div><div class="line">VOID 	LEVEL_PINCLIENT::RTN_InsertCallProbedEx (RTN orgRtn, IPOINT action, PROBE_MODE mode, AFUNPTR funptr,...)</div></pre></td></tr></table></figure>
<blockquote>
<p>Insert a call to an analysis routine relative to a RTN.</p>
</blockquote>
<p>其他<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RTN_ReplaceProbed</div><div class="line">RTN_ReplaceProbedEx</div></pre></td></tr></table></figure></p>
<p>下面一个示例，可能更符合对函数hook的理解，这里使用到的是RTN_ReplaceSignatureProbed</p>
<p>这种方式需要向函数hook一样指定函数原型，也就是需要知道函数需要哪些参数，调用方式等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">typedef VOID * ( *FP_MALLOC )( size_t );</div><div class="line"></div><div class="line">// This is the replacement routine.</div><div class="line">//</div><div class="line">VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )</div><div class="line">&#123;</div><div class="line">    // Normally one would do something more interesting with this data.</div><div class="line">    //</div><div class="line">    cout &lt;&lt; &quot;NewMalloc (&quot;</div><div class="line">         &lt;&lt; hex &lt;&lt; ADDRINT ( orgFuncptr ) &lt;&lt; &quot;, &quot; </div><div class="line">         &lt;&lt; dec &lt;&lt; arg0 &lt;&lt; &quot;, &quot; </div><div class="line">         &lt;&lt; hex &lt;&lt; returnIp &lt;&lt; &quot;)&quot;</div><div class="line">         &lt;&lt; endl &lt;&lt; flush;</div><div class="line"></div><div class="line">    // Call the relocated entry point of the original (replaced) routine.</div><div class="line">    //</div><div class="line">    VOID * v = orgFuncptr( arg0 );</div><div class="line"></div><div class="line">    return v;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// Pin calls this function every time a new img is loaded.</div><div class="line">// It is best to do probe replacement when the image is loaded,</div><div class="line">// because only one thread knows about the image at this time.</div><div class="line">//</div><div class="line">VOID ImageLoad( IMG img, VOID *v )</div><div class="line">&#123;</div><div class="line">    // See if malloc() is present in the image.  If so, replace it.</div><div class="line">    //</div><div class="line">    RTN rtn = RTN_FindByName( img, &quot;malloc&quot; );</div><div class="line">    </div><div class="line">    if (RTN_Valid(rtn))</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; &quot;Replacing malloc in &quot; &lt;&lt; IMG_Name(img) &lt;&lt; endl;</div><div class="line">        </div><div class="line">        // Define a function prototype that describes the application routine</div><div class="line">        // that will be replaced.</div><div class="line">        //</div><div class="line">        PROTO proto_malloc = PROTO_Allocate( PIN_PARG(void *), CALLINGSTD_DEFAULT,</div><div class="line">                                             &quot;malloc&quot;, PIN_PARG(int), PIN_PARG_END() );</div><div class="line">        </div><div class="line">        // Replace the application routine with the replacement function.</div><div class="line">        // Additional arguments have been added to the replacement routine.</div><div class="line">        //</div><div class="line">        RTN_ReplaceSignatureProbed(rtn, AFUNPTR(NewMalloc),</div><div class="line">                                   IARG_PROTOTYPE, proto_malloc,</div><div class="line">                                   IARG_ORIG_FUNCPTR,</div><div class="line">                                   IARG_FUNCARG_ENTRYPOINT_VALUE, 0,</div><div class="line">                                   IARG_RETURN_IP,</div><div class="line">                                   IARG_END);</div><div class="line"></div><div class="line">        // Free the function prototype.</div><div class="line">        //</div><div class="line">        PROTO_Free( proto_malloc );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="can-be-hook"><a href="#can-be-hook" class="headerlink" title="can be hook"></a>can be hook</h3><p>另外pin还提供对任意地址做hook的函数，也就是PIN_InsertCallProbed。</p>
<p>显然这也是用于Probe模式下的函数，顺便就说一下Probe模式下需要注意，调用PIN_StartProgramProbed()启动目标进程，这样子之后，JIT模式的很多函数就不能使用了。正是因为这个，如RTN、INS、Trace插桩函数不能使用，只能通过IMG插桩，在回调中进行函数的分析，想下面的实例代码中一样。</p>
<p>这样就给我要实现的功能带来了麻烦，无法通过INS插桩分析call xxx的目标地址，更别说后续的使用PIN_InsertCallProbed来对函数hook了，这样子PIN_InsertCallProbed对我来说显得很鸡肋。</p>
<blockquote>
<p>PIN_StartProgramProbed() must be used when using this API.<br>Use RTN_IsSafeForProbedInsertion() to determine if a function is a suitable candidate for probed function insertion.</p>
</blockquote>
<p>不过，我觉得这种模式更类似于函数hook，不会像上面指定IPOINT_BEFORE，它更像hook一样只是对函数进行inline hook（或者其他方式）。</p>
<p>使用示例(代码来自于pin例子源码<code>source\tools\Probes\insert_call_probed.cpp</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">void Notification(ADDRINT val)</div><div class="line">&#123;</div><div class="line">    char buff[80];</div><div class="line"></div><div class="line">    if (!writeFun)</div><div class="line">    &#123;</div><div class="line">        fprintf(stderr, &quot;Write Function was not initialized ...\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sprintf(buff, &quot;Notification value: %p&quot;, Addrint2VoidStar(val));</div><div class="line">    writeFun(buff);</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID ImageLoad(IMG img, VOID *v)</div><div class="line">&#123;</div><div class="line">    const ANNOTATION *ann = 0;</div><div class="line">    USIZE num = 0;</div><div class="line"></div><div class="line">    printf(&quot;Processing %s\n&quot;, IMG_Name(img).c_str());</div><div class="line">    </div><div class="line">    for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))</div><div class="line">    &#123;</div><div class="line">        if (SEC_Name(sec) == &quot;MyAnnot&quot;)</div><div class="line">        &#123;</div><div class="line">            ann = reinterpret_cast&lt;const ANNOTATION*&gt;(SEC_Data(sec));</div><div class="line">            num = SEC_Size(sec) / sizeof(ANNOTATION);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ann)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Found annotations: \n&quot;);</div><div class="line">        for (UINT32 i = 0; i &lt; num; i++)</div><div class="line">        &#123;</div><div class="line">            ADDRINT addr = ann[i].addr + IMG_LoadOffset(img);</div><div class="line">            ADDRINT val = ann[i].value;</div><div class="line">            printf(&quot;\t%p %p\t&quot;, Addrint2VoidStar(addr), Addrint2VoidStar(val));</div><div class="line">            if (PIN_IsSafeForProbedInsertion(addr)) //检查addr对应指令是否可以做hook</div><div class="line">            &#123;</div><div class="line">                PIN_InsertCallProbed(addr, AFUNPTR(Notification), IARG_ADDRINT, val, IARG_END);</div><div class="line">                printf(&quot; - OK\n&quot;);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                printf(&quot; - Failed\n&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Set the write line function, from the image of the annotations (i.e. the main executable).</div><div class="line">        RTN writeRtn = RTN_FindByName(img, &quot;write_line&quot;);</div><div class="line">        if (RTN_Valid(writeRtn))</div><div class="line">        &#123;</div><div class="line">            writeFun = (void (*)(char *))RTN_Funptr(writeRtn);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printf(&quot;Completed %s\n&quot;, IMG_Name(img).c_str());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="INS"><a href="#INS" class="headerlink" title="INS"></a>INS</h2><p>INS表示某地址对应的指令对象，通过INS_XXX函数可以获取指令对应汇编代码，可以判断指令时什么类型，也可以对INS进行插桩。</p>
<blockquote>
<p>An INS represents an instruction. Can only be accessed at instrumentation time.</p>
</blockquote>
<p>下面列出一部分函数，看名字就知道干什么的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">string 	LEVEL_CORE::INS_Disassemble (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsLea (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsNop (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsCall (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsProcedureCall (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsRet (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsSysret (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsSyscall (INS ins)</div><div class="line"></div><div class="line">ADDRINT 	LEVEL_PINCLIENT::INS_Address (INS ins)</div><div class="line">USIZE 	LEVEL_PINCLIENT::INS_Size (INS ins)</div><div class="line">RTN 	LEVEL_PINCLIENT::INS_Rtn (INS x)</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsBranch (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsDirectBranch (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsDirectCall (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsDirectBranchOrCall (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsBranchOrCall (INS ins)</div><div class="line">BOOL 	LEVEL_CORE::INS_IsIndirectBranchOrCall (INS ins)</div><div class="line"></div><div class="line">ADDRINT 	LEVEL_PINCLIENT::INS_DirectBranchOrCallTargetAddress (INS ins)</div></pre></td></tr></table></figure>
<p>下面主要对用到的几个函数，对其理解做一下笔记。</p>
<h3 id="call-branch"><a href="#call-branch" class="headerlink" title="call/branch"></a>call/branch</h3><p>上面提到我要对call xxx中xxx的信息进行获取，就需要用到对INS的分析，进而通过插桩来获取地址。</p>
<p>用到了下面几个函数对指令进行判断，是否是call。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BOOL 	LEVEL_CORE::INS_IsCall (INS ins)</div><div class="line">//call，不管目标是不是地址，或者寄存器等</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsBranch (INS ins) </div><div class="line">//jmp,jz,jnz等等，不管目标是不是地址，或者寄存器等</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsDirectBranch (INS ins)</div><div class="line">//jmp,jz,jnz等等，目标是地址</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsDirectCall (INS ins)</div><div class="line">//call xxx，目标是地址</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsDirectBranchOrCall (INS ins)</div><div class="line">//call,jmp,jz,jnz等等，目标是地址</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsBranchOrCall (INS ins)</div><div class="line">//call,jmp,jz,jnz等等，不管目标是不是地址，或者寄存器等</div><div class="line"></div><div class="line">BOOL 	LEVEL_CORE::INS_IsIndirectBranchOrCall (INS ins)</div><div class="line">//call,jmp,jz,jnz等等，目标是寄存器</div></pre></td></tr></table></figure>
<h3 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h3><p>如果INS满足INS_IsDirectBranchOrCall，可以直接通过<code>INS_DirectBranchOrCallTargetAddress</code>获取到目标地址。</p>
<p>如果INS是<code>INS_IsIndirectBranchOrCall</code>，那么只有通过插桩来获取目标地址。插桩是必须使用<code>IPOINT_TAKEN_BRANCH</code>类型的action，然后再回调函数中可以通过寄存器来获取目标地址。</p>
<p>如下所示代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)RttiCall, IARG_CONTEXT, IARG_INST_PTR, IARG_END);</div><div class="line"></div><div class="line">void RttiCall(CONTEXT* ctx, ADDRINT addr)</div><div class="line">&#123;</div><div class="line">    ADDRINT TakenIP = (ADDRINT)PIN_GetContextReg(ctx, REG_INST_PTR);</div><div class="line">	ADDRINT RIP = (ADDRINT)PIN_GetContextReg(ctx, REG_RIP);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面对RNT，INS使用的相关总结，已经可以拿到call xxx的目标地址，也可以对任意地址进行插桩（hook），但是就在JIT\Probe两个模式中找不到可以以结合的地方。</p>
<ol>
<li>JIT模式下，可以通过INS拿到目标地址，但是不能对目标地址进行插桩</li>
<li>Probe模式下，可以对目标地址插桩，但是拿不到目标地址</li>
</ol>
<p>不知道pin是否可以满足这种需求，但在我目前看到的东西里，是没法实现了。</p>
<p>如果有过路的高人，想可以指点一二，不甚感激。</p>
<p>另外总结一下pin中各对象的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IMG-&gt;SEC-&gt;BBL-&gt;RTN-&gt;INS</div></pre></td></tr></table></figure></p>
<p>完结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;相关：&lt;a href=&quot;https://software.intel.com/en-us/articles/pintool/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pin是什么&lt;/a&gt;  &lt;a href=&quot;https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pin可以做什么&lt;/a&gt;  &lt;a href=&quot;https://software.intel.com/sites/landingpage/pintool/docs/76991/Pin/html/index.html#EXAMPLES&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pin examples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此次使用pin目的，是为了能够应用pin在函数分析方面的功能，以及XXXInsertCall的功能&lt;/p&gt;
&lt;p&gt;由于此前对pin了解不够深入，以为可以实现相应功能，哪知撞了南墙才知道pin也有些许局限。&lt;/p&gt;
&lt;p&gt;下面将我对了解到的pin可以实现以及不能实现的各种坑写作笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="pin" scheme="https://anhkgg.github.io/tags/pin/"/>
    
      <category term="pintool" scheme="https://anhkgg.github.io/tags/pintool/"/>
    
      <category term="function analysis" scheme="https://anhkgg.github.io/tags/function-analysis/"/>
    
      <category term="hook" scheme="https://anhkgg.github.io/tags/hook/"/>
    
      <category term="insertcall" scheme="https://anhkgg.github.io/tags/insertcall/"/>
    
      <category term="instrument" scheme="https://anhkgg.github.io/tags/instrument/"/>
    
      <category term="asm" scheme="https://anhkgg.github.io/tags/asm/"/>
    
      <category term="插桩" scheme="https://anhkgg.github.io/tags/%E6%8F%92%E6%A1%A9/"/>
    
      <category term="钩子" scheme="https://anhkgg.github.io/tags/%E9%92%A9%E5%AD%90/"/>
    
      <category term="指令级" scheme="https://anhkgg.github.io/tags/%E6%8C%87%E4%BB%A4%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用预先算好的字符串hash逆向分析shellcode</title>
    <link href="https://anhkgg.github.io/precalculated-string-hashes-reverse-engineering-shellcode/"/>
    <id>https://anhkgg.github.io/precalculated-string-hashes-reverse-engineering-shellcode/</id>
    <published>2016-07-11T10:29:16.000Z</published>
    <updated>2016-07-11T10:38:41.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对fireeye关于ida中shellcode_hashes_search_plugin.py的文章翻译，原文链接是<a href="https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html" target="_blank" rel="external">USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE</a></p>
<p>文章是fireeye的<a href="https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/cap-jay-smith" target="_blank" rel="external">Jay Smith</a>写的，介绍说经常在分析恶意样本中遇到shellcode，文章会介绍shellcode导入技术的背景以及如何是IDA自动化标记来更快分析shellcode</p>
<a id="more"></a>
<h1 id="逆向shellcode"><a href="#逆向shellcode" class="headerlink" title="逆向shellcode"></a>逆向shellcode</h1><p>判断一段shellcode做了什么，最简单的方法是将其放在一个监控环境中运行。但是如果shellcode是被exploit加载并且你没有对应版本的可利用程序，这种方式就没什么用了。在我们研究shellcode的经验中，我们发现很多恶意样本含有一段嵌入的shellcode，样本将shellcode注入到其他进程中执行。然而，获取到这段嵌入的shellcode，让他运行起来，并不总是可用的。在这些情况下，就需要静态分析shellcode来看看它有些什么功能了。</p>
<p>Shellcode的二进制文件一般都不是很大，所以逆向它们并不是很难，但是通常shellcode作者会使用一些技术手段来阻碍逆向分析。其中一种技术就是使用API函数名的hash来手工导入函数。</p>
<h1 id="shellcode导入技术"><a href="#shellcode导入技术" class="headerlink" title="shellcode导入技术"></a>shellcode导入技术</h1><p>开发者编写正常的程序通常使用kernel32.dll的LoadLibraryA和GetProcAddress来加载任意DLL和获取它们的到处函数地址。而shllcode的作者经常遇到内存大小限制，所以如果在代码中使用API函数名的完整字符串是不大可能的。相对于使用完整函数名字符串，预先计算好函数名的hash值，保存到shellcode中，花费更少的内存大小。使用这种方式的话，shellcode就不能使用GetProcAddress来获取函数地址了，需要解析DLL的PE文件找到导出目录，解析到处函数数组。对每个函数名字，计算出它的hash值，对比先前保存在shellcode中的hash值，如果相等就找到了对应的API函数。关于这种技术的背景资料可以在Last Stage的<a href="http://lsd-pl.net/projects/winasm.zip" target="_blank" rel="external">winasm</a>项目中公开的paper中找到。</p>
<p>这种技术听起来很难，但是幸运的是shellcode作者大都会重用已知的hash算法和值，这样逆向分析就更简单了。我所见过的大部分shellcode样本的hash算法都被metasploit收录了。这个算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">acc := 0</div><div class="line">for c in input_string do</div><div class="line">    acc := ROR(acc, 13);</div><div class="line">    acc := acc + c;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>这个肯定不是一个很强的hash算法，但是它已经完全可以达到将任意长度的输入字符串计算成一个整数的目的。这个算法唯一的限制是开发者使用的每一个API函数都有唯一的hash值，算法中简单的ROR-13是很有效的。我见过的不一样的hash算法通常只是将这个算法进行了轻微的修改：位移一个不同的值，将右移换成左移，或者使用其他方法将输入的所有字符串混合成一个整数值。</p>
<h1 id="自动标记shellcode导入"><a href="#自动标记shellcode导入" class="headerlink" title="自动标记shellcode导入"></a>自动标记shellcode导入</h1><p>当你第一次逆向shellcode的时候，你通常可能在网上搜搜这些魔数，或者自己计算这些值保存在文本中以后使用。很长一段时间，我看了很多的样本，我意思到这是一个烦人且重复的工作，该使用IDA脚本进行自动化。</p>
<p>由于shellcode作者重用通用的代码，我觉得公开我的IDA脚本集对恶意代码分析有帮助。预先用已知的hash算法计算出重用API函数名的hash后，如果有新的hash算法出现，就不难实现它来产生hash值了。在Poison Ivy RAT的字符串hash，有过这种情况（这句原文：There has only been one instance, involving string hash from Poison Ivy RAT, in which this wasn’t the case）。</p>
<p>可以在<a href="https://github.com/mandiant/Reversing." target="_blank" rel="external">https://github.com/mandiant/Reversing</a>找到脚本。</p>
<p>有两个部分：</p>
<ol>
<li><code>make_sc_hash_db.py</code> 是用于预先计算函数名字的hash值。这是一个实现了我以前遇到过的hash算法的命令行python脚本。它处理了一个目录中的所有DLL，计算了每个到处函数的hash值，保存在SQLite数据库中。</li>
<li><code>shellcode_hash_search.py</code> 是一个IDAPython脚本，用来打开SQLite数据库，获取其中预先计算的hash值，在当前文件中搜索已知的hash值。</li>
</ol>
<p><code>make_sc_hash_db.py</code>可以像下面那样使用，第一个参数是要创建的数据库名字，第二个参数是保存DLL的目录。如果你跳过这个步骤，发布版本中已经有个简单的数据库了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python make_sc_hash_db.py sc_hashes.db /customer/microsoft/shellcode_dlls/</div></pre></td></tr></table></figure>
<p>当<code>shellcode_hash_search.py</code>运行起来后，提示用户使用哪个数据库，然后询问用户其他的搜索参数。它显示所有的保存在数据库中的hash算法，然后提供一些简单的已知的伪代码，如图：</p>
<p><img src="/img/Figure-3-QT-GUI-view-300x185.png" alt="Figure-3-QT-GUI-view-300x185"></p>
<p>脚本会尝试使用HexRays发布的用于QT的PySide(可以在这里下载<a href="http://www.hex-rays.com/products/ida/support/download.shtml" target="_blank" rel="external">http://www.hex-rays.com/products/ida/support/download.shtml)</a>))。如果HexRays中没有PySide，它使用简单的对话框来或者相同的信息。</p>
<p>如果没有任何信息被高亮，脚本搜索当前段或者高亮区域。脚本查询每个DWORD（选中了DWORD Array选项），每个指令操作数（选中了Instr Operands选项）来决定是不是选中算法的一个hash值。如果找到了一个hash值会有一个line comment。如图：</p>
<p><img src="/img/Figure-4-Comments-are-added-for-identified-hashes-300x150.png" alt="Figure-4-Comments-are-added-for-identified-hashes-300x150.png"></p>
<p>有些shellcode作者也经常使用hash值保存在DWORD数组中，而不是将每个值压入函数参数，如图：</p>
<p><img src="/img/Figure-5-DWORD-array-of-hashes-300x149.png" alt="Figure-5-DWORD-array-of-hashes-300x149.png"></p>
<p>如果选中了Create Struct，如果找到的hash值在一段连续地址，脚本会自动创建一个结构体，如图：</p>
<p><img src="/img/Figure-6-Generated-structure-of-function-pointers-300x221.png" alt="Figure-6-Generated-structure-of-function-pointers-300x221.png"></p>
<p>如果shellcode作者使用函数指针数组，结构体非常有用，它会转换成<code>[base+index]</code>的结构体引用。如图：</p>
<p><img src="/img/Figure-7-Sample-function-pointer-array-usage-300x199.png" alt="Figure-7-Sample-function-pointer-array-usage-300x199 (1).png"></p>
<p><code>shellcode_hashes_search_plugin.py</code>用来显示IDA插件菜单的。拷贝到<code>%PROGRAMFILES%IDAplugins</code>，设置其他python文件到PATH环境变量中确保可被使用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通常，逆向分析一个shellcode比正常的binary文件更加乏味。IDA的导入表分析缺陷是一个延长分析的很大原因。通过IDAPython脚本可以解决上面的问题，我们已经将脚本公开在githun，希望你们的shellcode分析能够得到改进。</p>
<p><strong>参考:</strong></p>
<p><a href="https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html" target="_blank" rel="external">USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE</a></p>
<hr>
<p>转载请注明出处，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对fireeye关于ida中shellcode_hashes_search_plugin.py的文章翻译，原文链接是&lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2012/11/precalculated-string-hashes-reverse-engineering-shellcode.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章是fireeye的&lt;a href=&quot;https://www.fireeye.com/blog/threat-research.html/category/etc/tags/fireeye-blog-authors/cap-jay-smith&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jay Smith&lt;/a&gt;写的，介绍说经常在分析恶意样本中遇到shellcode，文章会介绍shellcode导入技术的背景以及如何是IDA自动化标记来更快分析shellcode&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>
    
      <category term="shellcode" scheme="https://anhkgg.github.io/tags/shellcode/"/>
    
      <category term="IDAPython" scheme="https://anhkgg.github.io/tags/IDAPython/"/>
    
  </entry>
  
  <entry>
    <title>Windbg系列-RPC调试</title>
    <link href="https://anhkgg.github.io/Windbg%E7%B3%BB%E5%88%97-RPC%E8%B0%83%E8%AF%95/"/>
    <id>https://anhkgg.github.io/Windbg%E7%B3%BB%E5%88%97-RPC%E8%B0%83%E8%AF%95/</id>
    <published>2016-01-04T12:16:10.000Z</published>
    <updated>2016-07-06T23:46:33.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在调试rpc，没法子，翻译了一下windbg这篇调试RPC的文档，后面可能还有其他内容，也就弄个系列吧<br>算是自己的笔记，有看客的话，可以多多指出问题，提提建议，不吝赐教！</p>
<p>微软的远程过程调用（RPC）可以轻松越过进程和机器的界限并且进行数据通信。这种网络通信标准是微软Window网络通信如此强大的原因（….太绕了，翻不来，也不重要）。<br>然而，因为RPC对进程隐藏了网络调用，所以隐藏了计算机之间的交互细节。这使得用户很难确认线程为什么这么做，正在做什么，为什么在支持的功能上失败。所以，调试和解决RPC错误非常困难。另外，大部分RPC错误的问题实际上出现在配置问题，网络连接问题，其他组件问题上。<br><a id="more"></a><br>Windows有个调试工具是DbgRpc，是RPC相关的调试器扩展。这些扩展能够用来分析Windows Xp以及更新版本系统的各种RPC问题。<br>这些Windows版本可以配置来保存RPC实时状态信息。可以保存不同数量的状态信息；这可以让你获得需要的信息，而不用防止一个重的负担在你的电脑上了（significant burden，什么东西）。细节请看Enabling RPC State Information</p>
<p>之后这些信息就可以被调试器或者DbgRpc访问了。在每种情况下，一个集合的查询都是可以用的。细节请看Displaying RPC State Information</p>
<p>在大部分情况下，你可以通过使用Common RPC Debugging Techniques.中的技术找到问题。<br>如果你想探索一下机器是怎么保存这些细腻的，或者你想设计自己的状态信息分析的技术，可以看看RPC State Information Internals.<br>这些工具和技术在Windows2000中不能使用</p>
<h1 id="激活RPC状态信息"><a href="#激活RPC状态信息" class="headerlink" title="激活RPC状态信息"></a>激活RPC状态信息</h1><p>可以收集两种不同的RPC运行时状态信息：服务端信息和完整信息。必须要在调试器或者DbgRpc使用之前激活状态信息的收集。<br>只有Windows XP以及以后的系统可以收集RPC状态信息。<br>收集服务端状态信息是比较轻量级。每次RPC调用大概需要100条机器指令，甚至在性能测试中都几乎不可察觉已经被加载了（…）。但是收集这些信息会耗费内存（每个RPC服务端大概4KB），所以不推荐内存有压力的机器使用。服务端信息包括数据，endpoints，线程，连接对象和服务调用对象（SCALL）。这些足够调试大部分RPC问题了。<br>收集全部状态信息更加heavyweight。它收集了所有的信息，包括服务端信息，另外还有客户端调用对象（CCALL）。全部状态信息通常是不需要的。<br>在电脑中运行Group Policy Editor(Gpedit.msc)可以激活收集RPC状态信息的功能。在本地电脑策略中，找到Computer Configuration/Administrative Templates/System/Remote Procedure Call。在这节下面可以看到RPC Troubleshooting State Information，当你编辑它的属性时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本地计算机策略-计算机配置-管理模板-系统-远程过程调用-维护RPC疑难解答状态信息（默认未启用，启用之后配置下面5中状态）</div></pre></td></tr></table></figure>
<p>可以看到5中可能的状态：<br>None：不维持任何状态信息。除非你电脑内存压力很大，不推荐这种配置。<br>Server：收集服务端状态信息。推荐在个人电脑中设置这个。<br>Full：收集全部状态信息。<br>Auto1：在内存小于64MB的电脑中，相当于None配置。在大于64MB的电脑中相当于Server配置。<br>Auto2：在内存小于128MB的运行Windows Server2003的电脑，或者运行Windows XP的电脑，相当于None配置。在大于128MB的Windows Server 2003中，相当于Server。这个也是默认配置。</p>
<p>如果你想同时配置一个局域网中的电脑的这些状态，使用Group Policy Editor卷起（roll out）机器策略到首选的机器中。策略引擎会监视你配置的策略传到首选的机器中。在这种情况下，Auto1和Auto2是特别有用的，因为不同机器的操作系统和内存大小是不一样的。<br>如果网络中包括运行了比Windows XP更老的系统，这些电脑会忽略这些配置。</p>
<h1 id="显示RPC状态信息"><a href="#显示RPC状态信息" class="headerlink" title="显示RPC状态信息"></a>显示RPC状态信息</h1><p>各种各样的RPC调试扩展在Rpcexts.dll中导出。<br>这些用来显示RPC状态信息RPC扩展只能在用户模式中运行。他们可以在CDB(或者NTSD)或者用户模式的Windbg中使用。<br>用户模式的调试器必须有一个目标程序，但是这个目标跟RPC扩展又是没有关系的（？？）。如果调试器还没有运行，你可以简单打开它调试一个毫不相干的目标（比如windbg notepad或者cdb winmine）。接着在CDB中CTRL+C，或者Windbg中Debug|Break来停止目标进程，这样可以使用调试器的命令窗口。<br>如果你需要分析一个远程电脑的RPC状态信息，你需要在目标电脑中运行一个用户模式的调试器，然后使用Remote Debugging。<br>通过调试器访问RPC状态信息在一个stress环境中是特别有用的，或者当一个调试器已经运行了。</p>
<h2 id="使用RPC调试扩展"><a href="#使用RPC调试扩展" class="headerlink" title="使用RPC调试扩展"></a>使用RPC调试扩展</h2><p>各种各样的RPC调试扩展在Rpcexts.dll中导出。<br>这些用来显示RPC状态信息RPC扩展只能在用户模式中运行。他们可以在CDB(或者NTSD)或者用户模式的Windbg中使用。<br>用户模式的调试器必须有一个目标程序，但是这个目标跟RPC扩展又是没有关系的（？？）。如果调试器还没有运行，你可以简单打开它调试一个毫不相干的目标（比如windbg notepad或者cdb winmine）。接着在CDB中CTRL+C，或者Windbg中Debug|Break来停止目标进程，这样可以使用调试器的命令窗口。<br>如果你需要分析一个远程电脑的RPC状态信息，你需要在目标电脑中运行一个用户模式的调试器，然后使用Remote Debugging。<br>通过调试器访问RPC状态信息在一个stress环境中是特别有用的，或者当一个调试器已经运行了。</p>
<h2 id="使用DbgRpc工具"><a href="#使用DbgRpc工具" class="headerlink" title="使用DbgRpc工具"></a>使用DbgRpc工具</h2><p>DbgRpc工具（DbgRpc.exe）放在windbg安装目录中，必须使用命令提示窗口打开它。<br>双击是不能启动这个工具的。<br>命令提示窗口必须运行在本地电脑的administrator权限的账户下，或者域管理员权限。<br>DbgRpc不会对系统服务产生任何调用（比如LSASS）。 这个对调试时非常有用的，只要内核还在运行，即便在系统服务已经崩溃了。</p>
<p>在远程电脑中使用DbgRpc<br>DbgRpc也可以用来检查远程电脑的信息。为了让这个可以正常工作，远程电脑需要可以接受远程连接和远程认证用户。如果远程电脑的RPCSS服务已经崩溃，DbgRpc将不能工作。远程电脑中也需要Administrative或者域管理员权限。</p>
<p>-s参数用来指定服务端名字，-p指定传输协议。TCP和命名管道都可以使用。推荐使用TCP协议，它几乎可以在每种情况下使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">G:\&gt;dbgrpc -s MyServer -p ncacn_ip_tcp -l -P 1e8 -L 0.1</div><div class="line">Getting remote cell info ...</div><div class="line">Endpoint</div><div class="line">Status: Active</div><div class="line">Protocol Sequence: LRPC</div><div class="line">Endpoint name: OLE18</div></pre></td></tr></table></figure>
<p>DbgRpc命令行<br>可以查看详细的DbgRpc命令描述</p>
<h2 id="获取RPC-Cell信息"><a href="#获取RPC-Cell信息" class="headerlink" title="获取RPC Cell信息"></a>获取RPC Cell信息</h2><p>详细的cell信息通过!rpcexts.getdbgcell显示，或者使用DbgRpc的-l开关。<br>需要指定进程id已经cell number。<br>下面的例子，进程id是0x278，cell number是0000.0002</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -l -P 278 -L 0.2</div><div class="line">Getting cell info ...</div><div class="line">Thread</div><div class="line">Status: Dispatched</div><div class="line">Thread ID: 0x1A4 (420)</div><div class="line">Last update time (in seconds since boot):470.25 (0x1D6.19)</div><div class="line">For details on the optional parameters, see DbgRpc Command-Line Options.</div><div class="line">For a similar example using the RPC debugger extensions, see !rpcexts.getdbgcell.</div></pre></td></tr></table></figure>
<h2 id="获取RPC-Endpoint信息"><a href="#获取RPC-Endpoint信息" class="headerlink" title="获取RPC Endpoint信息"></a>获取RPC Endpoint信息</h2><p>Endpoint信息通过!rpcexts.getendpointinfo显示，或者DbgRpc的-e开关。<br>如果指定了endpoint number，就会显示它的信息。如果忽略endpoint number，系统中所有进程的endpoint都会显示。<br>下面是显示所有endpoints的例子，通常包含进程id和cell number作为额外的参数是很有用的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -e</div><div class="line">Searching for endpoint info ...</div><div class="line">PID  CELL ID   ST PROTSEQ        ENDPOINT</div><div class="line">-------------------------------------------------------</div><div class="line">00a8 0000.0001 01            NMP \PIPE\InitShutdown</div><div class="line">00a8 0000.0003 01            NMP \PIPE\SfcApi</div><div class="line">00a8 0000.0004 01            NMP \PIPE\ProfMapApi</div><div class="line">00a8 0000.0007 01            NMP \pipe\winlogonrpc</div><div class="line">00a8 0000.0008 01           LRPC OLE5</div><div class="line">00c4 0000.0001 01           LRPC ntsvcs</div><div class="line">00c4 0000.0003 01            NMP \PIPE\ntsvcs</div><div class="line">00c4 0000.0008 01            NMP \PIPE\scerpc</div><div class="line">00d0 0000.0001 01            NMP \PIPE\lsass</div><div class="line">00d0 0000.0004 01            NMP \pipe\WMIEP_d0</div><div class="line">00d0 0000.000b 01            NMP \PIPE\POLICYAGENT</div><div class="line">00d0 0000.000c 01           LRPC policyagent</div><div class="line">0170 0000.0001 01           LRPC epmapper</div><div class="line">0170 0000.0003 01            TCP 135</div><div class="line">0170 0000.0005 01            SPX 34280</div><div class="line">0170 0000.0006 01             NB 135</div><div class="line">0170 0000.0007 01             NB 135</div><div class="line">0170 0000.000b 01            NMP \pipe\epmapper</div><div class="line">01b8 0000.0001 01            NMP \pipe\spoolss</div><div class="line">01b8 0000.0003 01           LRPC spoolss</div><div class="line">01b8 0000.0007 01           LRPC OLE7</div><div class="line">00ec 0000.0001 01           LRPC OLE2</div><div class="line">00ec 0000.0003 01           LRPC senssvc</div><div class="line">00ec 0000.0007 01            NMP \pipe\tapsrv</div><div class="line">00ec 0000.0008 01           LRPC tapsrvlpc</div><div class="line">00ec 0000.000c 01            NMP \PIPE\ROUTER</div><div class="line">00ec 0000.0010 01            NMP \pipe\WMIEP_ec</div><div class="line">0214 0000.0001 01            NMP \PIPE\winreg</div><div class="line">022c 0000.0001 01           LRPC LRPC0000022c.00000001</div><div class="line">022c 0000.0003 01            TCP 1058</div><div class="line">022c 0000.0005 01            SPX 24576</div><div class="line">022c 0000.0006 01            NMP \PIPE\atsvc</div><div class="line">02a8 0000.0001 01           LRPC OLE3</div><div class="line">0370 0000.0001 01           LRPC OLE9</div><div class="line">0278 0000.0001 01            TCP 1120</div><div class="line">030c 0000.0001 01           LRPC OLE12</div></pre></td></tr></table></figure>
<p>For details on the optional parameters, see DbgRpc Command-Line Options.<br>For a similar example using the RPC debugger extensions, see !rpcexts.getendpointinfo.</p>
<h2 id="获取RPC线程信息"><a href="#获取RPC线程信息" class="headerlink" title="获取RPC线程信息"></a>获取RPC线程信息</h2><p>使用显示!rpcexts.getthreadinfo线程信息，或者DbgRpc的-t开关。<br>必须指定进程pid。也可以指定线程ID，如果忽略，显示进程的所有线程。<br>例子，进程ID 0x278，忽略了线程ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -t -P 278</div><div class="line">Searching for thread info ...</div><div class="line">PID  CELL ID   ST TID      LASTTIME</div><div class="line">-----------------------------------</div><div class="line">0278 0000.0002 01 000001a4 00072c09</div><div class="line">0278 0000.0005 03 0000031c 00072bf5</div><div class="line">For details on the optional parameters, see DbgRpc Command-Line Options.</div><div class="line">For a similar example using the RPC debugger extensions, see !rpcexts.getthreadinfo.</div></pre></td></tr></table></figure>
<h2 id="获取RPC调用信息"><a href="#获取RPC调用信息" class="headerlink" title="获取RPC调用信息"></a>获取RPC调用信息</h2><p>服务端调用信息通过!rpcexts.getcallinfo显示，DbgRpc的-c开关<br>有4个可选的参数。其中三个CallID，IfStart，ProcNum是用来跟中RPC调用来标记信息的。第四个参数是ProcessID是服务端的Pid。你可以使用你知道的参数值来缩小搜索。<br>如果没有参数指定，系统中所有可知的SCALLs都会显示。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -c</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   ST PNO IFSTART  TIDNUMBER CALLFLAG CALLID   LASTTIME CONN/CLN</div><div class="line">----------------------------------------------------------------------------</div><div class="line">00c4 0000.0002 00 00f 82273fdc 0000.0007 00000001 00000002 0003595d 0000.0010</div><div class="line">00c4 0000.0006 00 009 367abb81 0000.0015 00000001 0000004d 000185bd 0000.0005</div><div class="line">00c4 0000.000a 00 007 367abb81 0000.002d 00000001 0000009f 00014672 0000.0009</div><div class="line">00c4 0000.000c 00 007 367abb81 0000.002d 00000001 00000083 000122e3 0000.000b</div><div class="line">00c4 0000.000d 00 03b 8d9f4e40 0000.002d 00000001 000000f7 0001aba5 0000.0020</div><div class="line">00c4 0000.000e 00 03b 8d9f4e40 0000.0026 00000001 00000002 00023056 0000.0021</div><div class="line">00c4 0000.000f 00 008 82273fdc 0000.001e 00000009 baadf00d 000366b4 00ec.03bc</div><div class="line">00c4 0000.0012 00 00d 8d9f4e40 0000.0004 00000001 00000051 0000a334 0000.0011</div><div class="line">00c4 0000.0014 00 000 367abb81 0000.0015 00000001 0000004c 0002db53 0000.0013</div><div class="line">00c4 0000.0017 00 007 367abb81 0000.0015 00000001 00000006 0000d102 0000.0016</div><div class="line">00c4 0000.0019 00 007 367abb81 0000.0004 00000001 00000006 0000f09e 0000.0018</div><div class="line">00c4 0000.001b 00 009 65a93890 0000.0007 00000001 0000012e 00630f65 0000.001a</div><div class="line">00c4 0000.001e 00 026 8d9f4e40 0000.0015 00000001 0000037d 0005e579 0000.002c</div><div class="line">00c4 0000.001f 00 008 82273fdc 0000.0033 00000009 baadf00d 000145b3 00c4.02f8</div><div class="line">00c4 0000.0023 00 000 367abb81 0000.0004 00000001 0000007e 000372f3 0000.0022</div><div class="line">00c4 0000.0025 00 03b 8d9f4e40 0000.0026 00000001 0000000b 000122e3 0000.0024</div><div class="line">00c4 0000.0027 00 000 367abb81 0000.002d 00000001 0000000b 00012e27 0000.0028</div><div class="line">00c4 0000.002a 00 008 82273fdc 0000.0033 00000009 baadf00d 0001245f 022c.0290</div><div class="line">00c4 0000.002f 00 007 367abb81 0000.0026 00000001 0000000a 0002983c 0000.002e</div><div class="line">00c4 0000.0031 00 004 3ba0ffc0 0000.0026 00000001 00000007 0005c439 0000.001c</div><div class="line">00c4 0000.0032 00 00b 82273fdc 0000.0039 00000009 baadf00d 00687db6 00d0.01d4</div><div class="line">00c4 0000.0036 00 007 367abb81 0000.0030 00000001 00000065 0003a5e1 0000.0035</div><div class="line">00c4 0000.0037 00 00d 8d9f4e40 0000.0015 00000001 0000033f 000376fa 0000.002b</div><div class="line">00c4 0000.0038 00 008 8d9f4e40 0000.0015 00000001 00000803 0018485c 0000.003b</div><div class="line">00c4 0000.003c 00 00b 82273fdc 0000.0034 00000009 baadf00d 0001f956 00a8.0244</div><div class="line">00c4 0000.003d 00 008 82273fdc 0000.0034 00000009 baadf00d 0001ff02 01b8.037c</div><div class="line">0170 0000.0009 00 002 e60c73e6 0000.0013 00000009 baadf00d 0005a371 00ec.031c</div><div class="line">0170 0000.000a 00 002 0b0a6584 0000.0002 00000009 baadf00d 000126ae 00c4.0130</div><div class="line">0170 0000.000c 00 002 0b0a6584 0000.0010 00000009 baadf00d 00012bc4 022c.0290</div><div class="line">0170 0000.000d 00 003 00000136 0000.001b 00000009 baadf00d 0005ba71 00ec.0310</div><div class="line">0170 0000.000e 00 000 412f241e 0000.0002 00000009 baadf00d 00012f21 02a8.029c</div><div class="line">0170 0000.0010 00 003 00000136 0000.0013 00000009 00000003 000341da 0370.0060</div><div class="line">0170 0000.0011 00 006 e60c73e6 0000.001b 00000009 baadf00d 000f1d00 0370.0328</div><div class="line">0170 0000.0017 00 002 0b0a6584 0000.001b 00000009 baadf00d 0006c803 0278.0184</div><div class="line">0170 0000.001a 00 004 00000136 0000.0012 00000001 baadf00d 00038e9b 00ec.0348</div><div class="line">00ec 0000.0006 00 009 00000134 0000.0011 00000009 baadf00d 000b233f 0170.0244</div><div class="line">00ec 0000.000b 00 001 2f5f6520 0000.001c 00000009 baadf00d 00035510 00ec.0334</div><div class="line">00ec 0000.000e 00 001 629b9f66 0000.0014 00000009 baadf00d 00035813 00ec.01c4</div><div class="line">00ec 0000.0012 00 000 629b9f66 0000.0014 00000009 baadf00d 00026cc6 00a8.0164</div><div class="line">00ec 0000.001b 00 001 2f5f6520 0000.0004 00000001 baadf00d 000352c1 00ec.03a8</div><div class="line">02a8 0000.0004 00 009 00000134 0000.0002 00000009 baadf00d 0009a540 0170.0244</div><div class="line">0370 0000.0006 00 003 00000134 0000.0005 0000000b baadf00d 0002e7cd 00ec.0350</div><div class="line">0370 0000.0008 00 009 00000134 0000.0007 0000000b 01cee9e4 000838fa 0170.0244</div><div class="line">0278 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00072c09 0000.0003</div></pre></td></tr></table></figure>
<p>For details on the optional parameters, see DbgRpc Command-Line Options.<br>For a similar example using the RPC debugger extensions, see !rpcexts.getcallinfo.</p>
<h2 id="获取RPC客户端调用信息"><a href="#获取RPC客户端调用信息" class="headerlink" title="获取RPC客户端调用信息"></a>获取RPC客户端调用信息</h2><p>使用!rpcexts.getclientcallinfo获取客户端调用信息，或者DbgRpc的-a开关。<br>也有四个参数可选。其中三个CallID，IfStart，ProcNum是用来跟中RPC调用来标记信息的。第四个参数ProcessID是属于这个调用的进程的Pid。你可以使用你知道的参数值来缩小搜索。<br>如果没有参数指定，系统中所有可知的CCALLs都会显示。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -a</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   PNO  IFSTART  TIDNUMBER CALLID   LASTTIME PS CLTNUMBER ENDPOINT</div><div class="line">------------------------------------------------------------------------------</div><div class="line">0390 0000.0001 0000 19bb5061 0000.0000 00000001 00072bff 07 0000.0002 1120</div></pre></td></tr></table></figure>
<p>For details on the optional parameters, see DbgRpc Command-Line Options.<br>For a similar example using the RPC debugger extensions, see !rpcexts.getclientcallinfo.</p>
<p>注意：<br>只有在全部状态信息都收集的时候，才有CCALLS的信息。</p>
<h1 id="常用的RPC调试技术"><a href="#常用的RPC调试技术" class="headerlink" title="常用的RPC调试技术"></a>常用的RPC调试技术</h1><p>下面将介绍4中常见的RPC问题。RPC状态信息可以用来检查这些问题。<br>DbgRpc和RPC调试扩展命令都可以使用。</p>
<h2 id="分析一个Stuck（卡）调用问题"><a href="#分析一个Stuck（卡）调用问题" class="headerlink" title="分析一个Stuck（卡）调用问题"></a>分析一个Stuck（卡）调用问题</h2><p>当一个进程直接或间接的进行一次RPC调用时，等待（holding）一个critical section或者资源时通过会出现这个问题。在这种情况下，RPC调用会到另一个进程或者机器，然后派遣到管理接口（服务接口）中，这个会等待很久。这导致调用方会出现等待超时。</p>
<p>当通过调试器检查时，RPC是这个等待线程的最高层，但是不清楚究竟在等待什么。<br>下面是一个这种堆栈的例子，有很多可能性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0:002&gt; ~1k</div><div class="line">ChildEBP RetAddr</div><div class="line">0068fba0 77e9e8eb ntdll!ZwWaitForSingleObject+0xb</div><div class="line">0068fbc8 4efeff73 KERNEL32!WaitForSingleObjectEx+0x5a</div><div class="line">0068fbe8 4eff0012 RPCRT4!UTIL_WaitForSyncIO+0x21</div><div class="line">0068fc0c 4efe6e2b RPCRT4!UTIL_GetOverlappedResultEx+0x44</div><div class="line">0068fc44 4ef973bf RPCRT4!WS_SyncRecv+0x12a</div><div class="line">0068fc68 4ef98d5a RPCRT4!OSF_CCONNECTION__TransSendReceive+0xcb</div><div class="line">0068fce4 4ef9b682 RPCRT4!OSF_CCONNECTION__SendFragment+0x297</div><div class="line">0068fd38 4ef9a5a8 RPCRT4!OSF_CCALL__SendNextFragment+0x272</div><div class="line">0068fd88 4ef9a9cb RPCRT4!OSF_CCALL__FastSendReceive+0x165</div><div class="line">0068fda8 4ef9a7f8 RPCRT4!OSF_CCALL__SendReceiveHelper+0xed</div><div class="line">0068fdd4 4ef946a7 RPCRT4!OSF_CCALL__SendReceive+0x37</div><div class="line">0068fdf0 4efd56b3 RPCRT4!I_RpcSendReceive+0xc4</div><div class="line">0068fe08 01002850 RPCRT4!NdrSendReceive+0x4f</div><div class="line">0068ff40 01001f32 rtclnt+0x2850</div><div class="line">0068ffb4 77e92ca8 rtclnt+0x1f32</div><div class="line">0068ffec 00000000 KERNEL32!CreateFileA+0x11b</div></pre></td></tr></table></figure>
<p>下面是怎么检查这个问题。<br><strong>Troubleshooting a stuck call problem</strong></p>
<p>1- 保证调试器正在调试有这个stuck cell的进程。（是那个可能在等待RPC的线程所属的进程）<br>2- 或者线程的堆栈指针。堆栈就像上面例子中显示的那样，这个例子的堆栈指针是0x0068FBA0<br>3- 获取这个线程的调用信息。通过!rpcexts.rpcreadstack加上堆栈指针作为参数来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.rpcreadstack 68fba0</div><div class="line">CallID: 1</div><div class="line">IfStart: 19bb5061</div><div class="line">ProcNum: 0</div><div class="line">Protocol Sequence:      &quot;ncacn_ip_tcp&quot;  (Address: 00692ED8)</div><div class="line">NetworkAddress: &quot;&quot;      (Address: 00692F38)</div><div class="line">Endpoint:       &quot;1120&quot;  (Address: 00693988)</div></pre></td></tr></table></figure>
<p>显示的这些信息可以让你跟踪这个调用。</p>
<p>4- 网络地址是空的，标明是本地机器。Endpoint是1120。需要确认哪个进程拥有这个endpoint。通过!rpcexts.getendpointinfo加上endpoint作为参数来获取 //应该是客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getendpointinfo 1120</div><div class="line">Searching for endpoint info ...</div><div class="line">PID  CELL ID   ST PROTSEQ        ENDPOINT</div><div class="line">--------------------------------------------</div><div class="line">0278 0000.0001 01            TCP 1120</div></pre></td></tr></table></figure>
<p>5- 根据前面的信息，可以看到进程0x278拥有这个endpoint，可以通过!rpcexts.getcallinfo<br>获取到这个call的所有信息，需要加上四个参数CallID, IfStart, and ProcNum（3步骤已经知道）和进程pid 0x278</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getcallinfo 1 19bb5061 0 278</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   ST PNO IFSTART  TIDNUMBER CALLFLAG CALLID   LASTTIME CONN/CLN</div><div class="line">----------------------------------------------------------------------------</div><div class="line">0278 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00072c09 0000.0003</div></pre></td></tr></table></figure>
<p>6- 第5步的信息非常有用，但是有些信息太少了。第二列给出的cell id是0000.0004。如果<br>!rpcexts.getdbgcell加上这个cell id，可以显示更易读的cell信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getdbgcell 278 0.4</div><div class="line">Getting cell info ...</div><div class="line">Call</div><div class="line">Status: Dispatched</div><div class="line">Procedure Number: 0</div><div class="line">Interface UUID start (first DWORD only): 19BB5061</div><div class="line">Call ID: 0x1 (1)</div><div class="line">Servicing thread identifier: 0x0.2</div><div class="line">Call Flags: cached</div><div class="line">Last update time (in seconds since boot):470.25 (0x1D6.19)</div><div class="line">Owning connection identifier: 0x0.3</div></pre></td></tr></table></figure>
<p>信息显示这个调用已经”dispatched”，表示已经离开了RPC运行时。最后更新时间是470.25，通过!rpcexts.rpctime可以看到现在的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.rpctime</div><div class="line">Current time is: 6003, 422</div></pre></td></tr></table></figure>
<p>表示这次call的最后联系在5533秒之前了，接近92分钟，因此这个肯定是一个stuck call。</p>
<p>7- 在挂载到服务端进程之前，你可以使用Servicing thread identifier找到当前处理这个call的线程信息。也就是另一个cell number，第6步中的0x0.2，可以像下面一样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getdbgcell 278 0.2</div><div class="line">Getting cell info ...</div><div class="line">Thread</div><div class="line">Status: Dispatched</div><div class="line">Thread ID: 0x1A4 (420)</div><div class="line">Last update time (in seconds since boot):470.25 (0x1D6.19)</div></pre></td></tr></table></figure>
<p>现在你知道你要找的是0x278进程的0x1A4线程。</p>
<p>可能这个线程已经在做其他的RPC调用了，你又必要重复这个过程跟踪这个call。</p>
<p>##跟踪服务端进程的Contention（争用）</p>
<p>为了能够处理发来的请求，RPC报了一个工作线程集合。理论上这个线程数量很小。然后理想的情况只存在实验室环境下，这些服务管理函数非常小心和谐（。。。）。在真实情况下，线程的数量决定于服务端的工作量，不过不管怎么样都在1-50的范围内。<br>如果工作线程数量超过了50，可能服务端进程有过多的竞争。通过引起这个的是heap的胡乱使用，内存的压力，或者服务端大部分的活动都通过一个单独的临界区。<br>使用!rpcexts.getthreadinfo获取服务进程的线程数量，或者DbgRpc的-t选项。需要指定进程ID，如下面的0xC4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -t -P c4</div><div class="line">Searching for thread info ...</div><div class="line">PID  CELL ID   ST TID      LASTTIME</div><div class="line">-----------------------------------</div><div class="line">00c4 0000.0004 03 0000011c 000f164f</div><div class="line">00c4 0000.0007 03 00000120 008a6290</div><div class="line">00c4 0000.0015 03 0000018c 008a6236</div><div class="line">00c4 0000.0026 03 00000264 0005c443</div><div class="line">00c4 0000.002d 03 00000268 000265bb</div><div class="line">00c4 0000.0030 03 0000026c 000f1d32</div><div class="line">00c4 0000.0034 03 00000388 007251e9</div></pre></td></tr></table></figure>
<p>在这个例子中，只有7个工作线程，是合理的。<br>如果有超过100个线程，就需要加载调试器看看问题了。<br>Note  Running queries such as dbgrpc -t remotely is expensive to the server and the network. If you use this query in a script, you should make sure this command is not run too often.</p>
<h2 id="检查Struct的线程"><a href="#检查Struct的线程" class="headerlink" title="检查Struct的线程"></a>检查Struct的线程</h2><p>RPC需要它的工作线程来完成正常的工作，通常有个问题，在同一个进程中的组件会因为等待一个公共的临界区死锁（比如，loader lock或者heap lock）。这将导致很多线程暂停，很有可能也有RPC工作线程。<br>如果出现了这种情况，RPC服务器不会再给外界响应。RPC调用将返回RPC_S_SERVER_UNAVAILABLE或者RPC_S_SERVER_TOO_BUSY</p>
<p>一个很小的问题可能会硬气有问题的驱动阻止IRPs完成，到达RPC服务器。<br>如果你怀疑可能出现了这个问题，使用DbgRpc –t或者!rpcexts.getthreadinfo需要进程PID作为参数。下面的列子是0xC4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">D:\wmsg&gt;dbgrpc -t -P c4</div><div class="line">Searching for thread info ...</div><div class="line">PID  CELL ID   ST TID      LASTTIME</div><div class="line">-----------------------------------</div><div class="line">00c4 0000.0004 03 0000011c 000f164f</div><div class="line">00c4 0000.0007 03 00000120 008a6290</div><div class="line">00c4 0000.0015 03 0000018c 008a6236</div><div class="line">00c4 0000.0026 03 00000264 0005c443</div><div class="line">00c4 0000.002d 03 00000268 000265bb</div><div class="line">00c4 0000.0030 03 0000026c 000f1d32</div><div class="line">00c4 0000.0034 03 00000388 007251e9</div></pre></td></tr></table></figure>
<p>TID那一列给出了每个线程的ID。LATSTIME列包含每个线程最近状态改变的时间戳。<br>只要服务器收到一个请求，至少有一个线程会改变状态，时间戳就会更新。因此，一个RPC请求失败了，但是没有任何一个线程的时间戳改变，表示这个请求没有到达RPC运行时中。你需要在研究是什么引起的。</p>
<h2 id="在服务端标明调用者"><a href="#在服务端标明调用者" class="headerlink" title="在服务端标明调用者"></a>在服务端标明调用者</h2><p>有些时候需要确认谁发送的RPC请求，虽然你只有这次调用的服务线程信息。<br>这个非常有用-比如，找到谁传递了不合法的参数给RPC调用。<br>根据某些特别依赖于协议序列的调用，你可以或者不同程度的细节，而有些协议根本没有这些信息（比如NetBiso）</p>
<p>Identifying the caller from the server thread<br>1- 打开用户模式调试器，挂载到目标服务线程中<br>2- 通过|命令获取到进程id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:001&gt; |</div><div class="line">0     id: 3d4 name: rtsvr.exe</div></pre></td></tr></table></figure>
<p>3- !rpcexts.getcallinfo获取到进程中存在的calls。需要指定进程ID 0x3D4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getcallinfo 0 0 FFFF 3d4</div><div class="line">Searching for call info ...</div><div class="line">PID  CELL ID   ST PNO IFSTART  THRDCELL  CALLFLAG CALLID   LASTTIME CONN/CLN</div><div class="line">----------------------------------------------------------------------------</div><div class="line">03d4 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00a1aced 0000.0003</div></pre></td></tr></table></figure>
<p>查找状态时2或1（dispatched或active）的调用。在这个例子中，只有一个call，如果有更多的，你可以使用!rpcexts.getdbgcell加上cell number（THRDCELL列）来获取线程IDs，从而你可以决定哪个是你感兴趣的调用了</p>
<p>4- 在知道你感兴趣的call之后，看看CONN/CLN所在的cell number，这个是连接对象的cell ID。这里是0000.0003。使用!rpcexts.getdbgcell加上这个id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0:001&gt; !rpcexts.getdbgcell 3d4 0.3</div><div class="line">Getting cell info ...</div><div class="line">Connection</div><div class="line">Connection flags: Exclusive</div><div class="line">Authentication Level: Default</div><div class="line">Authentication Service: None</div><div class="line">Last Transmit Fragment Size: 24 (0x6F56D)</div><div class="line">Endpoint for the connection: 0x0.1</div><div class="line">Last send time (in seconds since boot):10595.565 (0x2963.235)</div><div class="line">Last receive time (in seconds since boot):10595.565 (0x2963.235)</div><div class="line">Getting endpoint info ...</div><div class="line">Process object for caller is 0xFF9DF5F0</div></pre></td></tr></table></figure>
<p>这个命令显示了这个连接的客户端的所有信息。实际的信息会有很多不同，跟使用的transport有关系。<br>在这个例子中，使用的本地命令管道通信，调用者的进程对象地址也显示了。如果你挂载了内核调试器（或者启动一个本地调试器），你可以使用!process看到看看这个地址的信息。<br>如果使用LRPC通信，会显示进程ID和线程ID。<br>如果使用TCP通信，会显示调用者的IP地址。<br>如果使用了远程命名管道，不会显示任何信息。</p>
<hr>
<p>转载请注明出处，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近在调试rpc，没法子，翻译了一下windbg这篇调试RPC的文档，后面可能还有其他内容，也就弄个系列吧&lt;br&gt;算是自己的笔记，有看客的话，可以多多指出问题，提提建议，不吝赐教！&lt;/p&gt;
&lt;p&gt;微软的远程过程调用（RPC）可以轻松越过进程和机器的界限并且进行数据通信。这种网络通信标准是微软Window网络通信如此强大的原因（….太绕了，翻不来，也不重要）。&lt;br&gt;然而，因为RPC对进程隐藏了网络调用，所以隐藏了计算机之间的交互细节。这使得用户很难确认线程为什么这么做，正在做什么，为什么在支持的功能上失败。所以，调试和解决RPC错误非常困难。另外，大部分RPC错误的问题实际上出现在配置问题，网络连接问题，其他组件问题上。&lt;br&gt;
    
    </summary>
    
      <category term="debug" scheme="https://anhkgg.github.io/categories/debug/"/>
    
    
      <category term="Windbg调试" scheme="https://anhkgg.github.io/tags/Windbg%E8%B0%83%E8%AF%95/"/>
    
      <category term="RPC" scheme="https://anhkgg.github.io/tags/RPC/"/>
    
      <category term="远程过程调用" scheme="https://anhkgg.github.io/tags/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux pyspider learning</title>
    <link href="https://anhkgg.github.io/linux-pyspider-learning/"/>
    <id>https://anhkgg.github.io/linux-pyspider-learning/</id>
    <published>2015-01-24T10:54:17.000Z</published>
    <updated>2016-07-07T04:27:03.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1. 创建工程"></a><strong>1. 创建工程</strong></h1><p>运行pyspider，然后浏览器中输入localhost:5000，即可进入project管理，Create创建新的project</p>
<a id="more"></a>
<h1 id="2-编码"><a href="#2-编码" class="headerlink" title="2. 编码"></a><strong>2. 编码</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">from pyspider.libs.base_handler import * </div><div class="line">import re </div><div class="line"></div><div class="line">class Handler(BaseHandler): </div><div class="line">crawl_config = &#123; </div><div class="line">&#125; </div><div class="line">@every(minutes=24 * 60) </div><div class="line">def on_start(self): </div><div class="line">for i in range(1, 287): </div><div class="line">self.crawl(&apos;http://xxx?ajax=1&amp;major=73&amp;showMore=0&amp;refer=cindex&amp;page=&apos;+str(i)+&apos;&amp;_CSRFToken=&apos;, callback=self.index_page) </div><div class="line"></div><div class="line">@config(age=10 * 24 * 60 * 60) </div><div class="line">def index_page(self, response): </div><div class="line">#print response.json[&apos;data&apos;] </div><div class="line">total = response.json[&apos;data&apos;][&apos;total&apos;] </div><div class="line">lists = response.json[&apos;data&apos;][&apos;lists&apos;] </div><div class="line">#print total, len(lists) </div><div class="line">for i in range(0, len(lists)): </div><div class="line">url = lists[i][&apos;url&apos;]; </div><div class="line">#if re.match(&quot;http://xxx?/corp/\d+/project/\d+&quot;, url): </div><div class="line">self.crawl(url, callback=self.detail_page) </div><div class="line"></div><div class="line">def detail_page(self, response): </div><div class="line">#信息过滤提取</div><div class="line">content = response.doc(&apos;div.position-content&apos;).text() </div><div class="line">if content == &quot;&quot; or content == None: </div><div class="line">content = response.doc(&apos;div.project-info &gt; div.pro-detail&apos;).text() </div><div class="line">return &#123; </div><div class="line">&quot;url&quot;: response.url, </div><div class="line">&quot;title&quot;: response.doc(&apos;title&apos;).text(), </div><div class="line">&quot;content&quot;: content </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>self.crawl(url, callback)抓取网页，callback为响应函数<br>def callback(self, response),response表示内容，可以通过response.doc(‘各类选择器’).text()获取到需要的内容<br>更多response的操作可以查看<a href="http://docs.pyspider.org/en/latest/apis/Response/" target="_blank" rel="external">pyspider response</a></p>
<p><em>注意：</em><br>由于 response.doc是一个<a href="https://pythonhosted.org/pyquery/#quickstart" target="_blank" rel="external">pyquery</a>对象，信息过滤中可以使用css选择器<br>pyspider自带css选择器生成，但是貌似不能使用<br>在浏览器中f12，也可以自动生成选择器<br><img src="/img/css_select.png" alt="img"><br>在生成的选择其中，如&lt;#pagecontent &gt; table:nth-child(3) &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(2) &gt; table &gt; tbody &gt; tr &gt; td &gt; div:nth-child(2)&gt;<br>需要去掉其中的tbody标签，否则无法使用，是否还有其他标签，没有过多测试<br>其实css选择器不用从上到下完整的生成，只要能够唯一获取指定的元素即可</p>
<h1 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a><strong>3. 调试</strong></h1><p>第一次run，调用on_start，crawl指定的url，然后调用callback函数，界面显示如图<br><img src="/img/pyspider_d1.png" alt="img"></p>
<p>切换到follow窗口，可以看到符合callback函数的url列表<br><img src="/img/pyspider_d2.png" alt="img"></p>
<p>点击列表中右侧播放按钮，crawl该页面，获取符合规则的url，调用下一个callback<br><img src="/img/pyspider_d3.png" alt="img"></p>
<p>然后继续播放按钮，可能就是需要页面内容过滤了，根据自己的需求进行过滤<br>return返回的内容会写入数据库</p>
<h1 id="4-调试好之后，run"><a href="#4-调试好之后，run" class="headerlink" title="4.  调试好之后，run"></a><strong>4.  调试好之后，run</strong></h1><p><img src="/img/pyspider_d4.png" alt="img"><br>然后就可以在results页面看到爬取结果了。<br><img src="/img/pyspider_d5.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-创建工程&quot;&gt;&lt;a href=&quot;#1-创建工程&quot; class=&quot;headerlink&quot; title=&quot;1. 创建工程&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 创建工程&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;运行pyspider，然后浏览器中输入localhost:5000，即可进入project管理，Create创建新的project&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://anhkgg.github.io/categories/python/"/>
    
    
      <category term="pyspider" scheme="https://anhkgg.github.io/tags/pyspider/"/>
    
  </entry>
  
  <entry>
    <title>upx3.05手脱笔记</title>
    <link href="https://anhkgg.github.io/upx3-05%E6%89%8B%E8%84%B1%E7%AC%94%E8%AE%B0/"/>
    <id>https://anhkgg.github.io/upx3-05%E6%89%8B%E8%84%B1%E7%AC%94%E8%AE%B0/</id>
    <published>2015-01-07T06:57:42.000Z</published>
    <updated>2015-01-07T07:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来一直对upx3.0以后加密壳挺畏惧的，其逻辑看起来挺简单的，有想逆一把的想法，但是都没实施，今天又遇到了，没法，太急，去google了一下，找到几篇资料<br>但是年代都挺久远的，看到[1]中直接esp定律就脱了，有点不信，就试了试，靠，居然可以，只能表示，实践是检验真理的唯一标准。</p>
<a id="more"></a>
<p>#<strong>1. 查壳</strong><br><strong>[!] UPX 3.05 compressed !</strong><br>查出来是3.05，也不知道是不是误报，比[1]中版本高了点，所以也就是尝试尝试esp定律拖一下</p>
<p>#<strong>2. 脱壳</strong><br>OD加载（是个dll，通过load.exe加载），在DllMain断下，看到熟悉的pushad，感觉方法可能靠谱了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">103432E0 &gt;  807C24 08 01    cmp byte ptr ss:[esp+0x8],0x1</div><div class="line">103432E5    0F85 9D0B0000   jnz xxx.10343E88</div><div class="line">103432EB    60              pushad</div><div class="line">103432EC    BE 00C02C10     mov esi,xxx.102CC000</div></pre></td></tr></table></figure></p>
<p>f8到103432EC ，在数据窗口显示esp值，然后右键下了个硬件访问断点（其实以前尝试过，但是下的是内存访问断点，失败了，也不知道是不是这个原因，待会儿试试）。接着F9，断在了下面的代码中，看不出啥，就有个 jmp xxx.100C3C71，地址离当前地址还算较远，可能是另一个节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10343E7B    8D4424 80       lea eax,dword ptr ss:[esp-0x80] //这个就是先前pushad压入的吗？？</div><div class="line">10343E7F    6A 00           push 0x0</div><div class="line">10343E81    39C4            cmp esp,eax</div><div class="line">10343E83  ^ 75 FA           jnz short xxx.10343E7F //循环了多次，F4直接到10343E85  ，应该是在清理堆栈吧？？  </div><div class="line">10343E85    83EC 80         sub esp,-0x80</div><div class="line">10343E88  - E9 E4FDD7FF     jmp xxx.100C3C71</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">100C3C71   /E9 CA371100     jmp xxx.101D7440</div><div class="line">100C3C76   |E9 15311700     jmp xxx.10236D90                           ; jmp 到 kernel32.UnlockFile</div></pre></td></tr></table></figure>
<p>单步到jmp，F8跟到其代码中，看到了熟悉的一段入口代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">101D7440    8BFF            mov edi,edi</div><div class="line">101D7442    55              push ebp</div><div class="line">101D7443    8BEC            mov ebp,esp</div><div class="line">101D7445    837D 0C 01      cmp dword ptr ss:[ebp+0xC],0x1</div><div class="line">101D7449    75 05           jnz short xxx.101D7450</div><div class="line">101D744B    E8 32DFEEFF     call xxx.100C5382</div><div class="line">101D7450    8B45 10         mov eax,dword ptr ss:[ebp+0x10]</div><div class="line">101D7453    50              push eax</div><div class="line">101D7454    8B4D 0C         mov ecx,dword ptr ss:[ebp+0xC]</div><div class="line">101D7457    51              push ecx</div><div class="line">101D7458    8B55 08         mov edx,dword ptr ss:[ebp+0x8]</div><div class="line">101D745B    52              push edx</div><div class="line">101D745C    E8 1F000000     call xxx.101D7480</div><div class="line">101D7461    83C4 0C         add esp,0xC</div><div class="line">101D7464    5D              pop ebp</div><div class="line">101D7465    C2 0C00         retn 0xC</div></pre></td></tr></table></figure></p>
<p>通过堆栈参数，进一步确认了下，这是DllMain函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0006F880   7C92118A  返回到 ntdll.7C92118A</div><div class="line">0006F884   10000000  xxx.10000000</div><div class="line">0006F888   00000001</div><div class="line">0006F88C   00000000</div></pre></td></tr></table></figure></p>
<p>然后在101D7440地址，尝试dump，成功之后在检测壳信息<br><strong>[CompilerDetect] -&gt; Visual C++ 9.0 (Visual Studio 2008)</strong><br>应该是脱壳成功了，但是iat没有修复，先ida看看是否需要修复</p>
<p>#<strong>3. 修复</strong><br>如果需要修复，使用importRec工具<br><img src="/img/fix.png" alt="img"><br>找到进程，选择目标dll，然后填入OEP，修复即可</p>
<p>#<strong>4. 参考</strong></p>
<p>[1]: <a href="http://bbs.pediy.com/showthread.php?t=44125" target="_blank" rel="external">http://bbs.pediy.com/showthread.php?t=44125</a> 【原创】手脱 UPX3.0<br>[2]: <a href="http://bbs.pediy.com/showthread.php?t=140312" target="_blank" rel="external">http://bbs.pediy.com/showthread.php?t=140312</a> 【原创】UPX3.03脱壳机-学习版[代码更新]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来一直对upx3.0以后加密壳挺畏惧的，其逻辑看起来挺简单的，有想逆一把的想法，但是都没实施，今天又遇到了，没法，太急，去google了一下，找到几篇资料&lt;br&gt;但是年代都挺久远的，看到[1]中直接esp定律就脱了，有点不信，就试了试，靠，居然可以，只能表示，实践是检验真理的唯一标准。&lt;/p&gt;
    
    </summary>
    
      <category term="reverse" scheme="https://anhkgg.github.io/categories/reverse/"/>
    
    
      <category term="upx" scheme="https://anhkgg.github.io/tags/upx/"/>
    
      <category term="unpack" scheme="https://anhkgg.github.io/tags/unpack/"/>
    
  </entry>
  
  <entry>
    <title>xctf sctf summary, little writeup</title>
    <link href="https://anhkgg.github.io/sctf-summary/"/>
    <id>https://anhkgg.github.io/sctf-summary/</id>
    <published>2014-12-07T13:02:23.000Z</published>
    <updated>2016-07-07T04:28:44.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Misc10"><a href="#1-Misc10" class="headerlink" title="1. Misc10"></a><strong>1. Misc10</strong></h1><p>xctf优良传统，百度之<br>手持两把锟斤拷，口中疾呼烫烫烫<br>脚踏千朵屯屯屯，笑看万物锘锘锘<br>其实我没提交，队友提交的，应该是这个</p>
<a id="more"></a>
<h1 id="2-Re50"><a href="#2-Re50" class="headerlink" title="2. Re50"></a><strong>2. Re50</strong></h1><p>听说逆向都挺难的，这里有个简单的，快来秒~~~ :D</p>
<p>逆向题把我们逼疯了，才弄个这个出来，秀优越吗？<br>队友做的，看了一下，很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">k = &quot;Jr3gFud6n&quot;</div><div class="line">flag = &quot;&quot;</div><div class="line">for i in range(0, len(k)):</div><div class="line">    a = ord(k[i])-3</div><div class="line">    flag += chr(a)</div><div class="line"></div><div class="line">print flag</div><div class="line">#应该是这个SCTF&#123;Go0dCra3k&#125;</div></pre></td></tr></table></figure></p>
<h1 id="3-Misc100"><a href="#3-Misc100" class="headerlink" title="3. Misc100"></a><strong>3. Misc100</strong></h1><p>简单的贪吃蛇，吃到30分它就告诉你flag！但是要怎么控制它呢? </p>
<p>妹的，确定是100的，搞了老半天，还是linux的，upx加壳，首先就乱了<br>好吧，过了不知道多久，回过神来，upx脱壳，ida加载分析，大致弄清楚流程，代码用到了几个关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">move移动光标</div><div class="line">printw显示字符</div></pre></td></tr></table></figure></p>
<p>然后就是位置比较，成功了30次之后，就会显示出flag，可是代码中没有啊，习惯了可以f5就f5，所以，乱了很久<br>回到汇编窗口，通过printw找到几处打印，提取字符，通过python打印了一下，妹的乱码，有什么编码问题，不懂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">flag = [0x7F, 0x1A, 0x64, 0x7F, 0x78, 0x44, 0x5E, 0x50, 0x67, 0x7d, 0x4E, 0x5F, 0x2A, </div><div class="line">        0x64, 0x6D, 0x52, 0x4C, 0x67, 0x72, 0x64, 0x4C, 0x70, 0x44, 0x7C, 0x5F, 0x2A,</div><div class="line">        0x48, 0x44, 0x41, 0x1C, 0x61, 0x72, 0x1A, 0x17]</div><div class="line">def printArr(arr):</div><div class="line">    for i in range(0, len(arr)):</div><div class="line">        s += chr(arr[i])</div><div class="line">    print s</div><div class="line">printArr(flag)</div></pre></td></tr></table></figure></p>
<p>没法子，我也不可能玩30分钟，只好暴力解决了，修改了几个比较，成功进入异常处理（请原谅我，看着真是异常处理），注释中是几次暴力修改位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//.text:08049D75 jz      loc_8049EA0</div><div class="line">  if ( v11 &amp;&amp; v6 == target_y )//!=text:08049EA6 jnz     loc_8049D7B</div><div class="line">        &#123;</div><div class="line">          ++dword_804C3C0;</div><div class="line">          if ( dword_804C3C0 == 5 * dword_804C3C0 / 5 )</div><div class="line">            ++dword_804C3D8;</div><div class="line">          if ( dword_804C3C0 == 3 * dword_804C3C0 / 3 )</div><div class="line">            ++dword_804C3D4;</div><div class="line">          if ( dword_804C3C0 == 30 )//!=.text:08049EFD   jz      loc_8049F94</div><div class="line">          &#123;</div><div class="line">            if ( dword_804C3D8 == 6 )//!=text:08049F9B  jnz     loc_8049F03</div><div class="line">            &#123;</div><div class="line">              if ( dword_804C3D4 == 10 )//!=.text:08049FA8 jnz     loc_8049F03</div><div class="line">              &#123;</div><div class="line">                v16 = __cxa_allocate_exception();</div><div class="line">		//执行异常中会调用chk(3)，显示Mission Complete，然后居然没有调用打印flag，</div><div class="line">		//看到有个.text:0804A039 cmp     ds:dword_804C3DC, 3Bh</div><div class="line">		//.text:0804A040 jg      short loc_804A051强制跳转到打印flag</div><div class="line">		//会进入f5没解析成功的代码，最后我都没弄清，是出题人故意的，还是ida能力问题，亦或是我的问题</div><div class="line">                *(_DWORD *)v16 = 0;</div><div class="line">                __cxa_throw(v16, &amp;_typeinfo_for_int, 0, v17);</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>ok,终于打印出来了U0NURntzMWduNGxfMXNfZnVubnk6KX0=，base64解码之后SCTF{s1gn4l_1s_funny:)}，做出来还是比较兴奋的</p>
<h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a><strong>4. 其他</strong></h1><p>其他题目也尝试了很多。<br>re300，算法太绕，晕了，没去弄了，后面提示是三阶魔方，你妹啊，被吓住了，最后也没人做出来<br>re500，又来了个lua虚拟机，额，我再次败退，这次比赛逆向题基本完败，丢人。<br>图片题貌似是两题，用自己知道的各种方式尝试了，无果。<br>web题目，额，我scan了一题，看到了个head attck，然后不会了。<br>pwn题目，好简单，可是，路在何方？求writeup啊。<br>哦，还有两道code的题目，code200在我们努力下，队友提交成功，code400目前还在暴力运算中，明天看看有答案不（求思路，野路子只有暴力破了，也不知道对不）。<br>我想说code500，请问3 3 1是几个意思啊。按我们分析的思路弄出来了，跟我说wrong input！逗我呢啊，要writeup！</p>
<p>最后总结：<br>太急躁，没思路，最后还是能力问题！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Misc10&quot;&gt;&lt;a href=&quot;#1-Misc10&quot; class=&quot;headerlink&quot; title=&quot;1. Misc10&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. Misc10&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;xctf优良传统，百度之&lt;br&gt;手持两把锟斤拷，口中疾呼烫烫烫&lt;br&gt;脚踏千朵屯屯屯，笑看万物锘锘锘&lt;br&gt;其实我没提交，队友提交的，应该是这个&lt;/p&gt;
    
    </summary>
    
      <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://anhkgg.github.io/tags/ctf/"/>
    
      <category term="sctf" scheme="https://anhkgg.github.io/tags/sctf/"/>
    
      <category term="writeup" scheme="https://anhkgg.github.io/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>some thing in c++ reverse</title>
    <link href="https://anhkgg.github.io/some-thing-in-c-reverse/"/>
    <id>https://anhkgg.github.io/some-thing-in-c-reverse/</id>
    <published>2014-12-05T09:10:20.000Z</published>
    <updated>2016-07-07T04:29:20.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a><strong>1. 工具</strong></h1><p>逆向中，在c++类识别中，IDA能够比较好完成一些工作。<br>由于此类经验较少，写上一点自己的总结，不对之处，请指正，或者有更好的经验，请大牛们指导，最好能放点com逆向的经验就更好了。<br><a id="more"></a></p>
<h1 id="2-寻找构造函数"><a href="#2-寻找构造函数" class="headerlink" title="2. 寻找构造函数"></a><strong>2. 寻找构造函数</strong></h1><p>在分析mfc程序中，很多时候，对应响应函数的查找比较麻烦。比如，注册验证中，无法定位按钮点击之后的响应函数，无法对获取输出函数下断，无法弹框下断。但是可以对控件类下断，比如<br>窗口初始化中，控件初始化，可以对某些控件类进行下断，如CButton::CButton，那么就可以回溯到窗口的构造函数中了。至于如何获取CButton::CButton地址，那就要结合ida（符号文件）之类的的</p>
<h1 id="3-虚表"><a href="#3-虚表" class="headerlink" title="3. 虚表"></a><strong>3. 虚表</strong></h1><p>在窗口的构造函数中，一般会对对象进行初始化，很重要的一个就是虚表指针的初始化，嘿嘿，那么我们就可以到虚表指针一观了，看到了什么，恩，类脱光了衣服（别想歪了），我们可以很方便找到<br>窗口类的各种相应函数了，详细就多说了，各自体会吧</p>
<h1 id="4-详细分析"><a href="#4-详细分析" class="headerlink" title="4. 详细分析"></a><strong>4. 详细分析</strong></h1><p>既然找到了响应函数，那么后续的就是详细的分析了。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h1><p>这只是自己的一点点小小总结，内容较少，希望对大家有点帮助，还是那句话，请大家多交流，多指导。<br>某对于com逆向真是，，，一个字，，，很晕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-工具&quot;&gt;&lt;a href=&quot;#1-工具&quot; class=&quot;headerlink&quot; title=&quot;1. 工具&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 工具&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;逆向中，在c++类识别中，IDA能够比较好完成一些工作。&lt;br&gt;由于此类经验较少，写上一点自己的总结，不对之处，请指正，或者有更好的经验，请大牛们指导，最好能放点com逆向的经验就更好了。&lt;br&gt;
    
    </summary>
    
      <category term="reverse" scheme="https://anhkgg.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>
    
      <category term="c++" scheme="https://anhkgg.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>inject process analyze 2</title>
    <link href="https://anhkgg.github.io/inject-process-analyze%202/"/>
    <id>https://anhkgg.github.io/inject-process-analyze%202/</id>
    <published>2014-11-25T09:45:00.000Z</published>
    <updated>2016-07-07T04:31:16.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a><strong>1. 来源</strong></h1><p>某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。<br>前面分析了一种进程注入方法，现在开始分析另外一种貌似更猥琐的方式，貌似说这种技术用在ramnit病毒中，下面这图是大致原理图（<a href="http://www.pctrojan.com/content/723-virus-blocks-itself" target="_blank" rel="external">引用的</a>）<br><a id="more"></a><br><img src="/img/it_infection.png" alt="img"><br>简单测试了下，CreateProcess时，会多次调用ZwWriteVirtualMemroy，本以为是写入PE文件的，结果没有看到，所有有点不明白，钩住ZwWriteVirtualMemroy怎么用，文章中提到的是这样：<br>The hooked Windows native system service redirects the code execution flow to the module defined in the caller process to perform the code injection routine. The injected code in the new process includes the capability for file infection (Windows executable and HTML files), as well as backdoor and downloader functionalities.<br>大意可能是各位写入进程中一些代码，比如backdoor，downloader，但是就是不明白如何执行起来，所以需要找个样本来学习一下，如何利用</p>
<h1 id="2-样本获取"><a href="#2-样本获取" class="headerlink" title="2. 样本获取"></a><strong>2. 样本获取</strong></h1><p>在卡饭中搜索到了几个可能是ramnit的样本，有两个没有解压密码，气死了，其他的都是upx3.0加壳，妹啊，脱不了啊，最后下了个交desktoplayer.exe，以为没壳了，结果弄了半天还是upx3.0.8，最后，直接OD吧，<br>断了几次CreateProcessA，可以看到创建了iexplorer.exe，但是参数貌似不是CREATE_SUSPENDED（后面才想起，这种方式不用），然后就想直接在ZwWriteVirtualMemory下断，od没法了，转到windbg吧，有了下面的分析</p>
<h1 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a><strong>3. 分析</strong></h1><p>首先想到就是直接对zwwritevirtualmemory下断，然后回溯到inject代码中，结果居然会崩。。这。。不过还是找到了inject代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">0:000&gt; bp ntdll!zwwritevirtualmemory</div><div class="line">0:000&gt; g</div><div class="line">(7e8.af4): Break instruction exception - code 80000003 (first chance)</div><div class="line">eax=00960000 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56c</div><div class="line">eip=00930005 esp=0012f094 ebp=0012f0b4 iopl=0         nv up ei pl nz na pe cy</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207</div><div class="line">00930005 cc              int     3</div><div class="line">0:000&gt; g</div><div class="line">(7e8.af4): Access violation - code c0000005 (first chance)</div><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected and handled.</div><div class="line">eax=ba960002 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56c</div><div class="line">eip=7c92df96 esp=0012f094 ebp=0012f0b4 iopl=0         nv up ei ng nz na po nc</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010282</div><div class="line">ntdll!ZwWriteVirtualMemory+0x6:</div><div class="line">7c92df96 0003            add     byte ptr [ebx],al          ds:0023:000009c6=??</div><div class="line">0:000&gt; kn</div><div class="line"> # ChildEBP RetAddr  </div><div class="line">00 0012f090 00402a74 ntdll!ZwWriteVirtualMemory+0x6</div><div class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</div><div class="line">01 0012f0b4 7c81a636 image00400000+0x2a74//这里既是调用ZwWriteVirtualMemory的代码</div><div class="line">02 0012f3ac 7c819da8 kernel32!BasePushProcessParameters+0x281</div><div class="line">03 0012fe0c 7c81d627 kernel32!CreateProcessInternalW+0x184e</div><div class="line">04 0012fef8 7c802397 kernel32!CreateProcessInternalA+0x29c</div><div class="line">05 0012ff30 004013c0 kernel32!CreateProcessA+0x2c</div><div class="line">06 0012ffb4 00402cda image00400000+0x13c0</div><div class="line">07 0012fff0 00000000 image00400000+0x2cda</div><div class="line">0:000&gt; ub 7c81a636</div><div class="line">kernel32!BasePushProcessParameters+0x266:</div><div class="line">7c81a61b 6a00            push    0</div><div class="line">7c81a61d 53              push    ebx</div><div class="line">7c81a61e 56              push    esi</div><div class="line">7c81a61f 8b85ccfdffff    mov     eax,dword ptr [ebp-234h]</div><div class="line">7c81a625 ff7048          push    dword ptr [eax+48h]</div><div class="line">7c81a628 ffb580fdffff    push    dword ptr [ebp-280h]</div><div class="line">7c81a62e 8b350014807c    mov     esi,dword ptr [kernel32!_imp__NtWriteVirtualMemory (7c801400)]</div><div class="line">7c81a634 ffd6            call    esi//这里既是调用ZwWriteVirtualMemory的代码</div></pre></td></tr></table></figure></p>
<p>对7c81a634 下断，重新加载程序，g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">0:000&gt; bp 7c81a634</div><div class="line">0:000&gt; g</div><div class="line">ModLoad: 76300000 7631d000   C:\WINDOWS\system32\IMM32.DLL</div><div class="line">ModLoad: 62c20000 62c29000   C:\WINDOWS\system32\LPK.DLL</div><div class="line">ModLoad: 73fa0000 7400b000   C:\WINDOWS\system32\USP10.dll</div><div class="line">ModLoad: 77180000 77283000   C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\comctl32.dll</div><div class="line">ModLoad: 5d170000 5d20a000   C:\WINDOWS\system32\comctl32.dll</div><div class="line">(1ec.1f4): Access violation - code c0000005 (first chance)</div><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected and handled.</div><div class="line">eax=00000001 ebx=84493bb9 ecx=7ffdf000 edx=00150608 esi=00150000 edi=84493bb1</div><div class="line">eip=7c98d811 esp=0012fc38 ebp=0012fc98 iopl=0         nv up ei pl zr na pe nc</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246</div><div class="line">ntdll!RtlDebugFreeHeap+0x82:</div><div class="line">7c98d811 0fb707          movzx   eax,word ptr [edi]       ds:0023:84493bb1=????</div><div class="line">0:000&gt; g</div><div class="line">Breakpoint 0 hit</div><div class="line">eax=00960000 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56c</div><div class="line">eip=7c81a634 esp=0012f0bc ebp=0012f3ac iopl=0         nv up ei pl zr na pe nc</div><div class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</div><div class="line">kernel32!BasePushProcessParameters+0x27f:</div><div class="line">7c81a634 ffd6            call    esi &#123;ntdll!ZwWriteVirtualMemory (7c92df90)&#125;</div></pre></td></tr></table></figure></p>
<p>确认一下ZwWriteVirtualMemory被hook<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0:000&gt; u 7c92df90</div><div class="line">ntdll!ZwWriteVirtualMemory:</div><div class="line">*** WARNING: Unable to verify checksum for image00400000</div><div class="line">*** ERROR: Module load completed but symbols could not be loaded for image00400000</div><div class="line">7c92df90 e9c44aad83      jmp     image00400000+0x2a59 (00402a59)</div><div class="line">7c92df95 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)</div><div class="line">7c92df9a ff12            call    dword ptr [edx]</div><div class="line">7c92df9c c21400          ret     14h</div><div class="line">7c92df9f 90              nop</div></pre></td></tr></table></figure></p>
<p>想着就在这把文件dump出来，在ida中看方便点，然后再od中下断，为了怕跑飞，也对CreateProcessA下断了，然后运行，现在CreateProcessA中断下来，回溯了一下，看着堆栈栈帧很少，就尝试看能够脱壳不<br>很笨的下断回溯了两次，到了00402C5B ，一点都不想c入口，但是上次没有，调用地址是0012FFC4   7C817067  返回到 kernel32.7C817067<br>也不像是壳进行了入口的patch，将就吧，dump出来，importrect修复了一下，嘿，在ida中一看，还不错，入口代码这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00402C5B    68 00040000     push 0x400</div><div class="line">00402C60    68 D0DF4000     push DesktopL.0040DFD0</div><div class="line">00402C65    E8 AEEAFFFF     call DesktopL.00401718</div><div class="line">00402C6A    83F8 01         cmp eax,0x1</div><div class="line">00402C6D    75 70           jnz short DesktopL.00402CDF</div><div class="line">00402C6F    68 00404000     push DesktopL.00404000                                            ; ASCII &quot;KyUffThOkYwRRtgPP&quot;</div><div class="line">00402C74    E8 66EAFFFF     call DesktopL.004016DF</div></pre></td></tr></table></figure></p>
<p>马上定位到image00400000+0x2a59，修复的还不错，这下子方便多了，可以直接f5，但是不能正常执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">__int64 __stdcall myHookZwWriteVirtualMemory(HANDLE hProcess, int a2, int a3, int a4, int a5) </div><div class="line">&#123; </div><div class="line">LODWORD(v5) = mySysZwWriteVirtualMemory(hProcess, a2, a3, a4, a5, NumberOfBytesWritten, flOldProtect, v12);// 调用原函数 </div><div class="line">NumberOfBytesWritten = (SIZE_T)&amp;v12;</div><div class="line">v9 = v5;</div><div class="line">if ( hProcess != (HANDLE)-1 )</div><div class="line">&#123;</div><div class="line">if ( !myInjectFlag )</div><div class="line">&#123;</div><div class="line">if ( !lpAddress ) // 初始化为0</div><div class="line">&#123;</div><div class="line">EOP = (void *)myGetEOP(hProcess); // 获取到宿主进程EOP</div><div class="line">if ( EOP )</div><div class="line">&#123;</div><div class="line">myInjectFlag = 1;</div><div class="line">lpAddress = EOP;</div><div class="line">dword_40DFA8 = myInjectMyExe(hProcess, (int)&quot;MZ, 0x9800u);</div><div class="line">dword_40DFAD = v7;</div><div class="line">if ( dword_40DFA8 )</div><div class="line">&#123;</div><div class="line">VirtualProtectEx(hProcess, lpAddress, 0xCu, 0x40u, &amp;flOldProtect);</div><div class="line">WriteProcessMemory(hProcess, lpAddress, &amp;byte_40DFA7, 0xCu, &amp;NumberOfBytesWritten); //入口感染</div><div class="line">VirtualProtectEx(hProcess, lpAddress, 0xCu, flOldProtect, &amp;flOldProtect);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return v9;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在钩子函数中，工作很少，获取到宿主进程EOP，在宿主进程中加载自己的程序，然后对EOP进行感染，也就是跳转到自己的程序代码空间<br>代码基本就这么多了，最后怎么玩就靠自己的代码了。</p>
<h1 id="3-技术总结"><a href="#3-技术总结" class="headerlink" title="3. 技术总结"></a><strong>3. 技术总结</strong></h1><p>其实和另一个中注入方式大同小异，目标都是为了将自己的程序映射到宿主进程空间中。<br>一个直接暴力suspend，读写，另一个在创建进程过程中进行读写。<br>由于两种方式都有远程进程读写操作，都应该会被主防拦住，貌似现在效果也不是很好了<br>是否可以再读写内存时，对主防进行欺骗呢，还需要研究….</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-来源&quot;&gt;&lt;a href=&quot;#1-来源&quot; class=&quot;headerlink&quot; title=&quot;1. 来源&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 来源&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。&lt;br&gt;前面分析了一种进程注入方法，现在开始分析另外一种貌似更猥琐的方式，貌似说这种技术用在ramnit病毒中，下面这图是大致原理图（&lt;a href=&quot;http://www.pctrojan.com/content/723-virus-blocks-itself&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;引用的&lt;/a&gt;）&lt;br&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>
    
      <category term="inject process" scheme="https://anhkgg.github.io/tags/inject-process/"/>
    
  </entry>
  
  <entry>
    <title>inject process analyze and code</title>
    <link href="https://anhkgg.github.io/inject-process-analyze-and-code/"/>
    <id>https://anhkgg.github.io/inject-process-analyze-and-code/</id>
    <published>2014-11-25T09:45:00.000Z</published>
    <updated>2017-05-16T13:36:00.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a><strong>1. 起因</strong></h1><p>某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。由于没有样本，也没有搜索到资料，只能作罢。<br>某天，突然来了兴致，要分析个样本，随便在卡饭样本区下了个感觉挺啥啥的样本，一分析，你妹，咋这么熟悉呢，居然就是同类的进程注入，然后某人就有了下面的文章。</p>
<a id="more"></a>
<h1 id="2-分析与实现"><a href="#2-分析与实现" class="headerlink" title="2. 分析与实现"></a><strong>2. 分析与实现</strong></h1><h2 id="2-1-PEID"><a href="#2-1-PEID" class="headerlink" title="2.1 PEID"></a><strong>2.1 PEID</strong></h2><p>壳信息：Microsoft Visual C++ v6.0，无壳<br>文件名：bbs.exe<br>既然无壳，直接ida先分析一下，遇到无法分析的OD继续调试。</p>
<h2 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a><strong>2.2 分析</strong></h2><p>打开IDA，拖入文件，找到主函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.text:0040A720 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</div><div class="line">.text:0040A720</div><div class="line">.text:0040A720                 push    ebp</div><div class="line">.text:0040A721                 mov     ebp, esp</div><div class="line">.text:0040A723                 push    ecx</div><div class="line">.text:0040A724                 call    sub_408BE0</div><div class="line">.text:0040A729                 mov     esp_4FEE68, esp</div><div class="line">.text:0040A72F                 mov     esp_4FEE6C, ebp</div><div class="line">.text:0040A735                 call    sub_408929//主功能函数</div><div class="line">.text:0040A73A                 mov     [ebp+var_4], eax</div><div class="line">.text:0040A73D                 mov     eax, [ebp+var_4]</div><div class="line">.text:0040A740                 mov     esp, ebp</div><div class="line">.text:0040A742                 pop     ebp</div><div class="line">.text:0040A743                 retn    10h</div><div class="line">.text:0040A743 _WinMain@16     endp</div></pre></td></tr></table></figure></p>
<p>没什么东西，继续sub_408929：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.text:00408929 sub_408929      proc near               ; CODE XREF: WinMain(x,x,x,x)+15</div><div class="line">.text:00408929                 cld</div><div class="line">.text:0040892A                 fninit</div><div class="line">.text:0040892C                 call    myNewObj</div><div class="line">.text:00408931                 push    offset sub_406C2A</div><div class="line">.text:00408936                 mov     eax, 3</div><div class="line">.text:0040893B                 call    myInitFunc</div><div class="line">.text:00408940                 add     esp, 4</div><div class="line">.text:00408943                 call    sub_40101D//这几个都是些无用函数，多半是花指令</div><div class="line">.text:00408948                 call    sub_406B84</div><div class="line">.text:0040894D                 call    sub_406BDB</div><div class="line">.text:00408952                 call    sub_401000</div><div class="line">.text:00408957                 call    sub_406BBE</div><div class="line">.text:0040895C                 call    sub_406BA1</div><div class="line">.text:00408961                 call    sub_406BF8</div><div class="line">.text:00408966                 call    myReleaseFile//文件释放，可能是功能文件</div><div class="line">.text:0040896B                 push    eax             ; uExitCode</div><div class="line">.text:0040896C                 call    nullsub_1</div><div class="line">.text:00408971                 call    j_myExit</div><div class="line">.text:00408976                 add     esp, 4</div><div class="line">.text:00408979                 retn</div><div class="line">.text:00408979 sub_408929      endp</div></pre></td></tr></table></figure></p>
<p>其他函数都没有什么重要的代码，接着看看myReleaseFile，代码太多，直接f5看看整体流程，结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">int __cdecl myReleaseFile()</div><div class="line">&#123;</div><div class="line">  lpMem = &quot;QzpcUHJvZ3JhbSBGaWxlc1xDb21tb24gRmlsZXNcTWljcm9zb2Z0IFNoYXJlZFxNU0luZm9ca2trLnR4dA==&quot;;// C:\Program Files\Common Files\Microsoft Shared\MSInfo\kkk.txt</div><div class="line">  v12 = (void *)myBase64Dec(&amp;lpMem);</div><div class="line">  if ( lpMem )</div><div class="line">    j_myIsInMyImg(lpMem);</div><div class="line">  v1 = (int)v12;</div><div class="line">  if ( !v12 )</div><div class="line">    v1 = (int)dword_416285;</div><div class="line">  pszPath = (LPCSTR)myFormat(ebp0, 1, (unsigned int)v1, 0x80000005u);//  C:\Program Files\Common Files\Microsoft Shared\MSInfo\kkk.txt</div><div class="line">  v2 = (int)v12;</div><div class="line">  if ( v12 )</div><div class="line">    j_myIsInMyImg(v12);</div><div class="line">  v10 = (int *)&amp;v6;</div><div class="line">  v3 = PathFileExistsA(pszPath);</div><div class="line">  if ( (void **)v10 != &amp;v6 )</div><div class="line">    v3 = myRunError(v2, 6);</div><div class="line">  v9 = v3;</div><div class="line">  if ( pszPath )</div><div class="line">    j_myIsInMyImg((void *)pszPath);</div><div class="line">  if ( v9 == 1 )</div><div class="line">  &#123;</div><div class="line">    lpMem = &quot;我是一个中国人&quot;;//恩，很爱国</div><div class="line">    v12 = &quot;34,85,10,1D,04,D1,CF,42,DF,A4,B0,&quot;;</div><div class="line">    pszPath = (LPCSTR)myDecStr(&amp;v12, &amp;lpMem);   // 字符串解密，&quot;svchost.exe&quot;</div><div class="line">    if ( v12 )</div><div class="line">      j_myIsInMyImg(v12);</div><div class="line">    if ( lpMem )</div><div class="line">      j_myIsInMyImg(lpMem);</div><div class="line">    v4 = j_myNewBuf(ebp0, 0x10u);</div><div class="line">    v10 = (int *)v4;</div><div class="line">    *(_DWORD *)v4 = 0;</div><div class="line">    *((_DWORD *)v4 + 1) = 0;</div><div class="line">    *((_DWORD *)v4 + 2) = 0;</div><div class="line">    *((_DWORD *)v4 + 3) = 0;</div><div class="line">    v9 = 0;</div><div class="line">    v8 = 0;</div><div class="line">    v7 = 0;</div><div class="line">    v6 = &amp;unk_4162BE;</div><div class="line">    myWork(&amp;v6, &amp;v7, 0, &amp;pszPath, 1, 0, 0, 0, 0, &amp;v10, 0);//注入进程的功能，代码中很多混淆</div><div class="line">    if ( v6 )</div><div class="line">      j_myIsInMyImg(v6);</div><div class="line">    if ( v7 )</div><div class="line">      j_myIsInMyImg(v7);</div><div class="line">    if ( pszPath )</div><div class="line">      j_myIsInMyImg((void *)pszPath);</div><div class="line">    j_myIsInMyImg(v10);</div><div class="line">    sub_40574F();</div><div class="line">  &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于在myWork中太多混淆，IDA无力，转战OD，看到高大上的进程注入。由于代码混淆，太多PE操作，而且IDA没有有效识别内存拷贝函数，给分析带来了较大困难。<br>下面是主要的进程注入用到的函数表，myWork中调用这些关键函数，都是通过该函数表调用，里面通过loaddll+getprocaddress获取到函数地址，返回，然后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">.data:004FB87F myLocalSize1    dd offset myLocalSize   ; DATA XREF: .text:00402CAC r</div><div class="line">.data:004FB883 myRtlMoveMemory1 dd offset myRtlMoveMemory ; DATA XREF: .text:00402F32 r</div><div class="line">.data:004FB887 myLocalSize2    dd offset sub_4089DC    ; DATA XREF: .text:00403303 r</div><div class="line">.data:004FB88B myRtlMoveMemory2 dd offset sub_4089F2   ; DATA XREF: .text:00403701 r</div><div class="line">.data:004FB88F myLocalSize3    dd offset sub_408A08    ; DATA XREF: .text:00403A06 r</div><div class="line">.data:004FB893 myCreateProcessA dd offset sub_408A1E   ; DATA XREF: .text:00403DEE r</div><div class="line">.data:004FB897 myGetThreadContext dd offset sub_408A34 ; DATA XREF: sub_403FC0+C8 r</div><div class="line">.data:004FB89B myReadProcessMemory dd offset sub_408A4A ; DATA XREF: sub_403FC0+2E9 r</div><div class="line">.data:004FB89F myZwUnmapViewOfSection dd offset sub_408A60 ; DATA XREF: sub_403FC0+335 r</div><div class="line">.data:004FB8A3 myVirtualAllocEx dd offset sub_408A76   ; DATA XREF: sub_403FC0+3AC r</div><div class="line">.data:004FB8A7 myWriteProcessMemory dd offset sub_408A8C ; DATA XREF: sub_403FC0+43F r</div><div class="line">.data:004FB8AB myLocalSize5    dd offset sub_408AA2    ; DATA XREF: sub_403FC0+9A7 r</div><div class="line">.data:004FB8AF myRtlMoveMemory_0 dd offset sub_408AB8  ; DATA XREF: sub_403FC0+B0E r</div><div class="line">.data:004FB8B3 myVirtualProtectEx dd offset sub_408ACE ; DATA XREF: sub_403FC0+D60 r</div><div class="line">.data:004FB8B7 myWriteProcessMemory_0 dd offset sub_408AE4 ; DATA XREF: sub_403FC0+DD2 r</div><div class="line">.data:004FB8BB mySetThreadContext dd offset sub_408AFA ; DATA XREF: sub_403FC0+FA8 r</div><div class="line">.data:004FB8BF myResumeThread  dd offset sub_408B10    ; DATA XREF: sub_403FC0+1172 r</div><div class="line">.data:004FB8C3 myWaitForSingleObject dd offset sub_408B26 ; DATA XREF: sub_403FC0+11AD r</div><div class="line">.data:004FB8C7 myCloseHandle_  dd offset sub_408B3C    ; DATA XREF: sub_403FC0+11E6 r</div><div class="line">.data:004FB8CB myGetEnvironmentVariableA dd offset sub_408B52</div><div class="line">.data:004FB8CF myTerminateProcess dd offset sub_408B68 ; DATA XREF: sub_4053DE+1E r</div><div class="line">.data:004FB8D3 myReadFileEx    dd offset sub_408B7E    ; DATA XREF: sub_405FAA+1E2 r</div><div class="line">.data:004FB8D7 myGetFileSize   dd offset sub_408B94    ; DATA XREF: sub_4063B0+DF r</div><div class="line">.data:004FB8DB myCloseHandle   dd offset sub_408BAA    ; DATA XREF: sub_4064C4+1D r</div><div class="line">.data:004FB8DF myLocalFree     dd offset sub_408BC0    ; DATA XREF: sub_4065D9+541 r</div></pre></td></tr></table></figure></p>
<p>获取函数的代码结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.text:004089B0 myLocalSize     proc near               ; CODE XREF: .text:00402CAC p</div><div class="line">.text:004089B0                                         ; DATA XREF: .data:myLocalSize1 o</div><div class="line">.text:004089B0                 push    offset myLocalSize1 ; int</div><div class="line">.text:004089B5                 push    offset aLocalsize ; &quot;LocalSize&quot;</div><div class="line">.text:004089BA                 push    offset aKernel32 ; &quot;kernel32&quot;</div><div class="line">.text:004089BF                 call    myGetProc</div><div class="line">.text:004089C4                 jmp     eax</div><div class="line">.text:004089C4 myLocalSize     endp</div></pre></td></tr></table></figure></p>
<p>最后基本总结了myWork的代码逻辑，也一窥了进程注入的猥琐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CreateProcessA(0, &quot;svchost.exe&quot;, 0, 0, 0, 4/*CREATE_SUSPENDED*/, 0, 0, &amp;sa, &amp;pi );//按suspend创建进程，这样主线程就会挂起，等待后面的宰割</div><div class="line">GetThreadContext(pi.hThread, &amp;context);</div><div class="line">ReadProcessMemory(pi.hProcess, 0x7ffde008/*peb-&gt;ImageBaseAddress*/, buf, 4, &amp;size); /*获取到的是img基地址 peb-&gt;ImageBaseAddress*/</div><div class="line">ZwUnmapViewOfSection(pi.hProcess, buf);//这里有个bug，buf传递方式错误，导致无法unmap，应该是&amp;buf</div><div class="line">VirtualAllocEx(pi.hProcess, 0x400000, size, MEM_COMMIT|MEM_RESERVE/*0x3000*/, PAGE_READWRITE/**4/ );</div><div class="line">//解析PE文件，写入进程对应位置</div><div class="line">WriteProcessMemory(pi.hProcess, 0x400000, buf, 0x1000, &amp;size);//写入头部</div><div class="line">for(i =0 ;i&lt;num_of_sec; i++)</div><div class="line">&#123;</div><div class="line">    WriteProcessMemory(pi.hProcess, 0x400000+sec[i].va, buf, sec[i].size, &amp;size);//.text, .rdata, .data</div><div class="line">    VirtualProtectEx(pi.hProcess, 0x400000+sec[i].va, sec[i].size, NewProtect, &amp;oldProtect);//PAGE_EXECUTE_READ, PAGE_READONLY, PAGE_READWRITE</div><div class="line">&#125;</div><div class="line">//重写eop</div><div class="line">//重写基地址</div><div class="line">WriteProcessMemory(pi.hProcess, 0x7ffde008/*peb-&gt;ImageBaseAddress*/, MyBaseAddr, 4, &amp;size);//写入我的img 基地址 0x400000</div><div class="line">SetThreadContext(pi.hProcess, context);//恢复</div><div class="line">ResumeThread(pi.hThread);//恢复线程执行</div></pre></td></tr></table></figure></p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h1><p>本来打算完整分析一下的，在分析到进程注入时，由于自己代码实现中，遇到了一些问题，调试无语，eop和基地址都改写了，那么就是映射section遇到问题，终于修改成<br>直接pe完整写入宿主进程，成功执行了注入进程的功能。<br>所以，后面也没时间具体分析样本的功能了。<br>测试了该方式，无法过掉主防，在WriteProcessMemory就会被拦截，所以该方式基本只是作为技术研究，直接使用，还需努力。</p>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a><strong>4. 参考</strong></h1><p>[1] <a href="http://www.cnblogs.com/lbq1221119/archive/2008/07/22/1248706.html" target="_blank" rel="external">http://www.cnblogs.com/lbq1221119/archive/2008/07/22/1248706.html</a><br>[2] <a href="http://blog.csdn.net/darthas/article/details/12569443" target="_blank" rel="external">http://blog.csdn.net/darthas/article/details/12569443</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-起因&quot;&gt;&lt;a href=&quot;#1-起因&quot; class=&quot;headerlink&quot; title=&quot;1. 起因&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 起因&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。由于没有样本，也没有搜索到资料，只能作罢。&lt;br&gt;某天，突然来了兴致，要分析个样本，随便在卡饭样本区下了个感觉挺啥啥的样本，一分析，你妹，咋这么熟悉呢，居然就是同类的进程注入，然后某人就有了下面的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="reverse" scheme="https://anhkgg.github.io/tags/reverse/"/>
    
      <category term="inject process" scheme="https://anhkgg.github.io/tags/inject-process/"/>
    
  </entry>
  
  <entry>
    <title>010注册算法分析</title>
    <link href="https://anhkgg.github.io/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://anhkgg.github.io/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2014-11-17T02:13:19.000Z</published>
    <updated>2016-07-07T04:32:12.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-关键函数定位"><a href="#1-关键函数定位" class="headerlink" title="1. 关键函数定位"></a><strong>1. 关键函数定位</strong></h2><p>进入register窗口，随便填入name，然后check license，弹框信息”Invalid name or password. Please enter your name and password exactly as given when you purchased 010 Editor (make sure no quotes are included).”，通过该信息在IDA中找到对应函数地址，基本可以确认是关键函数位置，函数居然有名字，这是作者故意留下的吗。下面是整个验证函数流程：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void __usercall chekc(char a1&lt;zf&gt;, int a2&lt;ecx&gt;)</div><div class="line">&#123;</div><div class="line">	//获取用户名</div><div class="line">	//是否为空</div><div class="line">	//获取注册码</div><div class="line">	//是否为空</div><div class="line">	//注册码格式检查xxxx-xxxx-xxxx-xxxx-xxxx</div><div class="line">	v42 = (void *)myCheck(mygbName, 3u, &apos;9A&apos;); //注册码验证，返回值v42对于是否注册成功，有很大关系，返回值为231，为失败</div><div class="line">	v26 = mySecondCheck(mygbName, 3u, &apos;9A&apos;);  // 第二次检查，如果返回中为219，就会进入后面的注册成功提示</div><div class="line">	//myCheck中返回不等于231，mygbName + 44提示进入网络验证，没有弄清楚，哪里会等于1</div><div class="line">	if ( v42 != (void *)231 &amp;&amp; *(_DWORD *)(mygbName + 44) )</div><div class="line">	&#123;</div><div class="line">		v27 = myWebCheck((void *)mygbName, 0);</div><div class="line">		if(v27 &lt; 0 )</div><div class="line">		&#123;</div><div class="line">			v43 = myMsg(&quot;Could not contact the webserver. Please check your internet connection. If your internet connection is currently working, the server may be down. If this problem persists, please visit &apos;http://www.sweetscape.com/support/&apos; (&quot;, 0xFFFFFFFFu);</div><div class="line">		&#125;</div><div class="line">		if ( !v27 )</div><div class="line">		&#123;</div><div class="line">			v43 = myMsg( &quot;010 Editor has detected that you have entered an invalid license. Please check to see if your license is entered correctly and try again. If this problem persists, please visit &apos;http://www.sweetscape.com/support/&apos;.&quot;, 0xFFFFFFFFu);</div><div class="line">		&#125;</div><div class="line">		v33 = mySecondCheck(mygbName, 3u, &apos;9A&apos;);//网络验证是否成功，成功，返回219</div><div class="line">	&#125;</div><div class="line">	if ( v43 == (void *)219 )                     // v43 == 219，注册成功</div><div class="line">	&#123;</div><div class="line">		v43 = myMsg(&quot;Password accepted. Thank you for purchasing 010 Editor!&quot;, 0xFFFFFFFFu);</div><div class="line">		//写入注册表</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2. 算法分析"></a><strong>2. 算法分析</strong></h2><p>下面看看主要的验证函数myCheck和mySecondCheck，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">signed int __thiscall mySecondCheck(int this, unsigned int a2, unsigned int a3)</div><div class="line">&#123;</div><div class="line">  int v3; // esi@1</div><div class="line">  signed int result; // eax@2</div><div class="line">  int v5; // eax@3</div><div class="line">  int v6; // eax@6</div><div class="line">  int v7; // eax@9</div><div class="line"></div><div class="line">  v3 = this;</div><div class="line">  if ( *(_DWORD *)(this + 44) )                 // 要让这个值等于0，否则进入网络验证，初始化就是0</div><div class="line">	return 275;</div><div class="line">  v5 = myCheck(this, a2, a3);	//可以看到，只有返回值是45时，才能返回219，注册成功</div><div class="line">  if ( v5 == 45 )</div><div class="line">  &#123;</div><div class="line">	result = 219;                               // 返回219， 注册成功</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，只有返回值是45时，才能返回219，注册成功。<br>那么返回myCheck看看，怎么才能得到45的返回值，整个返回值查看一下，只有两处位置，可能返回45，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if ( v26 == 0x9Cu )</div><div class="line">&#123;</div><div class="line">	v20 = *(_DWORD *)(regdlg + 28) &lt; a2;</div><div class="line">	return (-v20 &amp; 0x21) + 45;                  // 成功？</div><div class="line">&#125;</div><div class="line">if ( v26 != 0xFCu )</div><div class="line">&#123;</div><div class="line">	if ( v26 == 0xACu &amp;&amp; v33 )</div><div class="line">	&#123;</div><div class="line">	  v20 = v33 &lt; a3;</div><div class="line">	  return (-v20 &amp; 0x21) + 45;                // 成功？</div><div class="line">	&#125;</div><div class="line">return 231;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么就需要回溯回去，看看v26，是如何得到的，只有在v26等于0x9c或者0xAc时，才有可能注册成功。下面看看完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">int __thiscall myCheck(int this, unsigned int a2, unsigned int a3)</div><div class="line">&#123;</div><div class="line">	//name和key长度是否为0</div><div class="line">	//myPassCheck(this, (int)&amp;v23);//将key字符串转换成数值，每两个字符转化成2为十六进制数，</div><div class="line">	//xxxx-xxxx-xxxx-xxxx-xxxx分别对应k1k2-k3k4-k5k6-k7k8-k9k10</div><div class="line">	//v23其实就是一个数组，存的就是k1-k10</div><div class="line">	//检测name是否等于&apos;999&apos;,是，则失败</div><div class="line">	if ( v26 == 0x9Cu )</div><div class="line">	&#123;</div><div class="line">		LOBYTE(v32) = v23 ^ v28;                    // k1^k7</div><div class="line">		LOWORD(v6) = (unsigned __int8)(v24 ^ v29);  // k2^k8</div><div class="line">		LOWORD(v7) = (unsigned __int8)(v25 ^ HIBYTE(v27));// k3^k6</div><div class="line">		v11 = v7 + ((_DWORD)v6 &lt;&lt; 8);               // v11 = k3^k6 + ((k2^k8)&lt;&lt;8)</div><div class="line">		*(_DWORD *)(regdlg + 28) = (unsigned __int8)myCal1(v23 ^ v28);// k1^k7 =&gt; 不能等于0</div><div class="line">		v9 = myCal2(v11);                           // 不能等于0</div><div class="line">		v10 = *(_DWORD *)(regdlg + 28);</div><div class="line">		*(_DWORD *)(regdlg + 32) = (unsigned __int16)v9;</div><div class="line">		// v10==0,v9==0或者v9&gt;0x3e8，返回231</div><div class="line">		if ( !v10 || !v9 || (unsigned __int16)v9 &gt; 0x3E8u )</div><div class="line">		  return 231;                               </div><div class="line">		v12 = v10 &lt; 2 ? v10 : 0;                    // v12 = 0或者1</div><div class="line">	&#125;else</div><div class="line">	&#123;</div><div class="line">		if(v26 == 0xFC)</div><div class="line">		&#123;//不可能成功</div><div class="line">		&#125;esle </div><div class="line">		&#123;</div><div class="line">			//v26不等于0xAC，退出，返回231，失败</div><div class="line">			//myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &gt;  0x3E8, 失败</div><div class="line">			if ( v26 != 0xACu</div><div class="line">			|| (v15 = v24 ^ v29,//k2^k8</div><div class="line">				v16 = v25 ^ HIBYTE(v27),//k3^k6</div><div class="line">				*(_DWORD *)(regdlg + 28) = 2,</div><div class="line">				v14 = (unsigned __int16)myCal2(v16 + (v15 &lt;&lt; 8)),v11 = k3^k6 + ((k2^k8)&lt;&lt;8)</div><div class="line">				*(_DWORD *)(regdlg + 32) = (unsigned __int16)v14,</div><div class="line">				!(_WORD)v14)</div><div class="line">				|| v14 &gt; 0x3E8 )</div><div class="line">			return 231;</div><div class="line">			//sub_4FD0B9( (k1^k7 + (k9^k5 + (k6^k10)&lt;&lt;8)&lt;&lt;8), xxx);</div><div class="line">			//其实就是凑成十六进制数(k6^k10)(k9^k5)(k1^k7)</div><div class="line">			v17 = sub_4FD0B9(</div><div class="line">				  (v23 ^ v28) + (((v30 ^ (unsigned __int8)v27) + ((HIBYTE(v27) ^ v31) &lt;&lt; 8)) &lt;&lt; 8),</div><div class="line">				  (char *)loc_5B8C25 + 2);</div><div class="line">			v33 = v17;</div><div class="line">			*(_DWORD *)(regdlg + 52) = v17;</div><div class="line">			v12 = v17;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//编码name，返回给v18，</div><div class="line">	v18 = myEncStr(*(const char **)(*(_DWORD *)qstrname + 12), v26 != -4, v12, *(_DWORD *)(regdlg + 32));</div><div class="line">	//如果v18，如0xABCDEF10分解成0xAB，0xCD， 0xEF10,不等于v29, v28,v27就失败，其实就是</div><div class="line">	//(k6k5) = 0xEF10, k7 = 0xCD, k8 = 0xAB</div><div class="line">	if ( v27 != (_WORD)v18</div><div class="line">		|| v28 != (unsigned __int8)((unsigned int)v18 &gt;&gt; 0x10u)</div><div class="line">		|| v29 != (unsigned __int8)((unsigned int)v18 &gt;&gt; 0x18u) )</div><div class="line">		return 231;                                 // 这三个条件很重要啊</div><div class="line">	//下面就接近成功了，就是上面提到的返回45的结果，成功</div><div class="line">	if ( v26 == 0x9Cu )</div><div class="line">	&#123;</div><div class="line">		//这里就需要regdlg + 28 = myCal1(k1^k7) &gt;= a2,也就是3，传入的a2是3</div><div class="line">		//然后v20就是0，那么(-v20 &amp; 0x21)=0，最后返回45</div><div class="line">		v20 = *(_DWORD *)(regdlg + 28) &lt; a2;</div><div class="line">		return (-v20 &amp; 0x21) + 45;                  // 成功？</div><div class="line">	&#125;</div><div class="line">	if ( v26 != 0xFCu )</div><div class="line">	&#123;</div><div class="line">		if ( v26 == 0xACu &amp;&amp; v33 )</div><div class="line">		&#123;</div><div class="line">		  v20 = v33 &lt; a3;</div><div class="line">		  return (-v20 &amp; 0x21) + 45;                // 成功？</div><div class="line">		&#125;</div><div class="line">	return 231;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后总结一下算法，基本可以列出一个方程类似的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">k4 = 0x9C或者0xAC</div><div class="line">myCal1(k1^k7) &gt;= 3;//可以任取大于等于3的值，算出k1^k7=？</div><div class="line">myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &gt; 0;//可以任去大于0</div><div class="line">myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &lt; 0x3E8;//小于0x3E8的某一个值，算出k3^k6 + ((k2^k8)&lt;&lt;8) = ？</div><div class="line">k8k7k6k5 = v18;//0xABCDEF10，可以得到k5=?,k6=?,k7=?,k8=?，由此可以算出上面的k1,k2</div><div class="line">sub_4FD0B9((k6^k10)(k9^k5)(k1^k7), xx) = ?//可以算出k9，k10</div></pre></td></tr></table></figure></p>
<p>下面就0x9C的情况写了个注册机</p>
<h2 id="3-注册机"><a href="#3-注册机" class="headerlink" title="3. 注册机"></a><strong>3. 注册机</strong></h2><p>根据上面的注册算法，写了个针对0x9c的注册机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">DWORD ckname(char* name, int isnotFC,  int islowk1k7, DWORD k3k6k2k8 )</div><div class="line">&#123;</div><div class="line">	int slen = strlen(name);</div><div class="line">	if(slen &gt; 0 )</div><div class="line">	&#123;</div><div class="line">		DWORD v15 = 0, v17 = 0, v16 = 0, chk = 0, v9 = 0, v8=0, v14 = 0, v5 = 0, v6 = 0;</div><div class="line">		while(v14 &lt; slen)</div><div class="line">		&#123;</div><div class="line">			DWORD v7 = toupper(name[v14]);</div><div class="line">			if(isnotFC)</div><div class="line">			&#123;</div><div class="line">				v9 = dword_B21DC4[(v17 + 15 * k3k6k2k8) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v6 + 17 * islowk1k7) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v7 + 47) &amp; 0xFF] * ((v5 + dword_B21DC4[v7]) ^ dword_B21DC4[(v7 + 13) &amp; 0xFF]);</div><div class="line">				v8 = v16;</div><div class="line">			&#125;</div><div class="line">			else&#123;</div><div class="line">				v9 = dword_B21DC4[(v17 + 15 * k3k6k2k8) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v6 + 17 * islowk1k7) &amp; 0xFF]</div><div class="line">				+ dword_B21DC4[(v7 + 23) &amp; 0xFF] * ((v5 + dword_B21DC4[v7]) ^ dword_B21DC4[(v7 + 63) &amp; 0xFF]);</div><div class="line">				v8 = v15;</div><div class="line">			&#125;</div><div class="line">			v16 += 19;</div><div class="line">			v17 += 13;</div><div class="line">			v15 += 7;</div><div class="line">			v6 += 9;</div><div class="line">			v5 = dword_B21DC4[v8] + v9;</div><div class="line">			v14 = v14 + 1;</div><div class="line">		&#125;</div><div class="line">		return v5;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	char name[] = &quot;&quot;;</div><div class="line">	char key[0x20] = &#123;0&#125;;</div><div class="line">	int k4 = 0x9c;//0xac	</div><div class="line">	int islowk1k7 = 3;//&gt;=3</div><div class="line">	int k1_xor_k7 = ((islowk1k7^0xA7)-61)^0x18;</div><div class="line"></div><div class="line">	int k3k6k2k8 = 1;//k3k6k2k8&gt;=1 &amp;&amp; k3k6k2k8&lt;0x3E8，其中任意一个值</div><div class="line">	int k3_xor_k6_k2_xor_k8 = 0xFFFF &amp; (((k3k6k2k8*11)^0x3421)-19760);</div><div class="line">	k3_xor_k6_k2_xor_k8 = k3_xor_k6_k2_xor_k8^0x7892;</div><div class="line">	int k3_xor_k6 = k3_xor_k6_k2_xor_k8 &amp; 0xff;//低位</div><div class="line">	int k2_xor_k8 = k3_xor_k6_k2_xor_k8 &gt;&gt; 8;//高位</div><div class="line"></div><div class="line">	int k1=0, k2=0, k3=0, k5=0, k6=0, k7=0, k8=0, k9=0, k10=0;//</div><div class="line"></div><div class="line">	printf(&quot;****************************************************\n&quot;);</div><div class="line">	printf(&quot;************* 010 Editor v3.1.2 keygen *************\n&quot;);</div><div class="line">	printf(&quot;*************   by anhkgg 2014-11-18   *************\n&quot;);</div><div class="line">	printf(&quot;****************************************************\n\n&quot;);</div><div class="line">	printf(&quot;name&gt;&quot;);</div><div class="line">	</div><div class="line">	scanf(&quot;%s&quot;, name);</div><div class="line">	</div><div class="line">	if(!stricmp(name, &quot;999&quot;))</div><div class="line">	&#123;</div><div class="line">		printf(&quot;name is not valid!\n&quot;);</div><div class="line">		system(&quot;pause&quot;);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	DWORD name_chk = ckname(name, k4==0x9C?1:0, islowk1k7&lt;2?islowk1k7:0, k3k6k2k8) ;</div><div class="line">	k5 = name_chk &amp; 0xFF;</div><div class="line">	k6 = (name_chk &amp; 0xFFFF)&gt;&gt;8;//</div><div class="line">	k7 = (name_chk &gt;&gt; 16) &amp; 0xFF;//</div><div class="line">	k8 = (name_chk &gt;&gt; 24) &amp; 0xFF;//</div><div class="line">	k1 = k1_xor_k7 ^ k7;//</div><div class="line">	k2 = k2_xor_k8 ^ k8;</div><div class="line">	k3 = k3_xor_k6 ^ k6;//</div><div class="line"></div><div class="line">	printf(&quot;key&gt;%02x%02x-%02x%02x-%02x%02x-%02x%02x\n\n&quot;, k1, k2, k3, k4, k5, k6, k7, k8);</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a><strong>4. 其他</strong></h2><ul>
<li>本次分析针对的是010 v3.1.2</li>
<li>希望各位大牛不要见笑，欢迎交流</li>
<li>网站：<a href="http://anhkgg.gitcafe.com" target="_blank" rel="external">anhkgg.gitcafe.com</a>， <a href="http://www.devilstep.com" target="_blank" rel="external">www.devilstep.com</a></li>
<li>转载请注明出处：<a href="http://anhkgg.gitcafe.com/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">anhkgg.gitcafe.com/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</a></li>
<li>更新：最新版v5.0.2，分析之后，算法流程基本没有变化，只需要myCal1(k1^k7)条件更新一下就行！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-关键函数定位&quot;&gt;&lt;a href=&quot;#1-关键函数定位&quot; class=&quot;headerlink&quot; title=&quot;1. 关键函数定位&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 关键函数定位&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;进入register窗口，随便填入name，然后check license，弹框信息”Invalid name or password. Please enter your name and password exactly as given when you purchased 010 Editor (make sure no quotes are included).”，通过该信息在IDA中找到对应函数地址，基本可以确认是关键函数位置，函数居然有名字，这是作者故意留下的吗。下面是整个验证函数流程：&lt;/p&gt;
    
    </summary>
    
      <category term="reverse" scheme="https://anhkgg.github.io/categories/reverse/"/>
    
    
      <category term="010editor" scheme="https://anhkgg.github.io/tags/010editor/"/>
    
  </entry>
  
  <entry>
    <title>hctf writeup</title>
    <link href="https://anhkgg.github.io/hctf-writeup/"/>
    <id>https://anhkgg.github.io/hctf-writeup/</id>
    <published>2014-11-10T01:08:58.000Z</published>
    <updated>2014-11-10T02:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 丘比龙的最爱</strong><br>传说，丘比龙是丘比特的弟弟，丘比龙是一只小爱神，虽然有两只翅膀，但因为吃多了，导致身体太胖，所以飞不起来~那么问题来了?!丘比龙吃什么食物吃多了变胖了<br>百度之：甜甜圈</p>
<a id="more"></a>
<p><strong>1. nvshen</strong><br>猫流大大发现一个女神，你能告诉我女神的名字么（名字即是flag） <a href="http://107.189.158.112/0aab9b20410fdd880c53922048023266/nvshen.zip" target="_blank" rel="external">http://107.189.158.112/0aab9b20410fdd880c53922048023266/nvshen.zip</a><br>打开大量数据，感觉是base64，解密了前一部分数据看到PNG, IHDR字符，应该就是png图片了，然后python写了段脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import base64</div><div class="line">f1 = open(&quot;nvshen.txt&quot;, &quot;r&quot;)</div><div class="line">f2 = open(&quot;nvshen.png&quot;, &quot;wb&quot;)</div><div class="line"></div><div class="line">while 1:</div><div class="line">	buf = f1.read(12)</div><div class="line">	if not buf:</div><div class="line">		break;</div><div class="line">	#print buf, base64.decodestring(buf)</div><div class="line">	f2.write(base64.decodestring(buf))	</div><div class="line"></div><div class="line">f1.close()</div><div class="line">f2.close()</div></pre></td></tr></table></figure></p>
<p>得到一张女神照片，纠结了会，google图片之，找到女神名字“爱新觉罗·启星”，被中间的点坑了几次，然后flag是“爱新觉罗启星”， 出题人原来喜欢她啊<br><img src="http://www.taihainet.com/news/UploadFiles_6334/201306/20130618160811617.jpg" alt="img"></p>
<p><strong>3. babyCrack</strong><br>107.189.158.112/d55757a7ccf958399789e18e1d8199de/babyCrack.zip<br>PEID查了下，是.net，马上祭出神奇.net reflector， 结果工具过期，重新下了个注册机，搞定，几个函数，翻了下，看到flag：hctf{bABy<em>CtsvlmE</em>!}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void button1_Click(object sender, EventArgs e)</div><div class="line">&#123;</div><div class="line">	bool flag = false;</div><div class="line">	Config.user = this.textBox1.Text;</div><div class="line">	string user = Config.user;</div><div class="line">	string str2 = &quot;hctf&#123;bABy_CtsvlmE_!&#125;&quot;;</div><div class="line">	if (str2.CompareTo(user) == 0)</div><div class="line">	&#123;</div><div class="line">		flag = true;</div><div class="line">	&#125;</div><div class="line">	if (flag)</div><div class="line">	&#123;</div><div class="line">		MessageBox.Show(&quot;good !!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4. stego_final</strong><br>图片隐写题，Stegsolve各种通道翻了一下，看到张二维码，用手机一扫，识别不了，背影有些黑点，又不会图片处理，ps一番，终于找到flag：flag{hctf_3xF$235#^3}</p>
<p><strong>5. wzwzDingDing</strong><br>被坑的最惨的一道题，是个64位驱动，代码真不多，只有30多个函数，翻了一个遍，流程分析清楚，最后有个字符串提示 “OK!YOU ARE REALLY GOOD!Also, there is a } left!”<br>就是说代码执行到这，应该会得到flag，然后这个是在IRP_MJ_DEVICE_CONTROL函数中，函数对应多个ctl code，分别是：<br>0x88102004，0x88102008, 0x8810200C, 0x88102014, 0x88102010，以及都不是前面的一个ctl code，每个ctl code对应分支都会对偏移0x48E0的一个标志进行操作，最后得到0xFFFFFF，执行提示字符串的分支。<br>下面是触发的ring3代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">HANDLE hDev = CreateFileA(DRV_SYM, GENERIC_ALL, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</div><div class="line">if(hDev == INVALID_HANDLE_VALUE)</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] open dev error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">printf(&quot;[+] open dev success!\n&quot;);</div><div class="line">char buf[20] = &quot;^lejAJ]O&quot;;</div><div class="line">DWORD dwReturn = 0;</div><div class="line">if(! DeviceIoControl(hDev, 0x88102004, buf, strlen(buf), buf, strlen(buf),  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">char buf1[20] = &quot;MNIII&quot;;</div><div class="line">if(! DeviceIoControl(hDev, 0x88102004, buf1, strlen(buf1), buf1, strlen(buf1),  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(! DeviceIoControl(hDev, 0x88102008, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//8810200C</div><div class="line">if(! DeviceIoControl(hDev, 0x8810200C, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;	</div><div class="line"></div><div class="line">if(! DeviceIoControl(hDev, 0x88102014, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;	</div><div class="line">//88102010</div><div class="line">if(! DeviceIoControl(hDev,  0x88102010, NULL, 0, NULL, 0,  &amp;dwReturn, NULL))</div><div class="line">&#123;</div><div class="line">	printf(&quot;[-] dev control error %d\n&quot;, GetLastError());</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后就进入了提示字符分支，结果在这里 <code>text:0000000000012361 call    [rsp+0C8h+ShellCode]</code>，就崩了，被坑了好久，这里需要结合题目提示flag: HCTF{‘intput’.encode(‘hex’)}<br>就是需要修复那段shellcode，让其正确执行，然后顺利执行到提示字符串位置，分支中还有代码提示需要修复的代码字节位置，然后就是根据一个堆栈平衡就能修复（开始明显看不懂题意啊，坑）<br>修复前代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">fffff880`02f85d90 l5b</div><div class="line">wzwzDingDing+0x2d90:</div><div class="line">fffff880`02f85d90 （10） 5152          adc     byte ptr [rcx+52h],dl =&gt;(50 //push rax push rcx</div><div class="line">fffff880`02f85d93 53              push    rbx</div><div class="line">fffff880`02f85d94 55              push    rbp</div><div class="line">fffff880`02f85d95 56              push    rsi</div><div class="line">fffff880`02f85d96 57              push    rdi</div><div class="line">fffff880`02f85d97 （90）              nop</div><div class="line">fffff880`02f85d98 （90）              nop//push r8  (41 50</div><div class="line">fffff880`02f85d99 4151            push    r9</div><div class="line">fffff880`02f85d9b 4152            push    r10</div><div class="line">fffff880`02f85d9d 4153            push    r11</div><div class="line">fffff880`02f85d9f 4154            push    r12</div><div class="line">fffff880`02f85da1 4155            push    r13</div><div class="line">fffff880`02f85da3 4156            push    r14</div><div class="line">fffff880`02f85da5 4157            push    r15</div><div class="line">fffff880`02f85da7 90              nop</div><div class="line">fffff880`02f85da8 （90）              nop//(48 83 EC 28 sub rsp,28h</div><div class="line">fffff880`02f85da9 (90              nop</div><div class="line">fffff880`02f85daa (90              nop</div><div class="line">fffff880`02f85dab (90              nop</div><div class="line">fffff880`02f85dac 90              nop</div><div class="line">fffff880`02f85dad 48c7c600000000  mov     rsi,0</div><div class="line">fffff880`02f85db4 488b040e        mov     rax,qword ptr [rsi+rcx]</div><div class="line">fffff880`02f85db8 4883f007        xor     rax,7</div><div class="line">fffff880`02f85dbc 4889040e        mov     qword ptr [rsi+rcx],rax</div><div class="line">fffff880`02f85dc0 90              nop</div><div class="line">fffff880`02f85dc1 90              nop</div><div class="line">fffff880`02f85dc2 90              nop</div><div class="line">fffff880`02f85dc3 90              nop</div><div class="line">fffff880`02f85dc4 48ffc6          inc     rsi</div><div class="line">fffff880`02f85dc7 4883fe0b        cmp     rsi,0Bh</div><div class="line">fffff880`02f85dcb 74e0            je      wzwzDingDing+0x2dad (fffff880`02f85dad)</div><div class="line">fffff880`02f85dcd 90              nop</div><div class="line">fffff880`02f85dce 4883c428        add     rsp,28h</div><div class="line">fffff880`02f85dd2 415f            pop     r15</div><div class="line">fffff880`02f85dd4 415e            pop     r14</div><div class="line">fffff880`02f85dd6 415d            pop     r13</div><div class="line">fffff880`02f85dd8 415c            pop     r12</div><div class="line">fffff880`02f85dda 415b            pop     r11</div><div class="line">fffff880`02f85ddc 415a            pop     r10</div><div class="line">fffff880`02f85dde 4159            pop     r9</div><div class="line">fffff880`02f85de0 4158            pop     r8</div><div class="line">fffff880`02f85de2 5f              pop     rdi</div><div class="line">fffff880`02f85de3 5e              pop     rsi</div><div class="line">fffff880`02f85de4 5d              pop     rbp</div><div class="line">fffff880`02f85de5 5b              pop     rbx</div><div class="line">fffff880`02f85de6 5a              pop     rdx</div><div class="line">fffff880`02f85de7 (90)              nop //59 pop rcx </div><div class="line">fffff880`02f85de8 58              pop     rax</div><div class="line">fffff880`02f85de9 (90)              nop//ret C3</div><div class="line">fffff880`02f85dea 00cc            add     ah,cl</div></pre></td></tr></table></figure>
<p>修复后代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">kd&gt; u fffff880`02f85d90 l5b</div><div class="line">wzwzDingDing+0x2d90:</div><div class="line">fffff880`02f85d90 50              push    rax</div><div class="line">fffff880`02f85d91 51              push    rcx</div><div class="line">fffff880`02f85d92 52              push    rdx</div><div class="line">fffff880`02f85d93 53              push    rbx</div><div class="line">fffff880`02f85d94 55              push    rbp</div><div class="line">fffff880`02f85d95 56              push    rsi</div><div class="line">fffff880`02f85d96 57              push    rdi</div><div class="line">fffff880`02f85d97 4150            push    r8</div><div class="line">fffff880`02f85d99 4151            push    r9</div><div class="line">fffff880`02f85d9b 4152            push    r10</div><div class="line">fffff880`02f85d9d 4153            push    r11</div><div class="line">fffff880`02f85d9f 4154            push    r12</div><div class="line">fffff880`02f85da1 4155            push    r13</div><div class="line">fffff880`02f85da3 4156            push    r14</div><div class="line">fffff880`02f85da5 4157            push    r15</div><div class="line">fffff880`02f85da7 90              nop</div><div class="line">fffff880`02f85da8 4883ec28        sub     rsp,28h</div><div class="line">fffff880`02f85dac 90              nop</div><div class="line">fffff880`02f85dad 48c7c600000000  mov     rsi,0</div><div class="line">fffff880`02f85db4 488b040e        mov     rax,qword ptr [rsi+rcx]</div><div class="line">fffff880`02f85db8 4883f007        xor     rax,7</div><div class="line">fffff880`02f85dbc 4889040e        mov     qword ptr [rsi+rcx],rax</div><div class="line">fffff880`02f85dc0 90              nop</div><div class="line">fffff880`02f85dc1 90              nop</div><div class="line">fffff880`02f85dc2 90              nop</div><div class="line">fffff880`02f85dc3 90              nop</div><div class="line">fffff880`02f85dc4 48ffc6          inc     rsi</div><div class="line">fffff880`02f85dc7 4883fe0b        cmp     rsi,0Bh</div><div class="line">fffff880`02f85dcb 74e0            je      wzwzDingDing+0x2dad (fffff880`02f85dad)</div><div class="line">fffff880`02f85dcd 90              nop</div><div class="line">fffff880`02f85dce 4883c428        add     rsp,28h</div><div class="line">fffff880`02f85dd2 415f            pop     r15</div><div class="line">fffff880`02f85dd4 415e            pop     r14</div><div class="line">fffff880`02f85dd6 415d            pop     r13</div><div class="line">fffff880`02f85dd8 415c            pop     r12</div><div class="line">fffff880`02f85dda 415b            pop     r11</div><div class="line">fffff880`02f85ddc 415a            pop     r10</div><div class="line">fffff880`02f85dde 4159            pop     r9</div><div class="line">fffff880`02f85de0 4158            pop     r8</div><div class="line">fffff880`02f85de2 5f              pop     rdi</div><div class="line">fffff880`02f85de3 5e              pop     rsi</div><div class="line">fffff880`02f85de4 5d              pop     rbp</div><div class="line">fffff880`02f85de5 5b              pop     rbx</div><div class="line">fffff880`02f85de6 5a              pop     rdx</div><div class="line">fffff880`02f85de7 59              pop     rcx</div><div class="line">fffff880`02f85de8 58              pop     rax</div><div class="line">fffff880`02f85de9 c3              ret</div><div class="line">fffff880`02f85dea 00cc            add     ah,cl</div></pre></td></tr></table></figure></p>
<p>然后flag：HCTF{5041504883ec2859c3}，注意大小写啊</p>
<p><strong>6. 其他</strong></p>
<p>就这么多了，经验太少，就各路大牛路过指导</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1. 丘比龙的最爱&lt;/strong&gt;&lt;br&gt;传说，丘比龙是丘比特的弟弟，丘比龙是一只小爱神，虽然有两只翅膀，但因为吃多了，导致身体太胖，所以飞不起来~那么问题来了?!丘比龙吃什么食物吃多了变胖了&lt;br&gt;百度之：甜甜圈&lt;/p&gt;
    
    </summary>
    
      <category term="ctf" scheme="https://anhkgg.github.io/categories/ctf/"/>
    
    
      <category term="hctf" scheme="https://anhkgg.github.io/tags/hctf/"/>
    
  </entry>
  
  <entry>
    <title>how to get GS cookie</title>
    <link href="https://anhkgg.github.io/how-to-get-GS-cookie/"/>
    <id>https://anhkgg.github.io/how-to-get-GS-cookie/</id>
    <published>2014-11-05T03:32:29.000Z</published>
    <updated>2016-07-07T04:33:15.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-cookie"><a href="#Stack-cookie" class="headerlink" title="Stack cookie"></a><strong>Stack cookie</strong></h1><p>Stack cookies (/GS Switch cookie)，windows防止栈溢出的一种机制，<a href="http://www.pediy.com/kssd/pediy12/102719/724039/39112.pdf" target="_blank" rel="external">详见</a>。</p>
<a id="more"></a>
<blockquote>
<p><strong>栈中的 cookie/GS保护</strong></p>
<p>/GS 编译选项会在函数的开头和结尾添加代码来阻止对典型的栈溢出漏洞（字符串缓冲区）的利用。<br>当应用程序启动时，程序的 cookie（4 字节（dword），无符号整型）被计算出来（伪随机数）并保存在<br>加载模块的.data 节中,在函数的开头这个 cookie 被拷贝到栈中，位于 EBP 和返回地址的正前方（位于返<br>回地址和局部变量的中间）。<br>[buffer][cookie][saved EBP][saved EIP]<br>在函数的结尾处，程序会把这个 cookie 和保存在.data 节中的 cookie 进行比较。<br>如果不相等，就说明进程栈被破坏，进程必须被终止。</p>
<p><strong>栈中的 cookie/GS绕过方法</strong><br>挫败这种栈溢出保护机制的最直接的方法是检索/猜测/计算出 cookie 值（这样就可以用相同的 cookie<br>覆盖栈中的 cookie），这个 cookie 有时候（很少）是一个静态值…但即使如此，它也可能包含一些不利<br>的字符而导致不能使用它。</p>
</blockquote>
<h1 id="如何通过PE来获取GS-cookie的值"><a href="#如何通过PE来获取GS-cookie的值" class="headerlink" title="如何通过PE来获取GS cookie的值"></a><strong>如何通过PE来获取GS cookie的值</strong></h1><p>在PE的DataDirectory中，第10序号的是一个叫做LoadConfig的东西，保存了映像的配置数据，里面就有GS cookie，来看看这个数据结构<br><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680328(v=vs.85).aspx" title="loadconfig" target="_blank" rel="external">IMAGE_LOAD_CONFIG_DIRECTORY32</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    DWORD   Size;</div><div class="line">    DWORD   TimeDateStamp;</div><div class="line">    WORD    MajorVersion;</div><div class="line">    WORD    MinorVersion;</div><div class="line">    DWORD   GlobalFlagsClear;</div><div class="line">    DWORD   GlobalFlagsSet;</div><div class="line">    DWORD   CriticalSectionDefaultTimeout;</div><div class="line">    DWORD   DeCommitFreeBlockThreshold;</div><div class="line">    DWORD   DeCommitTotalFreeThreshold;</div><div class="line">    DWORD   LockPrefixTable;            // VA</div><div class="line">    DWORD   MaximumAllocationSize;</div><div class="line">    DWORD   VirtualMemoryThreshold;</div><div class="line">    DWORD   ProcessHeapFlags;</div><div class="line">    DWORD   ProcessAffinityMask;</div><div class="line">    WORD    CSDVersion;</div><div class="line">    WORD    Reserved1;</div><div class="line">    DWORD   EditList;                   // VA</div><div class="line">    DWORD   SecurityCookie;             // VA</div><div class="line">    DWORD   SEHandlerTable;             // VA</div><div class="line">    DWORD   SEHandlerCount;</div><div class="line">&#125; IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>SecurityCookie</strong><br>A pointer to a cookie that is used by Visual C++ or GS implementation.</p>
</blockquote>
<p>所以，可以通过解析pe的方式，获取到SecurityCookie，进而绕过cookie/GS保护，这只是我的想法，也没测试过，是在分析某个sys的时间想到的，下面贴出获取Cookie的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">unsigned int __stdcall myGetGSSecureCookie(PVOID ImageBase, ULONG Size)</div><div class="line">&#123;</div><div class="line">  ULONG v2; // edi@1</div><div class="line">  PVOID v3; // esi@1</div><div class="line">  PVOID v4; // eax@2</div><div class="line">  unsigned int result; // eax@7</div><div class="line"></div><div class="line">  v3 = ImageBase;</div><div class="line">  v2 = Size;</div><div class="line">  if ( (signed int)myGetValidNtHeader(1, (unsigned int)ImageBase, Size, (int)&amp;ImageBase) &lt; 0//myGetValidNtHeader获取nt头地址</div><div class="line">    || (v4 = RtlImageDirectoryEntryToData(v3, 1u, 0xAu, &amp;Size), !v4)// 通过加载配置目录信息找到SecureCookie</div><div class="line">    || !Size</div><div class="line">    || Size != 0x40 &amp;&amp; Size != *(_DWORD *)v4</div><div class="line">    || *(_DWORD *)v4 &lt; 0x48u</div><div class="line">    || (result = *((_DWORD *)v4 + 15), result &lt;= (unsigned int)v3)// loadcofig-&gt;SecurityCookie</div><div class="line">						// A pointer to a cookie that is used by Visual C++ or GS implementation.</div><div class="line">    || result &gt;= (unsigned int)(v3 + v2 - 4) )</div><div class="line">    result = 0;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><p>没来得及查资料，是否有完整的绕过方法，这只是自己突然分析到这，想到的，不对之处，敬请见谅。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Stack-cookie&quot;&gt;&lt;a href=&quot;#Stack-cookie&quot; class=&quot;headerlink&quot; title=&quot;Stack cookie&quot;&gt;&lt;/a&gt;&lt;strong&gt;Stack cookie&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;Stack cookies (/GS Switch cookie)，windows防止栈溢出的一种机制，&lt;a href=&quot;http://www.pediy.com/kssd/pediy12/102719/724039/39112.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详见&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="https://anhkgg.github.io/categories/security/"/>
    
    
      <category term="PE" scheme="https://anhkgg.github.io/tags/PE/"/>
    
      <category term="GS" scheme="https://anhkgg.github.io/tags/GS/"/>
    
      <category term="cookie" scheme="https://anhkgg.github.io/tags/cookie/"/>
    
  </entry>
  
</feed>
